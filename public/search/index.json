[{"content":"Docker搭建私人Docker镜像仓库\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 docker pull registry mkdir -p registry/data \u0026amp;\u0026amp; cd registry pwd # /root/registry docker run \\ --restart=always \\ -p 5000:5000 \\ --name registry \\ -v /root/registry/data:/var/lib/registry \\ -d registry:latest # 访问url，查看镜像仓库中的所有镜像 # http://ubuntu-notebook:5000/v2/_catalog docker私有仓库默认是基于https传输的，这里我们在客户端进行相关设置不使用https传输\n1 2 3 4 vim /etc/docker/daemon.json # 添加如下配置 \u0026#34;insecure-registries\u0026#34;: [\u0026#34;192.168.50.11:5000\u0026#34;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://dockerpull.org\u0026#34;, \u0026#34;https://docker.1panel.dev\u0026#34;, \u0026#34;https://docker.foreverlink.love\u0026#34;, \u0026#34;https://docker.fxxk.dedyn.io\u0026#34;, \u0026#34;https://docker.xn--6oq72ry9d5zx.cn\u0026#34;, \u0026#34;https://docker.zhai.cm\u0026#34;, \u0026#34;https://docker.5z5f.com\u0026#34;, \u0026#34;https://a.ussh.net\u0026#34;, \u0026#34;https://docker.cloudlayer.icu\u0026#34;, \u0026#34;https://hub.littlediary.cn\u0026#34;, \u0026#34;https://hub.crdz.gq\u0026#34;, \u0026#34;https://docker.unsee.tech\u0026#34;, \u0026#34;https://docker.kejilion.pro\u0026#34;, \u0026#34;https://registry.dockermirror.com\u0026#34;, \u0026#34;https://hub.rat.dev\u0026#34;, \u0026#34;https://dhub.kubesre.xyz\u0026#34;, \u0026#34;https://docker.nastool.de\u0026#34;, \u0026#34;https://docker.udayun.com\u0026#34;, \u0026#34;https://docker.rainbond.cc\u0026#34;, \u0026#34;https://hub.geekery.cn\u0026#34;, \u0026#34;https://docker.1panelproxy.com\u0026#34;, \u0026#34;https://atomhub.openatom.cn\u0026#34;, \u0026#34;https://docker.m.daocloud.io\u0026#34;, \u0026#34;https://docker.1ms.run\u0026#34;, \u0026#34;https://docker.linkedbus.com\u0026#34; ], \u0026#34;insecure-registries\u0026#34;: [ \u0026#34;192.168.50.11:5000\u0026#34; ], \u0026#34;exec-opts\u0026#34;: [ \u0026#34;native.cgroupdriver=systemd\u0026#34; ], \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;100m\u0026#34; }, \u0026#34;storage-driver\u0026#34;: \u0026#34;overlay2\u0026#34; } 重新加载docker配置\n1 2 systemctl daemon-reload systemctl restart docker 在推送镜像之前，还需要重做镜像tag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 重做镜像tag docker tag images:tag ip:5000/images:tag # 比如 docker tag nginx:latest 192.168.50.11:5000/nginx:latest # 或者 docker tag nginx 192.168.50.11:5000/nginx # 推送镜像 docker push ip:5000/images:tag # 比如 docker push 192.168.50.11:5000/nginx # 访问url，查看镜像仓库中的所有镜像 # http://ubuntu-notebook:5000/v2/_catalog # 或者在服务器上查看data目录下的内容 ll data/docker/registry/v2/repositories/ # nginx/ 这里使用registry-ui配置可视化界面进行管理\n新建docker-componse.yml文件，并上传到服务器/root/registry目录下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 version: \u0026#39;3.8\u0026#39; services: registry: image: registry volumes: - /root/registry/data:/var/lib/registry registry-ui: image: joxit/docker-registry-ui:1.5-static ports: - 8010:80 environment: - REGISTRY_TITLE=tong的私有镜像仓库 - REGISTRY_URL=http://registry:5000 - CATALOG_ELEMENTS_LIMIT=1000 depends_on: - registry 执行以下命令\n1 docker compose up -d 访问服务器url即可\nhttp://ubuntu-notebook:8010/\n接下来需要更新客户端daemon.json指向8010端口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://dockerpull.org\u0026#34;, \u0026#34;https://docker.1panel.dev\u0026#34;, \u0026#34;https://docker.foreverlink.love\u0026#34;, \u0026#34;https://docker.fxxk.dedyn.io\u0026#34;, \u0026#34;https://docker.xn--6oq72ry9d5zx.cn\u0026#34;, \u0026#34;https://docker.zhai.cm\u0026#34;, \u0026#34;https://docker.5z5f.com\u0026#34;, \u0026#34;https://a.ussh.net\u0026#34;, \u0026#34;https://docker.cloudlayer.icu\u0026#34;, \u0026#34;https://hub.littlediary.cn\u0026#34;, \u0026#34;https://hub.crdz.gq\u0026#34;, \u0026#34;https://docker.unsee.tech\u0026#34;, \u0026#34;https://docker.kejilion.pro\u0026#34;, \u0026#34;https://registry.dockermirror.com\u0026#34;, \u0026#34;https://hub.rat.dev\u0026#34;, \u0026#34;https://dhub.kubesre.xyz\u0026#34;, \u0026#34;https://docker.nastool.de\u0026#34;, \u0026#34;https://docker.udayun.com\u0026#34;, \u0026#34;https://docker.rainbond.cc\u0026#34;, \u0026#34;https://hub.geekery.cn\u0026#34;, \u0026#34;https://docker.1panelproxy.com\u0026#34;, \u0026#34;https://atomhub.openatom.cn\u0026#34;, \u0026#34;https://docker.m.daocloud.io\u0026#34;, \u0026#34;https://docker.1ms.run\u0026#34;, \u0026#34;https://docker.linkedbus.com\u0026#34; ], \u0026#34;insecure-registries\u0026#34;: [ \u0026#34;192.168.50.11:8010\u0026#34; ], \u0026#34;exec-opts\u0026#34;: [ \u0026#34;native.cgroupdriver=systemd\u0026#34; ], \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;100m\u0026#34; }, \u0026#34;storage-driver\u0026#34;: \u0026#34;overlay2\u0026#34; } 重新加载配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 systemctl daemon-reload systemctl restart docker # 步骤和之前类似，仍然先要重构镜像，只是端口变为刚刚`docker-componse.yml`里配置的8010 # 重做镜像tag docker tag images:tag ip:8010/images:tag # 比如 docker tag nginx:latest 192.168.50.11:8010/nginx:latest # 或者 docker tag nginx 192.168.50.11:8010/nginx # 推送镜像 docker push ip:8010/images:tag # 比如 docker push 192.168.50.11:8010/nginx ","date":"2024-12-27T00:00:00Z","image":"http://localhost:1313/p/docker%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BAdocker%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/dbc-docker-desktop-home_hu5165119418789691799.webp","permalink":"http://localhost:1313/p/docker%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BAdocker%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/","title":"Docker搭建私人Docker镜像仓库"},{"content":"Kubernetes\r核心概念\r什么是Kubernetes\rKubernetes 是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful），Kubernetes 提供了应用部署，规划，更新，维护的一种机制。\nKubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在 Google 大规模运行生产工作负载十几年经验的基础上， 结合了社区中最优秀的想法和实践。\n为什么需要 Kubernetes\r应用部署的三大阶段\r传统部署 程序员/运维工程师手动操作部署应用，直接将应用部署在目标机器上，由于资源不隔离，容易出现资源争抢、依赖冲突等各方面问题。 虚拟化部署 利用 OpenStask / VMware 等虚拟化技术，将一台目标机器虚拟化为多个虚拟机器，按照需求将应用部署到不同的虚拟机中，对虚拟机进行动态的水平扩容等管理操作。 相对传统部署自动化、资源隔离的能力提升了，带来的问题是虚拟化的逻辑过重，导致效率不高，且耗费资源较多。 容器化部署 可以理解为轻量级的虚拟化，完美弥补虚拟化技术过重的问题，且由于直接共享主机硬件资源，只是通过系统提供的命名空间等技术实现资源隔离，损耗更小，且效率更高。 k8s 的特点\r自我修复 弹性伸缩 自动部署和回滚 服务发现和负载均衡 机密和配置管理 存储编排 批处理 企业级容器调度平台\rApache Mesos 基本概念 Mesos 是一个分布式调度系统内核，早于 Docker 产生，Mesos 作为资源管理器，从 DC/OS (数据中心操作系统)的角度提供资源视图。主/从结构工作模式，主节点分配任务，并用从节点上的 Executor 负责执行，通过 Zookeeper 给主节点提供服务注册、服务发现功能。通过 Framework Marathon 提供容器调度的能力。 优势 经过时间的检验，作为资源管理器的 Apache Mesos 在容器之前就已经出现很久了，支持运行容器化化和非容器化的工作负载。可以支持应用程序的健康检查，开放的架构。支持多个框架和多个调度器，通过不同的 Framework 可以运行 Hadoop/Spark/MPI等多种不同的任务。 支持超大型规模的节点管理，模拟测试支持超过 5w+ 节点，在大规模上拥有较大优势。 Docker Swarm 基本概念 Docker Swarm 是一个由 Docker 开发的调度框架。由 Docker 自身开发的好处之一就是标准 Docker API 的使用，Swarm 由多个代理（Agent）组成，把这些代理称之为节点（Node）。这些节点就是主机，这些主机在启动 Docker Daemon 的时候就会打开相应的端口，以此支持 Docker 远程 API。这些机器会根据 Swarm 调度器分配给它们的任务，拉取和运行不同的镜像。 优势 从 Docker1.12 版本开始，Swarm 随 Docker 一起默认安装发布。由于随 Docker 引擎一起发布，无需额外安装，配置简单。支持服务注册、服务发现，内置 Overlay Network 以及 Load Balancer。与 Docker CLI 非常类似的操作命令，对熟悉 Docker 的人非常容易上手学习。 入门门槛、学习成本较低，使用更便捷，适用于中小型系统。 Google Kubernetes 基本概念 Kubernetes 是基于 Google 在过去十五年来大量生产环境中运行工作负载的经验。Kubernetes 的实现参考了 Google 内部的资源调度框架，但并不是 Borg 的内部容器编排系统的开源，而是借鉴 Google 从运行 Borg 获得的经验教训，形成了 Kubernetes 项目。 它使用 Label 和 Pod 的概念来将容器划分为逻辑单元。Pods 是同地协作（co-located）容器的集合，这些容器被共同部署和调度，形成了一个服务，这是 Kubernetes 和其他两个框架的主要区别。相比于基于相似度的容器调度方式（就像 Swarm 和Mesos），这个方法简化了对集群的管理。 优势 最流行等容器编排解决方案框架，基于 Google 庞大的生态圈及社区产生的产品。通过 Pods 这一抽象的概念，解决 Container 之间的依赖于通信问题。Pods，Services，Deployments 是独立部署的部分，可以通过 Selector 提供更多的灵活性。内置服务注册表和负载平衡。 适用度更广，功能更强大，相较于 Mesos 来说节点规模较小， 集群架构与组件\r相关组件\r控制面板组件（Master）\r其中标色的地方需要重点注意\nkube-api-server\rAPI 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。\nKubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。\nkube-controller-manager\rkube-controller-manager 是控制平面的组件， 负责运行控制器进程。\n从逻辑上讲， 每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。\n这些控制器包括：\n节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应 任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成 端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。 服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）。 cloud-controller-manager\r嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。\ncloud-controller-manager 仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。\n与 kube-controller-manager 类似，cloud-controller-manager 将若干逻辑上独立的控制回路组合到同一个可执行文件中， 供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。\nkube-scheduler\rscheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；\netcd\r一致且高度可用的键值存储，用作 Kubernetes 的所有集群数据的后台数据库。\n如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 备份计划。\n你可以在官方文档中找到有关 etcd 的深入知识。\n早期数据存放在内存，现在已经是持久化存储的了。\n节点组件\rkubelet\rkubelet 负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理；\nkube-proxy\rkube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡；kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡；\ncontainer runtime\rContainer runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）； Kubernetes 支持许多容器运行环境，例如 containerd、 CRI-O 以及 Kubernetes CRI (容器运行环境接口) 的其他任何实现。\n附加组件\rkube-dns\rkube-dns 负责为整个集群提供 DNS 服务\nIngress Controller\rIngress Controller 为服务提供外网入口\nPrometheus\rPrometheus 提供资源监控\nDashboard\rDashboard 提供 GUI\nFederation\rFederation 提供跨可用区的集群\nFluentd-elasticsearch\rFluentd-elasticsearch 提供集群日志采集、存储与查询\n分层架构\r生态系统 在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴： Kubernetes 外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS 应用、ChatOps 等 Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等 接口层 kubectl 命令行工具、客户端 SDK 以及集群联邦 管理层 系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等） 应用层 部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等） 核心层 Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境 核心概念与专业术语\r服务的分类\r无状态\r需要在服务运行环境下存储数据的服务，我们称之为无状态应用\n代表应用\nNginx Apache 优点：对客户端透明，无依赖关系，可以高效实现扩容、迁移\n缺点：不能存储数据，需要额外的数据服务支撑\n有状态\r代表应用\nMySQL Redis 优点：可以独立存储数据，实现数据管理 缺点：集群环境下需要实现主从、数据同步、备份、水平扩容复杂\n资源和对象\rKubernetes 中的所有内容都被抽象为“资源”，如 Pod、Service、Node 等都是资源。“对象”就是“资源”的实例，是持久化的实体。如某个具体的 Pod、某个具体的 Node。Kubernetes 使用这些实体去表示整个集群的状态。\n对象的创建、删除、修改都是通过 “Kubernetes API”，也就是 “Api Server” 组件提供的 API 接口，这些是 RESTful 风格的 Api，与 k8s 的“万物皆对象”理念相符。命令行工具 “kubectl”，实际上也是调用 kubernetes api。\nK8s 中的资源类别有很多种，kubectl 可以通过配置文件来创建这些 “对象”，配置文件更像是描述对象“属性”的文件，配置文件格式可以是 “JSON” 或 “YAML”，常用 “YAML”。\n元数据型\rHorizontal Pod Autoscaler（HPA） Pod 自动扩容：可以根据 CPU 使用率或自定义指标（metrics）自动对 Pod 进行扩/缩容。 控制管理器每隔30s（可以通过–horizontal-pod-autoscaler-sync-period修改）查询metrics的资源使用情况 支持三种metrics类型 预定义metrics（比如Pod的CPU）以利用率的方式计算 自定义的Pod metrics，以原始值（raw value）的方式计算 自定义的object metrics 支持两种metrics查询方式：Heapster和自定义的REST API 支持多metrics PodTemplate Pod Template 是关于 Pod 的定义，但是被包含在其他的 Kubernetes 对象中（例如 Deployment、StatefulSet、DaemonSet 等控制器）。控制器通过 Pod Template 信息来创建 Pod。 LimitRange 可以对集群内 Request 和 Limits 的配置做一个全局的统一的限制，相当于批量设置了某一个范围内（某个命名空间）的 Pod 的资源使用限制。 集群级\rNamespace\nKubernetes 支持多个虚拟集群，它们底层依赖于同一个物理集群，这些虚拟集群被称为命名空间。\n作用是用于实现多团队/环境的资源隔离。\n命名空间 namespace 是 k8s 集群级别的资源，可以给不同的用户、租户、环境或项目创建对应的命名空间。\n默认 namespace：\nkube-system 主要用于运行系统级资源，存放 k8s 自身的组件 kube-public 此命名空间是自动创建的，并且可供所有用户（包括未经过身份验证的用户）读取。此命名空间主要用于集群使用，关联的一些资源在集群中是可见的并且可以公开读取。此命名空间的公共方面知识一个约定，但不是非要这么要求。 default 未指定名称空间的资源就是 default，即你在创建pod 时如果没有指定 namespace，则会默认使用 default Node\n不像其他的资源（如 Pod 和 Namespace），Node 本质上不是Kubernetes 来创建的，Kubernetes 只是管理 Node 上的资源。虽然可以通过 Manifest 创建一个Node对象（如下 json 所示），但 Kubernetes 也只是去检查是否真的是有这么一个 Node，如果检查失败，也不会往上调度 Pod。 ClusterRole\nClusterRole 是一组权限的集合，但与 Role 不同的是，ClusterRole 可以在包括所有 Namespace 和集群级别的资源或非资源类型进行鉴权。 ClusterRoleBinding\nClusterRoleBinding：将 Subject 绑定到 ClusterRole，ClusterRoleBinding 将使规则在所有命名空间中生效。 命名空间级\r工作负载型\rPod Pod（容器组）是 Kubernetes 中最小的可部署单元。一个 Pod（容器组）包含了一个应用程序容器（某些情况下是多个容器）、存储资源、一个唯一的网络 IP 地址、以及一些确定容器该如何运行的选项。Pod 容器组代表了 Kubernetes 中一个独立的应用程序运行实例，该实例可能由单个容器或者几个紧耦合在一起的容器组成。\nDocker 是 Kubernetes Pod 中使用最广泛的容器引擎；Kubernetes Pod 同时也支持其他类型的容器引擎。\nKubernetes 集群中的 Pod 存在如下两种使用途径：\n一个 Pod 中只运行一个容器。\u0026ldquo;one-container-per-pod\u0026rdquo; 是 Kubernetes 中最常见的使用方式。此时，您可以认为 Pod 容器组是该容器的 wrapper，Kubernetes 通过 Pod 管理容器，而不是直接管理容器。 一个 Pod 中运行多个需要互相协作的容器。您可以将多个紧密耦合、共享资源且始终在一起运行的容器编排在同一个 Pod 中 副本（replicas）\n先引入“副本”的概念——一个 Pod 可以被复制成多份，每一份可被称之为一个“副本”，这些“副本”除了一些描述性的信息（Pod 的名字、uid 等）不一样以外，其它信息都是一样的，譬如 Pod 内部的容器、容器数量、容器里面运行的应用等的这些信息都是一样的，这些副本提供同样的功能。\nPod 的***“控制器”***通常包含一个名为 “replicas” 的属性。“replicas”属性则指定了特定 Pod 的副本的数量，当当前集群中该 Pod 的数量与该属性指定的值不一致时，k8s 会采取一些策略去使得当前状态满足配置的要求。\n控制器\n当 Pod 被创建出来，Pod 会被调度到集群中的节点上运行，Pod 会在该节点上一直保持运行状态，直到进程终止、Pod 对象被删除、Pod 因节点资源不足而被驱逐或者节点失效为止。Pod 并不会自愈，当节点失效，或者调度 Pod 的这一操作失败了，Pod 就该被删除。如此，单单用 Pod 来部署应用，是不稳定不安全的。\nKubernetes 使用更高级的资源对象 *“控制器”* 来实现对Pod的管理。控制器可以为您创建和管理多个 Pod，管理副本和上线，并在集群范围内提供自修复能力。 例如，如果一个节点失败，控制器可以在不同的节点上调度一样的替身来自动替换 Pod。\n适用无状态服务\nReplicationController（RC）\nReplication Controller 简称 RC，RC 是 Kubernetes 系统中的核心概念之一，简单来说，RC 可以保证在任意时间运行 Pod 的副本数量，能够保证 Pod 总是可用的。如果实际 Pod 数量比指定的多那就结束掉多余的，如果实际数量比指定的少就新启动一些Pod，当 Pod 失败、被删除或者挂掉后，RC 都会去自动创建新的 Pod 来保证副本数量，所以即使只有一个 Pod，我们也应该使用 RC 来管理我们的 Pod。可以说，通过 ReplicationController，Kubernetes 实现了 Pod 的高可用性。 ReplicaSet（RS）\nRC （ReplicationController ）主要的作用就是用来确保容器应用的副本数始终保持在用户定义的副本数 。即如果有容器异常退出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收（已经成为过去时），在 v1.11 版本废弃。\nKubernetes 官方建议使用 RS（ReplicaSet ） 替代 RC （ReplicationController ） 进行部署，RS 跟 RC 没有本质的不同，只是名字不一样，并且 RS 支持集合式的 selector。\nLabel 和 Selector\nlabel （标签）是附加到 Kubernetes 对象（比如 Pods）上的键值对，用于区分对象（比如Pod、Service）。 label 旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 label 可以用于组织和选择对象的子集。label 可以在创建时附加到对象，随后可以随时添加和修改。可以像 namespace 一样，使用 label 来获取某类对象，但 label 可以与 selector 一起配合使用，用表达式对条件加以限制，实现更精确、更灵活的资源查找。\nlabel 与 selector 配合，可以实现对象的“关联”，“Pod 控制器” 与 Pod 是相关联的 —— “Pod 控制器”依赖于 Pod，可以给 Pod 设置 label，然后给“控制器”设置对应的 selector，这就实现了对象的关联。\nDeployment\nDeployment 为 Pod 和 Replica Set 提供声明式更新。\n你只需要在 Deployment 中描述你想要的目标状态是什么，Deployment controller 就会帮你将 Pod 和 Replica Set 的实际状态改变到你的目标状态。你可以定义一个全新的 Deployment，也可以创建一个新的替换旧的 Deployment。\n创建 Replica Set / Pod 滚动升级/回滚 平滑扩容和缩容 暂停与恢复 Deployment 适用有状态服务\nStatefulSet\nStatefulSet 中每个 Pod 的 DNS 格式为 statefulSetName-{0..N-1}.serviceName.namespace.svc.cluster.local\nserviceName 为 Headless Service 的名字 0..N-1 为 Pod 所在的序号，从 0 开始到 N-1 statefulSetName 为 StatefulSet 的名字 namespace 为服务所在的 namespace，Headless Servic 和 StatefulSet 必须在相同的 namespace .cluster.local 为 Cluster Domain 主要特点\n稳定的持久化存储 即 Pod 重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现 稳定的网络标志 稳定的网络标志，即 Pod 重新调度后其 PodName 和 HostName 不变，基于 Headless Service（即没有 Cluster IP 的 Service）来实现 有序部署，有序扩展 有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从 0到 N-1，在下一个Pod 运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态），基于 init containers 来实现 有序收缩，有序删除 有序收缩，有序删除（即从 N-1 到 0） 组成\nHeadless Service\n用于定义网络标志（DNS domain）\nDomain Name Server：域名服务 将域名与 ip 绑定映射关系\n服务名 =\u0026gt; 访问路径（域名） =\u0026gt; ip\nvolumeClaimTemplate\n用于创建 PersistentVolumes 注意事项\nkubernetes v1.5 版本以上才支持 所有Pod的Volume必须使用PersistentVolume或者是管理员事先创建好 为了保证数据安全，删除StatefulSet时不会删除Volume StatefulSet 需要一个 Headless Service 来定义 DNS domain，需要在 StatefulSet 之前创建好 守护进程\nDaemonSet\nDaemonSet 保证在每个 Node 上都运行一个容器副本，常用来部署一些集群的日志、监控或者其他系统管理应用。典型的应用包括：\n日志收集，比如 fluentd，logstash 等 系统监控，比如 Prometheus Node Exporter，collectd，New Relic agent，Ganglia gmond 等 系统程序，比如 kube-proxy, kube-dns, glusterd, ceph 等 任务/定时任务\nJob CronJob 服务发现\rService\n“Service” 简写 “svc”。Pod 不能直接提供给外网访问，而是应该使用 service。Service 就是把 Pod 暴露出来提供服务，Service 才是真正的“服务”，它的中文名就叫“服务”。\n可以说 Service 是一个应用服务的抽象，定义了 Pod 逻辑集合和访问这个 Pod 集合的策略。Service 代理 Pod 集合，对外表现为一个访问入口，访问该入口的请求将经过负载均衡，转发到后端 Pod 中的容器。\nIngress\nIngress 可以提供外网访问 Service 的能力。可以把某个请求地址映射、路由到特定的 service。\ningress 需要配合 ingress controller 一起使用才能发挥作用，ingress 只是相当于路由规则的集合而已，真正实现路由功能的，是 Ingress Controller，ingress controller 和其它 k8s 组件一样，也是在 Pod 中运行。\n存储\rVolume\n数据卷，共享 Pod 中容器使用的数据。用来放持久化的数据，比如数据库数据。\nCSI\nContainer Storage Interface 是由来自 Kubernetes、Mesos、Docker 等社区成员联合制定的一个行业标准接口规范，旨在将任意存储系统暴露给容器化应用程序。\nCSI 规范定义了存储提供商实现 CSI 兼容的 Volume Plugin 的最小操作集和部署建议。CSI 规范的主要焦点是声明 Volume Plugin 必须实现的接口。\n特殊类型配置\rConfigMap\n用来放配置，与 Secret 是类似的，只是 ConfigMap 放的是明文的数据，Secret 是密文存放。\nSecret\nSecret 解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者 Pod Spec 中。Secret 可以以 Volume 或者环境变量的方式使用。\nSecret 有三种类型：\nService Account：用来访问 Kubernetes API，由 Kubernetes 自动创建，并且会自动挂载到 Pod 的 /run/secrets/kubernetes.io/serviceaccount 目录中； Opaque：base64 编码格式的 Secret，用来存储密码、密钥等； kubernetes.io/dockerconfigjson：用来存储私有 docker registry 的认证信息。 DownwardAPI\ndownwardAPI 这个模式和其他模式不一样的地方在于它不是为了存放容器的数据也不是用来进行容器和宿主机的数据交换的，而是让 pod 里的容器能够直接获取到这个 pod 对象本身的一些信息。\ndownwardAPI 提供了两种方式用于将 pod 的信息注入到容器内部：\n环境变量：用于单个变量，可以将 pod 信息和容器信息直接注入容器内部\nvolume 挂载：将 pod 信息生成为文件，直接挂载到容器内部中去\n其他\rRole\nRole 是一组权限的集合，例如 Role 可以包含列出 Pod 权限及列出 Deployment 权限，Role 用于给某个 Namespace 中的资源进行鉴权。\nRoleBinding\nRoleBinding ：将 Subject 绑定到 Role，RoleBinding 使规则在命名空间内生效。\n对象规约和状态\r对象是用来完成一些任务的，是持久的，是有目的性的，因此 kubernetes 创建一个对象后，将持续地工作以确保对象存在。当然，kubernetes 并不只是维持对象的存在这么简单，kubernetes 还管理着对象的方方面面。每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置，他们分别是 “spec” 和 “status” 。\n规约（Spec）\r“spec” 是 “规约”、“规格” 的意思，spec 是必需的，它描述了对象的期望状态（Desired State）—— 希望对象所具有的特征。当创建 Kubernetes 对象时，必须提供对象的规约，用来描述该对象的期望状态，以及关于对象的一些基本信息（例如名称）。\n状态（Status）\r表示对象的实际状态，该属性由 k8s 自己维护，k8s 会通过一系列的控制器对对应对象进行管理，让对象尽可能的让实际状态与期望状态重合。\nK8S实战进阶\r搭建 Kubernetes 集群\r搭建方案\rminikube\nminikube 是一个工具， 能让你在本地运行 Kubernetes。 minikube 在你的个人计算机（包括 Windows、macOS 和 Linux PC）上运行一个一体化（all-in-one）或多节点的本地 Kubernetes 集群，以便你来尝试 Kubernetes 或者开展每天的开发工作。\n官方安装文档\nkubeadm\n服务器要求\n3 台服务器（虚拟机） k8s-master：192.168.133.130 k8s-node1：192.168.133.131 k8s-node2：192.168.133.132 最低配置：2核、2G内存、20G硬盘 最好能联网，不能联网的话需要有提供对应镜像的私有仓库 软件环境\n操作系统：CentOS 7 Docker：20+ k8s：1.23.6 安装步骤\n环境配置这里选择20.10.7版本的Docker，因为kubernetes在1.24之后的版本不再支持Docker，所以这里选择安装1.23.6版本的kubernetes\n这里准备三个虚拟机，一个作为master节点，另外两个分别是node1和node2\n以kubeadm的方式进行安装kubernetes\n卸载k8s教程\n下面开始安装k8s\n在三台虚拟机上都需要执行\n初始操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 关闭防火墙 systemctl stop firewalld systemctl disable firewalld # 关闭selinux sed -i \u0026#39;s/enforcing/disabled/\u0026#39; /etc/selinux/config # 永久 setenforce 0 # 临时 # 关闭swap swapoff -a # 临时 sed -ri \u0026#39;s/.*swap.*/#\u0026amp;/\u0026#39; /etc/fstab # 永久 # 关闭完swap后，一定要重启一下虚拟机！！！ # 根据规划设置主机名 hostnamectl set-hostname \u0026lt;hostname\u0026gt; # 在master添加hosts cat \u0026gt;\u0026gt; /etc/hosts \u0026lt;\u0026lt; EOF 192.168.133.131 k8s-master 192.168.133.132 k8s-node1 192.168.133.133 k8s-node2 EOF # 将桥接的IPv4流量传递到iptables的链 cat \u0026gt; /etc/sysctl.d/k8s.conf \u0026lt;\u0026lt; EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system # 生效 # 时间同步 yum install ntpdate -y ntpdate time.windows.com # 查看当前时间 # 如果发现时间不正确，先重启一下虚拟机 date 安装Docker过程跳过\n安装基础软件（所有节点）\n安装 Docker\n添加阿里云 yum 源\n1 2 3 4 5 6 7 8 9 10 cat \u0026gt; /etc/yum.repos.d/kubernetes.repo \u0026lt;\u0026lt; EOF [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF 安装 kubeadm、kubelet、kubectl\n1 2 3 4 5 6 7 8 9 10 11 12 yum install -y kubelet-1.23.6 kubeadm-1.23.6 kubectl-1.23.6 systemctl enable kubelet systemctl status kubelet # 配置关闭 Docker 的 cgroups，修改 /etc/docker/daemon.json，加入以下内容 \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;] # 重启 docker systemctl daemon-reload systemctl restart docker 部署 Kubernetes Master\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 在 Master 节点下执行 kubeadm init \\ --apiserver-advertise-address=192.168.133.131 \\ --image-repository registry.aliyuncs.com/google_containers \\ --kubernetes-version v1.23.6 \\ --service-cidr=10.96.0.0/12 \\ --pod-network-cidr=10.244.0.0/16 # 安装成功后，复制如下配置并执行 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config kubectl get nodes 执行之后看到如下信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Alternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.conf You should now deploy a pod network to the cluster. Run \u0026#34;kubectl apply -f [podnetwork].yaml\u0026#34; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ Then you can join any number of worker nodes by running the following on each as root: kubeadm join 192.168.42.131:6443 --token g9tav3.xcm2xeniyr5oyib7 \\ --discovery-token-ca-cert-hash sha256:0a77d2c43287e745286bc98863e34ed678f5c9c9ee44a5c179d375755648852a 加入 Kubernetes Node\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 分别在 k8s-node1 和 k8s-node2 执行 # 下方命令可以在 k8s master 控制台初始化成功后复制 join 命令 kubeadm join 192.168.133.131:6443 --token j1wr0y.ej27ox9h3psu96jw --discovery-token-ca-cert-hash sha256:a751ecab11ba054ec4cb70d807de589ae6688324672f02fa4dc62560728d51d4 # 如果初始化的 token 不小心清空了，可以通过如下命令获取或者重新申请 # 如果 token 已经过期，就重新申请 kubeadm token create # token 没有过期可以通过如下命令获取 kubeadm token list # 获取 --discovery-token-ca-cert-hash 值，得到值后需要在前面拼接上 sha256: openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2\u0026gt;/dev/null | \\ openssl dgst -sha256 -hex | sed \u0026#39;s/^.* //\u0026#39; # 删除旧的 kubelet 证书文件 rm -f /opt/kubernetes/ssl/kubelet* # 删除 kubelet kubeconfig 文件 rm -f /opt/kubernetes/cfg/kubelet.kubeconfig # 重启 kubelet 服务，让 master 重新颁发客户端证书 systemctl restart kubelet # 重新join kubeadm join 192.168.133.131:6443 --token f9gwk1.8xastiqq3p9khlzm --discovery-token-ca-cert-hash sha256:7c10606bed070f0eb4ab19399de70744fca7a3e1be7324c9102cb53ba0ac9be6 可以看到子节点打印如下内容，代表已经加入k8s集群环境了\n1 2 3 4 5 This node has joined the cluster: * Certificate signing request was sent to apiserver and a response was received. * The Kubelet was informed of the new secure connection details. Run \u0026#39;kubectl get nodes\u0026#39; on the control-plane to see this node join the cluster 我注意到kubeadm init时报过两个，[WARNING SystemVerification]: this Docker version is not on the list of validated versions: 26.1.4. Latest validated version: 20.10\n原因是docker版本问题，后来安装20.10.7版本的docker之后，该警告消除掉了\n第二个警告是[WARNING Swap]: swap is enabled; production deployments should disable swap unless testing the NodeSwap feature gate of the kubelet\n执行以下命令即可swapoff -a\n部署 CNI 网络插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 在 master 节点上执行 cd /opt/k8s # 下载 calico 配置文件，可能会网络超时 curl https://docs.projectcalico.org/manifests/calico.yaml -O wget https://docs.projectcalico.org/manifests/calico.yaml # 修改 calico.yaml 文件中的 CALICO_IPV4POOL_CIDR 配置，修改为与初始化的 cidr 相同(10.244.0.0/16) # 修改 IP_AUTODETECTION_METHOD 下的网卡名称 sed -i \u0026#39;s/\u0026#34;autodetect\u0026#34;/\u0026#34;autodetect\u0026#34;\\n - name: IP_AUTODETECTION_METHOD\\n value: \u0026#34;interface=ens33\u0026#34;/g\u0026#39; calico.yaml # 查看需要下载的镜像 grep image calico.yaml # 删除镜像 docker.io/ 前缀，避免下载过慢导致失败 sed -i \u0026#39;s#docker.io/##g\u0026#39; calico.yaml # 查看删除前缀的操作是否成功 grep image calico.yaml # 构建应用 kubectl apply -f calico.yaml # 删除应用 # kubectl delete -f calico.yaml # 查看构建结果(Pending在执行中，需要等待变成Running) kubectl get po -n kube-system # 查看Pending状况 # 格式:kubectl describe po \u0026lt;name\u0026gt; -n kube-system kubectl describe po calico-node-sc9g6 -n kube-system docker images | grep calico/cni 如果拉取镜像超时，可以通过配置/etc/docker/daemon.json文件\n我在安装过程中遇到的问题如下\n搭建k8s集群时一直NotReady，我遇到的原因是镜像拉取失败calico/cni:v3.25.0、calico/node:v3.25.0，配置/etc/docker/daemon.json文件如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://hub.uuuadc.top\u0026#34;, \u0026#34;https://docker.anyhub.us.kg\u0026#34;, \u0026#34;https://dockerhub.jobcher.com\u0026#34;, \u0026#34;https://dockerhub.icu\u0026#34;, \u0026#34;https://docker.ckyl.me\u0026#34;, \u0026#34;https://docker.awsl9527.cn\u0026#34; ], \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;100m\u0026#34; }, \u0026#34;storage-driver\u0026#34;: \u0026#34;overlay2\u0026#34; } 继续使用如下命令更新配置，再重新pull一遍即可\n1 2 sudo systemctl daemon-reload sudo systemctl restart docker 测试 kubernetes 集群\n1 2 3 4 5 6 7 8 # 创建部署 kubectl create deployment nginx --image=nginx\t# 暴露端口 kubectl expose deployment nginx --port=80 --type=NodePort # 查看 pod 以及服务信息 kubectl get pod,svc 二进制安装\n利用 k8s 官方 github 仓库下载二进制包安装，安装过程较复杂，但相对较为稳定，推荐生产环境使用。 命令行工具\n命令行工具kubectl\rKubernetes 提供 kubectl 是使用 Kubernetes API 与 Kubernetes 集群的控制面进行通信的命令行工具。\n这个工具叫做 kubectl。 更多命令\nkubectl命令\n在任意节点使用 kubectl\r将 master 节点中 /etc/kubernetes/admin.conf 拷贝到需要运行的服务器的 /etc/kubernetes 目录中\r1 2 scp /etc/kubernetes/admin.conf root@k8s-node1:/etc/kubernetes scp /etc/kubernetes/admin.conf root@k8s-node2:/etc/kubernetes 在对应的服务器上配置环境变量\r1 2 echo \u0026#34;export KUBECONFIG=/etc/kubernetes/admin.conf\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 在子节点上执行kubectl命令查看是否成功\n1 kubectl get pod,svc 资源操作\r创建对象\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 kubectl create -f ./my-manifest.yaml # 创建资源 kubectl create -f ./my1.yaml -f ./my2.yaml # 使用多个文件创建资源 kubectl create -f ./dir # 使用目录下的所有清单文件来创建资源 kubectl create -f https://git.io/vPieo # 使用 url 来创建资源 kubectl run nginx --image=nginx # 启动一个 nginx 实例 kubectl explain pods,svc # 获取 pod 和 svc 的文档 # 从 stdin 输入中创建多个 YAML 对象 cat \u0026lt;\u0026lt;EOF | kubectl create -f - apiVersion: v1 kind: Pod metadata: name: busybox-sleep spec: containers: - name: busybox image: busybox args: - sleep - \u0026#34;1000000\u0026#34; --- apiVersion: v1 kind: Pod metadata: name: busybox-sleep-less spec: containers: - name: busybox image: busybox args: - sleep - \u0026#34;1000\u0026#34; EOF # 创建包含几个 key 的 Secret cat \u0026lt;\u0026lt;EOF | kubectl create -f - apiVersion: v1 kind: Secret metadata: name: mysecret type: Opaque data: password: $(echo \u0026#34;s33msi4\u0026#34; | base64) username: $(echo \u0026#34;jane\u0026#34; | base64) EOF nginx-demo.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 apiVersion: v1 # api文档版本 kind: Pod # 资源对象类型 metadata: # Pod相关的元数据，用于描述Pod name: nginx-demo # Pod的名称 labels: # 定义Pod的标签 type: myFirstApp # 以下全部都是自定义标签 version: 0.0.1 namespace: \u0026#39;default\u0026#39; # 命名空间 spec: # 期望Pod根据这里的描述进行创建 containers: # 对于Pod中容器的描述 - name: nginx # 容器名称 image: nginx:1.7.9 # 指定容器的镜像 imagePullPolicy: IfNotPresent # 指定镜像的拉取策略 command: # 指定容器启动时，执行的命令 - nginx - -g - \u0026#39;daemon off;\u0026#39; # nginx -g \u0026#39;daemon off;\u0026#39; workingDir: /usr/share/nginx/html # 指定工作目录 ports: - name: http # 端口名称 containerPort: 80 # 容器内暴露的端口 protocol: TCP # 描述该端口是基于什么协议进行通讯的 env: # 环境变量 - name: JVM_OPTS # 环境变量名称 value: \u0026#39;-Xms128m -Xmx128m\u0026#39; # 环境变量值 resources: # 配置资源 requests: # 最少需要多少资源 cpu: 100m # 1000m等于一个cpu核心，最少使用0.1个核心 memory: 128Mi # 限制内存最少使用128兆 limits: # 最多使用多少资源 cpu: 200m # 限制cpu最多使用0.2个核心 memory: 256Mi # 限制内存最多使用256兆 restartPolicy: OnFailure # 配置重启策略 可使用如下命令创建pod\n1 kubectl create -f nginx-demo.yaml 显示和查找资源\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # Get commands with basic output $ kubectl get services # 列出所有 namespace 中的所有 service $ kubectl get pods --all-namespaces # 列出所有 namespace 中的所有 pod $ kubectl get pods -o wide # 列出所有 pod 并显示详细信息 $ kubectl get deployment my-dep # 列出指定 deployment $ kubectl get pods --include-uninitialized # 列出该 namespace 中的所有 pod 包括未初始化的 # 使用详细输出来描述命令 $ kubectl describe nodes my-node $ kubectl describe pods my-pod $ kubectl get services --sort-by=.metadata.name # List Services Sorted by Name # 根据重启次数排序列出 pod $ kubectl get pods --sort-by=\u0026#39;.status.containerStatuses[0].restartCount\u0026#39; # 获取所有具有 app=cassandra 的 pod 中的 version 标签 $ kubectl get pods --selector=app=cassandra rc -o \\ jsonpath=\u0026#39;{.items[*].metadata.labels.version}\u0026#39; # 获取所有节点的 ExternalIP $ kubectl get nodes -o jsonpath=\u0026#39;{.items[*].status.addresses[?(@.type==\u0026#34;ExternalIP\u0026#34;)].address}\u0026#39; # 列出属于某个 PC 的 Pod 的名字 # “jq”命令用于转换复杂的 jsonpath，参考 https://stedolan.github.io/jq/ $ sel=${$(kubectl get rc my-rc --output=json | jq -j \u0026#39;.spec.selector | to_entries | .[] | \u0026#34;\\(.key)=\\(.value),\u0026#34;\u0026#39;)%?} $ echo $(kubectl get pods --selector=$sel --output=jsonpath={.items..metadata.name}) # 查看哪些节点已就绪 $ JSONPATH=\u0026#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}\u0026#39; \\ \u0026amp;\u0026amp; kubectl get nodes -o jsonpath=\u0026#34;$JSONPATH\u0026#34; | grep \u0026#34;Ready=True\u0026#34; # 列出当前 Pod 中使用的 Secret $ kubectl get pods -o json | jq \u0026#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name\u0026#39; | grep -v null | sort | uniq 更新资源\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ kubectl rolling-update frontend-v1 -f frontend-v2.json # 滚动更新 pod frontend-v1 $ kubectl rolling-update frontend-v1 frontend-v2 --image=image:v2 # 更新资源名称并更新镜像 $ kubectl rolling-update frontend --image=image:v2 # 更新 frontend pod 中的镜像 $ kubectl rolling-update frontend-v1 frontend-v2 --rollback # 退出已存在的进行中的滚动更新 $ cat pod.json | kubectl replace -f - # 基于 stdin 输入的 JSON 替换 pod # 强制替换，删除后重新创建资源。会导致服务中断。 $ kubectl replace --force -f ./pod.json # 为 nginx RC 创建服务，启用本地 80 端口连接到容器上的 8000 端口 $ kubectl expose rc nginx --port=80 --target-port=8000 # 更新单容器 pod 的镜像版本（tag）到 v4 $ kubectl get pod mypod -o yaml | sed \u0026#39;s/\\(image: myimage\\):.*$/\\1:v4/\u0026#39; | kubectl replace -f - $ kubectl label pods my-pod new-label=awesome # 添加标签 $ kubectl annotate pods my-pod icon-url=http://goo.gl/XXBTWq # 添加注解 $ kubectl autoscale deployment foo --min=2 --max=10 # 自动扩展 deployment “foo” 修补资源\r1 2 3 4 5 6 7 8 9 10 $ kubectl patch node k8s-node-1 -p \u0026#39;{\u0026#34;spec\u0026#34;:{\u0026#34;unschedulable\u0026#34;:true}}\u0026#39; # 部分更新节点 # 更新容器镜像； spec.containers[*].name 是必须的，因为这是合并的关键字 $ kubectl patch pod valid-pod -p \u0026#39;{\u0026#34;spec\u0026#34;:{\u0026#34;containers\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;kubernetes-serve-hostname\u0026#34;,\u0026#34;image\u0026#34;:\u0026#34;new image\u0026#34;}]}}\u0026#39; # 使用具有位置数组的 json 补丁更新容器镜像 $ kubectl patch pod valid-pod --type=\u0026#39;json\u0026#39; -p=\u0026#39;[{\u0026#34;op\u0026#34;: \u0026#34;replace\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/spec/containers/0/image\u0026#34;, \u0026#34;value\u0026#34;:\u0026#34;new image\u0026#34;}]\u0026#39; # 使用具有位置数组的 json 补丁禁用 deployment 的 livenessProbe $ kubectl patch deployment valid-deployment --type json -p=\u0026#39;[{\u0026#34;op\u0026#34;: \u0026#34;remove\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/spec/template/spec/containers/0/livenessProbe\u0026#34;}]\u0026#39; 编辑资源\r1 2 $ kubectl edit svc/docker-registry # 编辑名为 docker-registry 的 service $ KUBE_EDITOR=\u0026#34;nano\u0026#34; kubectl edit svc/docker-registry # 使用其它编辑器 scale 资源\r1 2 3 4 $ kubectl scale --replicas=3 rs/foo # Scale a replicaset named \u0026#39;foo\u0026#39; to 3 $ kubectl scale --replicas=3 -f foo.yaml # Scale a resource specified in \u0026#34;foo.yaml\u0026#34; to 3 $ kubectl scale --current-replicas=2 --replicas=3 deployment/mysql # If the deployment named mysql\u0026#39;s current size is 2, scale mysql to 3 $ kubectl scale --replicas=5 rc/foo rc/bar rc/baz # Scale multiple replication controllers 删除资源\r1 2 3 4 5 $ kubectl delete -f ./pod.json # 删除 pod.json 文件中定义的类型和名称的 pod $ kubectl delete pod,service baz foo # 删除名为“baz”的 pod 和名为“foo”的 service $ kubectl delete pods,services -l name=myLabel # 删除具有 name=myLabel 标签的 pod 和 serivce $ kubectl delete pods,services -l name=myLabel --include-uninitialized # 删除具有 name=myLabel 标签的 pod 和 service，包括尚未初始化的 $ kubectl -n my-ns delete po,svc --all # 删除 my-ns namespace 下的所有 pod 和 serivce，包括尚未初始化的 Pod 与集群\r与运行的 Pod 交互\r1 2 3 4 5 6 7 8 9 10 $ kubectl logs my-pod # dump 输出 pod 的日志（stdout） $ kubectl logs my-pod -c my-container # dump 输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用） $ kubectl logs -f my-pod # 流式输出 pod 的日志（stdout） $ kubectl logs -f my-pod -c my-container # 流式输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用） $ kubectl run -i --tty busybox --image=busybox -- sh # 交互式 shell 的方式运行 pod $ kubectl attach my-pod -i # 连接到运行中的容器 $ kubectl port-forward my-pod 5000:6000 # 转发 pod 中的 6000 端口到本地的 5000 端口 $ kubectl exec my-pod -- ls / # 在已存在的容器中执行命令（只有一个容器的情况下） $ kubectl exec my-pod -c my-container -- ls / # 在已存在的容器中执行命令（pod 中有多个容器的情况下） $ kubectl top pod POD_NAME --containers # 显示指定 pod 和容器的指标度量 与节点和集群交互\r1 2 3 4 5 6 7 8 9 10 $ kubectl cordon my-node # 标记 my-node 不可调度 $ kubectl drain my-node # 清空 my-node 以待维护 $ kubectl uncordon my-node # 标记 my-node 可调度 $ kubectl top node my-node # 显示 my-node 的指标度量 $ kubectl cluster-info # 显示 master 和服务的地址 $ kubectl cluster-info dump # 将当前集群状态输出到 stdout $ kubectl cluster-info dump --output-directory=/path/to/cluster-state # 将当前集群状态输出到 /path/to/cluster-state # 如果该键和影响的污点（taint）已存在，则使用指定的值替换 $ kubectl taint nodes foo dedicated=special-user:NoSchedule 资源类型与别名\rpods\rpo\nPod 的设计理念是支持多个容器在一个 Pod 中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod 对多容器的支持是 K8 最基础的设计理念。比如你运行一个操作系统发行版的软件仓库，一个 Nginx 容器用来发布软件，另一个容器专门用来从源仓库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一个微服务；这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。\nKubernetes（k8s）中的Pod与Docker Compose有相似之处\nReplication Controller\rrc（副本控制器）\nRC 是 Kubernetes 集群中最早的保证 Pod 高可用的 API 对象。通过监控运行中的 Pod 来保证集群中运行指定数目的 Pod 副本。指定的数目可以是多个也可以是 1 个；少于指定数目，RC 就会启动运行新的 Pod 副本；多于指定数目，RC 就会杀死多余的 Pod 副本。即使在指定数目为 1 的情况下，通过 RC 运行 Pod 也比直接运行 Pod 更明智，因为 RC 也可以发挥它高可用的能力，保证永远有 1 个 Pod 在运行。RC 是 Kubernetes 较早期的技术概念，只适用于长期伺服型的业务类型，比如控制小机器人提供高可用的 Web 服务。\nReplica Set\nrs（副本集）\nRS 是新一代 RC，提供同样的高可用能力，区别主要在于 RS 后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为 Deployment 的理想状态参数使用。\ndeployments\rdeploy\n部署表示用户对 Kubernetes 集群的一次更新操作。部署是一个比 RS 应用模式更广的 API 对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的 RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧 RS 中的副本数减小到 0 的复合操作；这样一个复合操作用一个 RS 是不太好描述的，所以用一个更通用的 Deployment 来描述。以 Kubernetes 的发展方向，未来对所有长期伺服型的的业务的管理，都会通过 Deployment 来管理。\nstatefulset\rsts（有状态服务集）\nRC 和 RS 主要是控制提供无状态服务的，其所控制的 Pod 的名字是随机设置的，一个 Pod 出故障了就被丢弃掉，在另一个地方重启一个新的 Pod，名字变了。名字和启动在哪儿都不重要，重要的只是 Pod 总数；而 StatefulSet 是用来控制有状态服务，StatefulSet 中的每个 Pod 的名字都是事先确定的，不能更改。\n对于 RC 和 RS 中的 Pod，一般不挂载存储或者挂载共享存储，保存的是所有 Pod 共享的状态；对于 StatefulSet 中的 Pod，每个 Pod 挂载自己独立的存储，如果一个 Pod 出现故障，从其他节点启动一个同样名字的 Pod，要挂载上原来 Pod 的存储继续以它的状态提供服务。\n适合于 StatefulSet 的业务包括数据库服务 MySQL 和 PostgreSQL，集群化管理服务 ZooKeeper、etcd 等有状态服务。StatefulSet 的另一种典型应用场景是作为一种比普通容器更稳定可靠的模拟虚拟机的机制。传统的虚拟机正是一种有状态的宠物，运维人员需要不断地维护它，容器刚开始流行时，我们用容器来模拟虚拟机使用，所有状态都保存在容器里，而这已被证明是非常不安全、不可靠的。使用 StatefulSet，Pod 仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，StatefulSet 做的只是将确定的 Pod 与确定的存储关联起来保证状态的连续性。\nvolume\rKubernetes 集群中的存储卷跟 Docker 的存储卷有些类似，只不过 Docker 的存储卷作用范围为一个容器，而 Kubernetes 的存储卷的生命周期和作用范围是一个 Pod。每个 Pod 中声明的存储卷由 Pod 中的所有容器共享。Kubernetes 支持非常多的存储卷类型，特别的，支持多种公有云平台的存储，包括 AWS，Google 和 Azure 云；支持多种分布式存储包括 GlusterFS 和 Ceph；也支持较容易使用的主机本地目录 emptyDir, hostPath 和 NFS。Kubernetes 还支持使用 Persistent Volume Claim 即 PVC 这种逻辑存储，使用这种存储，使得存储的使用者可以忽略后台的实际存储技术（例如 AWS，Google 或 GlusterFS 和 Ceph），而将有关存储实际技术的配置交给存储管理员通过 Persistent Volume 来配置。\nservices\rsvc\nnamespace\rns\n命名空间为 Kubernetes 集群提供虚拟的隔离作用，Kubernetes 集群初始有两个命名空间，分别是默认命名空间 default 和系统命名空间 kube-system，除此以外，管理员可以可以创建新的命名空间满足需要。\nnodes\rno\n格式化输出\r输出 json 格式\r1 -o json 仅打印资源名称\r1 -o name 以纯文本格式输出所有信息\r1 -o wide 输出 yaml 格式\r1 -o yaml API 概述\r官网文档：https://kubernetes.io/zh-cn/docs/reference/using-api/\nREST API 是 Kubernetes 系统的重要部分，组件之间的所有操作和通信均由 API Server 处理的 REST AP I调用，大多数情况下， API 定义和实现都符合标准的 HTTP REST 格式，可以通过 kubectl 命令管理工具或其他命令行工具来执行。\n类型\rAlpha\r包含 alpha 名称的版本（例如v1alpha1）。 该软件可能包含错误。启用一个功能可能会导致 bug。默认情况下，功能可能会被禁用。 随时可能会丢弃对该功能的支持，恕不另行通知。 API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。 该软件建议仅在短期测试集群中使用，因为错误的风险增加和缺乏长期支持。 Beta\r包含 beta 名称的版本（例如 v2beta3）。 该软件经过很好的测试。启用功能被认为是安全的。默认情况下功能是开启的。 细节可能会改变，但功能在后续版本不会被删除 对象的模式或语义在随后的 beta 版本或 Stable 版本中可能以不兼容的方式发生变化。如果这种情况发生时，官方会提供迁移操作指南。这可能需要删除、编辑和重新创建API对象。 该版本在后续可能会更改一些不兼容地方，所以建议用于非关键业务，如果你有多个可以独立升级的集群，你也可以放宽此限制。 大家使用过的 Beta 版本后，可以多给社区反馈，如果此版本在后续更新后将不会有太大变化。 Stable\r该版本名称命名方式：vX 这里 X 是一个整数。 Stable 版本的功能特性，将出现在后续发布的软件版本中。 访问控制\r认证\r授权\r废弃 api 说明\r相关文档\n深入Pod\rPod 配置文件\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 apiVersion: v1 # api 文档版本 kind: Pod # 资源对象类型，也可以配置为像Deployment、StatefulSet这一类的对象 metadata: # Pod 相关的元数据，用于描述 Pod 的数据 name: nginx-demo # Pod 的名称 labels: # 定义 Pod 的标签 type: app # 自定义 label 标签，名字为 type，值为 app test: 1.0.0 # 自定义 label 标签，描述 Pod 版本号 namespace: \u0026#39;default\u0026#39; # 命名空间的配置 spec: # 期望 Pod 按照这里面的描述进行创建 containers: # 对于 Pod 中的容器描述 - name: nginx # 容器的名称 image: nginx:1.7.9 # 指定容器的镜像 imagePullPolicy: IfNotPresent # 镜像拉取策略，指定如果本地有就用本地的，如果没有就拉取远程的 command: # 指定容器启动时执行的命令 - nginx - -g - \u0026#39;daemon off;\u0026#39; # nginx -g \u0026#39;daemon off;\u0026#39; workingDir: /usr/share/nginx/html # 定义容器启动后的工作目录 ports: - name: http # 端口名称 containerPort: 80 # 描述容器内要暴露什么端口 protocol: TCP # 描述该端口是基于哪种协议通信的 - env: # 环境变量 name: JVM_OPTS # 环境变量名称 value: \u0026#39;-Xms128m -Xmx128m\u0026#39; # 环境变量的值 reousrces: requests: # 最少需要多少资源 cpu: 100m # 限制 cpu 最少使用 0.1 个核心 memory: 128Mi # 限制内存最少使用 128兆 limits: # 最多可以用多少资源 cpu: 200m # 限制 cpu 最多使用 0.2 个核心 memory: 256Mi # 限制 最多使用 256兆 restartPolicy: OnFailure # 重启策略，只有失败的情况才会重启 执行以下命令进行创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # -f 指定创建模板 kubectl create -f nginx-demo.yaml # 查看pods状态，发现已经在运行了 kubectl get po # 查看更加详细的信息，如端口号 kubectl get po -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES nginx-demo 1/1 Running 0 2m26s 10.244.169.131 k8s-node2 \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; # 可以看到这个时候的ip(10.244.169.131)和节点(node2) route -n Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.42.2 0.0.0.0 UG 100 0 0 ens33 10.244.36.64 192.168.42.132 255.255.255.192 UG 0 0 0 tunl0 10.244.169.128 192.168.42.133 255.255.255.192 UG 0 0 0 tunl0 10.244.235.192 0.0.0.0 255.255.255.192 U 0 0 0 * 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 192.168.42.0 0.0.0.0 255.255.255.0 U 100 0 0 ens33 192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0 # 可以看到确实被路由到了node2节点上，这个功能是由于我们之前安装了`CNI 网络插件`实现的 # ip(10.244.169.131)通过node2节点进行转发，此时再进入node2节点下查看路由信息，就可以找到当前的网关了 Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.42.2 0.0.0.0 UG 100 0 0 ens33 10.244.36.64 192.168.42.132 255.255.255.192 UG 0 0 0 tunl0 10.244.169.128 0.0.0.0 255.255.255.192 U 0 0 0 * 10.244.169.130 0.0.0.0 255.255.255.255 UH 0 0 0 cali11b82779865 10.244.169.131 0.0.0.0 255.255.255.255 UH 0 0 0 cali7543b7f115c 10.244.235.192 192.168.42.131 255.255.255.192 UG 0 0 0 tunl0 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 192.168.42.0 0.0.0.0 255.255.255.0 U 100 0 0 ens33 192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0 探针\r在实际运行中可能会由于各种原因导致服务挂掉，比如内存溢出\n但是pod怎么监听到容器挂掉了呢？是通过探针来监控容器实现\n需要关注下配置的重启策略(restartPolicy)，当容器挂掉之后，kubelet会根据配置的重启策略进行重启\n容器内应用的监测机制，根据不同的探针来判断容器应用当前的状态\n1 2 3 4 # 删除nginx-demo pod kubectl delete po nginx-demo # 修改yaml，新增探针配置 StartupProbe\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 apiVersion: v1 # api文档版本 kind: Pod # 资源对象类型 metadata: # Pod相关的元数据，用于描述Pod name: nginx-demo # Pod的名称 labels: # 定义Pod的标签 type: myFirstApp # 以下全部都是自定义标签 version: 0.0.1 namespace: \u0026#39;default\u0026#39; # 命名空间 spec: # 期望Pod根据这里的描述进行创建 containers: # 对于Pod中容器的描述 - name: nginx # 容器名称 image: nginx:1.7.9 # 指定容器的镜像 imagePullPolicy: IfNotPresent # 指定镜像的拉取策略 startupProbe: # 应用启动探针配置 httpGet: # 探测方式，基于http请求探测 path: /api/path # http请求路径 port: 80 # http请求端口 failureThreshold: 3 # 失败重试多少次后，真正失败 periodSeconds: 10 # 间隔时间 successThreshold: 1 # 多少次成功后，真正成功 timeoutSeconds: 5 # 请求的超时时间 command: # 指定容器启动时，执行的命令 - nginx - -g - \u0026#39;daemon off;\u0026#39; # nginx -g \u0026#39;daemon off;\u0026#39; workingDir: /usr/share/nginx/html # 指定工作目录 ports: - name: http # 端口名称 containerPort: 80 # 容器内暴露的端口 protocol: TCP # 描述该端口是基于什么协议进行通讯的 env: # 环境变量 - name: JVM_OPTS # 环境变量名称 value: \u0026#39;-Xms128m -Xmx128m\u0026#39; # 环境变量值 resources: # 配置资源 requests: # 最少需要多少资源 cpu: 100m # 1000m等于一个cpu核心，最少使用0.1个核心 memory: 128Mi # 限制内存最少使用128兆 limits: # 最多使用多少资源 cpu: 200m # 限制cpu最多使用0.2个核心 memory: 256Mi # 限制内存最多使用256兆 restartPolicy: OnFailure # 配置重启策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 创建po kubectl create -f nginx-demo.yaml # 查看po状态 kubectl get po # 查看详细信息 kubectl describe po nginx-demo # 发现有如下日志 # Warning Unhealthy 6s (x7 over 66s) kubelet Startup probe failed: HTTP probe failed with statuscode: 404 # 因为nginx并没有/api/path请求路径，所以报404 # 现在更改为/index.html后重新构建po # 发现构建成功 # Normal Started 7s kubelet Started container nginx # 配置文件修改成如下，不再使用http，使用tcpSocket的协议 # 只要成功建立tcp连接，我们就认为pod构建成功 # 编辑pods kubectl edit po nginx-demo # 删除pods kubectl delete po nginx-demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 apiVersion: v1 # api文档版本 kind: Pod # 资源对象类型 metadata: # Pod相关的元数据，用于描述Pod name: nginx-demo # Pod的名称 labels: # 定义Pod的标签 type: myFirstApp # 以下全部都是自定义标签 version: 0.0.1 namespace: \u0026#39;default\u0026#39; # 命名空间 spec: # 期望Pod根据这里的描述进行创建 containers: # 对于Pod中容器的描述 - name: nginx # 容器名称 image: nginx:1.7.9 # 指定容器的镜像 imagePullPolicy: IfNotPresent # 指定镜像的拉取策略 startupProbe: # 应用启动探针配置 # httpGet: # 探测方式，基于http请求探测 # path: /index.html # http请求路径 # port: 80 # http请求端口 tcpSocket: port: 80 failureThreshold: 3 # 失败重试多少次后，真正失败 periodSeconds: 10 # 间隔时间 successThreshold: 1 # 多少次成功后，真正成功 timeoutSeconds: 5 # 请求的超时时间 command: # 指定容器启动时，执行的命令 - nginx - -g - \u0026#39;daemon off;\u0026#39; # nginx -g \u0026#39;daemon off;\u0026#39; workingDir: /usr/share/nginx/html # 指定工作目录 ports: - name: http # 端口名称 containerPort: 80 # 容器内暴露的端口 protocol: TCP # 描述该端口是基于什么协议进行通讯的 env: # 环境变量 - name: JVM_OPTS # 环境变量名称 value: \u0026#39;-Xms128m -Xmx128m\u0026#39; # 环境变量值 resources: # 配置资源 requests: # 最少需要多少资源 cpu: 100m # 1000m等于一个cpu核心，最少使用0.1个核心 memory: 128Mi # 限制内存最少使用128兆 limits: # 最多使用多少资源 cpu: 200m # 限制cpu最多使用0.2个核心 memory: 256Mi # 限制内存最多使用256兆 restartPolicy: OnFailure # 配置重启策略 修改成exec的形式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 apiVersion: v1 # api文档版本 kind: Pod # 资源对象类型 metadata: # Pod相关的元数据，用于描述Pod name: nginx-demo # Pod的名称 labels: # 定义Pod的标签 type: myFirstApp # 以下全部都是自定义标签 version: 0.0.1 namespace: \u0026#39;default\u0026#39; # 命名空间 spec: # 期望Pod根据这里的描述进行创建 containers: # 对于Pod中容器的描述 - name: nginx # 容器名称 image: nginx:1.7.9 # 指定容器的镜像 imagePullPolicy: IfNotPresent # 指定镜像的拉取策略 startupProbe: # 应用启动探针配置 # httpGet: # 探测方式，基于http请求探测 # path: /index.html # http请求路径 # port: 80 # http请求端口 # tcpSocket: # port: 80 exec: command: - sh - c - \u0026#34;sleep 5;echo \u0026#39;successful\u0026#39; \u0026gt; /inited;\u0026#34; failureThreshold: 3 # 失败重试多少次后，真正失败 periodSeconds: 10 # 间隔时间 successThreshold: 1 # 多少次成功后，真正成功 timeoutSeconds: 5 # 请求的超时时间 command: # 指定容器启动时，执行的命令 - nginx - -g - \u0026#39;daemon off;\u0026#39; # nginx -g \u0026#39;daemon off;\u0026#39; workingDir: /usr/share/nginx/html # 指定工作目录 ports: - name: http # 端口名称 containerPort: 80 # 容器内暴露的端口 protocol: TCP # 描述该端口是基于什么协议进行通讯的 env: # 环境变量 - name: JVM_OPTS # 环境变量名称 value: \u0026#39;-Xms128m -Xmx128m\u0026#39; # 环境变量值 resources: # 配置资源 requests: # 最少需要多少资源 cpu: 100m # 1000m等于一个cpu核心，最少使用0.1个核心 memory: 128Mi # 限制内存最少使用128兆 limits: # 最多使用多少资源 cpu: 200m # 限制cpu最多使用0.2个核心 memory: 256Mi # 限制内存最多使用256兆 restartPolicy: OnFailure # 配置重启策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 查看发现重试过4次，说明失败了 kubectl get po # 寻找失败原因 # 发现是命令有问题，实际执行的命令sh c sleep 5;echo \u0026#39;successful\u0026#39; \u0026gt; /inited; # 期待执行的命令sh -c sleep 5;echo \u0026#39;successful\u0026#39; \u0026gt; /inited; # 修改代码 【- c】 -\u0026gt; 【- -c】 # 提示Startup probe failed: command \u0026#34;sh -c sleep 5;echo \u0026#39;successful\u0026#39; \u0026gt; /inited;\u0026#34; timed out # 因为睡眠5s，而配置的超时时间也是5s，我们继续讲睡眠时间改短点 # -it表示交互模式 # -c指定容器为nginx # --后面的命令是执行的shell指令 kubectl exec -it nginx-demo -c nginx -- cat /inited 复制一个nginx-liveness-demo.yaml文件\nLivenessProbe\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 apiVersion: v1 # api文档版本 kind: Pod # 资源对象类型 metadata: # Pod相关的元数据，用于描述Pod name: nginx-liveness-demo # Pod的名称 labels: # 定义Pod的标签 type: myFirstApp # 以下全部都是自定义标签 version: 0.0.1 namespace: \u0026#39;default\u0026#39; # 命名空间 spec: # 期望Pod根据这里的描述进行创建 containers: # 对于Pod中容器的描述 - name: nginx # 容器名称 image: nginx:1.7.9 # 指定容器的镜像 imagePullPolicy: IfNotPresent # 指定镜像的拉取策略 startupProbe: # 应用启动探针配置 # httpGet: # 探测方式，基于http请求探测 # path: /index.html # http请求路径 # port: 80 # http请求端口 # tcpSocket: # port: 80 exec: command: - sh - -c - \u0026#34;sleep 2;echo \u0026#39;successful\u0026#39; \u0026gt; /inited;\u0026#34; failureThreshold: 3 # 失败重试多少次后，真正失败 periodSeconds: 10 # 间隔时间 successThreshold: 1 # 多少次成功后，真正成功 timeoutSeconds: 5 # 请求的超时时间 livenessProbe: # 应用存活探针配置 httpGet: # 探测方式，基于http请求探测 path: /index1.html # http请求路径 port: 80 # http请求端口 # tcpSocket: # port: 80 # exec: # command: # - sh # - -c # - \u0026#34;sleep 2;echo \u0026#39;successful\u0026#39; \u0026gt; /inited;\u0026#34; failureThreshold: 3 # 失败重试多少次后，真正失败 periodSeconds: 10 # 间隔时间 successThreshold: 1 # 多少次成功后，真正成功 timeoutSeconds: 5 # 请求的超时时间 command: # 指定容器启动时，执行的命令 - nginx - -g - \u0026#39;daemon off;\u0026#39; # nginx -g \u0026#39;daemon off;\u0026#39; workingDir: /usr/share/nginx/html # 指定工作目录 ports: - name: http # 端口名称 containerPort: 80 # 容器内暴露的端口 protocol: TCP # 描述该端口是基于什么协议进行通讯的 env: # 环境变量 - name: JVM_OPTS # 环境变量名称 value: \u0026#39;-Xms128m -Xmx128m\u0026#39; # 环境变量值 resources: # 配置资源 requests: # 最少需要多少资源 cpu: 100m # 1000m等于一个cpu核心，最少使用0.1个核心 memory: 128Mi # 限制内存最少使用128兆 limits: # 最多使用多少资源 cpu: 200m # 限制cpu最多使用0.2个核心 memory: 256Mi # 限制内存最多使用256兆 restartPolicy: OnFailure # 配置重启策略 1 2 3 4 5 6 7 # 请求/index1.html失败，在重试5次后，依然无法启动 # Warning Unhealthy 17s (x9 over 117s) kubelet Liveness probe failed: HTTP probe failed with statuscode: 404 # Normal Killing 17s (x3 over 97s) kubelet Container nginx failed liveness probe, will be restarted echo \u0026#39;success\u0026#39; \u0026gt; index1.html # 拷贝到文件内部 kubectl cp index1.html nginx-liveness-demo:/usr/share/nginx/html 当三种探针同时存在时，必定先运行startup，之后才是LivenessProbe和ReadinessProbe\nReadinessProbe\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 apiVersion: v1 # api文档版本 kind: Pod # 资源对象类型 metadata: # Pod相关的元数据，用于描述Pod name: nginx-liveness-demo # Pod的名称 labels: # 定义Pod的标签 type: myFirstApp # 以下全部都是自定义标签 version: 0.0.1 namespace: \u0026#39;default\u0026#39; # 命名空间 spec: # 期望Pod根据这里的描述进行创建 containers: # 对于Pod中容器的描述 - name: nginx # 容器名称 image: nginx:1.7.9 # 指定容器的镜像 imagePullPolicy: IfNotPresent # 指定镜像的拉取策略 startupProbe: # 应用启动探针配置 # httpGet: # 探测方式，基于http请求探测 # path: /index.html # http请求路径 # port: 80 # http请求端口 # tcpSocket: # port: 80 exec: command: - sh - -c - \u0026#34;sleep 2;echo \u0026#39;successful\u0026#39; \u0026gt; /inited;\u0026#34; failureThreshold: 3 # 失败重试多少次后，真正失败 periodSeconds: 10 # 间隔时间 successThreshold: 1 # 多少次成功后，真正成功 timeoutSeconds: 5 # 请求的超时时间 livenessProbe: # 应用存活探针配置 httpGet: # 探测方式，基于http请求探测 path: /index.html # http请求路径 port: 80 # http请求端口 # tcpSocket: # port: 80 # exec: # command: # - sh # - -c # - \u0026#34;sleep 2;echo \u0026#39;successful\u0026#39; \u0026gt; /inited;\u0026#34; failureThreshold: 3 # 失败重试多少次后，真正失败 periodSeconds: 10 # 间隔时间 successThreshold: 1 # 多少次成功后，真正成功 timeoutSeconds: 5 # 请求的超时时间 readinessProbe: # 应用存活探针配置 httpGet: # 探测方式，基于http请求探测 path: /index1.html # http请求路径 port: 80 # http请求端口 # tcpSocket: # port: 80 # exec: # command: # - sh # - -c # - \u0026#34;sleep 2;echo \u0026#39;successful\u0026#39; \u0026gt; /inited;\u0026#34; failureThreshold: 3 # 失败重试多少次后，真正失败 periodSeconds: 10 # 间隔时间 successThreshold: 1 # 多少次成功后，真正成功 timeoutSeconds: 5 # 请求的超时时间 command: # 指定容器启动时，执行的命令 - nginx - -g - \u0026#39;daemon off;\u0026#39; # nginx -g \u0026#39;daemon off;\u0026#39; workingDir: /usr/share/nginx/html # 指定工作目录 ports: - name: http # 端口名称 containerPort: 80 # 容器内暴露的端口 protocol: TCP # 描述该端口是基于什么协议进行通讯的 env: # 环境变量 - name: JVM_OPTS # 环境变量名称 value: \u0026#39;-Xms128m -Xmx128m\u0026#39; # 环境变量值 resources: # 配置资源 requests: # 最少需要多少资源 cpu: 100m # 1000m等于一个cpu核心，最少使用0.1个核心 memory: 128Mi # 限制内存最少使用128兆 limits: # 最多使用多少资源 cpu: 200m # 限制cpu最多使用0.2个核心 memory: 256Mi # 限制内存最多使用256兆 restartPolicy: OnFailure # 配置重启策略 1 2 3 4 5 # 404 # Warning Unhealthy 1s kubelet Readiness probe failed: HTTP probe failed with statuscode: 404 kubectl cp index1.html nginx-liveness-demo:/usr/share/nginx/html # node状态转为ready 类型\rStartupProbe\nk8s 1.16 版本新增的探针，用于判断应用程序是否已经启动了。\n当配置了 startupProbe 后，会先禁用其他探针，直到 startupProbe 成功后，其他探针才会继续。\n作用：由于有时候不能准确预估应用一定是多长时间启动成功，因此配置另外两种方式不方便配置初始化时长来检测，而配置了 statupProbe 后，只有在应用启动成功了，才会执行另外两种探针，可以更加方便的结合使用另外两种探针使用。\n1 2 3 4 startupProbe: httpGet: path: /api/startup port: 80 LivenessProbe\n用于探测容器中的应用是否运行，如果探测失败，kubelet 会根据配置的重启策略进行重启，若没有配置，默认就认为容器启动成功，不会执行重启策略。\n1 2 3 4 5 6 7 8 9 10 livenessProbe: failureThreshold: 5 httpGet: path: /health port: 8080 scheme: HTTP initialDelaySeconds: 60 periodSeconds: 10 successThreshold: 1 timeoutSeconds: 5 ReadinessProbe\n用于探测容器内的程序是否健康，它的返回值如果返回 success，那么就认为该容器已经完全启动，并且该容器是可以接收外部流量的。\n1 2 3 4 5 6 7 8 9 readinessProbe: failureThreshold: 3 # 错误次数 httpGet: path: /ready port: 8181 scheme: HTTP periodSeconds: 10 # 间隔时间 successThreshold: 1 timeoutSeconds: 1 探测方式\rExecAction\n在容器内部执行一个命令，如果返回值为 0，则任务容器时健康的。\n1 2 3 4 5 livenessProbe: exec: command: \\- cat \\- /health TCPSocketAction\n通过 tcp 连接监测容器内端口是否开放，如果开放则证明该容器健康\n1 2 3 livenessProbe: tcpSocket: port: 80 HTTPGetAction\n生产环境用的较多的方式，发送 HTTP 请求到容器内的应用程序，如果接口返回的状态码在 200~400 之间，则认为容器健康。\n1 2 3 4 5 6 7 8 9 livenessProbe: failureThreshold: 5 httpGet: path: /health port: 8080 scheme: HTTP httpHeaders: \\- name: xxx value: xxx 参数配置\r1 2 3 4 5 initialDelaySeconds: 60 # 初始化时间 timeoutSeconds: 2 # 超时时间 periodSeconds: 5 # 监测间隔时间 successThreshold: 1 # 检查 1 次成功就表示成功 failureThreshold: 2 # 监测失败 2 次就表示失败 生命周期\r修改nginx-demo.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 apiVersion: v1 # api文档版本 kind: Pod # 资源对象类型 metadata: # Pod相关的元数据，用于描述Pod name: nginx-demo # Pod的名称 labels: # 定义Pod的标签 type: myFirstApp # 以下全部都是自定义标签 version: 0.0.1 namespace: \u0026#39;default\u0026#39; # 命名空间 spec: # 期望Pod根据这里的描述进行创建 containers: # 对于Pod中容器的描述 - name: nginx # 容器名称 image: nginx:1.7.9 # 指定容器的镜像 imagePullPolicy: IfNotPresent # 指定镜像的拉取策略 lifecycle: # 生命周期的配置 postStart: # 生命周期启动阶段做的事情，但是不一定在容器command之前运行 exec: command: - sh - -c - \u0026#34;echo \u0026#39;this is postStart\u0026#39; \u0026gt; /usr/share/nginx/html/lifecycle.html\u0026#34; preStop: exec: command: - sh - -c - \u0026#34;sleep 50;echo \u0026#39;this is preStop\u0026#39; \u0026gt;\u0026gt; /usr/share/nginx/html/lifecycle.html\u0026#34; command: # 指定容器启动时，执行的命令 - nginx - -g - \u0026#39;daemon off;\u0026#39; # nginx -g \u0026#39;daemon off;\u0026#39; workingDir: /usr/share/nginx/html # 指定工作目录 ports: - name: http # 端口名称 containerPort: 80 # 容器内暴露的端口 protocol: TCP # 描述该端口是基于什么协议进行通讯的 env: # 环境变量 - name: JVM_OPTS # 环境变量名称 value: \u0026#39;-Xms128m -Xmx128m\u0026#39; # 环境变量值 resources: # 配置资源 requests: # 最少需要多少资源 cpu: 100m # 1000m等于一个cpu核心，最少使用0.1个核心 memory: 128Mi # 限制内存最少使用128兆 limits: # 最多使用多少资源 cpu: 200m # 限制cpu最多使用0.2个核心 memory: 256Mi # 限制内存最多使用256兆 restartPolicy: OnFailure # 配置重启策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 注意preStop处的命令，有一个sleep 50 # 获取详细信息(ip地址) kubectl get po -o wide curl 10.244.36.70:80/lifecycle.html # this is postStart # 再开一个窗口，持续监听po状态 kubectl get po -w # -w 代表持续监听pod状态 # 删除pod并查看删除的时间 # time代表打印执行命令消耗的时间 time kubectl delete po pod_name # 此时发现并没有在50s时删除(因为我们`preStop`里定义的是sleep时间是50s) # 是因为存在一个删除默认时间配置，默认是`30s`(terminationGracePeriodSeconds) # 打印结果如下 NAME READY STATUS RESTARTS AGE nginx-demo 1/1 Running 0 14s nginx-demo 1/1 Terminating 0 15s nginx-demo 1/1 Terminating 0 45s nginx-demo 0/1 Terminating 0 45s nginx-demo 0/1 Terminating 0 45s nginx-demo 0/1 Terminating 0 45s # 从第一个Terminating到最后，消耗了30s，并不是50s # 因为k8s 默认给 pod 的停止宽限时间为 30s，配置参数为terminationGracePeriodSeconds: 30 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 apiVersion: v1 # api文档版本 kind: Pod # 资源对象类型 metadata: # Pod相关的元数据，用于描述Pod name: nginx-po # Pod的名称 labels: # 定义Pod的标签 type: myFirstApp # 以下全部都是自定义标签 version: 0.0.1 namespace: \u0026#39;default\u0026#39; # 命名空间 spec: # 期望Pod根据这里的描述进行创建 terminationGracePeriodSeconds: 50 # 当pod被删除时，给这个pod宽限多长时间 containers: # 对于Pod中容器的描述 - name: nginx # 容器名称 image: nginx:1.7.9 # 指定容器的镜像 imagePullPolicy: IfNotPresent # 指定镜像的拉取策略 lifecycle: # 生命周期的配置 postStart: # 生命周期启动阶段做的事，不一定在command之前执行 exec: command: - sh - -c - \u0026#34;echo \u0026#39;hello\u0026#39; \u0026gt; /usr/share/nginx/html/prestop.html\u0026#34; preStop: exec: command: - sh - -c - \u0026#34;sleep 50;echo \u0026#39;sleep..\u0026#39; \u0026gt;\u0026gt; /usr/share/nginx/html/prestop.html\u0026#34; command: # 指定容器启动时，执行的命令 - nginx - -g - \u0026#39;daemon off;\u0026#39; # nginx -g \u0026#39;daemon off;\u0026#39; workingDir: /usr/share/nginx/html # 指定工作目录 ports: - name: http # 端口名称 containerPort: 80 # 容器内暴露的端口 protocol: TCP # 描述该端口是基于什么协议进行通讯的 env: # 环境变量 - name: JVM_OPTS # 环境变量名称 value: \u0026#39;-Xms128m -Xmx128m\u0026#39; # 环境变量值 resources: # 配置资源 requests: # 最少需要多少资源 cpu: 100m # 1000m等于一个cpu核心，最少使用0.1个核心 memory: 128Mi # 限制内存最少使用128兆 limits: # 最多使用多少资源 cpu: 200m # 限制cpu最多使用0.2个核心 memory: 256Mi # 限制内存最多使用256兆 restartPolicy: OnFailure # 配置重启策略 发现这次就是50s了\nPod 退出流程\r删除操作\rEndpoint 删除 pod 的 ip 地址\nPod 变成 Terminating 状态\n变为删除中的状态后，会给 pod 一个宽限期，让 pod 去执行一些清理或销毁操作。\n配置参数：\n1 2 3 4 # 作用与 pod 中的所有容器 terminationGracePeriodSeconds: 30 containers: \\- xxx 执行 preStop 的指令\nPreStop 的应用\r如果应用销毁操作耗时需要比较长，可以在 preStop 按照如下方式进行配置\n1 2 3 4 5 6 preStop: exec: command: \\- sh \\- -c \\- \u0026#39;sleep 20; kill pgrep java\u0026#39; 但是需要注意，由于 k8s 默认给 pod 的停止宽限时间为 30s，如果我们停止操作会超过 30s 时，不要光设置 sleep 50，还要将 terminationGracePeriodSeconds: 30 也更新成更长的时间，否则 k8s 最多只会在这个时间的基础上再宽限几秒，不会真正等待 50s\n注册中心下线 数据清理 数据销毁 资源调度\rLabel 和 Selector\r标签（Label）\rdeploy和rs之间的绑定关系，如果采用mysql表中一对多或多对多就会形成强绑定关系，k8s并没有采用这种方式\n配置文件\r在各类资源的 metadata.labels 中进行配置\nkubectl\r临时创建 label\n1 2 3 4 kubectl label po \u0026lt;资源名称\u0026gt; app=hello # 指定命名空间 kubectl label po \u0026lt;资源名称\u0026gt; app=hello -n kube-public 修改已经存在的标签\n1 kubectl label po \u0026lt;资源名称\u0026gt; app=hello2 --overwrite 查看 label\n1 2 3 4 5 # selector 按照 label 单值查找节点 kubectl get po -A -l app=hello # 查看所有节点的 labels kubectl get po --show-labels 修改配置文件的形式修改lable\n1 kubectl edit po nginx-demo 如果希望给deploy打上标签有两种方式\n修改对应的yaml配置文件(spec.meta.data.labels) 使用命令打标签 创建临时label(kubectl label po pod_name app=hello) 修改已经存在的label(kubectl label po pod_name app=hello1 \u0026ndash;overwrite) 查看label(kubectl get po [pod_name] \u0026ndash;show-labels) 1 2 3 4 5 6 7 8 9 10 11 12 [root@k8s-master pods]# kubectl create -f nginx-po.yaml pod/nginx-po created [root@k8s-master pods]# kubectl get po NAME READY STATUS RESTARTS AGE nginx-po 1/1 Running 0 2m5s [root@k8s-master pods]# kubectl get po --show-labels NAME READY STATUS RESTARTS AGE LABELS nginx-po 1/1 Running 0 2m32s type=myFirstApp,version=0.0.1 [root@k8s-master pods]# kubectl get po nginx-po --show-labels NAME READY STATUS RESTARTS AGE LABELS nginx-po 1/1 Running 0 2m40s type=myFirstApp,version=0.0.1 [root@k8s-master pods]# 能查看到标签是因为在原来的yaml里我们已经配置了一部分label\n除此之外，如果希望在已经存在的po上新建/修改label可以使用如下命令\n1 2 3 4 5 6 7 8 [root@k8s-master pods]# kubectl get po nginx-po --show-labels NAME READY STATUS RESTARTS AGE LABELS nginx-po 1/1 Running 0 17m type=app1,version=0.0.1 [root@k8s-master pods]# kubectl edit po nginx-po pod/nginx-po edited [root@k8s-master pods]# kubectl get po nginx-po --show-labels NAME READY STATUS RESTARTS AGE LABELS nginx-po 1/1 Running 0 25m type=app2,version=0.0.1 选择器（Selector）\r在各对象的配置 spec.selector 或其他可以写 selector 的属性中编写\n配置文件\r在各对象的配置 spec.selector 或其他可以写 selector 的属性中编写\nkubectl\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # -l表示根据label进行匹配,匹配单个值，查找 =app2 的 pod [root@k8s-master pods]# kubectl get po -l type=app2 NAME READY STATUS RESTARTS AGE nginx-po 1/1 Running 0 27m # -A显示命名空间 [root@k8s-master pods]# kubectl get po -A -l type=app2 NAMESPACE NAME READY STATUS RESTARTS AGE default nginx-po 1/1 Running 0 29m # 同时使用--show-labels [root@k8s-master pods]# kubectl get po -A -l type=app2 --show-labels NAMESPACE NAME READY STATUS RESTARTS AGE LABELS default nginx-po 1/1 Running 0 85m type=app2,version=0.0.1 # in [root@k8s-master pods]# kubectl get po -l \u0026#39;version in (0.0.1, 0,0.2, 0.0.3)\u0026#39; NAME READY STATUS RESTARTS AGE nginx-po 1/1 Running 0 88m # 同时匹配多个label [root@k8s-master pods]# kubectl get po -l version!=0.0.2,type=app2 NAME READY STATUS RESTARTS AGE nginx-po 1/1 Running 0 89m # 查找 version!=1 and app=nginx 的 pod 信息 kubectl get po -l version!=1,app=nginx # 不等值 + 语句 kubectl get po -A -l version!=1,\u0026#39;app in (busybox, nginx)\u0026#39; Deployment\r功能\r创建\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 kubectl delete po nginx-po cd ../ mkdir deployments cd deployments # 创建deploy [root@k8s-master deployments]# kubectl create deploy nginx-deploy --image=nginx:latest deployment.apps/nginx-deploy created # 或执行 kubectl create -f xxx.yaml --record # --record 会在 annotation 中记录当前命令创建或升级了资源，后续可以查看做过哪些变动操作。 # 查看状态 [root@k8s-master deployments]# kubectl get deploy NAME READY UP-TO-DATE AVAILABLE AGE nginx-deploy 1/1 1 1 72s # 如果没有ready，查看下pod，看看对应pod是否启动成功 [root@k8s-master deployments]# kubectl get po NAME READY STATUS RESTARTS AGE nginx-deploy-65bdccd7c7-rj8xw 1/1 Running 0 70s # 查看rs [root@k8s-master deployments]# kubectl get replicaset NAME DESIRED CURRENT READY AGE nginx-deploy-65bdccd7c7 1 1 1 4m56s # 也可以使用缩写 [root@k8s-master deployments]# kubectl get rs NAME DESIRED CURRENT READY AGE nginx-deploy-65bdccd7c7 1 1 1 5m19s # 查看 pod 以及展示标签，可以看到是关联的那个 rs [root@k8s-master deployments]# kubectl get pods --show-labels 仔细观察你可能会发现如下特点，他们的名字逐步增加了id\n1 2 3 4 5 6 # deploy nginx-deploy # replicset nginx-deploy-65bdccd7c7 # pod nginx-deploy-65bdccd7c7-rj8xw 如果希望自己通过配置文件来创建deploy，而不是直接通过镜像来创建\n1 2 3 4 5 [root@k8s-master deployments]# kubectl get deploy NAME READY UP-TO-DATE AVAILABLE AGE nginx-deploy 1/1 1 1 8m6s # 以yaml格式输出`nginx-deploy`的配置 [root@k8s-master deployments]# kubectl get deploy nginx-deploy -o yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 piVersion: apps/v1 kind: Deployment metadata: labels: app: nginx-deploy name: nginx-deploy namespace: default spec: replicas: 1 # 期望的副本数 revisionHistoryLimit: 10 # 进行滚动更新后，保留的历史版本数 selector: matchLabels: app: nginx-deploy # 按照标签匹配rs、po strategy: rollingUpdate: # 滚动更新策略 maxSurge: 25% # 进行滚动更新时，更新个数最多可以超过期望副本数的个数/比例 maxUnavailable: 25% # 更新时，最大不可用更新比例，表示所有副本中，有多少个/比例更新不成功 type: RollingUpdate template: # pod模板 metadata: labels: app: nginx-deploy spec: # 元信息 containers: - image: nginx:latest imagePullPolicy: IfNotPresent name: nginx # 容器名称 restartPolicy: Always terminationGracePeriodSeconds: 30 deploy、rs、pod通过app=nginx-deploy的**label**进行关联\n修改已经创建好的deploy\n1 kubectl edit deploy nginx-deploy 滚动更新\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 只有修改了 deployment 配置文件中的 template 中的属性后，才会触发更新操作 # 修改 nginx 版本号 kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1 # 或者通过 kubectl edit deployment/nginx-deployment 进行修改 # 查看滚动更新的过程 kubectl rollout status deploy \u0026lt;deployment_name\u0026gt; # 查看部署描述，最后展示发生的事件列表也可以看到滚动更新过程 kubectl describe deploy \u0026lt;deployment_name\u0026gt; # 通过 kubectl get deployments 获取部署信息，UP-TO-DATE 表示已经有多少副本达到了配置中要求的数目 # 通过 kubectl get rs 可以看到增加了一个新的 rs # 通过 kubectl get pods 可以看到所有 pod 关联的 rs 变成了新的 还可以通过修改yaml的replicas来增加副本数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 apiVersion: apps/v1 kind: Deployment metadata: annotations: deployment.kubernetes.io/revision: \u0026#34;1\u0026#34; creationTimestamp: \u0026#34;2024-12-15T13:37:52Z\u0026#34; generation: 4 labels: app: nginx-deploy test: \u0026#34;123\u0026#34; name: nginx-deploy namespace: default resourceVersion: \u0026#34;110810\u0026#34; uid: 55fcd95d-2217-4c6e-91c4-e112e88edb2e spec: progressDeadlineSeconds: 600 replicas: 3 # 副本数 ... 1 2 3 [root@k8s-master k8s]# kubectl get deploy NAME READY UP-TO-DATE AVAILABLE AGE nginx-deploy 3/3 3 3 23h 在修改template的时候就会触发滚动更新\n比如这里nginx的版本是latest，修改image的版本就会触发滚动更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ... template: metadata: creationTimestamp: null labels: app: nginx-deploy spec: containers: - image: nginx:latest imagePullPolicy: Always name: nginx resources: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File dnsPolicy: ClusterFirst restartPolicy: Always schedulerName: default-scheduler securityContext: {} terminationGracePeriodSeconds: 30 查看滚动更新的过程 kubectl rollout status deploy \u0026lt;deployment_name\u0026gt;\n查看部署描述，最后展示发生的事件列表也可以看到滚动更新过程 kubectl describe deploy \u0026lt;deployment_name\u0026gt;\n通过 kubectl get deployments 获取部署信息，UP-TO-DATE 表示已经有多少副本达到了配置中要求的数目\n通过 kubectl get rs 可以看到增加了一个新的 rs\n通过 kubectl get pods 可以看到所有 pod 关联的 rs 变成了新的\n假设当前有 5 个 nginx:1.7.9 版本，你想将版本更新为 1.9.1，当更新成功第三个以后，你马上又将期望更新的版本改为 1.9.2，那么此时会立马删除之前的三个，并且立马开启更新 1.9.2 的任务(k8s判断之前的更新没有意义，所以会从初始版本开始更新，忽略掉上一次没有意义的更新)\n如下，我将image版本从latest更新为1.7.9\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 [root@k8s-master k8s]# kubectl get deploy NAME READY UP-TO-DATE AVAILABLE AGE nginx-deploy 3/3 3 3 23h [root@k8s-master k8s]# kubectl describe deploy nginx-deploy Name: nginx-deploy Namespace: default CreationTimestamp: Sun, 15 Dec 2024 21:37:52 +0800 Labels: app=nginx-deploy test=123 Annotations: deployment.kubernetes.io/revision: 2 Selector: app=nginx-deploy Replicas: 3 desired | 3 updated | 3 total | 3 available | 0 unavailable StrategyType: RollingUpdate MinReadySeconds: 0 RollingUpdateStrategy: 25% max unavailable, 25% max surge Pod Template: Labels: app=nginx-deploy Containers: nginx: Image: nginx:1.7.9 Port: \u0026lt;none\u0026gt; Host Port: \u0026lt;none\u0026gt; Environment: \u0026lt;none\u0026gt; Mounts: \u0026lt;none\u0026gt; Volumes: \u0026lt;none\u0026gt; Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailable OldReplicaSets: \u0026lt;none\u0026gt; NewReplicaSet: nginx-deploy-65976b546f (3/3 replicas created) Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 23h deployment-controller Scaled up replica set nginx-deploy-65bdccd7c7 to 1 Normal ScalingReplicaSet 20m deployment-controller Scaled up replica set nginx-deploy-65bdccd7c7 to 3 Normal ScalingReplicaSet 18m deployment-controller Scaled down replica set nginx-deploy-65bdccd7c7 to 1 Normal ScalingReplicaSet 12m deployment-controller Scaled up replica set nginx-deploy-65bdccd7c7 to 3 Normal ScalingReplicaSet 2m16s deployment-controller Scaled up replica set nginx-deploy-65976b546f to 1 Normal ScalingReplicaSet 115s deployment-controller Scaled down replica set nginx-deploy-65bdccd7c7 to 2 Normal ScalingReplicaSet 115s deployment-controller Scaled up replica set nginx-deploy-65976b546f to 2 Normal ScalingReplicaSet 94s deployment-controller Scaled down replica set nginx-deploy-65bdccd7c7 to 1 Normal ScalingReplicaSet 94s deployment-controller Scaled up replica set nginx-deploy-65976b546f to 3 Normal ScalingReplicaSet 73s deployment-controller Scaled down replica set nginx-deploy-65bdccd7c7 to 0 多个滚动更新并行\r假设当前有 5 个 nginx:1.7.9 版本，你想将版本更新为 1.9.1，当更新成功第三个以后，你马上又将期望更新的版本改为 1.9.2，那么此时会立马删除之前的三个，并且立马开启更新 1.9.2 的任务\n回滚\r有时候你可能想回退一个Deployment，例如，当Deployment不稳定时，比如一直crash looping。\n默认情况下，kubernetes会在系统中保存前两次的Deployment的rollout历史记录，以便你可以随时会退（你可以修改revision history limit来更改保存的revision数）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # 案例： # 更新 deployment 时参数不小心写错，如 nginx:1.9.1 写成了 nginx:1.91 kubectl set image deployment/nginx-deploy nginx=nginx:1.91 # 监控滚动升级状态，由于镜像名称错误，下载镜像失败，因此更新过程会卡住 kubectl rollout status deployments nginx-deploy # 结束监听后，获取 rs 信息，我们可以看到新增的 rs 副本数是 2 个 kubectl get rs # 通过 kubectl get pods 获取 pods 信息，我们可以看到关联到新的 rs 的 pod，状态处于 ImagePullBackOff 状态 # 为了修复这个问题，我们需要找到需要回退的 revision 进行回退 # 通过 以下命令 可以获取 revison 的列表 kubectl rollout history deployment/nginx-deploy # deployment.apps/nginx-deploy # REVISION CHANGE-CAUSE # 1 \u0026lt;none\u0026gt; # 2 \u0026lt;none\u0026gt; # 这里是none的原因是因为更新的时候没有写明原因，比如 # kubectl set image deployment/nginx-deploy nginx=nginx:1.7.9 --record # 回退到上一个版本，即1，先查看一下该版本的信息 # 通过 以下命令 可以查看指定版本的详细信息 kubectl rollout history deployment/nginx-deploy --revision=1 # 确认要回退的版本后，可以通过 以下命令 可以回退到上一个版本 kubectl rollout undo deployment/nginx-deploy # 也可以回退到指定的 revision kubectl rollout undo deployment/nginx-deploy --to-revision=1 # 再次通过 以下命令 可以看到，我们的版本已经回退到对应的 revison 上了 kubectl get deployment kubectl describe deployment # 我们可以回退版本是因为在yaml里设置了`revisionHistoryLimit` # 可以通过设置 .spec.revisonHistoryLimit 来指定 deployment 保留多少 revison，如果设置为 0，则不允许 deployment 回退了。 扩容缩容\r通过 kube scale 命令可以进行自动扩容/缩容，以及通过 kube edit 编辑 replcas 也可以实现扩容/缩容\n扩容与缩容只是直接创建副本数，没有更新 pod template 因此不会创建新的 rs\n1 2 3 4 kubectl scale --replicas=6 deployment nginx-deploy # 查看帮助文档 kubectl scale --help 暂停与恢复\r由于每次对 pod template 中的信息发生修改后，都会触发更新 deployment 操作，那么此时如果频繁修改信息，就会产生多次更新，而实际上只需要执行最后一次更新即可，当出现此类情况时我们就可以暂停 deployment 的 rollout\n1 2 3 4 5 6 # 通过 kubectl rollout pause deployment \u0026lt;name\u0026gt; 就可以实现暂停，直到你下次恢复后才会继续进行滚动更新 kubectl rollout pause deployment nginx-deploy # 尝试对容器进行修改，然后查看是否发生更新操作了 kubectl set image deploy \u0026lt;name\u0026gt; nginx=nginx:1.17.9 kubectl get po 通过以上操作可以看到实际并没有发生修改，此时我们再次进行修改一些属性，如限制 nginx 容器的最大cpu为 0.2 核，最大内存为 128M，最小内存为 64M，最小 cpu 为 0.1 核\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 kubectl set resources deploy \u0026lt;deploy_name\u0026gt; -c \u0026lt;container_name\u0026gt; --limits=cpu=200m,memory=128Mi --requests=cpu100m,memory=64Mi # 通过格式化输出 kubectl get deploy \u0026lt;name\u0026gt; -oyaml，可以看到配置确实发生了修改，再通过 kubectl get po 可以看到 pod 没有被更新 # 那么此时我们再恢复 rollout，通过命令 kubectl rollout resume deploy \u0026lt;name\u0026gt; kubectl rollout resume deploy nginx-deploy # 恢复后，我们再次查看 rs 和 po 信息，我们可以看到就开始进行滚动更新操作了 kubectl get rs kubectl get po # 暂停 kubectl rollout pause deploy \u0026lt;name\u0026gt; # 恢复 kubectl rollout resume deploy \u0026lt;name\u0026gt; 配置文件\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 apiVersion: apps/v1 # deployment api 版本 kind: Deployment # 资源类型为 deployment metadata: # 元信息 labels: # 标签 app: nginx-deploy # 具体的 key: value 配置形式 name: nginx-deploy # deployment 的名字 namespace: default # 所在的命名空间 spec: replicas: 1 # 期望副本数 revisionHistoryLimit: 10 # 进行滚动更新后，保留的历史版本数 selector: # 选择器，用于找到匹配的 RS matchLabels: # 按照标签匹配 app: nginx-deploy # 匹配的标签key/value strategy: # 更新策略 rollingUpdate: # 滚动更新配置 maxSurge: 25% # 进行滚动更新时，更新的个数最多可以超过期望副本数的个数/比例 maxUnavailable: 25% # 进行滚动更新时，最大不可用比例更新比例，表示在所有副本数中，最多可以有多少个不更新成功 type: RollingUpdate # 更新类型，采用滚动更新 template: # pod 模板 metadata: # pod 的元信息 labels: # pod 的标签 app: nginx-deploy spec: # pod 期望信息 containers: # pod 的容器 - image: nginx:1.7.9 # 镜像 imagePullPolicy: IfNotPresent # 拉取策略 name: nginx # 容器名称 restartPolicy: Always # 重启策略 terminationGracePeriodSeconds: 30 # 删除操作最多宽限多长时间 StatefulSet\r以上是关于无状态应用的内容，增加删除简单执行命令即可 但是有状态应用却不一样，可能会依赖本地的文件、网络\n功能\r创建\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 kubectl create -f web.yaml # 查看 service 和 statefulset =\u0026gt; sts kubectl get service nginx kubectl get statefulset web # 查看service(简写) kubectl get svc # 查看statefulset(简写) kubectl get sts # 查看 PVC 信息 kubectl get pvc # 查看创建的 pod，这些 pod 是有序的 kubectl get pods -l app=nginx # 查看这些 pod 的 dns # 运行一个 pod，基础镜像为 busybox 工具包，利用里面的 nslookup 可以看到 dns 信息 kubectl run -i --tty --image busybox dns-test --restart=Never --rm /bin/sh nslookup web-0.nginx # 创建sts kubectl create -f web.yaml # service/nginx created # statefulset.apps/web created # 再次查看情况 # 这里没有绑定ip，所以ip显示none kubectl get svc # NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE # kubernetes ClusterIP 10.96.0.1 \u0026lt;none\u0026gt; 443/TCP 69d # nginx ClusterIP None \u0026lt;none\u0026gt; 80/TCP 47s kubectl get sts # NAME READY AGE # web 0/2 51s # 查看持久卷(数据卷) kubectl get pvc # NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE # www-web-0 Pending 2m4s # 查看详细信息，发现有问题 kubectl describe pvc www-web-0 # Name: www-web-0 # Namespace: default # StorageClass: # Status: Pending # Volume: # Labels: app=nginx # Annotations: volume.alpha.kubernetes.io/storage-class: anything # Finalizers: [kubernetes.io/pvc-protection] # Capacity: # Access Modes: # VolumeMode: Filesystem # Used By: web-0 # Events: # Type Reason Age From Message # ---- ------ ---- ---- ------- # Normal FailedBinding 8s (x15 over 3m34s) persistentvolume-controller no persistent volumes available for this claim and no storage class is set # 由于没有可用的持久卷而且没有设置存储类，所以sts依旧没有ready kubectl get sts # NAME READY AGE # web 0/2 4m18s 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 --- apiVersion: v1 kind: Service metadata: name: nginx labels: app: nginx spec: ports: - port: 80 name: web clusterIP: None selector: app: nginx --- apiVersion: apps/v1 kind: StatefulSet metadata: name: web spec: serviceName: \u0026#34;nginx\u0026#34; replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:latest ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumeClaimTemplates: - metadata: name: www annotations: volume.alpha.kubernetes.io/storage-class: anything spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] resources: requests: storage: 1Gi 由于存储卷的问题，现在修改一下yaml，暂时不添加存储卷\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 --- apiVersion: v1 kind: Service metadata: name: nginx labels: app: nginx spec: ports: - port: 80 name: web clusterIP: None selector: app: nginx --- apiVersion: apps/v1 kind: StatefulSet metadata: name: web spec: serviceName: \u0026#34;nginx\u0026#34; replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:latest ports: - containerPort: 80 name: web 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 # 直接替换掉sts的yaml kubectl replace -f web.yaml sts web # service/nginx replaced # The StatefulSet \u0026#34;web\u0026#34; is invalid: spec: Forbidden: updates to statefulset spec for fields other than \u0026#39;replicas\u0026#39;, \u0026#39;template\u0026#39;, \u0026#39;updateStrategy\u0026#39;, \u0026#39;persistentVolumeClaimRetentionPolicy\u0026#39; and \u0026#39;minReadySeconds\u0026#39; are forbidden # 这个提示的原因是有些参数是不能替换的，所以还是删除重建吧 kubectl delete sts web # statefulset.apps \u0026#34;web\u0026#34; deleted kubectl delete svc nginx # service \u0026#34;nginx\u0026#34; deleted kubectl delete pvc www-web-0 # persistentvolumeclaim \u0026#34;www-web-0\u0026#34; deleted kubectl create -f web.yaml # service/nginx created # statefulset.apps/web created # 查看信息 kubectl get sts # NAME READY AGE # web 2/2 39s kubectl get svc # NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE # kubernetes ClusterIP 10.96.0.1 \u0026lt;none\u0026gt; 443/TCP 69d # nginx ClusterIP None \u0026lt;none\u0026gt; 80/TCP 42s kubectl get pvc # No resources found in default namespace. # 查看po kubectl get po # NAME READY STATUS RESTARTS AGE # web-0 1/1 Running 0 65s # web-1 1/1 Running 0 58s # 新建一个po，去ping这两个po，观察是否可以ping通 # busybox是linux里的一个工具镜像 kubectl run -it --image busybox:1.28.4 dns-test /bin/sh kubectl get po # NAME READY STATUS RESTARTS AGE # dns-test 1/1 Running 0 77s # web-0 1/1 Running 1 13h # web-1 1/1 Running 1 13h # 我这里执行完命令之后没有自动进入po内部，查看发现已经ready了 # 执行以下命令进入po内部 kubectl exec -it dns-test -- /bin/sh #statefulset中每个pod的dns格式为statefulsetName-{0,1...n}.serviceName.namespace.svc.cluster.local / # nslookup web-0.nginx # Server: 10.96.0.10 # Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local # Name: web-0.nginx # Address 1: 10.244.36.74 web-0.nginx.default.svc.cluster.local 扩容缩容\r1 2 3 4 5 6 7 # 扩容 kubectl scale statefulset web --replicas=5 # 或者如下 kubectl patch statefulset web -p \u0026#39;{\u0026#34;spec\u0026#34;:{\u0026#34;replicas\u0026#34;:5}}\u0026#39; # 缩容 kubectl patch statefulset web -p \u0026#39;{\u0026#34;spec\u0026#34;:{\u0026#34;replicas\u0026#34;:3}}\u0026#39; 镜像更新\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 # 镜像更新（目前不支持直接使用`edit`命令以及参数`-o yaml`来修改yaml里的image，需要 patch 来间接实现） kubectl patch sts web --type=\u0026#39;json\u0026#39; -p=\u0026#39;[{\u0026#34;op\u0026#34;: \u0026#34;replace\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/spec/template/spec/containers/0/image\u0026#34;, \u0026#34;value\u0026#34;:\u0026#34;nginx:1.9.1\u0026#34;}]\u0026#39; # 使用如下 # web是sts的名字，类型是json数据，操作是replace，将/spec/.../image替换成nginx:1.9.1 kubectl patch sts web --type=\u0026#39;json\u0026#39; -p=\u0026#39;[{\u0026#34;op\u0026#34;:\u0026#34;replace\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/spec/template/spec/containers/0/image\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;nginx:1.9.1\u0026#34;}]\u0026#39; # 使用 [root@k8s-master ~]# kubectl patch sts web --type=\u0026#39;json\u0026#39; -p=\u0026#39;[{\u0026#34;op\u0026#34;:\u0026#34;replace\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/spec/template/spec/containers/0/image\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;nginx:1.9.1\u0026#34;}]\u0026#39; statefulset.apps/web patched [root@k8s-master ~]# kubectl get sts NAME READY AGE web 1/2 24h [root@k8s-master ~]# kubectl get po NAME READY STATUS RESTARTS AGE dns-test 1/1 Running 0 10h web-0 0/1 ContainerCreating 0 40s web-1 1/1 Running 0 55s [root@k8s-master ~]# kubectl describe po web-0 ... Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 44s default-scheduler Successfully assigned default/web-0 to k8s-node1 Normal Pulling 43s kubelet Pulling image \u0026#34;nginx:1.9.1\u0026#34; # 等待pull完成 [root@k8s-master ~]# kubectl get po NAME READY STATUS RESTARTS AGE dns-test 1/1 Running 0 10h web-0 1/1 Running 0 2m7s web-1 1/1 Running 0 2m22s [root@k8s-master ~]# kubectl get sts NAME READY AGE web 2/2 24h # 查看历史版本 # 可以明显看到镜像从latest更新到1.9.1了 [root@k8s-master k8s]# kubectl rollout history sts statefulset.apps/web REVISION CHANGE-CAUSE 1 \u0026lt;none\u0026gt; 2 \u0026lt;none\u0026gt; [root@k8s-master k8s]# kubectl rollout history sts --revision=2 statefulset.apps/web with revision #2 Pod Template: Labels:\tapp=nginx Containers: nginx: Image:\tnginx:1.9.1 Port:\t80/TCP Host Port:\t0/TCP Environment:\t\u0026lt;none\u0026gt; Mounts:\t\u0026lt;none\u0026gt; Volumes:\t\u0026lt;none\u0026gt; [root@k8s-master k8s]# kubectl rollout history sts --revision=1 statefulset.apps/web with revision #1 Pod Template: Labels:\tapp=nginx Containers: nginx: Image:\tnginx:latest Port:\t80/TCP Host Port:\t0/TCP Environment:\t\u0026lt;none\u0026gt; Mounts:\t\u0026lt;none\u0026gt; Volumes:\t\u0026lt;none\u0026gt; # 查看sts内容，先删除web-1，再创建web-1，web-0也是如此 [root@k8s-master k8s]# kubectl describe sts web ... Type Reason Age From Message ---- ------ ---- ---- ------- Normal SuccessfulCreate 9h statefulset-controller create Pod web-2 in StatefulSet web successful Normal SuccessfulCreate 9h statefulset-controller create Pod web-3 in StatefulSet web successful Normal SuccessfulCreate 9h statefulset-controller create Pod web-4 in StatefulSet web successful Normal SuccessfulDelete 9h statefulset-controller delete Pod web-4 in StatefulSet web successful Normal SuccessfulDelete 9h statefulset-controller delete Pod web-3 in StatefulSet web successful Normal SuccessfulDelete 9h statefulset-controller delete Pod web-2 in StatefulSet web successful Normal SuccessfulDelete 6m38s statefulset-controller delete Pod web-1 in StatefulSet web successful Normal SuccessfulCreate 6m37s (x2 over 24h) statefulset-controller create Pod web-1 in StatefulSet web successful Normal SuccessfulDelete 6m23s statefulset-controller delete Pod web-0 in StatefulSet web successful Normal SuccessfulCreate 6m22s (x2 over 24h) statefulset-controller create Pod web-0 in StatefulSet web successful RollingUpdate\nStatefulSet 也可以采用滚动更新策略，同样是修改 pod template 属性后会触发更新，但是由于 pod 是有序的，在 StatefulSet 中更新时是基于 pod 的顺序倒序更新的\n灰度发布\n利用滚动更新中的 partition 属性，可以实现简易的灰度发布的效果\n例如我们有 5 个 pod，如果当前 partition 设置为 3，那么此时滚动更新时，只会更新那些 序号 \u0026gt;= 3 的 pod\n利用该机制，我们可以通过控制 partition 的值，来决定只更新其中一部分 pod，确认没有问题后再主键增大更新的 pod 数量，最终实现全部 pod 更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 # 实现灰度发布(金丝雀发布) # 扩容 kubectl scale sts web --replicas 6 # 更新如下内容 kubectl edit sts web ... updateStrategy: rollingUpdate: partition: 3 # 改为3 type: RollingUpdate [root@k8s-master k8s]# kubectl get po NAME READY STATUS RESTARTS AGE dns-test 1/1 Running 0 47h web-0 1/1 Running 0 37h web-1 1/1 Running 0 37h web-2 1/1 Running 0 12h web-3 1/1 Running 0 12h web-4 1/1 Running 0 12h web-5 1/1 Running 0 12h # 如果sts发生更新，优先更新web-3、web-4、web-5(优先更新\u0026gt;=3的po) # 此时更新sts的image版本，查看po的内容 # image从1.9.1更新为latest [root@k8s-master k8s]# kubectl describe po web-3 Name: web-3 Namespace: default Priority: 0 Node: k8s-node1/192.168.42.132 Start Time: Thu, 19 Dec 2024 21:29:18 +0800 Labels: app=nginx controller-revision-hash=web-7974cc466 statefulset.kubernetes.io/pod-name=web-3 Annotations: cni.projectcalico.org/containerID: 0c73e705476bd47bae66ff1b3e3763705fb433000aaf7411ad30cf4dd358bfb9 cni.projectcalico.org/podIP: 10.244.36.70/32 cni.projectcalico.org/podIPs: 10.244.36.70/32 Status: Running IP: 10.244.36.70 IPs: IP: 10.244.36.70 Controlled By: StatefulSet/web Containers: nginx: Container ID: docker://873c777e9938672b070e104e0d9453d4c8caa16761c327cdaadb45a3aa078fa9 Image: nginx:latest # 可以看到web-3已经更新为latest版本了 ... [root@k8s-master k8s]# kubectl describe po web-2 Name: web-2 Namespace: default Priority: 0 Node: k8s-node2/192.168.42.133 Start Time: Thu, 19 Dec 2024 08:30:21 +0800 Labels: app=nginx controller-revision-hash=web-567b56dd statefulset.kubernetes.io/pod-name=web-2 Annotations: cni.projectcalico.org/containerID: 737d7c5bb252479092322bfa6edceb42b6538b29e6615402f68a6767f891de85 cni.projectcalico.org/podIP: 10.244.169.131/32 cni.projectcalico.org/podIPs: 10.244.169.131/32 Status: Running IP: 10.244.169.131 IPs: IP: 10.244.169.131 Controlled By: StatefulSet/web Containers: nginx: Container ID: docker://d9efaad9065e835a888499244edecd5e83b66513905ea08d3908c893782f1049 Image: nginx:1.9.1 # 但是web-2还没有更新 # 最终逐步减小`partition`的值直至为0，这样就实现了灰度发布(金丝雀发布) OnDelete\n只有在 pod 被删除时会进行更新操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 将如下代码进行更新 updateStrategy: rollingUpdate: partition: 0 type: RollingUpdate ... # 更新为如下代码 updateStrategy: type: OnDelete # 表示更新策略设置为当删除时才更新 # 此时再修改image的版本从latest更新为1.9.1 # 此时po是不会对版本进行更新的，只有在删除对应po时才会进行更新，删除po之后就会重建po，并更新image # 这样就能实现指定更新的po，比如我只希望更新web-3，而其他的po不希望进行更新 # 此时删除web-3这个po即可 删除\r1 2 3 4 5 6 7 8 9 10 11 12 # 在无状态应用中，删除deploy之后，对应的po也会自动删除 # 而在有状态应用中，删除sts之后，默认也会进行级联删除 # 删除 StatefulSet 和 Headless Service # 默认级联删除：删除 statefulset 时会同时删除 pods kubectl delete statefulset web # 非级联删除：删除 statefulset 时不会删除 pods，删除 sts 后，pods 就没人管了，此时再删除 pod 不会重建的 kubectl deelte sts web --cascade=false # 删除 service kubectl delete service nginx 删除 pvc\r1 2 # StatefulSet删除后PVC还会保留着，数据不再使用的话也需要删除 kubectl delete pvc www-web-0 www-web-1 配置文件\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 --- apiVersion: v1 kind: Service metadata: name: nginx labels: app: nginx spec: ports: - port: 80 name: web clusterIP: None selector: app: nginx --- apiVersion: apps/v1 kind: StatefulSet metadata: name: web spec: serviceName: \u0026#34;nginx\u0026#34; replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumeClaimTemplates: - metadata: name: www annotations: volume.alpha.kubernetes.io/storage-class: anything spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] resources: requests: storage: 1Gi DaemonSet\r为每一个匹配到的Node都部署一个守护进程\n如果有以下的业务场景，以下是微服务的调用链路\n一般会存在第四个节点，部署普罗米修斯(监控)、elasticsearch(存放日志)\n加入这种模式出现问题，我们一个个节点调查日志未免太过麻烦，最好有一个东西可以给每个节点的log信息统一写入es就好了\nDaemonSet正好符合需求，通过nodeSelector匹配到对应的pod，通过Fluentd收集日志并发送到es\nDaemonSet 会忽略 Node 的 unschedulable 状态，有两种方式来指定 Pod 只运行在指定的 Node 节点上：\nnodeSelector：只调度到匹配指定 label 的 Node 上 nodeAffinity：功能更丰富的 Node 选择器，比如支持集合操作 podAffinity：调度到满足条件的 Pod 所在的 Node 上 暂时先讲一下nodeSelector，其他两种后文再讲\n配置文件\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 apiVersion: apps/v1 kind: DaemonSet metadata: name: fluentd spec: template: metadata: labels: app: logging id: fluentd name: fluentd spec: containers: - name: fluentd-es image: agilestacks/fluentd-elasticsearch:v1.3.0 env: - name: FLUENTD_ARGS value: -qq volumeMounts: - name: containers mountPath: /var/lib/docker/containers - name: varlog mountPath: /varlog volumes: - hostPath: path: /var/lib/docker/containers name: containers - hostPath: path: /var/log name: varlog 指定 Node 节点\rDaemonSet 会忽略 Node 的 unschedulable 状态，有两种方式来指定 Pod 只运行在指定的 Node 节点上：\nnodeSelector：只调度到匹配指定 label 的 Node 上 nodeAffinity：功能更丰富的 Node 选择器，比如支持集合操作 podAffinity：调度到满足条件的 Pod 所在的 Node 上 nodeSelector\n先为 Node 打上标签\n1 kubectl label nodes k8s-node1 svc_type=microsvc 然后再 daemonset 配置中设置 nodeSelector\n1 2 3 4 5 spec: template: spec: nodeSelector: svc_type: microsvc nodeAffinity\nnodeAffinity 目前支持两种：requiredDuringSchedulingIgnoredDuringExecution 和 preferredDuringSchedulingIgnoredDuringExecution，分别代表必须满足条件和优选条件。\n比如下面的例子代表调度到包含标签 wolfcode.cn/framework-name 并且值为 spring 或 springboot 的 Node 上，并且优选还带有标签 another-node-label-key=another-node-label-value 的Node。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 apiVersion: v1 kind: Pod metadata: name: with-node-affinity spec: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: wolfcode.cn/framework-name operator: In values: - spring - springboot preferredDuringSchedulingIgnoredDuringExecution: - weight: 1 preference: matchExpressions: - key: another-node-label-key operator: In values: - another-node-label-value containers: - name: with-node-affinity image: pauseyyf/pause podAffinity\npodAffinity 基于 Pod 的标签来选择 Node，仅调度到满足条件Pod 所在的 Node 上，支持 podAffinity 和 podAntiAffinity。这个功能比较绕，以下面的例子为例：\n如果一个 “Node 所在空间中包含至少一个带有 auth=oauth2 标签且运行中的 Pod”，那么可以调度到该 Node 不调度到 “包含至少一个带有 auth=jwt 标签且运行中 Pod”的 Node 上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 apiVersion: v1 kind: Pod metadata: name: with-pod-affinity spec: affinity: podAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: auth operator: In values: - oauth2 topologyKey: failure-domain.beta.kubernetes.io/zone podAntiAffinity: preferredDuringSchedulingIgnoredDuringExecution: - weight: 100 podAffinityTerm: labelSelector: matchExpressions: - key: auth operator: In values: - jwt topologyKey: kubernetes.io/hostname containers: - name: with-pod-affinity image: pauseyyf/pause 滚动更新\r不建议使用 RollingUpdate，建议使用 OnDelete 模式，这样避免频繁更新 ds\nHPA 自动扩/缩容\r通过观察 pod 的 cpu、内存使用率或自定义 metrics 指标进行自动的扩容或缩容 pod 的数量。\n通常用于 Deployment，不适用于无法扩/缩容的对象，如 DaemonSet\n控制管理器每隔30s（可以通过–horizontal-pod-autoscaler-sync-period修改）查询metrics的资源使用情况\n开启指标服务\r1 2 3 4 5 6 7 8 9 10 11 12 13 # 下载 metrics-server 组件配置文件 wget https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml -O metrics-server-components.yaml # 修改镜像地址为国内的地址 sed -i \u0026#39;s/k8s.gcr.io\\/metrics-server/registry.cn-hangzhou.aliyuncs.com\\/google_containers/g\u0026#39; metrics-server-components.yaml # 修改容器的 tls 配置，不验证 tls，在 containers 的 args 参数中增加 --kubelet-insecure-tls 参数 # 安装组件 kubectl apply -f metrics-server-components.yaml # 查看 pod 状态 kubectl get pods --all-namespaces | grep metrics cpu、内存指标监控\r实现 cpu 或内存的监控，首先有个前提条件是该对象必须配置了 resources.requests.cpu 或 resources.requests.memory 才可以，可以配置当 cpu/memory 达到上述配置的百分比后进行扩容或缩容\n创建一个 HPA：\n先准备一个好一个有做资源限制的 deployment\n执行命令\n1 kubectl autoscale deploy nginx-deploy --cpu-percent=20 --min=2 --max=5 通过 kubectl get hpa 可以获取 HPA 信息\n测试：找到对应服务的 service，编写循环测试脚本提升内存与 cpu 负载\n1 while true; do wget -q -O- http://\u0026lt;ip:port\u0026gt; \u0026gt; /dev/null ; done 可以通过多台机器执行上述命令，增加负载，当超过负载后可以查看 pods 的扩容情况 kubectl get pods\n查看 pods 资源使用情况 kubectl top pods\n扩容测试完成后，再关闭循环执行的指令，让 cpu 占用率降下来，然后过 5 分钟后查看自动缩容情况\n自定义 metrics\r控制管理器开启–horizontal-pod-autoscaler-use-rest-clients 控制管理器的–apiserver指向API Server Aggregator 在API Server Aggregator中注册自定义的metrics API ","date":"2024-12-24T00:00:00Z","image":"http://localhost:1313/p/kubernetes/202412242125601_hu7692637107178965198.png","permalink":"http://localhost:1313/p/kubernetes/","title":"Kubernetes"},{"content":"Springboot整合Minio\r我这里已经使用Docker配置了一个Minio容器\n参考博客\n创建桶\n点进去之后，设置为public\n以下是SpringBoot代码\npom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/io.minio/minio --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.minio\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;minio\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; application.yml\n1 2 3 4 5 6 7 8 9 # 应用服务 WEB 访问端口 server: port: 8080 minio: endpoint: http://ubuntu-notebook:9091 # Minio服务所在地址,如192.168.42.128:9091 bucketName: boot-minio # 存储桶名称 accessKey: minioadmin # 访问的key secretKey: minioadmin # 访问的秘钥 配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Data @Configuration @ConfigurationProperties(prefix = \u0026#34;minio\u0026#34;) public class MinioConfig { private String endpoint; private String accessKey; private String secretKey; private String bucketName; @Bean public MinioClient minioClient() { return MinioClient.builder() .endpoint(endpoint) .credentials(accessKey, secretKey) .build(); } } 以下是两个工具类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 @Data @AllArgsConstructor @NoArgsConstructor public class JsonData { /** * 状态码 0 表示成功，1表示处理中，-1表示失败 */ private Integer code; /** * 数据 */ private Object data; /** * 描述 */ private String msg; /** * 成功，传入数据 * * @return */ public static JsonData buildSuccess() { return new JsonData(0, null, null); } /** * 成功，传入数据 * * @param data * @return */ public static JsonData buildSuccess(Object data) { return new JsonData(0, data, null); } /** * 失败，传入描述信息 * * @param msg * @return */ public static JsonData buildError(String msg) { return new JsonData(-1, null, msg); } /** * 失败，传入描述信息,状态码 * * @param msg * @param code * @return */ public static JsonData buildError(String msg, Integer code) { return new JsonData(code, null, msg); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @Component @Slf4j public class MinioUtil { @Autowired private MinioConfig prop; @Resource private MinioClient minioClient; /** * 查看存储bucket是否存在 * * @return boolean */ @SneakyThrows public Boolean bucketExists(String bucketName) { return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build()); } /** * 创建存储bucket * * @return Boolean */ @SneakyThrows public Boolean makeBucket(String bucketName) { minioClient.makeBucket(MakeBucketArgs.builder() .bucket(bucketName) .build()); return true; } /** * 删除存储bucket * * @return Boolean */ @SneakyThrows public Boolean removeBucket(String bucketName) { minioClient.removeBucket(RemoveBucketArgs.builder() .bucket(bucketName) .build()); return true; } /** * 获取全部bucket */ @SneakyThrows public List\u0026lt;Bucket\u0026gt; getAllBuckets() { return minioClient.listBuckets(); } /** * 文件上传 * * @param file 文件 * @return Boolean */ @SneakyThrows public String upload(MultipartFile file) { String originalFilename = file.getOriginalFilename(); if (StrUtil.isBlank(originalFilename)) { throw new RuntimeException(); } String fileName = IdUtil.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //String objectName = CommUtils.getNowDateLongStr(\u0026#34;yyyy-MM/dd\u0026#34;) + \u0026#34;/\u0026#34; + fileName; String objectName = DateUtil.format(DateUtil.date(), \u0026#34;yyyy-MM/dd\u0026#34;) + \u0026#34;/\u0026#34; + fileName; PutObjectArgs objectArgs = PutObjectArgs.builder().bucket(prop.getBucketName()).object(objectName) .stream(file.getInputStream(), file.getSize(), -1).contentType(file.getContentType()).build(); //文件名称相同会覆盖 minioClient.putObject(objectArgs); return objectName; } /** * 预览图片 * * @param fileName * @return */ @SneakyThrows public String preview(String fileName) { // 查看文件地址 GetPresignedObjectUrlArgs build = GetPresignedObjectUrlArgs.builder().bucket(prop.getBucketName()).object(fileName).method(Method.GET).build(); return minioClient.getPresignedObjectUrl(build); } /** * 文件下载 * * @param fileName 文件名称 * @param res response * @return Boolean */ @SneakyThrows public void download(String fileName, HttpServletResponse res) { GetObjectArgs objectArgs = GetObjectArgs.builder().bucket(prop.getBucketName()) .object(fileName).build(); GetObjectResponse response = minioClient.getObject(objectArgs); byte[] buf = new byte[1024]; int len; try (FastByteArrayOutputStream os = new FastByteArrayOutputStream()) { while ((len = response.read(buf)) != -1) { os.write(buf, 0, len); } os.flush(); byte[] bytes = os.toByteArray(); res.setCharacterEncoding(\u0026#34;utf-8\u0026#34;); // 设置强制下载不打开 // res.setContentType(\u0026#34;application/force-download\u0026#34;); res.addHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;fileName=\u0026#34; + fileName); try (ServletOutputStream stream = res.getOutputStream()) { stream.write(bytes); stream.flush(); } } } /** * 查看文件对象 * * @return 存储bucket内文件对象信息 */ @SneakyThrows public List\u0026lt;Item\u0026gt; listObjects() { Iterable\u0026lt;Result\u0026lt;Item\u0026gt;\u0026gt; results = minioClient.listObjects( ListObjectsArgs.builder().bucket(prop.getBucketName()).build()); List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;(); for (Result\u0026lt;Item\u0026gt; result : results) { items.add(result.get()); } return items; } /** * 删除 * * @param fileName * @return * @throws Exception */ @SneakyThrows public boolean remove(String fileName) { minioClient.removeObject(RemoveObjectArgs.builder().bucket(prop.getBucketName()).object(fileName).build()); return true; } } 以下是待测试的接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @RestController @RequestMapping(\u0026#34;/file\u0026#34;) public class FileController { @Autowired private MinioUtil minioUtil; @Autowired private MinioConfig prop; /** * 查看存储bucket是否存在 * * @param bucketName * @return */ @GetMapping(\u0026#34;/bucketExists\u0026#34;) public JsonData bucketExists(@RequestParam(\u0026#34;bucketName\u0026#34;) String bucketName) { return JsonData.buildSuccess(minioUtil.bucketExists(bucketName)); } /** * 创建存储bucket * * @param bucketName * @return */ @GetMapping(\u0026#34;/makeBucket\u0026#34;) public JsonData makeBucket(String bucketName) { return JsonData.buildSuccess(minioUtil.makeBucket(bucketName)); } /** * 删除存储bucket * * @param bucketName * @return */ @GetMapping(\u0026#34;/removeBucket\u0026#34;) public JsonData removeBucket(String bucketName) { return JsonData.buildSuccess(minioUtil.removeBucket(bucketName)); } /** * 获取全部bucket * * @return */ @GetMapping(\u0026#34;/getAllBuckets\u0026#34;) public JsonData getAllBuckets() { Set\u0026lt;String\u0026gt; collect = minioUtil.getAllBuckets().stream().map(Bucket::name).collect(Collectors.toSet()); return JsonData.buildSuccess(collect); } /** * 文件上传返回url * * @param file * @return */ @PostMapping(\u0026#34;/upload\u0026#34;) public JsonData upload(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile file) { String objectName = minioUtil.upload(file); if (null != objectName) { return JsonData.buildSuccess((prop.getEndpoint() + \u0026#34;/\u0026#34; + prop.getBucketName() + \u0026#34;/\u0026#34; + objectName)); } return JsonData.buildError(\u0026#34;上传失败\u0026#34;); } /** * 图片/视频预览 * * @param fileName * @return */ @GetMapping(\u0026#34;/preview\u0026#34;) public JsonData preview(@RequestParam(\u0026#34;fileName\u0026#34;) String fileName) { return JsonData.buildSuccess(minioUtil.preview(fileName)); } /** * 文件下载 * * @param fileName * @param res * @return */ @GetMapping(\u0026#34;/download\u0026#34;) public JsonData download(@RequestParam(\u0026#34;fileName\u0026#34;) String fileName, HttpServletResponse res) { minioUtil.download(fileName, res); return JsonData.buildSuccess(); } /** * 根据url地址删除文件 * * @param url * @return */ @PostMapping(\u0026#34;/delete\u0026#34;) public JsonData remove(String url) { boolean remove = minioUtil.remove(url); return JsonData.buildSuccess(remove); } } 这里需要注意一下，文件类型选择file\n键名字选择代码里@RequestParam(\u0026quot;file\u0026quot;)里的名字，这里是file\n最后postman测试全部通过，测试链接\n","date":"2024-12-24T00:00:00Z","image":"http://localhost:1313/p/minio/202412242319462_hu6864675366336813433.png","permalink":"http://localhost:1313/p/minio/","title":"Minio"},{"content":"Docker部署Gitlab\r参考博客\n部署\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 拉取镜像 docker pull gitlab/gitlab-ce:latest # 启动容器 docker run \\ -itd \\ -p 9980:80 \\ -p 9922:22 \\ -v /home/docker/gitlab/etc:/etc/gitlab \\ -v /home/docker/gitlab/log:/var/log/gitlab \\ -v /home/docker/gitlab/opt:/var/opt/gitlab \\ --restart always \\ --privileged=true \\ --name gitlab \\ gitlab/gitlab-ce 接下来的配置请在容器内进行修改，不要在挂载到宿主机的文件上进行修改。否则可能出现配置更新不到容器内，或者是不能即时更新到容器内，导致gitlab启动成功，但是无法访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #进容器内部 docker exec -it gitlab /bin/bash #修改gitlab.rb vi /etc/gitlab/gitlab.rb #加入如下 #gitlab访问地址，可以写域名。如果端口不写的话默认为80端口 external_url \u0026#39;http://192.168.42.128\u0026#39; #ssh主机ip gitlab_rails[\u0026#39;gitlab_ssh_host\u0026#39;] = \u0026#39;192.168.42.128\u0026#39; #ssh连接端口 gitlab_rails[\u0026#39;gitlab_shell_ssh_port\u0026#39;] = 9922 # 让配置生效 gitlab-ctl reconfigure 注意不要重启 /etc/gitlab/gitlab.rb文件的配置会映射到gitlab.yml这个文件，由于咱们在docker中运行，在gitlab上生成的http地址应该是http://192.168.42.128:9980,所以，要修改下面文件\n1 vi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml 1 2 3 4 gitlab: host: 192.168.42.128 port: 9980 # 这里改为9980 https: false 1 2 3 4 #重启gitlab gitlab-ctl restart #退出容器 exit 访问链接http://192.168.42.128:9980/即可，注意机器配置要大于4g，否则很容易启动不了，报502\n修改root密码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 进入容器内部 docker exec -it gitlab /bin/bash # 进入控制台 gitlab-rails console -e production # 查询id为1的用户，id为1的用户是超级管理员 user = User.where(id:1).first # 修改密码为tong123456，另外密码设置有强度检测，不要设置`123456`，会失败的 user.password=\u0026#39;tong123456\u0026#39; # 保存 user.save! # 退出 exit ","date":"2024-12-23T00:00:00Z","image":"http://localhost:1313/p/docker%E9%83%A8%E7%BD%B2gitlab/dbc-docker-desktop-home_hu5165119418789691799.webp","permalink":"http://localhost:1313/p/docker%E9%83%A8%E7%BD%B2gitlab/","title":"Docker部署Gitlab"},{"content":"Docker部署Jenkins\r部署\r参考博客\n1 docker pull jenkins/jenkins:lts-jdk8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 创建容器 docker run -d \\ --name jenkins \\ -p 8080:8080 \\ -p 50000:50000 \\ -v /home/docker/jenkins_data:/var/jenkins_home \\ -v $(which docker):/usr/bin/docker \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -u 0 \\ --restart=on-failure:3 \\ -d jenkins/jenkins:lts-jdk8 # 查看日志 docker logs -f 8605cc78de0d 这就是管理员密码\n1 aaadd43cf529436ea4500df629d64226 修改文件/home/docker/jenkins_data/config.xml\n将excludeClientIPFromCrumb标签里的false改为true\n1 2 3 \u0026lt;crumbIssuer class=\u0026#34;hudson.security.csrf.DefaultCrumbIssuer\u0026#34;\u0026gt; \u0026lt;excludeClientIPFromCrumb\u0026gt;true\u0026lt;/excludeClientIPFromCrumb\u0026gt; \u0026lt;/crumbIssuer\u0026gt; 插件下载缓慢\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 进入容器 docker exec -it jenkins /bin/bash # 找到 default.json 文件 find / -name default.json # 进入对应目录 cd /var/jenkins_home/updates # 替换 default.json 中的内容 # 将 updates.jenkins-ci.org/download 替换为 mirrors.tuna.tsinghua.edu.cn/jenkins， # 将 www.google.com 替换为 www.baidu.com sed -i \u0026#39;s/www.google.com/www.baidu.com/g\u0026#39; default.json sed -i \u0026#39;s/updates.jenkins-ci.org\\/download/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g\u0026#39; default.json # 退出 exit # 重启容器 docker restart 8605cc78de0d 我这边遇到了这个问题，查看日志发现启动成功了，但是无法访问\n1 2 3 4 5 6 7 8 9 10 11 12 # 进入容器 docker exec -it jenkins /bin/bash find / -name hudson.model.UpdateCenter.xml # 进入对应目录 cd /var/jenkins_home/ sed -i \u0026#39;s|updates.jenkins.io/update-center.json|mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json|g\u0026#39; /var/jenkins_home/hudson.model.UpdateCenter.xml # 重启容器 docker restart 8605cc78de0d 将日志里的管理员密码粘贴进来，文章上面已经提过了\n点击安装推介的插件 ","date":"2024-12-23T00:00:00Z","image":"http://localhost:1313/p/docker%E9%83%A8%E7%BD%B2jenkins/dbc-docker-desktop-home_hu5165119418789691799.webp","permalink":"http://localhost:1313/p/docker%E9%83%A8%E7%BD%B2jenkins/","title":"Docker部署Jenkins"},{"content":"Docker部署Nginx\r1 2 3 4 # 创建挂载目录 mkdir -p /home/tong/software/docker/nginx_angular15_docs/conf mkdir -p /home/tong/software/docker/nginx_angular15_docs/log mkdir -p /home/tong/software/docker/nginx_angular15_docs/html 复制配置文件\n1 2 3 4 5 6 7 8 9 10 # 生成容器 docker run --name nginx -p 9001:80 -d nginx # 将容器nginx.conf文件复制到宿主机 docker cp nginx:/etc/nginx/nginx.conf /home/nginx/conf/nginx.conf # 将容器conf.d文件夹下内容复制到宿主机 docker cp nginx:/etc/nginx/conf.d /home/nginx/conf/conf.d # 将容器中的html文件夹复制到宿主机 docker cp nginx:/usr/share/nginx/html /home/nginx/ # 删除容器 docker rm -f nginx 我这里本来就有文件在/home/tong/software/docker/nginx目录下，就不复制容器内的文件了\n1 2 cp -rp /home/tong/software/docker/nginx/conf /home/tong/software/docker/nginx_angular15_docs cp -rp /home/tong/software/docker/nginx/html /home/tong/software/docker/nginx_angular15_docs 运行容器\n1 2 3 4 5 6 7 docker run \\ -p 8015:80 \\ --name angular15 \\ -v /home/tong/software/docker/nginx_angular15_docs/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v /home/tong/software/docker/nginx_angular15_docs/conf/conf.d:/etc/nginx/conf.d \\ -v /home/tong/software/docker/nginx_angular15_docs/html:/usr/share/nginx/html \\ -d nginx:latest ","date":"2024-12-23T00:00:00Z","image":"http://localhost:1313/p/docker%E9%83%A8%E7%BD%B2nginx/dbc-docker-desktop-home_hu5165119418789691799.webp","permalink":"http://localhost:1313/p/docker%E9%83%A8%E7%BD%B2nginx/","title":"Docker部署Nginx"},{"content":"Docker部署Portainer\r参考资料\n拉取镜像\n1 docker pull portainer/portainer-ce:latest 创建数据卷\n1 docker volume create portainer_data 1 2 3 4 5 6 7 8 docker run \\ --name=portainer \\ -p 9000:9000 \\ -p 8000:8000 \\ --restart=always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v portainer_data:/data \\ -d portainer/portainer-ce:latest 访问url即可\nhttp://docker-learning.com:9000/#!/2/docker/containers\n","date":"2024-12-23T00:00:00Z","image":"http://localhost:1313/p/docker%E9%83%A8%E7%BD%B2portainer/dbc-docker-desktop-home_hu5165119418789691799.webp","permalink":"http://localhost:1313/p/docker%E9%83%A8%E7%BD%B2portainer/","title":"Docker部署Portainer"},{"content":"参考博客，这篇是配置短代码的\n博客这篇是配置图片放大的\n博客这篇是配置Alert块引用的\nTip\r我是一段 Alerts 提示文字。\nNote\r我是一段 Alerts 提示文字。\nWarning\r我是一段 Alerts 提示文字。\nImportant\r我是一段 Alerts 提示文字。\nCaution\r我是一段 Alerts 提示文字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026gt; [!TIP] \u0026gt; 我是一段 Alerts 提示文字。 \u0026gt; [!NOTE] \u0026gt; 我是一段 Alerts 提示文字。 \u0026gt; [!WARNING] \u0026gt; 我是一段 Alerts 提示文字。 \u0026gt; [!IMPORTANT] \u0026gt; 我是一段 Alerts 提示文字。 \u0026gt; [!caution] \u0026gt; 我是一段 Alerts 提示文字。 ","date":"2024-12-22T00:00:00Z","image":"http://localhost:1313/p/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu4898064707681593350.jpg","permalink":"http://localhost:1313/p/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/","title":"博客配置"},{"content":"Golang\r下载链接 选择windows-amd64.msi版本即可\n配置环境变量\n在Path下新建如下内容\n1 %GOROOT%\\bin 还需要配置GOPATH作为以后存放go项目的位置\n通过cmd输入命令查看版本\n1 go version 配置GoLand\n1 2 3 4 5 6 7 package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } ","date":"2024-12-21T00:00:00Z","image":"http://localhost:1313/p/golang%E9%85%8D%E7%BD%AE/202412211329268_hu13691399108471869930.png","permalink":"http://localhost:1313/p/golang%E9%85%8D%E7%BD%AE/","title":"Golang"},{"content":"Angular\r基本要点\r基础\r官方文档\n中文文档\n安装脚手架\n1 npm install -g @angular/cli 查看命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ng --help Commands: ng add \u0026lt;collection\u0026gt; Adds support for an external library to your project. ng analytics Configures the gathering of Angular CLI usage metrics. ng build [project] Compiles an Angular application or library into an output directory named dist/ at the given output path. [aliases: b] ng cache Configure persistent disk cache and retrieve cache statistics. ng completion Set up Angular CLI autocompletion for your terminal. ng config [json-path] [value] Retrieves or sets Angular configuration values in the angular.json file for the workspace. ng deploy [project] Invokes the deploy builder for a specified project or for the default project in the workspace. ng e2e [project] Builds and serves an Angular application, then runs end-to-end tests. [aliases: e] ng extract-i18n [project] Extracts i18n messages from source code. ng generate Generates and/or modifies files based on a schematic. [aliases: g] ng lint [project] Runs linting tools on Angular application code in a given project folder. ng new [name] Creates a new Angular workspace. [aliases: n] ng run \u0026lt;target\u0026gt; Runs an Architect target with an optional custom builder configuration defined in your project. ng serve [project] Builds and serves your application, rebuilding on file changes. [aliases: dev, s] ng test [project] Runs unit tests in a project. [aliases: t] ng update [packages..] Updates your workspace and its dependencies. See https://update.angular.dev/. ng version Outputs Angular CLI version. [aliases: v] Options: --help Shows a help message for this command in the console. [boolean] --version Show Angular CLI version. [boolean] For more information, see https://angular.dev/cli/. 创建项目\n1 ng new angular-learning 运行项目\n1 npm run start 访问页面\nhttp://localhost:4200/\n项目结构解析\r接下来介绍一下项目的结构\napp.routes.ts是路由配置文件\napp.component.html是模板文件\napp.component.scss是css文件\napp.component.spec.ts是app.component.ts的单元测试文件\napp.component.ts是当前app组建的核心js文件\n有些项目可能会有app.module.ts文件，是app组件的入口文件\n没有app.module.ts文件是因为Angular CLI默认创建的是一个独立组件的应用程序，而不是传统的基于模块的应用程序\n在独立组件模式下，组件直接在其类中定义模板和样式，不需要显式地在模块中声明它们\napp.config.server.ts 文件主要用于配置 Angular 应用程序的服务器端渲染(SSR)\n1 2 3 4 5 6 7 8 9 10 11 import { mergeApplicationConfig, ApplicationConfig } from \u0026#39;@angular/core\u0026#39;; import { provideServerRendering } from \u0026#39;@angular/platform-server\u0026#39;; import { appConfig } from \u0026#39;./app.config\u0026#39;; const serverConfig: ApplicationConfig = { providers: [ provideServerRendering() ] }; export const config = mergeApplicationConfig(appConfig, serverConfig); 以下是 app.config.server.ts 文件的主要作用：\n合并配置： 使用 mergeApplicationConfig 函数将客户端配置与服务器端配置合并。 这样可以确保服务器端和客户端共享相同的配置基础，同时允许特定于服务器的配置覆盖或扩展。 提供服务器端渲染支持： provideServerRendering() 是一个提供者，它为服务器端渲染添加必要的支持。 在 serverConfig 中，通过 providers 数组添加了 provideServerRendering() 提供者。 导出最终配置： 最终的配置通过 export const config 导出，以便在其他地方（如主服务器文件）使用。 app.config.ts 文件主要用于配置 Angular 应用程序的基础配置，特别是针对客户端的初始化和运行时配置\n1 2 3 4 5 6 7 8 9 import { ApplicationConfig, provideZoneChangeDetection } from \u0026#39;@angular/core\u0026#39;; import { provideRouter } from \u0026#39;@angular/router\u0026#39;; import { routes } from \u0026#39;./app.routes\u0026#39;; import { provideClientHydration } from \u0026#39;@angular/platform-browser\u0026#39;; export const appConfig: ApplicationConfig = { providers: [provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes), provideClientHydration()] }; 主要作用\n配置全局提供者： 通过 providers 数组配置全局提供者，这些提供者在整个应用程序范围内有效。 路由配置： 配置应用程序的路由，确保正确的路由功能。 事件处理： 配置事件处理机制，如 Zone.js 的变更检测。 客户端水合： 配置客户端水合（hydration），确保客户端能够正确接管服务器端渲染的内容。 逐行解释\n导入必要模块： ApplicationConfig 和 provideZoneChangeDetection 从 @angular/core 导入。 provideRouter 从 @angular/router 导入。 provideClientHydration 从 @angular/platform-browser 导入。 routes 从 ./app.routes 导入。 定义配置对象： appConfig 是一个 ApplicationConfig 类型的对象。 配置提供者： provideZoneChangeDetection({ eventCoalescing: true })：配置 Zone.js 的变更检测机制，提高性能。 eventCoalescing: true 表示启用事件合并，减少不必要的事件处理。 provideRouter(routes)：配置应用程序的路由。 routes 是从 ./app.routes 导入的路由配置。 provideClientHydration()：配置客户端水合，确保客户端能够接管服务器端渲染的内容。 main.ts 文件的主要作用是启动 Angular 应用程序，并将 AppComponent 渲染到 index.html 上\n组件\r每个组件由以下四个部分组成\n一个包含一些配置的@Component装饰器 控制将渲染到 DOM 中的 HTML模板 定义组件在 HTML 中如何使用的CSS选择器 一个包含管理状态、处理用户输入或从服务器获取数据等行为的 TypeScript类 1 2 3 4 5 6 7 8 9 10 11 12 13 import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { title = \u0026#39;angular-demo\u0026#39;; } 逐行解释以上配置\nselector: \u0026lsquo;app-root\u0026rsquo; 作用：定义组件的选择器（selector），即在模板中如何引用这个组件。 示例：在 HTML 中使用 \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; 标签来引用 AppComponent standalone: true 作用：表示这是一个独立组件，不需要依赖其他模块。 优点：简化了组件的定义和使用，减少了对全局模块的依赖。 imports: [RouterOutlet] 作用：导入所需的其他组件或指令。 示例：这里导入了 RouterOutlet，用于路由导航。 优点：确保组件内部可以正常使用 RouterOutlet 组件。 templateUrl: \u0026lsquo;./app.component.html\u0026rsquo; 作用：指定组件的模板文件路径。 示例：模板文件位于当前目录下的 app.component.html 文件中。 styleUrls: [\u0026rsquo;./app.component.scss\u0026rsquo;] 作用：指定组件的样式文件路径。 示例：样式文件位于当前目录下的 app.component.scss 文件中。 类定义 title: 组件的一个属性，用于存储组件的标题。 示例：title = 'angular-demo'，表示组件的标题为 'angular-demo'。也可以在模板中使用该参数比如\u0026lt;div\u0026gt;页面标题是{{title}}\u0026lt;/div\u0026gt; 如果希望在独立组件中使用其他组件\n注意这里的定义的selector是todo-list-item，会作为模板里的选择器使用\n1 2 3 4 5 6 7 8 @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, template:`\u0026lt;li\u0026gt;(TODO) Read Angular Essentials Guide\u0026lt;/li\u0026gt;` }) export class TodoListItem { title = \u0026#39;angular-demo\u0026#39;; } 在app组件中使用\n1 2 3 4 5 6 7 8 9 10 11 12 import { TodoListItem } from \u0026#39;../todo/todo.component\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet,TodoListItem], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { title = \u0026#39;angular-demo\u0026#39;; } todo-list-item标签来引用子组件\n1 2 3 4 5 6 7 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div\u0026gt;当前页面是{{title}}\u0026lt;/div\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34;\u0026gt;首页\u0026lt;/button\u0026gt; \u0026lt;todo-list-item\u0026gt;\u0026lt;/todo-list-item\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;router-outlet /\u0026gt; 如果你不希望使用独立组件，其实在使用独立组件之前，Angular 代码使用 NgModule 作为导入和使用其他组件的机制\n参考文档\n管理动态数据\r定义状态\r要定义状态，你可以在组件内使用类字段语法\n例如，使用 TodoListItem 组件，创建两个你想要跟踪的属性：\ntaskTitle — 任务的标题 isComplete — 任务是否完成 1 2 3 4 5 6 7 8 9 @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, template:`这里是{{taskTitle}},您{{isComplete?\u0026#39;已经\u0026#39;:\u0026#39;还没有\u0026#39;}}完成` }) export class TodoListItem { taskTitle = \u0026#39;代办事项\u0026#39;; isComplete = false; } 更新状态\r这里并没有绑定事件，在后续中会提到如何绑定事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, template:` \u0026lt;div\u0026gt;这里是{{taskTitle}},您{{isComplete?\u0026#39;已经\u0026#39;:\u0026#39;还没有\u0026#39;}}完成\u0026lt;/div\u0026gt; ` }) export class TodoListItem { taskTitle = \u0026#39;代办事项\u0026#39;; isComplete = false; /** * 完成待办事项 */ completeTask() { this.isComplete = true; } /** * 更新待办事项 */ updateTitle(newTitle: string) { this.taskTitle = newTitle; } } 渲染动态模板\r渲染动态数据\r使用双花括号来渲染数据\n1 2 3 4 5 6 7 8 9 @Component({ selector: \u0026#39;todo-list-item\u0026#39;, template: ` \u0026lt;p\u0026gt;Title: {{ taskTitle }}\u0026lt;/p\u0026gt; `, }) export class TodoListItem { taskTitle = \u0026#39;Read cup of coffee\u0026#39;; } 动态属性\r当你需要在 HTML 元素上动态设置标准 DOM 属性的值时，该属性会用方括号包裹，以通知 Angular 声明的值应被解释为类似 JavaScript 的语句，而不是纯字符串\n1 2 3 4 5 6 7 8 9 10 11 @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, template:` \u0026lt;input type=\u0026#34;text\u0026#34; [value]=\u0026#34;taskTitle\u0026#34;\u0026gt; ` }) export class TodoListItem { taskTitle = \u0026#39;代办事项\u0026#39;; isComplete = false; } 如果你想动态绑定自定义的 HTML 属性（例如， aria-， data- 等），你可能会倾向于用相同的方括号包裹自定义属性\n但需要注意的是，这样的实现无效\n1 2 3 4 5 6 7 8 9 10 11 @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, template:` \u0026lt;button [data-test-title]=\u0026#34;taskTitle\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; ` }) export class TodoListItem { taskTitle = \u0026#39;代办事项\u0026#39;; isComplete = false; } 应该使用如下方法设置前缀attr.来使用\n1 2 3 4 5 6 7 8 9 10 @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, template:` \u0026lt;button [attr.data-test-title]=\u0026#34;taskTitle\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; ` }) export class TodoListItem { taskTitle = \u0026#39;代办事项\u0026#39;; } 条件与循环\r开发中经常需要根据条件进行dom渲染\n@if控制块\r类似于 JavaScript 的 if 语句，Angular 使用 @if 控制块有条件地隐藏和显示模板及其内容的部分\n1 2 3 4 5 6 7 8 9 10 11 12 @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, template:` @if(showFlag){ \u0026lt;button\u0026gt;隐藏\u0026lt;/button\u0026gt; } ` }) export class TodoListItem { showFlag=false; } 只有当showFlag为true时，才会渲染button按钮\n@else控制块\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, template:` @if(showFlag){ \u0026lt;button\u0026gt;隐藏\u0026lt;/button\u0026gt; }@else { \u0026lt;button\u0026gt;显示\u0026lt;/button\u0026gt; } ` }) export class TodoListItem { showFlag=false; } @else if控制块\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, template:` @if(showFlag1){ \u0026lt;button\u0026gt;隐藏\u0026lt;/button\u0026gt; }@else if(showFlag2) { \u0026lt;button\u0026gt;显示\u0026lt;/button\u0026gt; }@else { \u0026lt;button\u0026gt;其他\u0026lt;/button\u0026gt; } ` }) export class TodoListItem { showFlag1=false; showFlag2=true; } @for控制块\r类似于 JavaScript 的 for...of 循环，Angular 提供了 @for 控制块来渲染重复的元素\n需要注意的是还有一个额外的 track 关键字\n当 Angular 使用 @for 渲染元素列表时，这些条目可能会在后续更改或移动。Angular 需要通过任何重新排序跟踪每个元素，通常是将条目的某个属性作为唯一标识符或键\n这确保了对列表的任何更新都能在 UI 中正确反映，并且在 Angular 内部得到正确的跟踪，特别是在有状态元素或动画的情况下\n为此，我们可以使用 track 关键字为 Angular 提供唯一的键\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, template: ` @for(user of userList; track user.name){ \u0026lt;div\u0026gt; \u0026lt;li\u0026gt;姓名:{{user.name}}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;年龄:{{user.age}}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;性别:{{user.gender}}\u0026lt;/li\u0026gt; \u0026lt;/div\u0026gt; } ` }) export class TodoListItem { userList = [ { name: \u0026#39;John\u0026#39;, age: 25, gender: \u0026#39;男\u0026#39; }, { name: \u0026#39;Jane\u0026#39;, age: 30, gender: \u0026#39;女\u0026#39; }, { name: \u0026#39;Jack\u0026#39;, age: 40, gender: \u0026#39;男\u0026#39; } ] } 用户交互\r事件处理\r可以通过以下方式向元素添加事件处理器：\n在圆括号内添加一个带有事件名称的属性 指定当事件触发时你想运行的 JavaScript 语句 1 2 3 4 5 6 7 8 9 10 11 12 @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, template: ` \u0026lt;button (click)=\u0026#34;testClick()\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; ` }) export class TodoListItem { testClick() { console.log(\u0026#39;click\u0026#39;) } } 如果需要访问事件对象event，Angular 提供了一个隐式的 $event 变量，你可以将其传递给一个函数\n1 \u0026lt;button (click)=\u0026#34;createUser($event)\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; 共享逻辑\r当你需要在组件之间共享逻辑时，Angular 利用 依赖注入的设计模式，允许你创建一个“服务”，从而允许你将代码注入组件，并从单一事实之源管理它\n服务\r服务是可重用的代码片段，可以被注入\n类似于定义组件，服务由以下内容组成：\n一个 TypeScript 装饰器，通过 @Injectable 声明该类为 Angular 服务，并允许你通过 providedIn 属性（通常为 'root'）定义应用程序中哪些部分可以访问该服务，从而允许服务在应用程序中的任何地方被访问 一个 TypeScript 类，定义当服务被注入时将可访问的代码 这是一个 Calculator 服务的示例\n1 2 3 4 5 6 7 8 9 import {Injectable} from \u0026#39;@angular/core\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39;, }) export class CalculatorService { add(x: number, y: number) { return x + y; } } 当你想在组件中使用服务时，你需要：\n导入服务 声明一个类字段，服务被注入到其中。将类字段赋值为调用内置函数 inject 创建服务的结果 这是在 Receipt组件中的可能样子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Component, inject } from \u0026#34;@angular/core\u0026#34;; import { CalculatorService } from \u0026#34;../share/test.service\u0026#34;; @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, styleUrl: \u0026#39;./todo.component.scss\u0026#39;, template: ` \u0026lt;button class=\u0026#34;btn btn-default\u0026#34; (click)=\u0026#34;useShareService()\u0026#34;\u0026gt;计算\u0026lt;/button\u0026gt; ` }) export class TodoListItem { private calculatorService = inject(CalculatorService); useShareService() { let result = this.calculatorService.add(1, 2) console.log(`result:${result}`) } } inject仅支持angular14以上的版本，否则可以使用传统方法进行注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Component } from \u0026#34;@angular/core\u0026#34;; import { CalculatorService } from \u0026#34;../share/test.service\u0026#34;; @Component({ standalone: true, selector: \u0026#39;todo-list-item\u0026#39;, styleUrl: \u0026#39;./todo.component.scss\u0026#39;, template: ` \u0026lt;button class=\u0026#34;btn btn-default\u0026#34; (click)=\u0026#34;useShareService()\u0026#34;\u0026gt;计算\u0026lt;/button\u0026gt; ` }) export class TodoListItem { constructor(private calculatorService: CalculatorService) { } useShareService() { let result = this.calculatorService.add(1, 2) console.log(`result:${result}`) } } 深度指南\r组件的剖析\r如何导入以及使用其他独立组件在上方基本要点中已经了解到，如果希望使用NgModule的方式而非独立组件，可以参考文档\n组件选择器\r类型选择器\r每个组件都定义了一个css选择器用于使用该组件\n1 2 3 4 5 @Component({ selector: \u0026#39;profile-photo\u0026#39;, ... }) export class ProfilePhoto { } Angular在编译时静态匹配选择器。在运行时改变DOM，无论是通过Angular绑定还是DOM API，都不会影响渲染的组件\n**一个元素只能匹配一个组件选择器。**如果多个组件选择器匹配一个元素，Angular会报错\n需要注意的是，组件选择器是区分大小写的\n选择器类型\rAngular 在组件选择器中支持一组 基本 CSS 选择器类型\n选择器类型 说明 例子 类型选择器 根据HTML标签名称或节点名称匹配元素。 profile-photo 属性选择器 根据HTML属性的存在以及可选的属性确切值匹配元素。 [dropzone] [type=\u0026ldquo;reset\u0026rdquo;] 类选择器 根据CSS类的存在匹配元素。 .menu-item Angular 组件选择器不支持组合器，包括 后代组合器或 子组合器\nAngular 组件选择器不支持指定 命名空间\n:not伪类\rAngular 支持 伪类 :not，可以将这个伪类附加到任何其他选择器上，以缩小组件选择器匹配的元素范围\n可以定义一个 [dropzone]属性选择器并阻止匹配 textarea元素\n1 2 3 4 5 6 7 8 9 10 @Component({ standalone: true, selector: \u0026#39;[dropzone]:not(textarea)\u0026#39;, styleUrl: \u0026#39;./todo.component.scss\u0026#39;, template: ` 你好 ` }) export class TodoListItem { } 组合选择器\r可以通过它们来组合多个选择器。比如，可以匹配指定了 type=\u0026quot;reset\u0026quot;的 \u0026lt;button\u0026gt;元素\n1 2 3 4 5 6 7 8 9 10 @Component({ standalone: true, selector: \u0026#39;button[type=\u0026#34;reset\u0026#34;]\u0026#39;, styleUrl: \u0026#39;./todo.component.scss\u0026#39;, template: ` 你好 ` }) export class TodoListItem { } 也可以使用逗号分隔的列表定义多个选择器\n1 2 3 4 5 6 7 8 9 10 @Component({ standalone: true, selector: \u0026#39;button[type=\u0026#34;reset\u0026#34;],.btn-info\u0026#39;, styleUrl: \u0026#39;./todo.component.scss\u0026#39;, template: ` 你好 ` }) export class TodoListItem { } 此时会选择type为reset的button元素以及类名为btn-info的元素\n指定样式\r样式化组件\r可以在xxx.component.ts中直接配置html与对应的css样式\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet], template:`\u0026lt;button class=\u0026#34;btn\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt;`, styles:`.btn{ height: 100px; width: 200px; }` }) export class AppComponent { title = \u0026#39;angular-app\u0026#39;; } 不过将html和css抽出作为单独文件更加规范一点\n1 2 3 4 5 6 7 8 9 10 @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { title = \u0026#39;angular-app\u0026#39;; } 样式作用域\r每个组件都有一个 视图封装设置，这个设置决定了框架如何限定组件的样式作用域。有三种视图封装模式： Emulated、 ShadowDom 和 None。你可以在 @Component 装饰器中指定模式：\n使用如下命令创建两个模块\n1 2 3 # g代表generate，c代表component ng g c user ng g c order 接下来可以自行使用这两个模块测试一下样式的作用域\n使用encapsulation指定\n1 2 3 4 5 6 7 8 9 10 @Component({ selector: \u0026#39;app-user\u0026#39;, standalone: true, imports: [], templateUrl: \u0026#39;./user.component.html\u0026#39;, styleUrl: \u0026#39;./user.component.scss\u0026#39;, encapsulation: ViewEncapsulation.None, }) export class UserComponent { } ViewEncapsulation.Emulated\rangular默认情况采用这种模拟封装，这样指定的样式只在模板中生效，不对其他模板造成干扰\n框架会为每个组件实例生成唯一一个HTML属性，并且会将该属性添加到组件模板中的元素，以及将该属性插入到组件样式定义的css选择器中\n在封装模式下，angular支持:host和:host-context()伪类，而无需使用 Shadow DOM。在编译期间，框架将这些伪类转换为属性，因此在运行时不遵循这些本地伪类的规则（例如浏览器兼容性、特异性）。Angular 的模拟封装模式不支持与 Shadow DOM 相关的任何其他伪类，例如 ::shadow 或 ::part。\nViewEncapsulation.ShadowDom\r这种模式通过使用 Web 标准 Shadow DOM API 来限定组件内的样式作用域。启用这种模式时，Angular 会将一个 shadow root 附着到组件的宿主元素，并将组件的模板和样式渲染到对应的 shadow 树中。\n此模式严格保证 只有该组件的样式适用于组件模板中的元素。全局样式不能影响影子树中的元素，影子树中的样式也不能影响影子树外的元素。\n然而，启用 ShadowDom 封装不仅仅影响样式作用域。在 shadow 树中渲染组件会影响事件传播、与 `` API 的交互，以及浏览器开发者工具显示元素的方式。在启用此选项之前，务必理解在你的应用中使用 Shadow DOM 的全部影响。\nViewEncapsulation.None\n这种模式会禁用组件的所有样式封装。任何与组件关联的样式都会作为全局样式来处理。\n定义样式\r你可以在组件的模板中使用 \u0026lt;style\u0026gt; 元素来定义额外样式。组件的视图封装模式会应用于这种方式定义的样式。\nAngular 不支持在样式元素内部进行绑定。\n这句话是啥意思呢，请看如下代码\nangular不支持\n1 2 3 4 5 6 7 8 \u0026lt;style\u0026gt; .myClass { color: {{ someColor }}; } \u0026lt;/style\u0026gt; \u0026lt;!-- 模板部分 --\u0026gt; \u0026lt;div class=\u0026#34;myClass\u0026#34;\u0026gt;Hello World!\u0026lt;/div\u0026gt; 正确做法是使用[ngClass]或[ngStyle]\n1 2 3 4 \u0026lt;div [ngStyle]=\u0026#34;{\u0026#39;color\u0026#39;: someColor}\u0026#34;\u0026gt;Hello World!\u0026lt;/div\u0026gt; \u0026lt;!-- 或者使用类名 --\u0026gt; \u0026lt;div [ngClass]=\u0026#34;someClass\u0026#34;\u0026gt;Hello World!\u0026lt;/div\u0026gt; 可以使用全局或局部css变量\n1 2 3 4 5 6 7 8 9 10 \u0026lt;style\u0026gt; :host{ --text-color:red; } .text{ color: var(--text-color); } \u0026lt;/style\u0026gt; \u0026lt;p class=\u0026#34;text\u0026#34;\u0026gt;user works!\u0026lt;/p\u0026gt; 接收输入属性中的数据\r以上是官方文档内记载的内容\n属性绑定\r属性绑定使用中括号[]将属性包裹进行绑定\n这里绑定的属性需要时dom已经存在的属性，比如如果希望绑定自定义的属性，就需要使用[attr.自定义属性名]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;!-- 在component中定义name为`angular_name` --\u0026gt; \u0026lt;!-- 所以这里的class就是`angular_name` --\u0026gt; \u0026lt;div [class]=\u0026#34;name\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 而如果希望使用字符串而不是变量，则需要使用单引号继续包裹对象 --\u0026gt; \u0026lt;!-- 这里的class就是`angular_name` --\u0026gt; \u0026lt;div [class]=\u0026#34;\u0026#39;angular_name\u0026#39;\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 这里绑定的属性需要时dom已经存在的属性，比如如果希望绑定自定义的属性 --\u0026gt; \u0026lt;!-- 则需要使用`[attr.自定义属性名]` --\u0026gt; \u0026lt;div [attr.data-name]=\u0026#34;name\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 如果希望可以动态控制是否显示某个属性 --\u0026gt; \u0026lt;!-- 显示class名称(angular_name) --\u0026gt; \u0026lt;div [class.angular_name]=\u0026#34;true\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 不显示class名称(angular_name) --\u0026gt; \u0026lt;div [class.angular_name]=\u0026#34;false\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 绑定多个属性值 --\u0026gt; \u0026lt;div [class]=\u0026#34;\u0026#39;abc_classname angular_name\u0026#39;\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 动态绑定 --\u0026gt; \u0026lt;div [class]=\u0026#34;[\u0026#39;abc_classname\u0026#39;,name]\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 这里最后一个空格不能省`abc_classname ` --\u0026gt; \u0026lt;div [class]=\u0026#34;\u0026#39;abc_classname \u0026#39;+name\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 控制多个属性值是否显示 --\u0026gt; \u0026lt;!-- 这种方法了解即可,我更推介下面的三元表达式来控制是否显示 --\u0026gt; \u0026lt;div [class]=\u0026#34;{\u0026#39;abc_classname\u0026#39;:false,\u0026#39;angular_name\u0026#39;:true}\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 推荐：三元表达式控制多个属性值是否显示,react也常用这种方式 --\u0026gt; \u0026lt;div [class]=\u0026#34;true?[\u0026#39;abc_classname\u0026#39;,name]:\u0026#39;abc_classname\u0026#39;\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; 样式绑定\rcomponent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Component } from \u0026#39;@angular/core\u0026#39;; // 导入`NgStyle`模块 import { NgStyle, NgClass } from \u0026#39;@angular/common\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, // 导入`NgStyle`模块 imports: [RouterOutlet, NgStyle, NgClass], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { } html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;!-- 单一样式绑定 --\u0026gt; \u0026lt;div [style.backgroundColor]=\u0026#34;\u0026#39;red\u0026#39;\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 带单位的样式绑定 --\u0026gt; \u0026lt;div [style.height.px]=\u0026#34;300\u0026#34; style=\u0026#34;background-color: green;\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 多重样式绑定 --\u0026gt; \u0026lt;div [style]=\u0026#34;\u0026#39;background-color:grey;height:200px\u0026#39;\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;div [style]=\u0026#34;{\u0026#39;background-color\u0026#39;:\u0026#39;grey\u0026#39;,\u0026#39;height\u0026#39;:\u0026#39;200px\u0026#39;}\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- 动态绑定样式 --\u0026gt; \u0026lt;!-- 这里需要在component导入`NgStyle`模块 --\u0026gt; \u0026lt;div [ngStyle]=\u0026#34;{\u0026#39;color\u0026#39;:\u0026#39;red\u0026#39;}\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;div [ngStyle]=\u0026#34;{\u0026#39;color\u0026#39;:false?\u0026#39;green\u0026#39;:\u0026#39;grey\u0026#39;}\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;!-- NgClass也是同理 --\u0026gt; \u0026lt;div [ngClass]=\u0026#34;{\u0026#39;class_name1\u0026#39;:true,\u0026#39;class_name2\u0026#39;:false,\u0026#39;class_name3\u0026#39;:true}\u0026#34;\u0026gt;abc\u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; 条件判断\r这种方法也需要导入NgIf模块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;!-- 条件判断语法 --\u0026gt; \u0026lt;!-- 这种方式是直接控制是否渲染,而非`display:none`的显示隐藏 --\u0026gt; \u0026lt;div *ngIf=\u0026#34;flag\u0026#34;\u0026gt;aaa\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;!flag\u0026#34;\u0026gt;bbb\u0026lt;/div\u0026gt; \u0026lt;!-- 以上代码解析完之后,其实本质的模板如下 --\u0026gt; \u0026lt;ng-template [ngIf]=\u0026#34;flag\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;flag\u0026#34;\u0026gt;aaa\u0026lt;/div\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;!-- 那如果条件判断需要分支实现 --\u0026gt; \u0026lt;div *ngIf=\u0026#34;flag;else otherTemplate\u0026#34;\u0026gt; \u0026lt;div\u0026gt;ccc\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ng-template #otherTemplate\u0026gt; \u0026lt;div\u0026gt;bbb\u0026lt;/div\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;!-- 其实还可以使用以下方式进行条件判断 --\u0026gt; \u0026lt;!-- `@if`和`ngIf`的区别是`ngIf`是指令语法,`@if`是流程控制语法(angular新特性) --\u0026gt; \u0026lt;!-- `@if`的性能更好,`ngIf`需要导入`NgIf`模块 --\u0026gt; \u0026lt;!-- 而`@if`是内置语法,无需额外导入,而且支持更复杂的条件分支 --\u0026gt; \u0026lt;!-- @if (condition1) { \u0026lt;div\u0026gt;content1\u0026lt;/div\u0026gt; } @else if (condition2) { \u0026lt;div\u0026gt;content2\u0026lt;/div\u0026gt; } @else { \u0026lt;div\u0026gt;content3\u0026lt;/div\u0026gt; } --\u0026gt; @if(true){ \u0026lt;div\u0026gt;显示\u0026lt;/div\u0026gt; }@else{ \u0026lt;div\u0026gt;隐藏\u0026lt;/div\u0026gt; } \u0026lt;/main\u0026gt; 循环语句\rcomponent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import { Component } from \u0026#39;@angular/core\u0026#39;; import { NgFor, NgForOf, NgSwitch, NgSwitchCase, NgSwitchDefault } from \u0026#39;@angular/common\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, // 导入`NgIf`模块 imports: [RouterOutlet, NgFor, NgForOf, NgSwitch, NgSwitchCase, NgSwitchDefault], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { colorList = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;grey\u0026#39;, \u0026#39;pink\u0026#39;]; type = 1; userList: User[] = [{ id: 1, name: \u0026#39;John\u0026#39;, age: 25, gender: \u0026#39;男\u0026#39; }, { id: 2, name: \u0026#39;Jane\u0026#39;, age: 30, gender: \u0026#39;女\u0026#39; }, { id: 3, name: \u0026#39;Jack\u0026#39;, age: 40, gender: \u0026#39;男\u0026#39; }] } interface User { id: number; name: string; age: number; gender: string; } html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;!-- 循环语句 --\u0026gt; \u0026lt;!-- for --\u0026gt; \u0026lt;div *ngFor=\u0026#34;let color of colorList let odd=odd let i=index\u0026#34;\u0026gt; \u0026lt;!-- 当前索引是否是偶数 --\u0026gt; {{odd}} \u0026lt;!-- 当前索引,从0开始 --\u0026gt; {{i}} \u0026lt;!-- 当前索引指向的字符串 --\u0026gt; {{color}} \u0026lt;/div\u0026gt; \u0026lt;!-- 以上代码解析完之后,模板内容如下 --\u0026gt; \u0026lt;ng-template ngFor let-color [ngForOf]=\u0026#34;colorList\u0026#34; let-i=\u0026#34;index\u0026#34; let-odd=\u0026#34;odd\u0026#34;\u0026gt; \u0026lt;div\u0026gt; {{odd}} {{i}} {{color}} \u0026lt;/div\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;!-- switch --\u0026gt; \u0026lt;div [ngSwitch]=\u0026#34;type\u0026#34;\u0026gt; \u0026lt;!-- `type`的值为1 --\u0026gt; \u0026lt;p *ngSwitchCase=\u0026#34;1\u0026#34;\u0026gt;1\u0026lt;/p\u0026gt; \u0026lt;!-- `type`的值为2 --\u0026gt; \u0026lt;p *ngSwitchCase=\u0026#34;2\u0026#34;\u0026gt;2\u0026lt;/p\u0026gt; \u0026lt;!-- `type`的值既不是1,也不是2 --\u0026gt; \u0026lt;p *ngSwitchDefault\u0026gt;3\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 除了以上的循环语句之后,在angular17中发布的新特性 --\u0026gt; \u0026lt;!-- `track`使用唯一id来提升遍历性能 --\u0026gt; @for(user of userList;track user.id){ \u0026lt;div\u0026gt; {{user.name}}=={{user.age}}=={{user.gender}} \u0026lt;/div\u0026gt; } @switch (type) { @case (1) { \u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt; }@case (2) { \u0026lt;p\u0026gt;2\u0026lt;/p\u0026gt; }@default { \u0026lt;p\u0026gt;3\u0026lt;/p\u0026gt; } } \u0026lt;/main\u0026gt; 事件绑定\rcomponent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { num = 1; incrementNum(event: Event): void { // 获取事件对象e console.log(event.target); this.num++; } inputValue(event: Event): void { // 打印当前input console.log(event.target); } getUserName(val: string): void { console.log(`当前input的值为${val}`); } } html\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; {{num}} \u0026lt;!-- click --\u0026gt; \u0026lt;button (click)=\u0026#34;incrementNum($event)\u0026#34;\u0026gt;点击增加\u0026lt;/button\u0026gt; \u0026lt;!-- input --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; (input)=\u0026#34;inputValue($event)\u0026#34; #userName\u0026gt; \u0026lt;!-- 模板引用变量 --\u0026gt; \u0026lt;!-- 上面input定义了一个模板名称`userName` --\u0026gt; \u0026lt;!-- 可以通过这个input的模板名称来获取其值 --\u0026gt; \u0026lt;button (click)=\u0026#34;getUserName(userName.value)\u0026#34;\u0026gt;获取userName\u0026lt;/button\u0026gt; \u0026lt;/main\u0026gt; 数据双向绑定\r双向绑定是应用中的组件共享数据的以种方式。使用双向绑定绑定来侦听事件并在父组件和子组件之间同步更新值\nngModel指令只对表单元素有效,所以在使用使用之前需要导入FormsModule模块\n1 2 3 4 5 6 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;!-- 双向绑定userName，双向绑定只对表单元素有效 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; [(ngModel)]=\u0026#34;userName\u0026#34;\u0026gt; \u0026lt;!-- 展示userName，判断变化双向绑定是否成功 --\u0026gt; \u0026lt;p\u0026gt;{{ userName }}\u0026lt;/p\u0026gt; \u0026lt;/main\u0026gt; 表单控件\r在你的应用中注册响应式表单模块。该模块声明了一些你要用在响应式表单中的指令。 生成一个新的FormControl 实例，并把它保存在组件中。 在模板中注册这个FormControl 注册响应式表单模块\r导入ReactiveFormsModule\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; import { FormControl, FormsModule, ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet, FormsModule, ReactiveFormsModule], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { userName = new FormControl(\u0026#39;angular\u0026#39;); changeUserName() { // 通过setValue方法修改表单对象的值 this.userName.setValue(this.userName.value + \u0026#34;==\u0026#34;); } } 1 2 3 4 5 6 7 8 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;!-- 动态表单控件 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; [formControl]=\u0026#34;userName\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ userName.value }}\u0026lt;/p\u0026gt; \u0026lt;!-- 修改表单项 --\u0026gt; \u0026lt;button (click)=\u0026#34;changeUserName()\u0026#34;\u0026gt;修改\u0026lt;/button\u0026gt; \u0026lt;/main\u0026gt; 表单控件分组\r表单中通常会包含几个相互关联的控件。响应式表单提供了两种把多个相关控件分组到同一个输入表单中的方法\n要将表单组添加到此组件中，请执行以下步骤。\n创建一个FormGroup实例 把这个FormGroup 模型关联到视图 保存表单数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; import { FormGroup, FormControl, FormsModule, ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet, FormsModule, ReactiveFormsModule], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { loginForm = new FormGroup({ username: new FormControl(\u0026#39;\u0026#39;), password: new FormControl(\u0026#39;\u0026#39;), }); /** * 打印表单 */ logForm() { console.log(this.loginForm.value); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;!-- 使用`formGroup`绑定控件组 --\u0026gt; \u0026lt;div [formGroup]=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;账号:\u0026lt;/label\u0026gt; \u0026lt;!-- 使用`[formControlName]`指定绑定的控件名称 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; placeholder=\u0026#34;请输入账号\u0026#34; formControlName=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;密码:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34; formControlName=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button (click)=\u0026#34;logForm()\u0026#34;\u0026gt;打印表单\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; 表单校验\r表单元素添加required关键字表示必填、minlength表示输入的最小长度，通过绑定ngMode1的引用可以拿到到当前组件的信息，通过引用获取到验证的信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;账号:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; required name=\u0026#34;username\u0026#34; placeholder=\u0026#34;请输入账号\u0026#34; #usernameInput=\u0026#34;ngModel\u0026#34; [(ngModel)]=\u0026#34;loginForm.username\u0026#34;\u0026gt; \u0026lt;p\u0026gt;username验证是否通过:验证{{usernameInput.invalid?\u0026#39;`不通过`\u0026#39;:\u0026#39;`通过`\u0026#39;}}\u0026lt;/p\u0026gt; \u0026lt;!-- 如果验证没有通过，而且`表单控件的值已经发生了变化` || `表单控件已经被用户输入或焦点` --\u0026gt; @if(usernameInput.invalid\u0026amp;\u0026amp;(usernameInput.dirty || usernameInput.touched)){ \u0026lt;div class=\u0026#34;alter\u0026#34;\u0026gt; @if(usernameInput.errors?.[\u0026#39;required\u0026#39;]){ \u0026lt;div\u0026gt; 还未填写username \u0026lt;/div\u0026gt; } \u0026lt;/div\u0026gt; } \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;密码:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; required minlength=\u0026#34;6\u0026#34; name=\u0026#34;password\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34; #passwordInput=\u0026#34;ngModel\u0026#34; [(ngModel)]=\u0026#34;loginForm.password\u0026#34;\u0026gt; \u0026lt;p\u0026gt;password验证是否通过:验证{{passwordInput.invalid?\u0026#39;`不通过`\u0026#39;:\u0026#39;`通过`\u0026#39;}}\u0026lt;/p\u0026gt; \u0026lt;!-- password表单校验 --\u0026gt; @if(passwordInput.invalid\u0026amp;\u0026amp;(passwordInput.dirty || passwordInput.touched)){ \u0026lt;div class=\u0026#34;alter\u0026#34;\u0026gt; @if(passwordInput.errors?.[\u0026#39;required\u0026#39;]){ \u0026lt;div\u0026gt; 还未填写password \u0026lt;/div\u0026gt; } @if(passwordInput.errors?.[\u0026#39;minlength\u0026#39;]){ \u0026lt;div\u0026gt; password最小长度是6位 \u0026lt;/div\u0026gt; } \u0026lt;/div\u0026gt; } \u0026lt;/div\u0026gt; \u0026lt;button (click)=\u0026#34;submitForm(usernameInput.value,passwordInput.value)\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; import { FormsModule, ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet, FormsModule, ReactiveFormsModule], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { loginForm = { username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39; } /** * 登录 */ submitForm(username: string, password: string) { console.log(`username:${username} password:${password}`); } } 以上是内置校验器，接下来学习自定义校验器\n定义自定义验证器 把自定义验证器添加到响应式表单中 为模板驱动表单添加自定义验证器 定义自定义验证器\n1 2 3 4 5 6 7 8 9 10 11 /** * 密码正则校验器 */ passwordRegValidator(): ValidatorFn { // 正则表达式如下 const passwordReg = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[$@,.])[a-zA-Z\\d$@,.]{6,12}$/ return (control: AbstractControl): ValidationErrors | null =\u0026gt; { const forbidden = passwordReg.test(control.value); return forbidden ? null : { forbiddenName: { value: control.value } }; }; } 把自定义验证器添加到响应式表单中\n1 2 3 4 5 6 7 8 9 10 11 loginForm = new FormGroup({ username: new FormControl(\u0026#39;\u0026#39;, [ Validators.required ]), password: new FormControl(\u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(12), this.passwordRegValidator() ]) }) 为模板驱动表单添加自定义验证器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;div\u0026gt; \u0026lt;!-- 密码如下 --\u0026gt; \u0026lt;!-- 1. 6~12位 --\u0026gt; \u0026lt;!-- 2. 必须包含数字、小写字母、大写字母、特殊字符($@,_.之一) --\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;密码:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; required name=\u0026#34;password\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34; formControlName=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;alter\u0026#34;\u0026gt; @if(checkPasswordIsValid){ @if(loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;required\u0026#39;]){ \u0026lt;span\u0026gt;密码不能为空\u0026lt;/span\u0026gt; }@else if (loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;minlength\u0026#39;]) { \u0026lt;span\u0026gt;密码长度不能小于6位\u0026lt;/span\u0026gt; }@else if (loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;maxlength\u0026#39;]) { \u0026lt;span\u0026gt;密码长度不能大于12位\u0026lt;/span\u0026gt; }@else if (loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;forbiddenName\u0026#39;]) { \u0026lt;span\u0026gt;密码必须包含数字、小写字母、大写字母、特殊字符\u0026lt;/span\u0026gt; } } \u0026lt;/div\u0026gt; 完整代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div [formGroup]=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;账号:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; required name=\u0026#34;username\u0026#34; placeholder=\u0026#34;请输入账号\u0026#34; formControlName=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;alter\u0026#34;\u0026gt; @if(checkUsernameIsValid){ \u0026lt;span\u0026gt;账号不能为空\u0026lt;/span\u0026gt; } \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 密码如下 --\u0026gt; \u0026lt;!-- 1. 6~12位 --\u0026gt; \u0026lt;!-- 2. 必须包含数字、小写字母、大写字母、特殊字符($@,_.之一) --\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;密码:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; required name=\u0026#34;password\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34; formControlName=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;alter\u0026#34;\u0026gt; @if(checkPasswordIsValid){ @if(loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;required\u0026#39;]){ \u0026lt;span\u0026gt;密码不能为空\u0026lt;/span\u0026gt; }@else if (loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;minlength\u0026#39;]) { \u0026lt;span\u0026gt;密码长度不能小于6位\u0026lt;/span\u0026gt; }@else if (loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;maxlength\u0026#39;]) { \u0026lt;span\u0026gt;密码长度不能大于12位\u0026lt;/span\u0026gt; }@else if (loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;forbiddenName\u0026#39;]) { \u0026lt;span\u0026gt;密码必须包含数字、小写字母、大写字母、特殊字符\u0026lt;/span\u0026gt; } } \u0026lt;/div\u0026gt; \u0026lt;button (click)=\u0026#34;submitForm()\u0026#34;\u0026gt;注册\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; import { AbstractControl, FormControl, FormGroup, FormsModule, ReactiveFormsModule, ValidationErrors, ValidatorFn, Validators } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet, FormsModule, ReactiveFormsModule], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { loginForm = new FormGroup({ username: new FormControl(\u0026#39;\u0026#39;, [ Validators.required ]), password: new FormControl(\u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(12), this.passwordRegValidator() ]) }) /** * 密码正则校验器 */ passwordRegValidator(): ValidatorFn { // 正则表达式如下 const passwordReg = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[$@,.])[a-zA-Z\\d$@,.]{6,12}$/ return (control: AbstractControl): ValidationErrors | null =\u0026gt; { const forbidden = passwordReg.test(control.value); return forbidden ? null : { forbiddenName: { value: control.value } }; }; } /** * 登录 */ submitForm() { if (this.loginForm.valid) { console.log(`username:${this.loginForm.value.username} password:${this.loginForm.value.password}`); } } /** * 验证用户名是否合法 */ get checkUsernameIsValid(): boolean { return this.loginForm.get(\u0026#39;username\u0026#39;)?.errors?.[\u0026#39;required\u0026#39;] \u0026amp;\u0026amp; (this.loginForm.get(\u0026#39;username\u0026#39;)?.dirty || this.loginForm.get(\u0026#39;username\u0026#39;)?.touched); } /** * 验证密码是否合法 */ get checkPasswordIsValid(): boolean { const requiredFlag = this.loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;required\u0026#39;] \u0026amp;\u0026amp; (this.loginForm.get(\u0026#39;password\u0026#39;)?.dirty || this.loginForm.get(\u0026#39;password\u0026#39;)?.touched); const minLengthFlag = this.loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;minlength\u0026#39;] \u0026amp;\u0026amp; (this.loginForm.get(\u0026#39;password\u0026#39;)?.dirty || this.loginForm.get(\u0026#39;password\u0026#39;)?.touched); const maxLengthFlag = this.loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;maxlength\u0026#39;] \u0026amp;\u0026amp; (this.loginForm.get(\u0026#39;password\u0026#39;)?.dirty || this.loginForm.get(\u0026#39;password\u0026#39;)?.touched); const regExpFlag = this.loginForm.get(\u0026#39;password\u0026#39;)?.errors?.[\u0026#39;forbiddenName\u0026#39;] \u0026amp;\u0026amp; (this.loginForm.get(\u0026#39;password\u0026#39;)?.dirty || this.loginForm.get(\u0026#39;password\u0026#39;)?.touched); console.log(`regExpFlag:${regExpFlag}`); return requiredFlag || minLengthFlag || maxLengthFlag || regExpFlag; } } 管道\r参考博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; import { FormsModule, ReactiveFormsModule, } from \u0026#39;@angular/forms\u0026#39;; // 导入CommonModule模块 import { CommonModule } from \u0026#39;@angular/common\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet, CommonModule, FormsModule, ReactiveFormsModule], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { dateTime = new Date() money = 12345; lowerCaseStr = \u0026#39;hello world\u0026#39;; upperCaseStr = \u0026#39;HELLO WORLD\u0026#39;; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;!-- 时间管道 --\u0026gt; \u0026lt;div\u0026gt; {{dateTime | date:\u0026#39;yyyy-MM-dd HH:mm:ss\u0026#39; }} \u0026lt;/div\u0026gt; \u0026lt;!-- 人名币格式的管道 --\u0026gt; \u0026lt;div\u0026gt; {{money | currency }} \u0026lt;/div\u0026gt; \u0026lt;!-- 字符串转大写 --\u0026gt; \u0026lt;div\u0026gt; {{lowerCaseStr | uppercase }} \u0026lt;/div\u0026gt; \u0026lt;!-- 字符串转小写 --\u0026gt; \u0026lt;div\u0026gt; {{upperCaseStr | lowercase}} \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;router-outlet /\u0026gt; 自定义管道\r快捷生成管道类\n1 2 3 # ng g p pipes/pipe-name ng g p pipes/strFilter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Pipe, PipeTransform } from \u0026#39;@angular/core\u0026#39;; @Pipe({ name: \u0026#39;strFilter\u0026#39;, standalone: true }) export class StrFilterPipe implements PipeTransform { transform(value: string, ...args: string[]): string { // 打印结果:value:abc cba args:a,c console.log(`value:${value} args:${args}`); args.forEach((str) =\u0026gt; { value = value.replaceAll(str, \u0026#39;\u0026#39;) }) // 返回结果是:b b return value; } } 使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; import { FormsModule, ReactiveFormsModule, } from \u0026#39;@angular/forms\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; // 导入模块 import { StrFilterPipe } from \u0026#39;./pipes/str-filter.pipe\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, // 导入模块 imports: [RouterOutlet, CommonModule, StrFilterPipe, FormsModule, ReactiveFormsModule], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { dateTime = new Date() money = 12345; lowerCaseStr = \u0026#39;hello world\u0026#39;; upperCaseStr = \u0026#39;HELLO WORLD\u0026#39;; strFilterPipeValue = \u0026#39;abc cba\u0026#39;; } 1 2 3 4 5 6 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;!-- 自定义管道 --\u0026gt; \u0026lt;div\u0026gt; {{ strFilterPipeValue | strFilter :\u0026#39;a\u0026#39; :\u0026#39;c\u0026#39; }} \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; 组件通信\r创建组件\n1 2 # ng g c + 组件名 ng g c component_name 我们在引用组件时，主要关注xxx.component.ts这个文件\n1 2 3 4 5 6 7 8 9 10 @Component({ selector: \u0026#39;app-user\u0026#39;, standalone: true, imports: [], templateUrl: \u0026#39;./user.component.html\u0026#39;, styleUrl: \u0026#39;./user.component.scss\u0026#39; }) export class UserComponent { } 这里我们定义的选择器是app-user\n所以，如果要在其他组件中引用UserComponent组件，我们需要新建一个app-user标签\n1 2 3 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;app-user\u0026gt;\u0026lt;/app-user\u0026gt; \u0026lt;/main\u0026gt; 除此之外还需要在xxx.component.ts中导入UserComponent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; import { FormsModule, ReactiveFormsModule, } from \u0026#39;@angular/forms\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; // 导入UserComponent import { UserComponent } from \u0026#39;./user/user.component\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, // 导入UserComponent imports: [RouterOutlet, CommonModule, UserComponent, FormsModule, ReactiveFormsModule], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { dateTime = new Date() money = 12345; lowerCaseStr = \u0026#39;hello world\u0026#39;; upperCaseStr = \u0026#39;HELLO WORLD\u0026#39;; strFilterPipeValue = \u0026#39;abc cba\u0026#39;; } 生命周期\r当你的应用通过调用构造函数来实例化一个组件或指令时，Angular 就会调用那个在该实例生命周期的适当位置实现了的那些钩子方法\nAngular 会按以下顺序执行钩子方法。可以用它来执行以下类型的操作。\n钩子方法 用途 时机 ngOnChanges() 当 Angular 设置或重新设置数据绑定的输入属性时响应。该方法接受当前和上一属性值的 SimpleChanges 对象 注意： 这发生得比较频繁，所以你在这里执行的任何操作都会显著影响性能。欲知详情，参阅本文档的使用变更检测钩子。 如果组件绑定过输入属性，那么在 ngOnInit() 之前以及所绑定的一个或多个输入属性的值发生变化时都会调用。 注意： 如果你的组件没有输入属性，或者你使用它时没有提供任何输入属性，那么框架就不会调用 ngOnChanges()。 ngOnInit() 在 Angular 第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。欲知详情，参阅本文档中的初始化组件或指令。 在第一轮 ngOnChanges() 完成之后调用，只调用一次。而且即使没有调用过 ngOnChanges()，也仍然会调用 ngOnInit()（比如当模板中没有绑定任何输入属性时）。 ngDoCheck() 检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。欲知详情和范例，参阅本文档中的自定义变更检测。 紧跟在每次执行变更检测时的 ngOnChanges() 和 首次执行变更检测时的 ngOnInit() 后调用。 ngAfterContentInit() 当 Angular 把外部内容投影进组件视图或指令所在的视图之后调用。 欲知详情和范例，参阅本文档中的响应内容中的变更。 第一次 ngDoCheck() 之后调用，只调用一次。 ngAfterContentChecked() 每当 Angular 检查完被投影到组件或指令中的内容之后调用。 欲知详情和范例，参阅本文档中的响应被投影内容的变更。 ngAfterContentInit() 和每次 ngDoCheck() 之后调用。 ngAfterViewInit() 当 Angular 初始化完组件视图及其子视图或包含该指令的视图之后调用。 欲知详情和范例，参阅本文档中的响应视图变更。 第一次 ngAfterContentChecked() 之后调用，只调用一次。 ngAfterViewChecked() 每当 Angular 做完组件视图和子视图或包含该指令的视图的变更检测之后调用。 ngAfterViewInit() 和每次 ngAfterContentChecked() 之后调用。 ngOnDestroy() 每当 Angular 每次销毁指令/组件之前调用并清扫。在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。欲知详情，参阅本文档中的在实例销毁时进行清理。 在 Angular 销毁指令或组件之前立即调用。 父子组件传参\r参考博客\n父传子\r@Input() 和 @Output() 为子组件提供了一种与其父组件通信的方法。@Input() 允许父组件更新子组件中的数据。相反，@Output() 允许子组件向父组件发送数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, // 导入UserComponent imports: [RouterOutlet, CommonModule, UserComponent, FormsModule, ReactiveFormsModule], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent implements OnInit { message = \u0026#39;你好，初次见面\u0026#39;; ngOnInit(): void { console.log(\u0026#39;初始化...\u0026#39;); } 在父组件中定义一个字符串message作为需要传递给user子组件的内容\n1 2 3 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;app-user [msg]=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/app-user\u0026gt; \u0026lt;/main\u0026gt; 像dom节点设置属性一样传递内容\n接下来在子组件中接收\n1 2 3 4 5 6 7 8 9 10 11 @Component({ selector: \u0026#39;app-user\u0026#39;, standalone: true, imports: [], templateUrl: \u0026#39;./user.component.html\u0026#39;, styleUrl: \u0026#39;./user.component.scss\u0026#39; }) export class UserComponent { // 使用`@Input()`装饰器接收 @Input() msg = \u0026#39;\u0026#39;; } 1 \u0026lt;p\u0026gt;msg:{{msg}}\u0026lt;/p\u0026gt; 子传父\r将输入框的内容传递给addNewIten函数\n1 2 \u0026lt;input type=\u0026#34;text\u0026#34; #childMsg\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;addNewIten(childMsg.value)\u0026#34;\u0026gt;传递信息给父组件\u0026lt;/button\u0026gt; 使用@Output()装饰器标注信息，通过xxx.emit('msg')向父组件传递信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Component({ selector: \u0026#39;app-user\u0026#39;, standalone: true, imports: [], templateUrl: \u0026#39;./user.component.html\u0026#39;, styleUrl: \u0026#39;./user.component.scss\u0026#39; }) export class UserComponent { @Output() msg = new EventEmitter\u0026lt;string\u0026gt;(); addNewIten(childMsg: string): void { this.msg.emit(`向父组件传递信息:【${childMsg}】`); } } 父组件通过(msg)=\u0026quot;getChildMsg($event)\u0026quot;接收信息\n1 2 3 4 5 6 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;app-user (msg)=\u0026#34;getChildMsg($event)\u0026#34;\u0026gt;\u0026lt;/app-user\u0026gt; @if(childMsg!==null \u0026amp;\u0026amp; childMsg!==\u0026#39;\u0026#39;){ 父组件接收到值:{{childMsg}} } \u0026lt;/main\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet, CommonModule, UserComponent, FormsModule, ReactiveFormsModule], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { childMsg = \u0026#39;\u0026#39;; getChildMsg(childMsg: string) { this.childMsg = childMsg; } } 获取子组件实例\r如果在父组件中，希望直接获取到子组件的实例，或者希望获取到子组件里的某个函数、属性\n以下是子组件中的代码\n1 \u0026lt;p\u0026gt;{{title}}\u0026lt;/p\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 import { Component } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-user\u0026#39;, standalone: true, imports: [], templateUrl: \u0026#39;./user.component.html\u0026#39;, styleUrl: \u0026#39;./user.component.scss\u0026#39; }) export class UserComponent { title = \u0026#39;这里是子组件\u0026#39;; } 以下是父组件中的代码\n1 2 3 4 5 6 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;app-user #childComponent\u0026gt;\u0026lt;/app-user\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn btn-success\u0026#34; (click)=\u0026#34;logChildComponent()\u0026#34;\u0026gt;点击获取子组件\u0026lt;/button\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;router-outlet /\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Component, ViewChild } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; import { FormsModule, ReactiveFormsModule, } from \u0026#39;@angular/forms\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { UserComponent } from \u0026#39;./user/user.component\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet, CommonModule, UserComponent, FormsModule, ReactiveFormsModule], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { @ViewChild(\u0026#39;childComponent\u0026#39;) child?: UserComponent; logChildComponent() { console.log(this.child?.title); } } 这样就可以通过获取到子组件实例从而取得子组件里的属性\n服务\rAngular 把组件和服务区分开，以提高模块性和复用性。\n理想情况下，组件的工作只管用户体验，而不用顾及其它。它应该提供用于数据绑定的属性和方法，以便作为视图和应用逻辑的中介者。视图就是模板所渲染的东西，而程序逻辑就是用于承载模型概念的东西。\n1 2 # 生成服务(service目录下的list服务) ng g s service/list 接下来演示一下用法\n1 2 3 4 5 export interface User { id: number; name: string; nickName: string; } 这里通常是发请求向后端请求数据，我这里暂时先把数据写死了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { User } from \u0026#39;../entity/User\u0026#39;; @Injectable({ // 作用域设定，`root`表示默认注入，注入到`AppModule`中 providedIn: \u0026#39;root\u0026#39; }) export class ListService { listUser(): User[] { return [{ id: 1, name: \u0026#39;zhangsan\u0026#39;, nickName: \u0026#39;张三\u0026#39; }, { id: 2, name: \u0026#39;lisi\u0026#39;, nickName: \u0026#39;李四\u0026#39; }, { id: 3, name: \u0026#39;wangwu\u0026#39;, nickName: \u0026#39;王五\u0026#39; }]; } } 导入服务使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet } from \u0026#39;@angular/router\u0026#39;; import { FormsModule, ReactiveFormsModule, } from \u0026#39;@angular/forms\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { ListService } from \u0026#39;./service/list.service\u0026#39;; import { User } from \u0026#39;./entity/User\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterOutlet, CommonModule, FormsModule, ReactiveFormsModule], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { list?: User[]; // 注入服务 constructor(private listService: ListService) { } showUsers() { this.list = this.listService.listUser(); } } 1 2 3 4 5 6 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; @for(user of list;track user.id){ \u0026lt;div\u0026gt;id:{{user.id}}===name:{{user.name}}==nickName:{{user.nickName}}\u0026lt;/div\u0026gt; } \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn btn-success\u0026#34; (click)=\u0026#34;showUsers()\u0026#34;\u0026gt;展示用户列表\u0026lt;/button\u0026gt; \u0026lt;/main\u0026gt; 路由\r参考文档\napp.routes.ts\n1 2 3 4 5 6 7 8 import { Routes } from \u0026#39;@angular/router\u0026#39;; import { UserComponent } from \u0026#39;./user/user.component\u0026#39;; import { OrdersComponent } from \u0026#39;./orders/orders.component\u0026#39;; export const routes: Routes = [ { path: \u0026#39;user\u0026#39;, component: UserComponent, pathMatch: \u0026#39;full\u0026#39; }, { path: \u0026#39;orders\u0026#39;, component: OrdersComponent, pathMatch: \u0026#39;full\u0026#39; }, ]; app.config.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { ApplicationConfig, provideZoneChangeDetection } from \u0026#39;@angular/core\u0026#39;; import { provideRouter } from \u0026#39;@angular/router\u0026#39;; import { routes } from \u0026#39;./app.routes\u0026#39;; import { provideClientHydration } from \u0026#39;@angular/platform-browser\u0026#39;; export const appConfig: ApplicationConfig = { providers: [ provideZoneChangeDetection({ eventCoalescing: true }), // 引入路由配置 provideRouter(routes), provideClientHydration() ] }; 这样就实现了路由的配置，如果希望通过link进行路由跳转\n1 2 3 4 5 6 7 8 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a class=\u0026#34;button\u0026#34; routerLink=\u0026#34;/user\u0026#34;\u0026gt;user\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a class=\u0026#34;button\u0026#34; routerLink=\u0026#34;/orders\u0026#34;\u0026gt;orders\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/main\u0026gt; 在app.component.html中使用routerLink进行跳转，注意要导包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterOutlet, RouterLink } from \u0026#39;@angular/router\u0026#39;; import { FormsModule, ReactiveFormsModule, } from \u0026#39;@angular/forms\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [ RouterOutlet, CommonModule, FormsModule, ReactiveFormsModule, // 导包 RouterLink ], templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrl: \u0026#39;./app.component.scss\u0026#39; }) export class AppComponent { } 标注出当前路由\r如果我们希望在RouterLink的基础上进一步，对当前路由的a标签展示更加明显的css样式\n可以使用routerLinkActive属性，当然，需要导入RouterLinkActive的包\n1 2 3 4 5 6 7 8 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;a class=\u0026#34;button\u0026#34; routerLink=\u0026#34;user\u0026#34; routerLinkActive=\u0026#34;activebutton\u0026#34;\u0026gt;user\u0026lt;/a\u0026gt; | \u0026lt;a class=\u0026#34;button\u0026#34; routerLink=\u0026#34;orders\u0026#34; routerLinkActive=\u0026#34;activebutton\u0026#34;\u0026gt;orders\u0026lt;/a\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;router-outlet /\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 .button { box-shadow: inset 0 1px 0 0 #ffffff; background: #ffffff linear-gradient(to bottom, #ffffff 5%, #f6f6f6 100%); border-radius: 6px; border: 1px solid #dcdcdc; display: inline-block; cursor: pointer; color: #666666; font-family: Arial, sans-serif; font-size: 15px; font-weight: bold; padding: 6px 24px; text-decoration: none; text-shadow: 0 1px 0 #ffffff; outline: 0; } .activebutton { box-shadow: inset 0 1px 0 0 #dcecfb; background: #bddbfa linear-gradient(to bottom, #bddbfa 5%, #80b5ea 100%); border: 1px solid #84bbf3; color: #ffffff; text-shadow: 0 1px 0 #528ecc; } 这意味着，当前路由会使用.activebutton的样式\n重定向\r1 2 3 4 5 export const routes: Routes = [ { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;/user\u0026#39;, pathMatch: \u0026#39;full\u0026#39; }, { path: \u0026#39;user\u0026#39;, component: UserComponent, pathMatch: \u0026#39;full\u0026#39; }, { path: \u0026#39;orders\u0026#39;, component: OrdersComponent, pathMatch: \u0026#39;full\u0026#39; }, ]; 这样配置之后，如果访问http://localhost:4200则会自动重定向到http://localhost:4200/user\n添加404页面\r1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box-404-wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;d-flex flex-column align-items-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;text-wrap\u0026#34;\u0026gt; \u0026lt;h1 data-t=\u0026#34;404\u0026#34; class=\u0026#34;h1\u0026#34;\u0026gt;404\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text-center mt-2\u0026#34;\u0026gt;页面不存在或者您没有权限访问。\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-4\u0026#34;\u0026gt;\u0026lt;a routerLink=\u0026#34;/\u0026#34; role=\u0026#34;button\u0026#34; tabindex=\u0026#34;0\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;回首页\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 import { Routes } from \u0026#39;@angular/router\u0026#39;; import { UserComponent } from \u0026#39;./user/user.component\u0026#39;; import { OrdersComponent } from \u0026#39;./orders/orders.component\u0026#39;; import { NotFoundComponent } from \u0026#39;./not-found/not-found.component\u0026#39;; export const routes: Routes = [ { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;/user\u0026#39;, pathMatch: \u0026#39;full\u0026#39; }, { path: \u0026#39;user\u0026#39;, component: UserComponent, pathMatch: \u0026#39;full\u0026#39; }, { path: \u0026#39;orders\u0026#39;, component: OrdersComponent, pathMatch: \u0026#39;full\u0026#39; }, // 使用通配符来匹配所有路径,如果没有匹配的路由将会返回404页面 { path: \u0026#39;**\u0026#39;, component: NotFoundComponent }, ]; 路由嵌套\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Routes } from \u0026#39;@angular/router\u0026#39;; import { UserComponent } from \u0026#39;./user/user.component\u0026#39;; import { OrdersComponent } from \u0026#39;./orders/orders.component\u0026#39;; import { NotFoundComponent } from \u0026#39;./not-found/not-found.component\u0026#39;; import { ListComponent } from \u0026#39;./list/list.component\u0026#39;; export const routes: Routes = [ { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;/user\u0026#39;, pathMatch: \u0026#39;full\u0026#39; }, { path: \u0026#39;user\u0026#39;, component: UserComponent, children: [ // 访问子路由`/user/list` { path: \u0026#39;list\u0026#39;, component: ListComponent, pathMatch: \u0026#39;full\u0026#39;, } ] }, { path: \u0026#39;orders\u0026#39;, component: OrdersComponent, pathMatch: \u0026#39;full\u0026#39; }, { path: \u0026#39;**\u0026#39;, component: NotFoundComponent }, ]; user.component.html\n1 2 3 4 \u0026lt;p\u0026gt;这里是user子组件\u0026lt;/p\u0026gt; \u0026lt;!-- 渲染user下的子路由 --\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; 路由传参\r路由传参一般有两种方式，一种是xxx/1斜线分割，一种是xxx?name=张三问号分割\n1 2 3 4 5 6 7 8 \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;a class=\u0026#34;button\u0026#34; routerLink=\u0026#34;user\u0026#34; routerLinkActive=\u0026#34;activebutton\u0026#34; [queryParams]=\u0026#34;{name:\u0026#39;aaa\u0026#39;}\u0026#34;\u0026gt;user\u0026lt;/a\u0026gt; | \u0026lt;a class=\u0026#34;button\u0026#34; [routerLink]=\u0026#34;[\u0026#39;orders\u0026#39;,\u0026#39;aaa\u0026#39;]\u0026#34; routerLinkActive=\u0026#34;activebutton\u0026#34;\u0026gt;orders\u0026lt;/a\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;router-outlet /\u0026gt; 通过点击这两个按钮进行传参\nquery\r访问http://localhost:4200/user?name=aaa\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { ActivatedRoute } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-user\u0026#39;, standalone: true, imports: [], templateUrl: \u0026#39;./user.component.html\u0026#39;, styleUrl: \u0026#39;./user.component.scss\u0026#39; }) export class UserComponent implements OnInit { constructor(private activatedRoute: ActivatedRoute) { } ngOnInit(): void { console.log(\u0026#39;name:\u0026#39;, this.activatedRoute.snapshot.queryParams[\u0026#39;name\u0026#39;]); } } parms\r访问http://localhost:4200/orders/aaa\nrouter需要新增一个:name表示传递参数的名字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Routes } from \u0026#39;@angular/router\u0026#39;; import { UserComponent } from \u0026#39;./user/user.component\u0026#39;; import { OrdersComponent } from \u0026#39;./orders/orders.component\u0026#39;; import { NotFoundComponent } from \u0026#39;./not-found/not-found.component\u0026#39;; export const routes: Routes = [ { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;/user\u0026#39;, pathMatch: \u0026#39;full\u0026#39; }, { path: \u0026#39;user\u0026#39;, component: UserComponent, }, { path: \u0026#39;orders/:name\u0026#39;, component: OrdersComponent }, { path: \u0026#39;**\u0026#39;, component: NotFoundComponent }, ]; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { ActivatedRoute, Params } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-orders\u0026#39;, standalone: true, imports: [], templateUrl: \u0026#39;./orders.component.html\u0026#39;, styleUrl: \u0026#39;./orders.component.scss\u0026#39; }) export class OrdersComponent implements OnInit { constructor(private activatedRoute: ActivatedRoute) { } ngOnInit(): void { this.activatedRoute.params.subscribe((parms: Params) =\u0026gt; { console.log(\u0026#39;name:\u0026#39;, parms[\u0026#39;name\u0026#39;]); }); } } ","date":"2024-12-08T00:00:00Z","image":"http://localhost:1313/p/angular/202412211941020_hu6506742085097644881.png","permalink":"http://localhost:1313/p/angular/","title":"Angular"},{"content":"beetl3\r参考文档\n基础入门\r安装\r1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.ibeetl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;beetl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.16.2.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 快速开始\rBeetl的核心是GroupTemplate，是一个重量级对象，实际使用的时候建议使用单模式创建 创建GroupTemplate需要2个参数，一个是模板资源加载器，一个是配置类 模板资源加载器Beetl内置了6种，分别是：\nStringTemplateResourceLoader：字符串模板加载器，用于加载字符串模板，如本例所示 FileResourceLoader：文件模板加载器，需要一个根目录作为参数构造，传入getTemplate方法的String是模板文件相对于Root目录的相对路径 ClasspathResourceLoader：现代web应用最常用的文件模板加载器，模板文件位于Classpath里 WebAppResourceLoader：用于webapp集成，假定模板根目录就是WebRoot目录，参考web集成章 MapResourceLoader：可以动态存入模板 CompositeResourceLoader：混合使用多种加载方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import org.beetl.core.Configuration; import org.beetl.core.GroupTemplate; import org.beetl.core.Template; import org.beetl.core.resource.StringTemplateResourceLoader; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class BeetlDemoApplicationTests { @Test void contextLoads() throws Exception { //初始化代码 StringTemplateResourceLoader resourceLoader = new StringTemplateResourceLoader(); Configuration cfg = Configuration.defaultConfiguration(); GroupTemplate gt = new GroupTemplate(resourceLoader, cfg); //获取模板 Template t = gt.getTemplate(\u0026#34;hello,${name}\u0026#34;); t.binding(\u0026#34;name\u0026#34;, \u0026#34;beetl\u0026#34;); //渲染结果 String str = t.render(); System.out.println(str); } } t.binding(\u0026quot;name\u0026quot;, \u0026quot;beetl\u0026quot;);将name的值绑定为beetl\nString str = t.render();渲染模板，得到输出的结果\n除此之外，还提供了多种渲染输出的方法\ntemplate.render() 返回渲染结果，如本例所示 template.renderTo(Writer) 渲染结果输出到Writer里，如果你的Writer是一个FilterWriter，则可把输出保存到文件里 template.renderTo(OutputStream) 渲染结果输出到OutputStream里 Beetl 支持为模板自定义定界符和占位符，如本例子采用的默认占位符号 ${}。 后面可以看到，可以定义任意其他符号，比如#{} 或者 ## 如果不想写代码直接体验 Beetl 提供的基本功能，可以使用 http://ibeetl.com/beetlonline/ 模板基础配置\rBeetl提供不但功能齐全，而且还有很多独特功能，通过简单的配置文件，就可以定义众多的功能，默认情况下，Configuration类总是会先加载默认的配置文件（位于/org/beetl/core/beetl-default.properties，作为新手，通常只需要关注3,4,5,6行定界符的配置，以及12行模板字符集的配置就可以了，其他配置会在后面章节陆续提到,同时，对于Spring等框架，有些配置将会被这些框架的配置覆盖，需要参考后面章节）下，beetl-default.properties其内容片断如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #默认配置 ENGINE=org.beetl.core.engine.FastRutimeEngine DELIMITER_PLACEHOLDER_START=${ DELIMITER_PLACEHOLDER_END=} DELIMITER_STATEMENT_START=\u0026lt;% DELIMITER_STATEMENT_END=%\u0026gt; DIRECT_BYTE_OUTPUT = FALSE HTML_TAG_SUPPORT = true HTML_TAG_FLAG = # HTML_TAG_BINDING_ATTRIBUTE = var #3.17版本以后，默认不再支持Java直接调用 NATIVE_CALL = FALSE TEMPLATE_CHARSET = UTF-8 ERROR_HANDLER = org.beetl.core.ConsoleErrorHandler #3.17版本以后，使用白名单管理Java直接调用 NATIVE_SECUARTY_MANAGER= org.beetl.core.WhiteListNativeSecurityManager MVC_STRICT = FALSE #资源配置，resource后的属性只限于特定ResourceLoader RESOURCE_LOADER=org.beetl.core.resource.ClasspathResourceLoader #classpath 根路径 RESOURCE.root= / #是否检测文件变化,开发用true合适，但线上要改为false RESOURCE.autoCheck= true #自定义脚本方法文件的Root目录和后缀 RESOURCE.functionRoot = functions RESOURCE.functionSuffix = html #自定义标签文件Root目录和后缀 RESOURCE.tagRoot = htmltag RESOURCE.tagSuffix = tag ##### 扩展 ############## ## 内置的方法 FN.date = org.beetl.ext.fn.DateFunction ...... ##内置的功能包 FNP.strutil = org.beetl.ext.fn.StringUtil ...... ##内置的默认格式化函数 FTC.java.util.Date = org.beetl.ext.format.DateFormat ..... ## 标签类 TAG.include= org.beetl.ext.tag.IncludeTag TAG.html.include= org.beetl.ext.tag.html.IncludeResourceHtmlTag TAG.html.foreach= org.beetl.ext.tag.html.ForeachHtmlTag 第3,4行指定了占位符号，默认是${``}，也可以指定为其他占位符。\n第5,6行指定了语句的定界符号，默认是\u0026lt;%``%\u0026gt;，也可以指定为其他定界符号\n第12行指定模板字符集是UTF-8\n模板开发者不需要关心如上配置，可以创建一个beetl.properties的配置文件，此时，该配置文件将覆盖默认的配置文件属性，比如，你的定界符考虑是\u0026lt;!--: 和 --\u0026gt; ,则在beetl.properties加入一行即可,并将此配置文件放入Classpath根目录下即可。\n模板加载器\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class BeetlDemoApplicationTests { private static final String RESOURCES_PATH=\u0026#34;%s\\\\src\\\\main\\\\resources\\\\%s\u0026#34;; @Test void contextLoads() throws Exception { // D:\\workspace\\IdeaProjects\\beetl-demo\\src\\main\\resources\\template // 设置根目录 String root = String.format(RESOURCES_PATH, System.getProperty(\u0026#34;user.dir\u0026#34;), \u0026#34;template\u0026#34;); // 指定字符集为UTF-8，也可不指定，因为配置文件默认就是UTF-8 FileResourceLoader resourceLoader = new FileResourceLoader(root,\u0026#34;utf-8\u0026#34;); Configuration cfg = Configuration.defaultConfiguration(); GroupTemplate gt = new GroupTemplate(resourceLoader, cfg); Template t = gt.getTemplate(\u0026#34;/s01/hello.txt\u0026#34;); t.binding(\u0026#34;name\u0026#34;, \u0026#34;名字\u0026#34;); t.binding(\u0026#34;my_name\u0026#34;, \u0026#34;张三\u0026#34;); String str = t.render(); System.out.println(str); } } src/main/resources/template/s01/hello.txt\n1 你好,请问你叫什么${name}，我叫${my_name} Classpath资源模板加载器\r最常用的加载器。在springboot里，模板资源是打包到jar文件或者同Class放在一起，因此，可以使用ClasspathResourceLoader来加载模板实例\n1 2 3 4 5 6 7 8 9 10 11 12 13 class BeetlDemoApplicationTests { @Test void contextLoads() throws Exception { ClasspathResourceLoader resourceLoader = new ClasspathResourceLoader(\u0026#34;org/tong/template/\u0026#34;); Configuration cfg = Configuration.defaultConfiguration(); GroupTemplate gt = new GroupTemplate(resourceLoader, cfg); Template t = gt.getTemplate(\u0026#34;/hello.txt\u0026#34;); t.binding(\u0026#34;name\u0026#34;, \u0026#34;beetl\u0026#34;); String str = t.render(); System.out.println(str); } } src/main/resources/org/tong/template/hello.txt\n1 你好，这是${name}模板 WebApp资源模板加载器\rWebAppResourceLoader 是用于Java EE web应用的资源模板加载器，默认根路径是WebRoot目录。也可以通过制定root属性来设置相对于WebRoot的的模板根路径，从安全角考虑，建议放到WEB-INF目录下\n如下是Jfinal集成 里初始化GroupTemplate的方法\n1 2 3 Configuration cfg = Configuration.defaultConfiguration(); WebAppResourceLoader resourceLoader = new WebAppResourceLoader(); groupTemplate = new GroupTemplate(resourceLoader, cfg); WebAppResourceLoader 假定 beetl.jar 是位于 WEB-INF/lib 目录下，因此，可以通过WebAppResourceLoader类的路径来推断出WebRoot路径从而指定模板根路径。所有线上环境一般都是如此，如果是开发环境或者其他环境不符合此假设，你需要调用resourceLoader.setRoot() 来指定模板更路径\n语法\r定界符与占位符号\rBeetl模板语言类似JS语言和习俗，只需要将Beetl语言放入定界符号里即可，如默认的是\u0026lt;% %\u0026gt; ,占位符用于静态文本里嵌入占位符用于输出，如下是正确例子\n1 2 3 4 5 6 \u0026lt;% var num1=3; var num2=2; var sum=num1+num2; %\u0026gt; sum:${num1+num2} 或者 ${sum} 千万不要在定界符里使用占位符号，因为占位符仅仅嵌在静态文本里，如下例子是错误例子\n1 2 3 4 5 \u0026lt;% var num1=3; var num2=2; var sum=${num1}+${num2}; %\u0026gt; 注释\r单行注释采用//，多行注释采用/* */\n变量\r临时变量\r临时变量使用var定义\n1 2 3 4 5 6 7 8 9 10 \u0026lt;% var name = \u0026#34;abc\u0026#34;; var sql =\u0026#34;\u0026#34;\u0026#34; SELECT * FROM TH_USER WHERE NAME = \u0026#39;张三\u0026#39; AND AGE \u0026gt; 18 \u0026#34;\u0026#34;\u0026#34;; %\u0026gt; SQL:${sql} ${name} 全局变量\r全局变量是通过在java代码里调用template.binding传入的变量,这些变量能在模板的任何一个地方，包括子模板都能访问到\n1 2 3 4 5 6 7 8 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer id; private String username; private String password; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class BeetlDemoApplicationTests { @Test void contextLoads() throws Exception { ClasspathResourceLoader resourceLoader = new ClasspathResourceLoader(\u0026#34;org/tong/template/\u0026#34;); Configuration cfg = Configuration.defaultConfiguration(); GroupTemplate gt = new GroupTemplate(resourceLoader, cfg); Template t = gt.getTemplate(\u0026#34;/demo.vue\u0026#34;); // 设置全局变量 t.binding(\u0026#34;userList\u0026#34;, initUserList()); String str = t.render(); System.out.println(str); } List\u0026lt;User\u0026gt; initUserList(){ List\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;\u0026gt;(); userList.add(new User(1,\u0026#34;admin\u0026#34;,\u0026#34;admin\u0026#34;)); userList.add(new User(2,\u0026#34;zhangsan\u0026#34;,\u0026#34;zhangsan\u0026#34;)); userList.add(new User(3,\u0026#34;lisi\u0026#34;,\u0026#34;lisi\u0026#34;)); return userList; } } 1 2 3 4 5 6 7 \u0026lt;% for(user in userList) { %\u0026gt; user_name is ${user.username} \u0026lt;% } %\u0026gt; 自从2.8.0版本后，有一个特殊的变量成为root变量，当模板找不到变量的时候，会寻找root变量的属性来作为变量的值，这个root变量必须绑定为\u0026quot;_root\u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 class BeetlDemoApplicationTests { @Test void contextLoads() throws Exception { ClasspathResourceLoader resourceLoader = new ClasspathResourceLoader(\u0026#34;org/tong/template/\u0026#34;); Configuration cfg = Configuration.defaultConfiguration(); GroupTemplate gt = new GroupTemplate(resourceLoader, cfg); Template t = gt.getTemplate(\u0026#34;/demo.vue\u0026#34;); //绑定\u0026#34;_root\u0026#34;变量的值 t.binding(\u0026#34;_root\u0026#34;, new User(1,\u0026#34;admin\u0026#34;,\u0026#34;123456\u0026#34;)); String str = t.render(); System.out.println(str); } } 1 2 ${username} ${password} ","date":"2024-11-05T00:00:00Z","image":"http://localhost:1313/p/beetl3/202412232109437_hu8399720255706859778.png","permalink":"http://localhost:1313/p/beetl3/","title":"Beetl3"},{"content":"Mongodb\r下载Mongodb\n参考博客\n如果采用msi安装，则无需继续后续步骤配置为本地服务\n配置环境变量\n在path下新建D:\\env\\Database\\MongoDB\\bin\n运行MongoDB服务\n在data目录下新建db目录\n在db目录下打开cmd执行如下命令，即可启动mongodb服务\n1 mongod --dbpath D:\\env\\Database\\MongoDB\\data\\db 在浏览器中打开如下链接http://localhost:27017，可以看到如下页面就表示服务启动成功\n新建log目录用来存放日志\n配置mongo.config(与 bin 目录同级)\n1 2 dbpath=D:\\env\\Database\\MongoDB\\data\\db logpath=D:\\env\\Database\\MongoDB\\data\\log\\mongo.log 使用管理员权限打开cmd，切换到mongodb/bin目录下，并输入如下命令\n1 mongod -dbpath \u0026#34;D:\\env\\Database\\MongoDB\\data\\db\u0026#34; -logpath \u0026#34;D:\\env\\Database\\MongoDB\\data\\log\\mongo.log\u0026#34; -install -serviceName \u0026#34;MongoDB\u0026#34; 使用navicat连接mongodb\n","date":"2024-10-20T00:00:00Z","image":"http://localhost:1313/p/mongodb%E9%85%8D%E7%BD%AE/202412211349060_hu18432554274727310962.png","permalink":"http://localhost:1313/p/mongodb%E9%85%8D%E7%BD%AE/","title":"Mongodb"},{"content":"PostgreSQL\r下载链接\n参考博客\n参考博客2\n不要跟着截图一路走下去，后续有报错，先看完解决方法，尽量避免报错！！！\n这里报了一个警告\n参考博客\n但我尝试之后并未解决\n重新安装时，选择\n依然报错!!!\n参考如下博客后依然无法解决问题\ncd到postgresql/bin下，执行如下命令初始化数据库集群\n1 initdb -D \u0026#34;D:\\env\\Database\\PostgreSQL\\data\u0026#34; 注册成windows服务\n1 pg_ctl.exe register -N postgresql17 -D D:\\env\\Database\\PostgreSQL\\data 配置环境变量\n新建如下配置\n1 2 PGHOME D:\\env\\Database\\PostgreSQL\\17 在path下新建\n1 %PGHOME%\\bin navicat连接postgresql\n报错信息乱码\n参考博客\n1 2 # TYPE DATABASE USER ADDRESS METHOD host all all 0.0.0.0/0 trust 再次卸载重装\n参考博客\n这次终于解决问题\n1 initdb -D \u0026#34;D:\\env\\Database\\PostgreSQL\\data\u0026#34; -E UTF-8 --locale=Chinese 打开psql之后，一路默认，报错postgres角色不存在，所以接下来需要创建这个角色\n再次打开psql，username输入Administrator，其他默认\n1 CREATE USER postgres SUPERUSER; 至此成功\n","date":"2024-10-20T00:00:00Z","image":"http://localhost:1313/p/postgresql%E9%85%8D%E7%BD%AE/202412211414934_hu261978600030145230.png","permalink":"http://localhost:1313/p/postgresql%E9%85%8D%E7%BD%AE/","title":"PostgreSQL"},{"content":"Metasploit\rkali安装Metasploit\r参考文章\n启动postgresql\n查看postgresql的状态，kali默认安装postgresql，无需再次安装\n1 systemctl status postgresql 如果postgresql没有启动，需要先启动\n1 sudo systemctl enable --now postgresql 初始化postgresql\nPostgreSQL 数据库服务器运行后，继续初始化 Metasploit PostgreSQL 数据库\n1 sudo msfdb init 安装msfconsole\n更新apt源\n1 vim /etc/apt/sources.list 添加如下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 中科大 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib # 阿里云 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib # 清华大学 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free # 浙大 deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free # 官方源 deb http://http.kali.org/kali kali-rolling main non-free contrib deb-src http://http.kali.org/kali kali-rolling main non-free contrib 1 2 3 4 5 # 更新源 apt-get update # 下载 apt install metasploit-framework 启动msfconsole\n1 sudo msfconsole ","date":"2024-10-11T00:00:00Z","image":"http://localhost:1313/p/kali/202412232120751_hu6827512440536727389.png","permalink":"http://localhost:1313/p/kali/","title":"Kali"},{"content":"Kotlin\r下载链接\n环境变量在path上添加如下内容\n1 D:\\env\\kotlinc\\bin 将D:\\env\\kotlinc替换成自己的安装路径\n查看信息\n1 kotlinc -version ","date":"2024-10-05T00:00:00Z","image":"http://localhost:1313/p/kotlin%E9%85%8D%E7%BD%AE/202412211343389_hu6146871212167752059.png","permalink":"http://localhost:1313/p/kotlin%E9%85%8D%E7%BD%AE/","title":"Kotlin"},{"content":"PHP8+Apache\r参考博客\n配置PHP\r下载链接 注意这里要下载Thread Safe的版本，而不是Non Thread Safe，否则后期整合Apache时会出现缺少必要文件\n复制php.ini-development文件，重命名为php.ini\n在该路径下输入命令查看版本信息\n1 php.exe -v 添加到环境变量到path\n1 D:\\env\\PHP8 然后输入如下命令即可查看版本信息\n1 php -v 配置Apache\r下载链接 下载Win64版本，解压之后关注Apache24目录的配置即可\n配置Apache24\\conf\\httpd.conf文件\n这里SRVROOT设置为自己的目录，需要注意路径中不要写\\，而是/\n这里的Listen就是启动的端口，默认是80，我这里修改为888，不修改也行\n只是如果安装了nginx，默认也是80端口，注意不要端口冲突\n进入安装目录后执行如下命令\n1 httpd.exe -k install 这里成功设置了开机自动运行\n也可以双击**Apache24\\bin\\ApacheMonitor.exe**文件也可以看到如下界面，点击start即可启动\n输入url查看，正常显示\n但此时Apache还不支持php，如果需要显示php页面，还需要进行额外配置\n修改php.ini文件\n新增如下内容，其中extension_dir后的内容修改成自己的ext目录\n1 extension_dir = \u0026#34;D:\\env\\PHP8\\ext\u0026#34; 还可以根据自己的需要来添加一些模块，删除前面的;即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 extension=curl ;extension=ffi ;extension=ftp extension=fileinfo extension=gd extension=gettext ;extension=gmp extension=intl ;extension=imap extension=mbstring ;extension=exif ; Must be after mbstring as it depends on it extension=mysqli ;extension=oci8_12c ; Use with Oracle Database 12c Instant Client ;extension=oci8_19 ; Use with Oracle Database 19 Instant Client extension=odbc extension=openssl extension=pdo_firebird extension=pdo_mysql extension=pdo_oci ;extension=pdo_odbc ;extension=pdo_pgsql extension=pdo_sqlite ;extension=pgsql ;extension=shmop 更新Apache的配置文件httpd.conf\n1 2 3 \u0026lt;IfModule dir_module\u0026gt; DirectoryIndex index.html \u0026lt;/IfModule\u0026gt; 修改为如下内容\n1 2 3 \u0026lt;IfModule dir_module\u0026gt; DirectoryIndex index.html index.php \u0026lt;/IfModule\u0026gt; 添加如下内容\n1 LoadModule php_module \u0026#34;PATH/php8apache2_4.dll\u0026#34; 同时还需要修改如下内容\n1 2 3 \u0026lt;IfModule dir_module\u0026gt; DirectoryIndex index.html index.php \u0026lt;/IfModule\u0026gt; 修改成\n1 2 3 4 5 6 \u0026lt;IfModule dir_module\u0026gt; PHPIniDir \u0026#34;D:/env/PHP8/\u0026#34; AddType application/x-httpd-php .php AddType application/x-httpd-source .phps DirectoryIndex index.html index.php \u0026lt;/IfModule\u0026gt; 这里的Path替换成自己的安装目录\n页面默认存放在htdocs目录下，这里我就不修改了\n在htdocs下新建index.php，内容如下\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php echo \u0026#34;Hello World!\u0026#34;; ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如果网站涉及到了MySQL还需要进行配置\n解锁如下Module\n1 2 3 4 5 6 LoadModule access_compat_module modules/mod_access_compat.so LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_http_module modules/mod_proxy_http.so LoadModule rewrite_module modules/mod_rewrite.so LoadModule vhost_alias_module modules/mod_vhost_alias.so LoadModule headers_module modules/mod_headers.so 测试一下，连接mysql是否成功\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;php\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php // 数据库配置信息 $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;123456\u0026#34;; $dbname = \u0026#34;php\u0026#34;; // 创建连接 $conn = new mysqli($servername, $username, $password, $dbname); // 检查连接 if ($conn-\u0026gt;connect_error) { die(\u0026#34;连接失败: \u0026#34; . $conn-\u0026gt;connect_error); } // SQL 查询语句 $sql = \u0026#34;SELECT id, username, password, nick_name FROM TB_USER\u0026#34;; $result = $conn-\u0026gt;query($sql); if ($result-\u0026gt;num_rows \u0026gt; 0) { // 输出每一行的数据 while ($row = $result-\u0026gt;fetch_assoc()) { echo \u0026#34;编号: \u0026#34; . $row[\u0026#34;id\u0026#34;] . \u0026#34; - 账号: \u0026#34; . $row[\u0026#34;username\u0026#34;] . \u0026#34; - 密码: \u0026#34; . $row[\u0026#34;password\u0026#34;] . \u0026#34; - 昵称: \u0026#34; . $row[\u0026#34;nick_name\u0026#34;] . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } } else { echo \u0026#34;0 结果\u0026#34;; } $conn-\u0026gt;close(); ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这里连接mysql的php数据库，并执行了如下sql\n1 SELECT id, username, password, nick_name FROM TB_USER; ","date":"2024-10-05T00:00:00Z","image":"http://localhost:1313/p/php8%E9%85%8D%E7%BD%AE/202412211409504_hu18244191102103723910.png","permalink":"http://localhost:1313/p/php8%E9%85%8D%E7%BD%AE/","title":"PHP8"},{"content":"Freemarker\r基础\r入门\r导入依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!-- freemarker依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 配置application.yml\n1 2 3 4 5 6 7 8 9 10 11 12 spring: freemarker: # 关闭缓存 cache: false charset: utf-8 suffix: .ftl settings: # 检查模板更新延迟时间，设置为0表示立即检查 template_update_delay: 0 server: # 服务端口 port: 8881 在resources下新建templates/01.basic.ftl，内容如下\n使用${}插值语法展示对应的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;freemark-01\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; hello,${student.name}！你的年龄是${student.age} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在对应的controller中设置数据\n1 2 3 4 5 6 7 8 9 @Controller public class FreemarkController { @GetMapping(\u0026#34;/basic\u0026#34;) public String basic(Model model) { Student student = new Student(\u0026#34;张三\u0026#34;,23); model.addAttribute(\u0026#34;student\u0026#34;,student); return \u0026#34;01.basic\u0026#34;; } } 扩展\r找到spring-boot-autoconfigure包，打开spring.factories文件，找到如下配置\n1 org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration 进入FreeMarkerProperties即可查看到默认配置\n基础语法\r注释\r1 \u0026lt;#-- 这是一段注释 --\u0026gt; 插值\r1 ${student.name} ftl指令\rftl指令与html标记类似，名字前加#进行区分，freemarker会解析标签中的表达式或者逻辑\n1 \u0026lt;# \u0026gt;Ftl指令\u0026lt;/#\u0026gt; 文本\r剩下的不是freemarker的注释、插值、ftl指令的内容就会被freemarker忽略解析，直接输出内容\nFTL指令\r集合指令\rList\r我们在案例中实现一个表格展示的效果，类似如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;地址\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;张三\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;23\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;江苏\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;李四\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;24\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;湖南\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 前端代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;序号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;#-- studentList就是在java中设置的attribute --\u0026gt; \u0026lt;#-- stu就是遍历之后的每一个对象 --\u0026gt; \u0026lt;#list studentList as stu\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;#-- 使用\u0026#39;_index\u0026#39;来获取当前对象序号(从0开始) --\u0026gt; \u0026lt;td\u0026gt;${stu_index+1}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.age}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/table\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Controller public class FreemarkController { @GetMapping(\u0026#34;/list\u0026#34;) public String list(Model model) { List\u0026lt;Student\u0026gt; studentList = getStudentList(); model.addAttribute(\u0026#34;studentList\u0026#34;,studentList); return \u0026#34;02.list\u0026#34;; } protected List\u0026lt;Student\u0026gt; getStudentList(){ List\u0026lt;Student\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Student student1 = new Student(\u0026#34;张三\u0026#34;,23); Student student2 = new Student(\u0026#34;李四\u0026#34;,24); Student student3 = new Student(\u0026#34;王五\u0026#34;,25); list.add(student1); list.add(student2); list.add(student3); return list; } } Map\r方式1：通过map['keyname'].property来获取对象的属性\n方式2：通过map.keyname.property来获取对象的属性\n遍历Map使用studentMap?keys as key来获取对象的key，但是需要注意，此时只能使用studentMap[key].name来获取属性\n如果使用studentMap.key的方式，它会认为studentMap中存在key这个键，但是实际上我们只有stu1、stu2、stu3，所以会报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;h2\u0026gt;方式1：通过map[\u0026#39;keyname\u0026#39;].property\u0026lt;/h2\u0026gt; 姓名:${studentMap[\u0026#39;stu1\u0026#39;].name}\u0026lt;br\u0026gt; 年龄:${studentMap[\u0026#39;stu1\u0026#39;].age}\u0026lt;br\u0026gt; \u0026lt;h2\u0026gt;方式2：通过map.keyname.property\u0026lt;/h2\u0026gt; 姓名:${studentMap.stu2.name}\u0026lt;br\u0026gt; 年龄:${studentMap.stu2.age}\u0026lt;br\u0026gt; \u0026lt;h2\u0026gt;遍历map\u0026lt;/h2\u0026gt; \u0026lt;#-- \u0026#39;?keys\u0026#39;代表获取到集合中的每一个key --\u0026gt; \u0026lt;#list studentMap?keys as key\u0026gt; 序号:${key_index+1} \u0026lt;#-- 注意这里不能使用`studentMap.key`的方式，否则它会认为studentMap中存在key这个对象 --\u0026gt; 姓名:${studentMap[key].name} 年龄:${studentMap[key].age}\u0026lt;br\u0026gt; \u0026lt;/#list\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Controller public class FreemarkController { @GetMapping(\u0026#34;/map\u0026#34;) public String map(Model model) { Map\u0026lt;String,Student\u0026gt; studentMap = getStudentMap(); model.addAttribute(\u0026#34;studentMap\u0026#34;,studentMap); return \u0026#34;03.map\u0026#34;; } protected Map\u0026lt;String,Student\u0026gt; getStudentMap(){ Map\u0026lt;String,Student\u0026gt; map = new HashMap\u0026lt;String,Student\u0026gt;(); Student student1 = new Student(\u0026#34;张三\u0026#34;,23); Student student2 = new Student(\u0026#34;李四\u0026#34;,24); Student student3 = new Student(\u0026#34;王五\u0026#34;,25); map.put(\u0026#34;stu1\u0026#34;,student1); map.put(\u0026#34;stu2\u0026#34;,student2); map.put(\u0026#34;stu3\u0026#34;,student3); return map; } } if指令\r格式如下\n1 2 3 \u0026lt;#if expression\u0026gt; \u0026lt;#else\u0026gt; \u0026lt;/#if\u0026gt; 案例，我们需要将李四的数据字体显示为红色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;序号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;#list studentList as stu\u0026gt; \u0026lt;#-- 判断条件 --\u0026gt; \u0026lt;#if stu.name=\u0026#39;李四\u0026#39;\u0026gt; \u0026lt;tr style=\u0026#34;color: red\u0026#34;\u0026gt; \u0026lt;td\u0026gt;${stu_index+1}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.age}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;#else \u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${stu_index+1}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.age}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/#if\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/table\u0026gt; 注意，在freemarker中，=与==一样\n运算符\r数学运算符\r加\r+\n减\r-\n乘\r*\n除\r/\n取模(求余)\r%\n比较运算符\r=或者==\n!=\n\u0026gt;或者gt\n\u0026gt;=或者gte\n\u0026lt;或者lt\n\u0026lt;=或者lte\n=和!=可以用于字符串、数值和日期来比较是否相等\n=和!=两边必须是相同类型的值,否则会产生错误\n字符串\u0026quot;x\u0026quot;、 \u0026ldquo;x\u0026rdquo;、\u0026ldquo;X\u0026quot;比较是不等的.因为FreeMarker是精确比较\ngt代替\u0026gt;, FreeMarker会把\u0026gt;解释成FTL标签的结束字符,可使用括号避免这种情况,如:\u0026lt;#if (x\u0026gt;y)\u0026gt;\n逻辑运算符\r与 \u0026amp;\u0026amp;\n或 ||\n非 !\n比如\n1 2 3 4 5 \u0026lt;#if (10\u0026gt;20) \u0026amp;\u0026amp; (10\u0026gt;0)\u0026gt; true \u0026lt;#else\u0026gt; false \u0026lt;/#if\u0026gt; 空值处理\r判断某变量是否存在使用??,如果该变量存在，则返回true，否则false\n1 2 3 4 \u0026lt;#if studentList??\u0026gt; \u0026lt;#list studentList as stu\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/#if\u0026gt; 设置缺失变量的默认值使用!\n1 2 3 4 ${name!\u0026#39;\u0026#39;} // 如果是嵌套对象，建议使用()包裹起来 ${(student.name)!\u0026#39;\u0026#39;} 内建函数\r内建函数语法格式:变量 + ? + 函数名称\n之前使用的?keys就是内建函数\n1 2 3 4 5 6 7 \u0026lt;#-- \u0026#39;?keys\u0026#39;代表获取到集合中的每一个key --\u0026gt; \u0026lt;#list studentMap?keys as key\u0026gt; 序号:${key_index+1} \u0026lt;#-- 注意这里不能使用`studentMap.key`的方式，否则它会认为studentMap中存在key这个对象 --\u0026gt; 姓名:${studentMap[key].name} 年龄:${studentMap[key].age}\u0026lt;br\u0026gt; \u0026lt;/#list\u0026gt; 集合大小Size\r1 集合大小：${studentList?size} 日期格式化\r1 2 3 4 显示年月日:${student.birthday?date} 显示时分秒:${student.birthday?time} 显示日期、时间:${student.birthday?datetime} 自定义格式化:${student.birthday?string(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)} 内建函数c\r1 model.addAttribute(\u0026#34;point\u0026#34;,123456789); point是数字型，使用${point}会显示这个数字的值,每三位使用逗号分隔。比如point:123,456,789\n如果不想显示为每三位分隔的数字，可以使用c函数将数字型转成字符串输出\n1 ${point?c} JSON字符串转对象 eval\rassign的作用是定义一个变量,?eval就是将当前字符串转成对象的内建函数\n1 2 3 4 5 \u0026lt;#assign say=\u0026#34;{\u0026#39;username\u0026#39;:\u0026#39;admin\u0026#39;,\u0026#39;password\u0026#39;:\u0026#39;123456\u0026#39;}\u0026#34;/\u0026gt; \u0026lt;#assign user=say?eval/\u0026gt; \u0026lt;div\u0026gt;${user.username}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;${user.password}\u0026lt;/div\u0026gt; 输出静态文件\r使用ftl模板以及数据模型，在freemarker整合就即可输出静态文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @SpringBootTest class FreemarkTestApplicationTests { @Autowired private Configuration configuration; @Test void contextLoads() throws Exception { Template template = configuration.getTemplate(\u0026#34;01.basic.ftl\u0026#34;); // 第一个参数是数据模型 // 第二个参数是输出流 template.process(getStudent(),new FileWriter(\u0026#34;C:\\\\Users\\\\93879\\\\Desktop\\\\map.html\u0026#34;)); } protected Map\u0026lt;String,Student\u0026gt; getStudent(){ Map\u0026lt;String, Student\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Student student = new Student(\u0026#34;张三\u0026#34;, 23, new Date(), 4000.0f); map.put(\u0026#34;student\u0026#34;,student); return map; } } 为什么Configuration可以直接被注入呢？\n找到FreeMarkerAutoConfiguration配置类\n源码中相关部分如下\n1 2 3 4 5 6 7 8 9 @Configuration( proxyBeanMethods = false ) @ConditionalOnClass({freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class}) @EnableConfigurationProperties({FreeMarkerProperties.class}) @Import({FreeMarkerServletWebConfiguration.class, FreeMarkerReactiveWebConfiguration.class, FreeMarkerNonWebConfiguration.class}) public class FreeMarkerAutoConfiguration { // 省略 } 重点在于@Import导入了FreeMarkerReactiveWebConfiguration配置，继续点进去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Configuration( proxyBeanMethods = false ) @ConditionalOnWebApplication( type = Type.REACTIVE ) @AutoConfigureAfter({WebFluxAutoConfiguration.class}) class FreeMarkerReactiveWebConfiguration extends AbstractFreeMarkerConfiguration { @Bean freemarker.template.Configuration freeMarkerConfiguration(FreeMarkerConfig configurer) { return configurer.getConfiguration(); } // 其余代码省略 } 这里声明了一个Configuration的Bean，所以后面可以直接注入\n","date":"2024-07-26T00:00:00Z","image":"http://localhost:1313/p/freemarker/202412212120187_hu15376131488378653658.png","permalink":"http://localhost:1313/p/freemarker/","title":"Freemarker"},{"content":"NestJs\r前置知识\rIOC控制反转和DI依赖注入\r以下A、B、C三个类之间的关系是强耦合的，当A类发生改变后，B类和C类也需要发生改变\n创建以下IOC.ts文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class A { name: string constructor(name: string) { this.name = name } } class B { a: any constructor() { this.a = new A(\u0026#39;\u0026#39;).name } } class C { a: any constructor() { this.a = new A(\u0026#39;\u0026#39;).name } } 这并不是我们所希望的，所以我们将使用控制反转的方式解决这个问题\n使用ts-node IOC.ts来运行代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class A { name: string constructor(name: string) { this.name = name } } class Container { module: any constructor() { this.module = {} } provide(key: string, value: any) { this.module[key] = value } get(key: string) { return this.module[key] } } const container = new Container() container.provide(\u0026#39;a\u0026#39;, new A(\u0026#39;唱\u0026#39;)) container.provide(\u0026#39;c\u0026#39;, new A(\u0026#39;跳\u0026#39;)) class B { a: any c: any constructor() { this.a = container.get(\u0026#39;a\u0026#39;) this.c = container.get(\u0026#39;c\u0026#39;) } } console.log(container.get(\u0026#39;a\u0026#39;)) console.log(container.get(\u0026#39;c\u0026#39;)) console.log(new B()) 类似于发布订阅（在发布者里存入需要推送的订阅者信息），实际上就是借助第三方作为容器来存入信息以消除强耦合\n装饰器\r类装饰器\r使用tsc \u0026ndash;init来生成tsconfig.json文件,并将如下代码解开注释,我们需要开放这段代码\n1 \u0026#34;experimentalDecorators\u0026#34;: true 再新建index.ts文件\n1 2 3 4 5 6 7 8 const doc: ClassDecorator = (param: any) =\u0026gt; { console.log(param) } @doc class MyDoc { constructor() {} } 这段代码的本质其实是将MyDoc的构造函数传入doc,即param\n我们可以通过这种方法给MyDoc来添加属性\n1 2 3 4 5 6 7 8 9 10 11 const doc: ClassDecorator = (param: any) =\u0026gt; { param.prototype.name = \u0026#39;doc\u0026#39; } @doc class MyDoc { constructor() {} } const myDoc: any = new MyDoc() console.log(myDoc.name) 1 ts-node .\\index.ts 属性装饰器\r1 2 3 4 5 6 7 8 9 10 11 const doc: PropertyDecorator = (param: any, key: string | symbol) =\u0026gt; { console.log(param, key) } class MyDoc { @doc public name: string constructor() { this.name = \u0026#39;张三\u0026#39; } } 打印如下内容\n1 {} name 方法装饰器\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const doc: MethodDecorator = ( param: any, key: string | symbol, descriptor: any ) =\u0026gt; { console.log(param, key, descriptor) } class MyDoc { private name: string constructor() { this.name = \u0026#39;张三\u0026#39; } @doc getName() { return this.name } } descriptor是一个描述符,这里暂写为any类型,打印内容如下\n1 2 3 4 5 6 {} getName { value: [Function: getName], writable: true, enumerable: false, configurable: true } 参数装饰器\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const doc: ParameterDecorator = ( param: any, key: string | symbol | undefined, index: number ) =\u0026gt; { console.log(param, key, index) } class MyDoc { private name: string constructor() { this.name = \u0026#39;张三\u0026#39; } getName(name: string, @doc age: number) {} } 参数分别代表构造函数、方法名、参数索引(从0开始),打印如下\n1 {} getName 1 装饰器使用案例\r使用axios、装饰器实现请求发送\n1 npm install axios -S 1 2 3 4 5 6 7 8 9 10 11 import axios from \u0026#39;axios\u0026#39; const Get = () =\u0026gt; {} class SendReq{ constructor(){} @Get(\u0026#39;http://xxx.com/xxx/list\u0026#39;) getList(){ } } 我们希望@Get('http://xxx.com/xxx/list')这样传入url来发起请求，但是装饰器默认会传入原型对象，所以不支持自定义参数\n所以这时候需要使用到装饰器工厂，查看资料\n如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。\n我们可以通过下面的方式来写一个装饰器工厂函数：\n1 2 3 4 5 function color(value: string) { // 这是一个装饰器工厂 return function (target) { // 这是装饰器 // do something with \u0026#34;target\u0026#34; and \u0026#34;value\u0026#34;... } } 注意 下面方法装饰器里有一个更加详细的例子。\n下面是一个方法装饰器（@enumerable）的例子，应用于Greeter类的方法上\n1 2 3 4 5 6 7 8 9 10 11 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } @enumerable(false) greet() { return \u0026#34;Hello, \u0026#34; + this.greeting; } } 我们可以用下面的函数声明来定义@enumerable装饰器：\n1 2 3 4 5 function enumerable(value: boolean) { return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { descriptor.enumerable = value; }; } 这里的@enumerable(false)是一个装饰器工厂。 当装饰器 @enumerable(false)被调用时，它会修改属性描述符的enumerable属性。\n回到我们的主题，继续编写代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import axios from \u0026#39;axios\u0026#39; const Get = (url: string) =\u0026gt; { return ( target: Object, key: string | symbol, descriptor: PropertyDescriptor ) =\u0026gt; { const fnc = descriptor.value axios .get(url) .then((res) =\u0026gt; { fnc(res, { status: 200, success: true, }) }) .catch((e) =\u0026gt; { fnc(e, { status: 500, success: false, }) }) } } class SendReq { constructor() {} @Get(\u0026#39;https://haokan.baidu.com/haokan/ui-web/subactauthor?num=5\u0026#39;) getList(res: any, status: any) { console.log(res.data, status) } } Get这里就是用到了装饰器工厂，return出去的就是真正的装饰器逻辑\n当装饰器应用于 getList 方法时，TypeScript 会执行如下操作：\n调用 Get 函数：首先，Get 函数被调用，传入装饰器使用的参数（在这里是 'https://haokan.baidu.com/haokan/ui-web/subactauthor?num=5'）。 返回装饰器逻辑：Get 函数返回一个接收 target、key、descriptor 参数的匿名函数，这是装饰器的具体实现逻辑。 执行装饰器逻辑：TypeScript 编译器自动调用这个返回的函数，实际上执行了装饰器内部的逻辑，包括设置axios的GET请求等。 这里的fnc或者说descriptor.value指的是getList方法，当axios发起请求后，就会执行getList的代码，且接收到的参数就是then里传入的参数\nPost方法同理，这里不再演示\nNestJs学习\r配置\r安装\n1 npm install -g @nestjs/cli 创建项目\n1 nest new nest-demo 目录结构\rmain.ts 入口文件 app.module.ts 根模块用于处理其他类的引用与共享 app.controller.ts 常见功能是用来处理http请求以及调用service层的处理方法 app.service.ts 封装通用的业务逻辑、与数据层的交互(例如数据库)、 其他额外的一-些三方请求 package.json\n1 \u0026#34;start:dev\u0026#34;: \u0026#34;nest start --watch\u0026#34; 代表代码修改后自动重启，运行npm run start:dev即可\n常用命令\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 查看帮助文档 nest --help # 生成模块 nest g controller demo # 简写 nest g co demo # 生成module nest g mo demo # 生成service nest g s demo # 生成以上一套 nest g resource demo 版本控制\r比如http://localhost:10020/v1/user/1代表v1版本\nmain.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { NestFactory } from \u0026#39;@nestjs/core\u0026#39;; import { AppModule } from \u0026#39;./app.module\u0026#39;; import { VersioningType } from \u0026#39;@nestjs/common\u0026#39;; async function bootstrap() { const app = await NestFactory.create(AppModule); // 配置跨域 app.enableCors(); app.enableVersioning({ type: VersioningType.URI, }); await app.listen(10020); } bootstrap(); 这样就开启了版本控制，主要代码是app.enableVersioning，里面接收一个VersioningType枚举类型\n类\r开启完之后，再controller使用版本控制\n1 2 3 4 5 6 7 @Controller({ path: \u0026#39;user\u0026#39;, version: \u0026#39;1\u0026#39;, }) export class UserController { // 代码省略 } 在加上version: '1'之后，即可重新请求http://localhost:10020/v1/user/1（注意这里请求路径会自动添加一个v，即1 -\u0026gt; v1）\n方法\r上面是在整个类上添加版本控制，其实也可以在单个方法上实现版本控制\n1 2 3 4 5 6 7 8 9 10 @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor(private readonly userService: UserService) {} @Get(\u0026#39;:id\u0026#39;) @Version(\u0026#39;1\u0026#39;) findOne(@Param(\u0026#39;id\u0026#39;) id: string) { return this.userService.findOne(+id); } } 请求\rGet\r问号传参\r传入query参数 /user?name=张三\n@Request()可以简写为@Req()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor(private readonly userService: UserService) {} @Get() findOne(@Request() req) { console.log(req.query); return { code: 200, data: req.query.name, }; } } 使用@Query()简写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor(private readonly userService: UserService) {} @Get() findOne(@Query() req) { console.log(req); return { code: 200, data: req.name, }; } } 路径传参\r/user/{id}\n1 2 3 4 5 6 7 8 9 @Get(\u0026#39;:id\u0026#39;) findOne(@Req() id) { console.log(id.params); return { code: 200, data: id.params, }; } 返回的响应如下\n1 2 3 4 5 6 { \u0026#34;code\u0026#34;: 200, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;123\u0026#34; } } 可简写成@Param()或者@Param('id') (注意这里没有s)\nPost\r请求传入Body的参数如下\n1 2 3 4 { \u0026#34;id\u0026#34;:1, \u0026#34;name\u0026#34;:\u0026#34;张三\u0026#34; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor(private readonly userService: UserService) {} @Post() findOne(@Request() req) { console.log(req.body); return { code: 200, data: req.body, }; } } 使用@Body()简写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor(private readonly userService: UserService) {} @Post() findOne(@Body() req) { console.log(req); return { code: 200, data: req, }; } } 也可以只读取name属性\n@Body('name')\nHeaders\r1 2 3 4 5 6 7 8 9 10 @Get() findOne(@Query(\u0026#39;name\u0026#39;) name, @Headers(\u0026#39;token\u0026#39;) token) { console.log(token); return { code: 200, data: name, token: token, }; } HttpCode\r1 2 3 4 5 6 7 8 9 10 11 @Get() @HttpCode(500) findOne(@Query(\u0026#39;name\u0026#39;) name, @Headers(\u0026#39;token\u0026#39;) token) { console.log(token); return { code: 200, data: name, token: token, }; } Session\r安装依赖\n1 2 3 4 npm i express-session --save # 代码提示 npm i @types/express-session -D 在main.ts中引入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import { NestFactory } from \u0026#39;@nestjs/core\u0026#39;; import { AppModule } from \u0026#39;./app.module\u0026#39;; import { VersioningType } from \u0026#39;@nestjs/common\u0026#39;; // 引入 import * as session from \u0026#39;express-session\u0026#39;; async function bootstrap() { const app = await NestFactory.create(AppModule); // 配置跨域 app.enableCors(); app.enableVersioning({ type: VersioningType.URI, }); // 使用 app.use( session({ // 签名 secret: \u0026#39;Tong\u0026#39;, // 在每次请求时强行设置cookie,这将重置cookie过期时间(默认:false) resave: true, // 生成客户端cookie的名字,默认connect.sid name: \u0026#39;tong.sid\u0026#39;, cookie: { // 过期时间,毫秒级,7天 maxAge: 1000 * 60 * 60 * 24 * 7, }, }), ); await app.listen(10020); } bootstrap(); 案例实现\r验证码\nnest项目安装验证码对应依赖\n1 npm i svg-captcha -S 编写nest代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import { Controller, Get, Post, Body, Req, Res, Session, } from \u0026#39;@nestjs/common\u0026#39;; import { UserService } from \u0026#39;./user.service\u0026#39;; // 引入 import * as svgCaptcha from \u0026#39;svg-captcha\u0026#39;; @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor(private readonly userService: UserService) {} @Get(\u0026#39;code/create\u0026#39;) createCode(@Req() req, @Res() res, @Session() session) { const captcha = svgCaptcha.create({ // 生成验证码位数 size: 4, // 文字大小 fontSize: 50, // 宽度 width: 100, // 高度 height: 34, // 背景颜色 background: \u0026#39;#cc9966\u0026#39;, }); // 将生成的验证码存入session console.log(captcha.text); session.code = captcha.text; res.type(\u0026#39;image/svg+xml\u0026#39;); res.send(captcha.data); } // 校验验证码 @Post(\u0026#39;code/check\u0026#39;) checkCode(@Body() body, @Session() session) { // 检验用户名、密码，判断用户是否存在 // 此时没有使用到数据库，所以暂时省略该步骤 if (body.code === session.code) { return { code: 200, msg: \u0026#39;验证码正确\u0026#39;, }; } else { return { code: 400, msg: \u0026#39;验证码错误\u0026#39;, }; } } } 我这里后端端口是10020，请求http://localhost:10020/user/code/create即可获得验证码图片\n前端vue项目配置vite.config.ts文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import { fileURLToPath, URL } from \u0026#39;node:url\u0026#39; import { defineConfig, loadEnv } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import vueJsx from \u0026#39;@vitejs/plugin-vue-jsx\u0026#39; import vueDevTools from \u0026#39;vite-plugin-vue-devtools\u0026#39; export default defineConfig(({ command, mode }) =\u0026gt; { //获取各种环境下的对应的变量 const env = loadEnv(mode, process.cwd()) return { plugins: [vue(), vueJsx(), vueDevTools()], server: { port: 10010, // 设置代理，根据我们项目实际情况配置 proxy: { [env.VITE_APP_BASE_API]: { //apiTest是自行设置的请求前缀，按照这个来匹配请求，有这个字段的请求，就会进到代理来 // 需要代理的域名 target: env.VITE_URL, // 是否跨域 changeOrigin: true, //重写匹配的字段，如果不需要放在请求路径上，可以重写为\u0026#34;\u0026#34; rewrite: (path) =\u0026gt; path.replace(\u0026#39;/api\u0026#39;, \u0026#39;\u0026#39;) } } }, resolve: { alias: { \u0026#39;@\u0026#39;: fileURLToPath(new URL(\u0026#39;./src\u0026#39;, import.meta.url)) } } } }) .env.local文件如果不存在，则在根目录下新建\n1 2 3 VITE_APP_BASE_API=/api VITE_PORT=10020 VITE_URL=http://localhost:$VITE_PORT 前端表单页面实现验证码功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;template\u0026gt; \u0026lt;el-form label-width=\u0026#34;auto\u0026#34; :model=\u0026#34;loginForm\u0026#34; style=\u0026#34;max-width: 600px\u0026#34; \u0026gt; \u0026lt;el-form-item label=\u0026#34;账号\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;loginForm.username\u0026#34; style=\u0026#34;width: 300px;\u0026#34;/\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;密码\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;loginForm.password\u0026#34; style=\u0026#34;width: 300px;\u0026#34;/\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;验证码\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;loginForm.code\u0026#34; style=\u0026#34;width: 100px;\u0026#34; /\u0026gt; \u0026lt;img :src=\u0026#34;codeUrl\u0026#34; @click=\u0026#34;getCode\u0026#34; style=\u0026#34;margin-left: 30px;\u0026#34;\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button @click=\u0026#34;submit\u0026#34;\u0026gt;登录\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; import { ElMessage } from \u0026#39;element-plus\u0026#39; import { reactive, ref } from \u0026#39;vue\u0026#39; // 后端url const url=import.meta.env.VITE_APP_BASE_API const codeUrl=ref\u0026lt;string\u0026gt;(url+\u0026#39;/user/code/create\u0026#39;); const loginForm = reactive({ username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39;, code: \u0026#39;\u0026#39;, }) // 重新请求验证码 const getCode=()=\u0026gt;codeUrl.value=codeUrl.value+\u0026#39;?\u0026#39;+Math.random(); const submit=()=\u0026gt;{ fetch(url+\u0026#39;/user/code/check\u0026#39;,{ method:\u0026#39;POST\u0026#39;, body:JSON.stringify(loginForm), headers:{ \u0026#39;Content-Type\u0026#39;:\u0026#39;application/json\u0026#39; } }).then(res=\u0026gt;res.json()).then((res)=\u0026gt;{ if(res.code===200){ // 验证码正确 ElMessage.success(res.msg) }else{ // 验证码错误 ElMessage.error(res.msg) // 重新请求验证码 getCode() } }) } \u0026lt;/script\u0026gt; 提供者\r基本使用\r使用@Injectable()修饰类\n1 2 3 @Injectable() export class UserService { } 通过Module模块注入到providers\n1 2 3 4 5 @Module({ controllers: [UserController], providers: [UserService], }) export class UserModule {} 然后就可以在controller里使用这个UserService服务了\n1 2 3 4 @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor(private readonly userService: UserService) {} } 自定义名称\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { UserService } from \u0026#39;./user.service\u0026#39;; import { UserController } from \u0026#39;./user.controller\u0026#39;; @Module({ controllers: [UserController], providers: [ { // 自定义名称 provide: \u0026#39;userService1\u0026#39;, useClass: UserService, }, ], }) export class UserModule {} 在controller中通过@Inject('userService1')来识别\n1 2 3 4 5 6 @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor( @Inject(\u0026#39;userService1\u0026#39;) private readonly userService: UserService, ) {} } 自定义注入值\r使用方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { UserService } from \u0026#39;./user.service\u0026#39;; import { UserController } from \u0026#39;./user.controller\u0026#39;; @Module({ controllers: [UserController], providers: [ { // 自定义名称 provide: \u0026#39;userService1\u0026#39;, useClass: UserService, }, { // 自定义值 provide: \u0026#39;shopService\u0026#39;, useValue: [\u0026#39;PDD\u0026#39;, \u0026#39;JD\u0026#39;, \u0026#39;TaoBao\u0026#39;], }, ], }) export class UserModule {} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor( @Inject(\u0026#39;userService1\u0026#39;) private readonly userService: UserService, // 注入 @Inject(\u0026#39;shopService\u0026#39;) private readonly shopService: string[], ) {} @Get() showShopList() { // 使用 return this.shopService; } } 工厂模式\r简单使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { UserService } from \u0026#39;./user.service\u0026#39;; import { UserController } from \u0026#39;./user.controller\u0026#39;; @Module({ controllers: [UserController], providers: [ { // 自定义名称 provide: \u0026#39;userService1\u0026#39;, useClass: UserService, }, { // 自定义值 provide: \u0026#39;shopService\u0026#39;, useValue: [\u0026#39;PDD\u0026#39;, \u0026#39;JD\u0026#39;, \u0026#39;TaoBao\u0026#39;], }, { // 工厂模式 provide: \u0026#39;testService1\u0026#39;, useFactory() { // 在这里可以写一些业务逻辑 let flag = true; if (flag) { return \u0026#39;yes\u0026#39;; } else { return \u0026#39;no\u0026#39;; } }, }, ], }) export class UserModule {} 1 2 3 4 5 6 7 8 9 10 11 @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor( @Inject(\u0026#39;testService1\u0026#39;) private readonly testService1: string[], ) {} @Get() showShopList() { return this.testService1; } } 如果这个工厂仅仅编写一些逻辑已经不太够了，它依赖于其他service，参考如下写法\n新建一个service，user.service2.ts\n1 2 3 4 5 6 7 8 import { Injectable } from \u0026#39;@nestjs/common\u0026#39;; @Injectable() export class UserService2 { sayHello(): string { return \u0026#39;Hello\u0026#39;; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { UserService } from \u0026#39;./user.service\u0026#39;; import { UserController } from \u0026#39;./user.controller\u0026#39;; import { UserService2 } from \u0026#39;./user.service2\u0026#39;; @Module({ controllers: [UserController], providers: [ UserService2, { // 工厂模式 provide: \u0026#39;testService1\u0026#39;, // 注入 inject: [UserService2], // 接收到的参数 useFactory(userService2: UserService2) { // 调用其他service let str = userService2.sayHello(); return str + \u0026#39;,tong\u0026#39;; }, }, ], }) export class UserModule {} 1 2 3 4 5 6 7 8 9 10 11 @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor( @Inject(\u0026#39;testService1\u0026#39;) private readonly testService1: string[], ) {} @Get() showShopList() { return this.testService1; } } 异步\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { UserService } from \u0026#39;./user.service\u0026#39;; import { UserController } from \u0026#39;./user.controller\u0026#39;; import { UserService2 } from \u0026#39;./user.service2\u0026#39;; @Module({ controllers: [UserController], providers: [ UserService2, { // 工厂模式 provide: \u0026#39;testService1\u0026#39;, inject: [UserService2], async useFactory(userService2: UserService2) { return await new Promise((r) =\u0026gt; { setTimeout(() =\u0026gt; { r(userService2.sayHello()); }, 3000); }); }, }, ], }) export class UserModule {} 模块\r基本用法\r创建两个模块\n1 2 3 4 5 # 创建list模块 nest g res list # 创建user模块 nest g res user 此时在app.module.ts下已经将这两个模块自动引入了\n1 2 3 4 5 6 @Module({ imports: [UserModule, ListModule], controllers: [AppController], providers: [AppService], }) export class AppModule {} 如果我希望在AppController下使用UserService模块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { UserService } from \u0026#39;./user/user.service\u0026#39;; @Controller() export class AppController { constructor( private readonly appService: AppService, private readonly userService: UserService, ) {} @Get() getHello(): string { return this.userService.test(); } } 还没完，不然会报错找不到UserService，因为它现在并不是一个共享模块，它现在只能在自己的User模块里使用，所以还需进行配置\n1 2 3 4 5 6 7 @Module({ controllers: [UserController], providers: [UserService], // 导出模块，设置为共享模块 exports: [UserService], }) export class UserModule {} 全局模块\r将模块注册到全局，下发到下面的子模块使用\nsrc下新建config/config.module.ts，并使用@Global装饰器将模块标记为全局模块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { Global, Module } from \u0026#39;@nestjs/common\u0026#39;; // 使用@Global装饰器将模块标记为全局模块 @Global() @Module({ // 注入 providers: [ { provide: \u0026#39;configModule\u0026#39;, useValue: { baseUrl: \u0026#39;/api\u0026#39;, }, }, ], // 导出 exports: [ { provide: \u0026#39;configModule\u0026#39;, useValue: { baseUrl: \u0026#39;/api\u0026#39;, }, }, ], }) export class ConfigModule {} 然后在app.module.ts注册该模块\n1 2 3 4 5 6 7 8 9 // 引入 import { ConfigModule } from \u0026#39;./config/config.module\u0026#39;; @Module({ imports: [UserModule, ListModule, ConfigModule], controllers: [AppController], providers: [AppService], }) export class AppModule {} 在controller里使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Controller() export class AppController { constructor( private readonly appService: AppService, private readonly userService: UserService, @Inject(\u0026#39;configModule\u0026#39;) private readonly configModule: ConfigModule, ) {} @Get() getHello(): ConfigModule { return this.configModule; } } 动态模块\r比如说我希望给ConfigModule模块传入参数，但现在是不支持的，代码如下\n1 2 3 4 5 6 7 @Module({ // 不支持传参 imports: [UserModule, ListModule, ConfigModule], controllers: [AppController], providers: [AppService], }) export class AppModule {} 可以使用静态方法来实现\n动态模块可以配合@Module结合来学习，这里就直接把Module装饰器里的代码copy到return里了\nreturn要求需要有一个module属性，名字与class保持一致即可，所以是module: ConfigModule\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import { DynamicModule, Global, Module } from \u0026#39;@nestjs/common\u0026#39;; interface Options { path: string; } // 使用@Global装饰器将模块标记为全局模块 @Global() @Module({}) export class ConfigModule { // 定义形参 static initModule(options: Options): DynamicModule { return { module: ConfigModule, providers: [ { provide: \u0026#39;configModule\u0026#39;, useValue: { // 使用参数 baseUrl: `/api${options.path}`, }, }, ], exports: [ { provide: \u0026#39;configModule\u0026#39;, useValue: { // 使用参数 baseUrl: `/api${options.path}`, }, }, ], }; } } 在AppModule里传入参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Module({ imports: [ UserModule, ListModule, // 传参 ConfigModule.initModule({ path: \u0026#39;/tong\u0026#39;, }), ], controllers: [AppController], providers: [AppService], }) export class AppModule {} 中间件\r基本使用\r中间件是在路由处理程序之前调用的函数。中间件函数可以访问请求和响应对象\n感觉有些像是vue里的路由守卫\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 查看文档 nest --help ┌───────────────┬─────────────┬──────────────────────────────────────────────┐ │ name │ alias │ description │ │ application │ application │ Generate a new application workspace │ │ class │ cl │ Generate a new class │ │ configuration │ config │ Generate a CLI configuration file │ │ controller │ co │ Generate a controller declaration │ │ decorator │ d │ Generate a custom decorator │ │ filter │ f │ Generate a filter declaration │ │ gateway │ ga │ Generate a gateway declaration │ │ guard │ gu │ Generate a guard declaration │ │ interceptor │ itc │ Generate an interceptor declaration │ │ interface │ itf │ Generate an interface │ │ library │ lib │ Generate a new library within a monorepo │ │ middleware │ mi │ Generate a middleware declaration │ │ module │ mo │ Generate a module declaration │ │ pipe │ pi │ Generate a pipe declaration │ │ provider │ pr │ Generate a provider declaration │ │ resolver │ r │ Generate a GraphQL resolver declaration │ │ resource │ res │ Generate a new CRUD resource │ │ service │ s │ Generate a service declaration │ │ sub-app │ app │ Generate a new application within a monorepo │ └───────────────┴─────────────┴──────────────────────────────────────────────┘ # 选择中间件，middleware，生成 nest g mi logger 但是我们接下来不使用命令创建模板\nsrc下新建middleware/index.ts\n1 2 3 4 5 6 7 8 9 10 11 import { Injectable, NestMiddleware } from \u0026#39;@nestjs/common\u0026#39;; import { log } from \u0026#39;console\u0026#39;; import { NextFunction, Request, Response } from \u0026#39;express\u0026#39;; @Injectable() export class Logger implements NestMiddleware { use(req: Request, res: Response, next: NextFunction) { log(\u0026#39;hello\u0026#39;); next(); } } app.module.ts\n实现了NestModule接口中的configure方法，并且指定了Logger生效的路由是/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { MiddlewareConsumer, Module, NestModule } from \u0026#39;@nestjs/common\u0026#39;; import { AppController } from \u0026#39;./app.controller\u0026#39;; import { AppService } from \u0026#39;./app.service\u0026#39;; import { UserModule } from \u0026#39;./user/user.module\u0026#39;; import { ListModule } from \u0026#39;./list/list.module\u0026#39;; import { ConfigModule } from \u0026#39;./config/config.module\u0026#39;; import { Logger } from \u0026#39;./middleware\u0026#39;; @Module({ imports: [ UserModule, ListModule, // 传参 ConfigModule.initModule({ path: \u0026#39;/tong\u0026#39;, }), ], controllers: [AppController], providers: [AppService], }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer.apply(Logger).forRoutes(\u0026#39;/\u0026#39;); } } 将middleware/index.ts的next注释掉之后就会挂起\n也可以直接通过response来拦截\n可以通过这种特性实现白名单的效果\n1 2 3 4 5 6 7 8 @Injectable() export class Logger implements NestMiddleware { use(req: Request, res: Response, next: NextFunction) { log(\u0026#39;hello\u0026#39;); res.send(\u0026#39;已被拦截\u0026#39;); // next(); } } 指定路由除了使用字符串的形式之外，还有其他两种形式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import {RequestMethod} from \u0026#39;@nestjs/common\u0026#39;; @Module({ imports: [ UserModule, ListModule, // 传参 ConfigModule.initModule({ path: \u0026#39;/tong\u0026#39;, }), ], controllers: [AppController], providers: [AppService], }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(Logger) .forRoutes({ path: \u0026#39;list\u0026#39;, method: RequestMethod.GET }); } } 或者直接写控制器即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Module({ imports: [ UserModule, ListModule, // 传参 ConfigModule.initModule({ path: \u0026#39;/tong\u0026#39;, }), ], controllers: [AppController], providers: [AppService], }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer.apply(Logger).forRoutes(UserController); } } 全局中间件\r全局中间件需要在main.ts里注册，而且必须是函数，不能是类\nmain.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function globalMiddleware(req: Request, res: Response, next: NextFunction) { log(req.originalUrl); // 实现白名单 const whiteList = [\u0026#39;/user\u0026#39;]; if (whiteList.includes(req.originalUrl)) { next(); } else { res.send(\u0026#39;没有权限\u0026#39;); } } async function bootstrap() { const app = await NestFactory.create(AppModule); // 使用 app.use(globalMiddleware); await app.listen(10020); } bootstrap(); 第三方中间件\r安装\n1 2 3 npm install cors npm install @types/cors -D 使用\n1 2 3 4 5 6 7 8 9 import * as cors from \u0026#39;cors\u0026#39;; async function bootstrap() { const app = await NestFactory.create(AppModule); // 使用 app.use(cors()); await app.listen(10020); } bootstrap(); 上传文件\r安装依赖\r1 2 3 4 5 6 npm install multer -S npm install @types/multer -D # 生成一个upload目录 nest g res upload 基本使用\r配置upload.module.ts模块\n下方使用到的多个nodejs里的函数，比如join、extname\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { UploadService } from \u0026#39;./upload.service\u0026#39;; import { UploadController } from \u0026#39;./upload.controller\u0026#39;; import { MulterModule } from \u0026#39;@nestjs/platform-express\u0026#39;; import { diskStorage } from \u0026#39;multer\u0026#39;; import { extname, join } from \u0026#39;path\u0026#39;; @Module({ imports: [ MulterModule.register({ // 配置图片存放路径 storage: diskStorage({ // 配置路径，这里使用join拼接 destination: join(__dirname, \u0026#39;../images\u0026#39;), // request暂时用不到，就使用_表示不获取 filename: (_, file, callback) =\u0026gt; { // 拼接时间戳，使用extname函数截取后缀 const filename = `${new Date().getTime()}` + extname(file.originalname); return callback(null, filename); }, }), }), ], controllers: [UploadController], providers: [UploadService], }) export class UploadModule {} 上传文件，编写upload.controller.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { Controller, Post, UseInterceptors, UploadedFile, } from \u0026#39;@nestjs/common\u0026#39;; import { UploadService } from \u0026#39;./upload.service\u0026#39;; import { FileInterceptor, FilesInterceptor } from \u0026#39;@nestjs/platform-express\u0026#39;; import { log } from \u0026#39;console\u0026#39;; @Controller(\u0026#39;upload\u0026#39;) export class UploadController { constructor(private readonly uploadService: UploadService) {} @Post(\u0026#39;image\u0026#39;) // 方法装饰器处理文件 // 上传单个文件是FileInterceptor，多个是FilesInterceptor // 字段名称是file @UseInterceptors(FileInterceptor(\u0026#39;file\u0026#39;)) // 使用参数装饰器读取文件 upload(@UploadedFile() file) { log(\u0026#39;file:\u0026#39;, file); return { code: 200, }; } } 在使用apifox或者postman发送请求后，dist/images下就已经存在了该文件\n访问文件\n现在是无法访问到这张图片的，因为它是一个静态资源，所以还需要配置一个静态资源的访问目录\n编写main.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { NestFactory } from \u0026#39;@nestjs/core\u0026#39;; import { AppModule } from \u0026#39;./app.module\u0026#39;; import { VersioningType } from \u0026#39;@nestjs/common\u0026#39;; import { NestExpressApplication } from \u0026#39;@nestjs/platform-express\u0026#39;; import { join } from \u0026#39;path\u0026#39;; async function bootstrap() { // 导入NestExpressApplication类型支持,否则没有对应的代码提示 const app = await NestFactory.create\u0026lt;NestExpressApplication\u0026gt;(AppModule); // 配置静态资源访问目录 app.useStaticAssets(join(__dirname, \u0026#39;images\u0026#39;)); await app.listen(10020); } bootstrap(); 访问http://localhost:10020/1720962299048.png即可访问到该图片\n但如果我们希望在前面加一个自定义路径\n1 2 3 4 5 6 7 8 9 10 11 async function bootstrap() { // 导入NestExpressApplication类型支持,否则没有对应的代码提示 const app = await NestFactory.create\u0026lt;NestExpressApplication\u0026gt;(AppModule); // 配置静态资源访问目录 app.useStaticAssets(join(__dirname, \u0026#39;images\u0026#39;), { // 配置前缀 prefix: \u0026#39;/files\u0026#39;, }); await app.listen(10020); } bootstrap(); 访问http://localhost:10020/files/1720962299048.png即可\n下载文件\rdownload写法 文件流 先演示download写法\n1 2 3 4 5 6 7 8 9 10 11 @Controller(\u0026#39;upload\u0026#39;) export class UploadController { constructor(private readonly uploadService: UploadService) {} @Get(\u0026#39;export\u0026#39;) download(@Res() res) { // 暂时写死地址，正常应该存储在数据库中 const url = join(__dirname, \u0026#39;../images/1720962299048.png\u0026#39;); res.download(url); } } 前端代码\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;el-button @click=\u0026#39;download\u0026#39;\u0026gt;下载\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; const download=()=\u0026gt;{ window.open(\u0026#39;http://localhost:10020/upload/export\u0026#39;) } \u0026lt;/script\u0026gt; 再看一下流的方式\n1 2 # 安装依赖 npm install compressing -S 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { zip } from \u0026#39;compressing\u0026#39;; import { Response } from \u0026#39;express\u0026#39;; @Controller(\u0026#39;upload\u0026#39;) export class UploadController { constructor(private readonly uploadService: UploadService) {} @Get(\u0026#39;stream\u0026#39;) async stream(@Res() res: Response) { const filename = \u0026#39;1720962299048.png\u0026#39;; const url = join(__dirname, \u0026#39;../images\u0026#39;, \u0026#39;/\u0026#39;, filename); const tarStream = new zip.Stream(); // 由于是异步的，所以需要等待处理完成再返回，否则返回的文件流是有问题的 await tarStream.addEntry(url); // 设置流的格式 res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/octet-stream\u0026#39;); // 设置文件名称 res.setHeader(\u0026#39;Content-Disposition\u0026#39;, `attachment; filename=${filename}`); //在此处开放Content-Disposition权限，前端代码才能获取到 res.setHeader(\u0026#39;Access-Control-Expose-Headers\u0026#39;, \u0026#39;Content-Disposition\u0026#39;); tarStream.pipe(res); } } 前端怎么解析流文件\n前端代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;el-button @click=\u0026#39;download\u0026#39;\u0026gt;下载\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; // 如果使用的是axios，那么responseType需要设置为ArrayBuffer或者Blob，而不再是json了 // 下面使用fetch进行演示 const useFetch=async (url:string)=\u0026gt;{ const res=await fetch(url) // 获取请求头里的content-disposition的内容 const header=res.headers.get(\u0026#39;content-disposition\u0026#39;) as string // 获取文件名 const filename=header.split(\u0026#39;filename=\u0026#39;)[1] const arrayBuffer =await res.arrayBuffer() const blob=new Blob([arrayBuffer]) const fileUrl=URL.createObjectURL(blob) // 创建a标签 const a=document.createElement(\u0026#39;a\u0026#39;) a.href=fileUrl // 这是一个zip包,下载 a.download=`${filename}.zip` a.click() } const download=()=\u0026gt;{ useFetch(\u0026#39;http://localhost:10020/upload/stream\u0026#39;) } \u0026lt;/script\u0026gt; RxJs\rRxJs使用的是观察者模式，用来编写异步队列和事件处理。\nObservable 可观察的物件 Subscription 监听Observable Operators 纯函数可以处理管道的数据 如 map filter concat reduce 等\n感觉用法像lambda表达式\n这里新建一个空的demo目录，使用命令初始化\n1 2 3 npm install ts-node -g npm install rxjs 基本使用\r新建index.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { Observable } from \u0026#39;rxjs\u0026#39; // 接收一个回调函数 const observable = new Observable((subscribe) =\u0026gt; { subscribe.next(1) subscribe.next(2) subscribe.next(3) setTimeout(() =\u0026gt; { subscribe.next(4) // 完成 subscribe.complete() }, 2000) }) // 接收一个对象,对象里存在一个next函数 observable.subscribe({ next: (num) =\u0026gt; { console.log(num) }, }) 运行\n1 ts-node index.ts 常用api\r1 2 3 4 5 6 7 8 9 10 import { of, Observable, interval, take } from \u0026#39;rxjs\u0026#39; import { map, filter, findIndex, reduce } from \u0026#39;rxjs/operators\u0026#39; // 将产生一个序列，每500毫秒发射一次值。初始值为0，之后每次发射的值比前一次多1 interval(500) // pipe是管道,到5的时候停止 .pipe(take(5)) .subscribe((e) =\u0026gt; { console.log(e) }) 打印结果如下\n1 2 3 4 5 0 1 2 3 4 map\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { of, Observable, interval, take } from \u0026#39;rxjs\u0026#39; import { map, filter, findIndex, reduce } from \u0026#39;rxjs/operators\u0026#39; interval(500) .pipe( // 封装成一个对象 map((v) =\u0026gt; ({ msg: \u0026#39;这是一个对象\u0026#39;, data: v, })) ) .subscribe((e) =\u0026gt; { console.log(e) }) 现在是无限打印如下内容\n1 2 3 4 5 6 7 8 9 10 11 { msg: \u0026#39;这是一个对象\u0026#39;, data: 0 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 1 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 2 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 3 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 4 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 5 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 6 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 7 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 8 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 9 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 10 } 我们需要做一个停止\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { of, Observable, interval, take } from \u0026#39;rxjs\u0026#39; import { map, filter, findIndex, reduce } from \u0026#39;rxjs/operators\u0026#39; // 用一个变量接收 const subs = interval(500) .pipe( map((v) =\u0026gt; ({ msg: \u0026#39;这是一个对象\u0026#39;, data: v, })) ) .subscribe((e) =\u0026gt; { console.log(e) if (e.data === 5) { subs.unsubscribe() } }) filter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { of, Observable, interval, take } from \u0026#39;rxjs\u0026#39; import { map, filter, findIndex, reduce } from \u0026#39;rxjs/operators\u0026#39; const subs = interval(500) .pipe( map((v) =\u0026gt; ({ msg: \u0026#39;这是一个对象\u0026#39;, data: v, })), // 过滤偶数 filter((v) =\u0026gt; v.data % 2 === 0) ) .subscribe((e) =\u0026gt; { console.log(e) if (e.data \u0026gt;= 5) { subs.unsubscribe() } }) 打印如下\n1 2 3 4 { msg: \u0026#39;这是一个对象\u0026#39;, data: 0 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 2 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 4 } { msg: \u0026#39;这是一个对象\u0026#39;, data: 6 } of\n我们希望使用自定义数据，而不是interval\n1 2 3 4 5 6 7 8 9 10 11 12 const subs = of(1, 2, 3, 4, 5, 6) .pipe( map((v) =\u0026gt; ({ msg: \u0026#39;这是一个对象\u0026#39;, data: v, })), // 过滤偶数 filter((v) =\u0026gt; v.data % 2 !== 0) ) .subscribe((e) =\u0026gt; { console.log(e) }) retry\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { of, Observable, interval, take, retry } from \u0026#39;rxjs\u0026#39; import { map, filter, findIndex, reduce } from \u0026#39;rxjs/operators\u0026#39; // 假设of是一个后台接口 const subs = of(1, 2, 3, 4, 5, 6) .pipe( // 如果后台接口报错了,会进行失败重试3次 retry(3), map((v) =\u0026gt; ({ msg: \u0026#39;这是一个对象\u0026#39;, data: v, })), filter((v) =\u0026gt; v.data % 2 !== 0) ) .subscribe((e) =\u0026gt; { console.log(e) }) 响应拦截器\r自动生成的模块都是自动返回一个字符串，而我们希望返回给前端的是一个json数据。现在需要对响应统一处理\n在src下新建common/response.ts\nresponse.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import { CallHandler, ExecutionContext, Injectable, NestInterceptor, } from \u0026#39;@nestjs/common\u0026#39;; import { Observable, map } from \u0026#39;rxjs\u0026#39;; interface Data\u0026lt;T\u0026gt; { data: T; } @Injectable() export class Response\u0026lt;T\u0026gt; implements NestInterceptor { intercept( context: ExecutionContext, next: CallHandler\u0026lt;any\u0026gt;, ): Observable\u0026lt;Data\u0026lt;T\u0026gt;\u0026gt; { return next.handle().pipe( map((data) =\u0026gt; { return { data, success: true, code: 200, message: \u0026#39;成功\u0026#39;, }; }), ); } } main.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { NestFactory } from \u0026#39;@nestjs/core\u0026#39;; import { AppModule } from \u0026#39;./app.module\u0026#39;; import { VersioningType } from \u0026#39;@nestjs/common\u0026#39;; import { NestExpressApplication } from \u0026#39;@nestjs/platform-express\u0026#39;; import { join } from \u0026#39;path\u0026#39;; import * as cros from \u0026#39;cors\u0026#39;; // 引入 import { Response } from \u0026#39;./common/response\u0026#39;; async function bootstrap() { const app = await NestFactory.create\u0026lt;NestExpressApplication\u0026gt;(AppModule); app.useStaticAssets(join(__dirname, \u0026#39;images\u0026#39;), { prefix: \u0026#39;/files\u0026#39;, }); app.use(cros()); // 注入响应拦截器 app.useGlobalInterceptors(new Response()); await app.listen(10020); } bootstrap(); 异常拦截器\r在src下新建common/filter.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { ArgumentsHost, Catch, ExceptionFilter, HttpException, } from \u0026#39;@nestjs/common\u0026#39;; import { Request, Response } from \u0026#39;express\u0026#39;; @Catch() export class HttpFilter implements ExceptionFilter { catch(exception: HttpException, host: ArgumentsHost) { const ctx = host.switchToHttp(); const request = ctx.getRequest\u0026lt;Request\u0026gt;(); const response = ctx.getResponse\u0026lt;Response\u0026gt;(); const status = exception.getStatus(); response.status(status).json({ success: false, time: new Date(), data: exception.message, status, // 需要知道哪个接口报的错误 path: request.url, }); } } main.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { NestFactory } from \u0026#39;@nestjs/core\u0026#39;; import { AppModule } from \u0026#39;./app.module\u0026#39;; import { VersioningType } from \u0026#39;@nestjs/common\u0026#39;; import { NestExpressApplication } from \u0026#39;@nestjs/platform-express\u0026#39;; import { join } from \u0026#39;path\u0026#39;; import * as cros from \u0026#39;cors\u0026#39;; // 引入 import { HttpFilter } from \u0026#39;./common/filter\u0026#39;; import { Response } from \u0026#39;./common/response\u0026#39;; async function bootstrap() { const app = await NestFactory.create\u0026lt;NestExpressApplication\u0026gt;(AppModule); app.useStaticAssets(join(__dirname, \u0026#39;images\u0026#39;), { prefix: \u0026#39;/files\u0026#39;, }); app.use(cros()); app.useGlobalInterceptors(new Response()); // 注入异常拦截器 app.useGlobalFilters(new HttpFilter()); await app.listen(10020); } bootstrap(); 随便访问一个不存在的url即可查看到404的效果\n管道转换\r管道可以做两件事\n转换，可以将前端传入的数据转成成我们需要的数据 验证类似于前端的rules配置验证规则 类型转换\r1 2 3 4 5 6 7 8 9 10 @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor(private readonly userService: UserService) {} @Get(\u0026#39;:id\u0026#39;) showShopList(@Param(\u0026#39;id\u0026#39;) id: string) { log(typeof id); return this.userService.findAll(); } } 访问http://localhost:10020/user/123，打印的id类型为string，我们希望转成number\n1 2 3 4 5 6 7 8 9 10 11 12 13 import {ParseIntPipe} from \u0026#39;@nestjs/common\u0026#39;; @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor(private readonly userService: UserService) {} @Get(\u0026#39;:id\u0026#39;) // 使用ParseIntPipe转成number showShopList(@Param(\u0026#39;id\u0026#39;, ParseIntPipe) id: string) { log(typeof id); return this.userService.findAll(); } } 常用的还可以转Float、Int、Bool、Array、UUID\n验证\r执行以下命令\n1 2 3 4 5 6 7 8 # 创建login模块 nest g res login # 创建login管道 nest g pi login # 安装校验库 npm install --save class-validator class-transformer login.pipe.ts\n1 2 3 4 5 6 7 8 9 10 import { ArgumentMetadata, Injectable, PipeTransform } from \u0026#39;@nestjs/common\u0026#39;; import { log } from \u0026#39;console\u0026#39;; @Injectable() export class LoginPipe implements PipeTransform { transform(value: any, metadata: ArgumentMetadata) { log(\u0026#39;value:\u0026#39;, value, \u0026#39;metadata:\u0026#39;, metadata); return value; } } login.controller.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 导入管道 import { LoginPipe } from \u0026#39;./login.pipe\u0026#39;; @Controller(\u0026#39;login\u0026#39;) export class LoginController { constructor(private readonly loginService: LoginService) {} @Post() // 使用管道 create(@Body(LoginPipe) createLoginDto: CreateLoginDto) { return this.loginService.create(createLoginDto); } } post请求携带的body参数为\n1 2 3 4 { \u0026#34;name\u0026#34;:\u0026#34;张三\u0026#34;, \u0026#34;age\u0026#34;:23 } 打印的内容如下\n1 value: { name: \u0026#39;张三\u0026#39;, age: 23 } metadata: { metatype: [class CreateLoginDto], type: \u0026#39;body\u0026#39;, data: undefined } 这个data: undefined是啥\n其实就是下面代码的name\n1 create(@Body(\u0026#39;name\u0026#39;,LoginPipe) createLoginDto: CreateLoginDto) 打印内容如下\n1 value: 张三 metadata: { metatype: [class CreateLoginDto], type: \u0026#39;body\u0026#39;, data: \u0026#39;name\u0026#39; } 了解到以上内容以后，开始编写校验代码\n模块中自动生成的dto目录下create-login.dto.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { IsNotEmpty, IsNumber, Length } from \u0026#39;class-validator\u0026#39;; export class CreateLoginDto { @IsNotEmpty({ message: \u0026#39;名字不能为空\u0026#39;, }) @Length(5, 10, { message: \u0026#39;名字的长度应该在5-10之间\u0026#39;, }) name: string; @IsNumber( {}, { message: \u0026#39;年龄必须是数字\u0026#39;, }, ) age: number; } login.controller.ts\n1 2 3 4 5 6 7 8 9 10 @Controller(\u0026#39;login\u0026#39;) export class LoginController { constructor(private readonly loginService: LoginService) {} @Post() // 使用管道 create(@Body(LoginPipe) createLoginDto: CreateLoginDto) { return this.loginService.create(createLoginDto); } } login.pipe.ts\n使用plainToInstance反射创建对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { ArgumentMetadata, Injectable, PipeTransform } from \u0026#39;@nestjs/common\u0026#39;; import { plainToInstance } from \u0026#39;class-transformer\u0026#39;; import { log } from \u0026#39;console\u0026#39;; @Injectable() export class LoginPipe implements PipeTransform { transform(value: any, metadata: ArgumentMetadata) { // 反射创建对象 const dto = plainToInstance(metadata.metatype, value); log(\u0026#39;dto:\u0026#39;, dto); return value; } } 打印如下\n1 dto: CreateLoginDto { name: \u0026#39;张三\u0026#39;, age: 23 } validate返回的是promise，所以加一个async和await\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { validate } from \u0026#39;class-validator\u0026#39;; @Injectable() export class LoginPipe implements PipeTransform { async transform(value: any, metadata: ArgumentMetadata) { // 反射创建对象 const dto = plainToInstance(metadata.metatype, value); // 校验dto const errors = await validate(dto); log(\u0026#39;errors:\u0026#39;, errors); return value; } } 打印内容如下\n1 2 3 4 5 6 7 8 9 errors: [ ValidationError { target: CreateLoginDto { name: \u0026#39;张三\u0026#39;, age: 23 }, value: \u0026#39;张三\u0026#39;, property: \u0026#39;name\u0026#39;, children: [], constraints: { isLength: \u0026#39;名字的长度应该在5-10之间\u0026#39; } } ] 如果数据啥也不传\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 errors: [ ValidationError { target: CreateLoginDto {}, value: undefined, property: \u0026#39;name\u0026#39;, children: [], constraints: { isLength: \u0026#39;名字的长度应该在5-10之间\u0026#39;, isNotEmpty: \u0026#39;名字不能为空\u0026#39; } }, ValidationError { target: CreateLoginDto {}, value: undefined, property: \u0026#39;age\u0026#39;, children: [], constraints: { isNumber: \u0026#39;年龄必须是数字\u0026#39; } } ] 这里可以选择使用管道来格式化一下错误信息\n返回错误信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Injectable() export class LoginPipe implements PipeTransform { async transform(value: any, metadata: ArgumentMetadata) { // 反射创建对象 const dto = plainToInstance(metadata.metatype, value); // 校验dto const errors = await validate(dto); if (errors.length \u0026gt; 0) { throw new HttpException(errors, HttpStatus.BAD_REQUEST); } return value; } } 如果返回的错误信息不对，请查看是否配置了全局的异常拦截器\n除了以上方法之外，还可以使用nest自带的校验方法\n1 2 3 4 5 6 7 8 9 10 @Controller(\u0026#39;login\u0026#39;) export class LoginController { constructor(private readonly loginService: LoginService) {} @Post() // 不再需要使用管道 create(@Body() createLoginDto: CreateLoginDto) { return this.loginService.create(createLoginDto); } } dto照样如上配置即可，无需改动\nmain.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 引入 import { ValidationPipe } from \u0026#39;@nestjs/common\u0026#39;; async function bootstrap() { const app = await NestFactory.create\u0026lt;NestExpressApplication\u0026gt;(AppModule); app.useStaticAssets(join(__dirname, \u0026#39;images\u0026#39;), { prefix: \u0026#39;/files\u0026#39;, }); app.use(cros()); app.useGlobalInterceptors(new Response()); app.useGlobalFilters(new HttpFilter()); // 使用 app.useGlobalPipes(new ValidationPipe()); await app.listen(10020); } bootstrap(); 爬虫\r1 2 3 4 5 6 # 类似于JQuery，操作dom npm install cheerio -S npm install axios -S nest g res reptile 目标https://love.19lou.com/recommend?sex=0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import { Controller, Get, Post, Body, Patch, Param, Delete, } from \u0026#39;@nestjs/common\u0026#39;; import { ReptileService } from \u0026#39;./reptile.service\u0026#39;; import { CreateReptileDto } from \u0026#39;./dto/create-reptile.dto\u0026#39;; import { UpdateReptileDto } from \u0026#39;./dto/update-reptile.dto\u0026#39;; import axios from \u0026#39;axios\u0026#39;; import { log } from \u0026#39;console\u0026#39;; import * as cheerio from \u0026#39;cheerio\u0026#39;; import * as fs from \u0026#39;fs\u0026#39;; import * as path from \u0026#39;path\u0026#39;; @Controller(\u0026#39;reptile\u0026#39;) export class ReptileController { constructor(private readonly reptileService: ReptileService) {} baseUrl: string = \u0026#39;https://love.19lou.com/recommend?sex=0\u0026#39;; @Get() async findAll() { const downloadUrls: string[] = []; const getImgUrls = async (url: string) =\u0026gt; { // 获取到html内容 const body = await axios.get(url).then((res) =\u0026gt; res.data); const $ = cheerio.load(body); $(\u0026#39;.list-main .love-item img\u0026#39;).each(function () { downloadUrls.push($(this).attr(\u0026#39;src\u0026#39;)); }); }; // 获取到图片链接 await getImgUrls(this.baseUrl); // 下载图片 this.write(downloadUrls); return downloadUrls; } /** * 下载文件 * @param urls 链接 */ write(urls: string[]) { urls.forEach(async (url) =\u0026gt; { const buffer = await axios .get(url, { responseType: \u0026#39;arraybuffer\u0026#39; }) .then((res) =\u0026gt; res.data); const ws = fs.createWriteStream( path.join(__dirname, \u0026#39;../images\u0026#39;, new Date().getTime() + \u0026#39;.jpg\u0026#39;), ); ws.write(buffer); }); } } 请求http://localhost:10020/reptile即可\n守卫\r守卫有一个单独的责任。 它们根据运行时出现的某些条件(例如权限、角色、访问控制列表等)来确定给定的请求是否由路由处理程序理。 这通常称为授权。在传统的Express应用程序中，通常由中间件处理授权(以及认证)。 中间件是身份验证的良好选择，因为诸如token验证或添加属性到request对象上与特定路由(及元数据)没有强关联。\n守卫在每个中间件之后执行,但在任何拦截器或管道之前执行。\n创建一个守卫\n1 2 3 4 5 6 7 8 nest g gu [name] nest g res guard cd src/guard # 在src下新建guard模块后 nest g gu role 局部使用\rrole.guard.ts\n1 2 3 4 5 6 7 8 9 @Injectable() export class RoleGuard implements CanActivate { canActivate( context: ExecutionContext, ): boolean | Promise\u0026lt;boolean\u0026gt; | Observable\u0026lt;boolean\u0026gt; { log(\u0026#39;经过了守卫\u0026#39;); return true; } } guard.controller.ts\n通过@UseGuards装饰器来使用守卫\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Controller, Get, UseGuards, } from \u0026#39;@nestjs/common\u0026#39;; // 引入守卫 import { RoleGuard } from \u0026#39;./role/role.guard\u0026#39;; @Controller(\u0026#39;guard\u0026#39;) // 使用 @UseGuards(RoleGuard) export class GuardController { constructor(private readonly guardService: GuardService) {} @Get() findAll() { return this.guardService.findAll(); } } 全局使用\rmain.ts\n1 2 3 4 5 6 7 8 9 10 // 引入 import { RoleGuard } from \u0026#39;./guard/role/role.guard\u0026#39;; async function bootstrap() { const app = await NestFactory.create\u0026lt;NestExpressApplication\u0026gt;(AppModule); // 使用 app.useGlobalGuards(new RoleGuard()); await app.listen(10020); } bootstrap(); 接下来还是以局部使用为例\n1 2 3 4 5 6 7 8 9 10 11 12 @Controller(\u0026#39;guard\u0026#39;) @UseGuards(RoleGuard) export class GuardController { constructor(private readonly guardService: GuardService) {} @Get() // 设置元信息 @SetMetadata(\u0026#39;roles\u0026#39;, [\u0026#39;admin\u0026#39;]) findAll() { return this.guardService.findAll(); } } role.guard.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Injectable() export class RoleGuard implements CanActivate { // 注入Reflector constructor(private readonly reflector: Reflector) {} canActivate( context: ExecutionContext, ): boolean | Promise\u0026lt;boolean\u0026gt; | Observable\u0026lt;boolean\u0026gt; { // roles需要与controller的key对应上 // 使用context.getHandler()来获取函数体 const admin = this.reflector.get\u0026lt;string[]\u0026gt;(\u0026#39;roles\u0026#39;, context.getHandler()); log(\u0026#39;经过了守卫:\u0026#39;, admin); return true; } } 打印如下\n1 经过了守卫: [ \u0026#39;admin\u0026#39; ] 已经获取到需要的角色了 这里可以去数据库查询是否具有相应角色，但由于还没有学习到orm框架，暂时从请求url里获取角色 http://localhost:10020/guard?roles=admin\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Injectable() export class RoleGuard implements CanActivate { // 注入Reflector constructor(private readonly reflector: Reflector) {} canActivate( context: ExecutionContext, ): boolean | Promise\u0026lt;boolean\u0026gt; | Observable\u0026lt;boolean\u0026gt; { // roles需要与controller的key对应上 // 使用context.getHandler()来获取函数体 const roles = this.reflector.get\u0026lt;string[]\u0026gt;(\u0026#39;roles\u0026#39;, context.getHandler()); const req = context.switchToHttp().getRequest\u0026lt;Request\u0026gt;(); log(\u0026#39;经过了守卫:\u0026#39;, req.query.roles, \u0026#39;需要角色:\u0026#39;, roles); if (roles.includes(req.query.roles as string)) { return true; } return false; } } 自定义装饰器\r将上一节使用的@SetMetadata('roles', ['admin'])封装成自定义装饰器\n1 2 # 建立装饰器 nest g d role 1 export const Role = (...args: string[]) =\u0026gt; SetMetadata(\u0026#39;role\u0026#39;, args); 引入使用\n1 2 3 4 5 6 7 8 9 10 11 @Controller(\u0026#39;guard\u0026#39;) @UseGuards(RoleGuard) export class GuardController { constructor(private readonly guardService: GuardService) {} @Get() @Role(\u0026#39;admin\u0026#39;) findAll() { return this.guardService.findAll(); } } 接下来自定义封装一个参数装饰器\nrole.decorator.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { ExecutionContext, SetMetadata, createParamDecorator, } from \u0026#39;@nestjs/common\u0026#39;; import { log } from \u0026#39;console\u0026#39;; import { Request } from \u0026#39;express\u0026#39;; export const Role = (...args: string[]) =\u0026gt; SetMetadata(\u0026#39;role\u0026#39;, args); export const ReqUrl = createParamDecorator( (data: string, context: ExecutionContext) =\u0026gt; { const request = context.switchToHttp().getRequest\u0026lt;Request\u0026gt;(); log(\u0026#39;data:\u0026#39;, data); return request.url; }, ); 1 2 3 4 5 6 7 8 9 10 11 12 13 @Controller(\u0026#39;guard\u0026#39;) @UseGuards(RoleGuard) export class GuardController { constructor(private readonly guardService: GuardService) {} @Get() @Role(\u0026#39;admin\u0026#39;) // 使用参数装饰器 findAll(@ReqUrl(\u0026#39;url:test\u0026#39;) url: string) { log(\u0026#39;url:\u0026#39;, url); return this.guardService.findAll(); } } 打印如下\n1 2 data: url:test url: /guard?roles=123 这里的data指@ReqUrl里的内容\nswagger接口文档\r1 2 # 安装依赖 npm i @nestjs/swagger swagger-ui-express main.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { SwaggerModule, DocumentBuilder } from \u0026#39;@nestjs/swagger\u0026#39;; async function bootstrap() { const app = await NestFactory.create\u0026lt;NestExpressApplication\u0026gt;(AppModule); app.useStaticAssets(join(__dirname, \u0026#39;images\u0026#39;), { prefix: \u0026#39;/files\u0026#39;, }); app.use(cros()); app.useGlobalInterceptors(new Response()); app.useGlobalFilters(new HttpFilter()); app.useGlobalPipes(new ValidationPipe()); // 设置接口文档信息 const options = new DocumentBuilder() // 设置JWT权限校验 .addBearerAuth() .setTitle(\u0026#39;xxx后台管理系统\u0026#39;) .setDescription(\u0026#39;后台系统使用nestJS、React构建\u0026#39;) .setVersion(\u0026#39;1\u0026#39;) .build(); const document = SwaggerModule.createDocument(app, options); // 接口文档路径(http://localhost:10020/api-docs) SwaggerModule.setup(\u0026#39;api-docs\u0026#39;, app, document); await app.listen(10020); } bootstrap(); 但是这样看起来很多很乱，我们需要对接口做分组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import { ApiBearerAuth, ApiOperation, ApiParam, ApiQuery, ApiResponse, ApiTags, } from \u0026#39;@nestjs/swagger\u0026#39;; // 权限校验 @ApiBearerAuth() @Controller(\u0026#39;guard\u0026#39;) @UseGuards(RoleGuard) // 用于分组 @ApiTags(\u0026#39;守卫接口\u0026#39;) export class GuardController { constructor(private readonly guardService: GuardService) {} @Post() // 对参数createLoginDto进行描述,@ApiProperty装饰器写在`create-guard.dto.ts`文件里 create(@Body() createLoginDto: CreateGuardDto) { return this.guardService.create(createLoginDto); } @Get() @Role(\u0026#39;admin\u0026#39;) // @ApiQuery和@ApiParam类似的，区别是@ApiQuery是请求参数，@ApiParam是路径参数 // 设置参数信息 @ApiParam({ name: \u0026#39;url\u0026#39;, description: \u0026#39;这是当前访问的url\u0026#39;, required: true, type: \u0026#39;string\u0026#39;, }) // 返回状态描述 @ApiResponse({ status: 403, description: \u0026#39;没有权限\u0026#39; }) // 描述和详细描述 @ApiOperation({ summary: \u0026#39;get接口\u0026#39;, description: \u0026#39;主要作用是xxx\u0026#39; }) findAll(@ReqUrl(\u0026#39;url:test\u0026#39;) url: string) { log(\u0026#39;url:\u0026#39;, url); return this.guardService.findAll(); } } create-guard.dto.ts\n1 2 3 4 5 6 7 8 9 import { ApiProperty } from \u0026#39;@nestjs/swagger\u0026#39;; export class CreateGuardDto { // 对Body参数进行描述 @ApiProperty({ example: \u0026#39;张三\u0026#39;, enum: [\u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;], type: \u0026#39;string\u0026#39; }) name: string; @ApiProperty({ example: 23 }) age: number; } 连接数据库\rorm框架这里使用typeOrm\n1 npm install --save @nestjs/typeorm typeorm mysql2 配置app.module.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Module({ imports: [ UserModule, TypeOrmModule.forRoot({ //数据库类型 type: \u0026#39;mysql\u0026#39;, //账号 username: \u0026#39;root\u0026#39;, //密码 password: \u0026#39;123456\u0026#39;, //host host: \u0026#39;localhost\u0026#39;, //端口 port: 3306, //库名 database: \u0026#39;book\u0026#39;, //实体文件 entities: [__dirname + \u0026#39;/**/*.entity{.ts,.js}\u0026#39;], //synchronize字段代表是否自动将实体类同步到数据库 synchronize: true, //重试连接数据库间隔 retryDelay: 500, //重试连接数据库的次数 retryAttempts: 10, //如果为true,将自动加载实体 forFeature()方法注册的每个实体都将自动添加到配置对象的实体数组中 autoLoadEntities: true, }), ], controllers: [AppController], providers: [AppService], }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer.apply(Logger).forRoutes(UserController); } } 推介使用自动加载实体autoLoadEntities: true\nuser.entity.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Column, Entity, PrimaryGeneratedColumn } from \u0026#39;typeorm\u0026#39;; @Entity({ name: \u0026#39;user\u0026#39; }) export class User { // 主键自增 @PrimaryGeneratedColumn(\u0026#39;increment\u0026#39;) id: number; @Column() username: string; @Column() password: string; @Column() nickName: string; } create-user.dto.ts\n1 2 3 4 5 export class CreateUserDto { username: string; password: string; nickName: string; } update-user.dto.ts\n1 2 3 4 5 6 7 8 9 import { PartialType } from \u0026#39;@nestjs/mapped-types\u0026#39;; import { CreateUserDto } from \u0026#39;./create-user.dto\u0026#39;; export class UpdateUserDto extends PartialType(CreateUserDto) { id: number; userrname: string; password: string; nickName: string; } user.module.ts\n1 2 3 4 5 6 7 8 9 10 import { User } from \u0026#39;./entities/user.entity\u0026#39;; @Module({ // 关联 imports: [TypeOrmModule.forFeature([User])], controllers: [UserController], providers: [UserService], exports: [UserService], }) export class UserModule {} CRUD\r这里使用React和NestJS实现一个CRUD\n前端代码\n后端代码\nuser.controller.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @ApiTags(\u0026#39;用户接口\u0026#39;) @Controller(\u0026#39;user\u0026#39;) export class UserController { constructor(private readonly userService: UserService) {} @Get() findOne(@Query(\u0026#39;username\u0026#39;) username: string) { return this.userService.findOneByUsername(username); } @Get(\u0026#39;list\u0026#39;) list() { return this.userService.findAll(); } @Post() saveUser(@Body() createUser: CreateUserDto) { return this.userService.create(createUser); } @Put() update(@Body() updateUser: UpdateUserDto) { return this.userService.update(updateUser); } @Delete(\u0026#39;:id\u0026#39;) removeOne(@Param(\u0026#39;id\u0026#39;, ParseIntPipe) id: number) { return this.userService.remove(id); } } user.service.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Injectable() export class UserService { constructor( @InjectRepository(User) private readonly userMapper: Repository\u0026lt;User\u0026gt;, ) {} create(createUserDto: CreateUserDto) { const user = new User(); user.username = createUserDto.username; user.password = createUserDto.password; user.nickName = createUserDto.nickName; return this.userMapper.save(user); } findAll() { return this.userMapper.find(); } findOneByUsername(username: string) { return this.userMapper.find({ where: { username: Like(`%${username}%`), }, }); } update(updateUserDto: UpdateUserDto) { return this.userMapper.update(updateUserDto.id, updateUserDto); } remove(id: number) { return this.userMapper.delete(id); } } ","date":"2024-07-18T00:00:00Z","image":"http://localhost:1313/p/nestjs/202412212154588_hu3210952307873656492.png","permalink":"http://localhost:1313/p/nestjs/","title":"NestJs"},{"content":"React\r参考文档\nReact基础\nReact\u0026amp;Mobx\n基础\r使用脚手架创建项目\n1 2 3 4 5 npx create-react-app react-basic cd react-basic yarn start 删除src下除了App.js和index.js之外的其他文件\nindex.js\n1 2 3 4 5 6 7 8 9 10 11 12 import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom/client\u0026#39;; // 引入根组件App import App from \u0026#39;./App\u0026#39;; // 通过调用ReactDOM的render方法渲染App根组件到id为root的dom节点上 const root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/React.StrictMode\u0026gt; ); App.js\n1 2 3 4 5 6 7 8 9 10 function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;header className=\u0026#34;App-header\u0026#34;\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 什么是JSX\rJSX是 JavaScript XML（HTML）的缩写，表示在 JS 代码中书写 HTML 结构\n需要注意的是JSX 并不是标准的 JS 语法，是 JS 的语法扩展，浏览器默认是不识别的\nJSX中使用js表达式\r1 2 3 4 5 6 function App() { const name = \u0026#34;张三\u0026#34;; return \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;我的名字是{name}\u0026lt;/div\u0026gt;; } export default App; 注意:if/变量声明语句是语句，并非表达式，不能出现在{}中\nJSX列表渲染\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 function App() { const nameList = [\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;]; return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; {nameList.map((item) =\u0026gt; ( \u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 我们一步步来分析，为什么这么写\n我们希望重复li标签\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function App() { const nameList = [\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;]; return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;张三\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;李四\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;王五\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 我们希望return li标签\n1 2 3 4 5 6 7 8 9 10 11 12 function App() { const nameList = [\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;]; return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; {nameList.map(item=\u0026gt;\u0026lt;li\u0026gt;张三\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 最后将文本内容替换成列表即可\n对象列表也是同理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function App() { const userList = [ { name: \u0026#34;张三\u0026#34;, age: 12, }, { name: \u0026#34;李四\u0026#34;, age: 13, }, { name: \u0026#34;王五\u0026#34;, age: 14, }, ]; return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; {userList.map((item) =\u0026gt; ( \u0026lt;li\u0026gt;{item.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 在渲染的节点上添加key属性可提高diff性能\n\u0026lt;div className=\u0026quot;App\u0026quot;\u0026gt;\r\u0026lt;ul\u0026gt;\r{userList.map((item) =\u0026gt; (\r\u0026lt;li key={item.name}\u0026gt;{item.name}\u0026lt;/li\u0026gt;\r))}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\rJSX条件渲染\r实现条件渲染有两种方式，三元运算和逻辑运算符(\u0026amp;\u0026amp;)\n1 2 3 4 5 6 7 8 9 10 11 function App() { const flag = true; return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{flag ? \u0026#34;yes\u0026#34; : \u0026#34;no\u0026#34;}\u0026lt;/span\u0026gt; {flag \u0026amp;\u0026amp; \u0026lt;span\u0026gt;显示\u0026lt;/span\u0026gt;} \u0026lt;/div\u0026gt; ); } export default App; JSX样式处理\r样式处理主要有以下几种写法\n行内样式\n1 2 3 4 5 6 7 8 9 function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;span style={{ color: \u0026#34;red\u0026#34; }}\u0026gt;React从入门到入土\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 为啥这里要套两层{}？\n其实这种写法中内部的{}表示{ color: \u0026quot;red\u0026quot; }是一个对象，效果和下面一样\n1 2 3 4 5 6 7 8 9 10 11 12 function App() { const fontColor={ color: \u0026#34;red\u0026#34; } return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;span style={fontColor}\u0026gt;React从入门到入土\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; className\n新建一个App.css\n1 2 3 4 5 6 .font-red { color: red; } .font-green { color: green; } 这里可以使用动态类名来控制样式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import \u0026#39;./App.css\u0026#39; function App() { const flag = true; return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;span className={flag ? \u0026#34;font-red\u0026#34; : \u0026#34;font-green\u0026#34;}\u0026gt; React从入门到入土 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; JSX注意事项\rJSX必须有一个根节点，如果没有根节点，可以使用\u0026lt;\u0026gt;\u0026lt;/\u0026gt;（幽灵节点）替代 所有标签必须形成闭合，成对闭合或者自闭合都可以 JSX中的语法更加贴近JS语法，属性名采用驼峰命名法 class -\u0026gt; className for -\u0026gt; htmlFor JSX支持多行（换行），如果需要换行，需使用() 包裹，防止bug出现 阶段练习\r项目demo\n完成 评论数据渲染 、 tab内容渲染 、评论列表点赞和点踩的功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 import \u0026#39;./index.css\u0026#39; import avatar from \u0026#39;./images/avatar.png\u0026#39; // 依赖的数据 const state = { // hot: 热度排序 time: 时间排序 tabs: [ { id: 1, name: \u0026#39;热度\u0026#39;, type: \u0026#39;hot\u0026#39; }, { id: 2, name: \u0026#39;时间\u0026#39;, type: \u0026#39;time\u0026#39; } ], active: \u0026#39;hot\u0026#39;, list: [ { id: 1, author: \u0026#39;刘德华\u0026#39;, comment: \u0026#39;给我一杯忘情水\u0026#39;, time: new Date(\u0026#39;2021-10-10 09:09:00\u0026#39;), // 1: 点赞 0：无态度 -1:踩 attitude: 1 }, { id: 2, author: \u0026#39;周杰伦\u0026#39;, comment: \u0026#39;哎哟，不错哦\u0026#39;, time: new Date(\u0026#39;2021-10-11 09:09:00\u0026#39;), // 1: 点赞 0：无态度 -1:踩 attitude: 0 }, { id: 3, author: \u0026#39;五月天\u0026#39;, comment: \u0026#39;不打扰，是我的温柔\u0026#39;, time: new Date(\u0026#39;2021-10-11 10:09:00\u0026#39;), // 1: 点赞 0：无态度 -1:踩 attitude: -1 } ] } function ShowComment() { return \u0026lt;\u0026gt; {state.list.map(item =\u0026gt; \u0026lt;div className=\u0026#34;list-item\u0026#34; key={item.id}\u0026gt; \u0026lt;div className=\u0026#34;user-face\u0026#34;\u0026gt; \u0026lt;img className=\u0026#34;user-head\u0026#34; src={avatar} alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;comment\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;user\u0026#34;\u0026gt;{item.author}\u0026lt;/div\u0026gt; \u0026lt;p className=\u0026#34;text\u0026#34;\u0026gt;{item.comment}\u0026lt;/p\u0026gt; \u0026lt;div className=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;time\u0026#34;\u0026gt; {item.time.toLocaleString()} \u0026lt;/span\u0026gt; \u0026lt;span className={`like ${item.attitude === 1 ? \u0026#39;liked\u0026#39; : \u0026#39;\u0026#39;}`}\u0026gt; \u0026lt;i className=\u0026#34;icon\u0026#34;/\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span className={`hate ${item.attitude === -1 ? \u0026#39;hated\u0026#39; : \u0026#39;\u0026#39;}`}\u0026gt; \u0026lt;i className=\u0026#34;icon\u0026#34;/\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;reply btn-hover\u0026#34;\u0026gt;删除\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;)} \u0026lt;/\u0026gt; } function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;comment-container\u0026#34;\u0026gt; {/* 评论数 */} \u0026lt;div className=\u0026#34;comment-head\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{state.list.length} 评论\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {/* 排序 */} \u0026lt;div className=\u0026#34;tabs-order\u0026#34;\u0026gt; \u0026lt;ul className=\u0026#34;sort-container\u0026#34;\u0026gt; {state.tabs.map(item =\u0026gt; \u0026lt;li key={item.id} className={item.type === state.active ? \u0026#39;on\u0026#39; : \u0026#39;\u0026#39;}\u0026gt;按{item.name}排序\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; {/* 添加评论 */} \u0026lt;div className=\u0026#34;comment-send\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;user-face\u0026#34;\u0026gt; \u0026lt;img className=\u0026#34;user-head\u0026#34; src={avatar} alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;textarea-container\u0026#34;\u0026gt; \u0026lt;textarea cols=\u0026#34;80\u0026#34; rows=\u0026#34;5\u0026#34; placeholder=\u0026#34;发条友善的评论\u0026#34; className=\u0026#34;ipt-txt\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;comment-submit\u0026#34;\u0026gt;发表评论\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;comment-emoji\u0026#34;\u0026gt; \u0026lt;i className=\u0026#34;face\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span className=\u0026#34;text\u0026#34;\u0026gt;表情\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* 评论列表 */} \u0026lt;div className=\u0026#34;comment-list\u0026#34;\u0026gt; \u0026lt;ShowComment/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default App 组件\r能够独立使用函数完成react组件的创建和渲染\n函数组件\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 定义函数组件 function SayHello () { return \u0026lt;span\u0026gt;Hello\u0026lt;/span\u0026gt; } function App () { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 渲染函数组件 */} \u0026lt;SayHello /\u0026gt; \u0026lt;/div\u0026gt; ) } export default App 约定说明\n组件的名称必须首字母大写，react内部会根据这个来判断是组件还是普通的HTML标签 函数组件必须有返回值，表示该组件的 UI 结构；如果不需要渲染任何内容，则返回 null 组件就像 HTML 标签一样可以被渲染到页面中。组件表示的是一段结构内容，对于函数组件来说，渲染的内容是函数的返回值就是对应的内容 使用函数名称作为组件标签名称，可以成对出现也可以自闭合 类组件\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import React from \u0026#34;react\u0026#34; class SayHello extends React.Component { render () { return \u0026lt;span\u0026gt;Hello\u0026lt;/span\u0026gt; } } function App () { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 渲染函数组件 */} \u0026lt;SayHello /\u0026gt; \u0026lt;/div\u0026gt; ) } export default App 约定说明\n类名称也必须以大写字母开头 类组件应该继承 React.Component 父类，从而使用父类中提供的方法或属性 类组件必须提供 render 方法render 方法必须有返回值，表示该组件的 UI 结构 函数组件事件绑定\r新建components/Home.js，以后再Home中编辑内容，就不直接更改App.js了\n1 2 3 4 5 6 7 8 9 10 11 12 import Home from \u0026#34;./components/Home\u0026#34; function App () { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Home /\u0026gt; \u0026lt;/div\u0026gt; ) } export default App 1 2 3 4 5 6 7 8 9 10 function Home () { // 定义事件 const clickLog = () =\u0026gt; { console.log(\u0026#39;点击\u0026#39;) } // 绑定事件 return \u0026lt;button onClick={clickLog}\u0026gt;点击\u0026lt;/button\u0026gt; } export default Home 获取事件对象\n1 2 3 4 5 6 7 8 9 10 function Home () { // 定义事件 const clickLog = (e) =\u0026gt; { console.log(\u0026#39;点击:\u0026#39;, e) } // 绑定事件 return \u0026lt;button onClick={clickLog}\u0026gt;点击\u0026lt;/button\u0026gt; } export default Home 传递额外参数\n如果及需要获取事件对象，又需要传递参数怎么办\n解决思路: 改造事件绑定为箭头函数 在箭头函数中完成参数的传递\n1 2 3 4 5 6 7 8 9 10 11 12 function Home () { // 定义事件 const clickLog = (e, flag) =\u0026gt; { if (flag) { console.log(\u0026#39;点击:\u0026#39;, e) } } // 绑定事件 return \u0026lt;button onClick={(e) =\u0026gt; clickLog(e, false)}\u0026gt;点击\u0026lt;/button\u0026gt; } export default Home 类组件的事件绑定\r类组件中的事件绑定，整体的方式和函数组件差别不大\n唯一需要注意的 因为处于class类语境下 所以定义事件回调函数以及定它写法上有不同\n定义的时候: class Fields语法\n使用的时候: 需要借助this关键词获取\n1 2 3 4 5 6 7 8 9 10 11 12 13 import React from \u0026#34;react\u0026#34; class Home extends React.Component { // class Fields clickLog = (e) =\u0026gt; { console.log(e) } render () { return \u0026lt;button onClick={this.clickLog}\u0026gt;点击\u0026lt;/button\u0026gt; } } export default Home 注意这里的写法\n1 2 3 clickLog = (e) =\u0026gt; { console.log(e) } 你可能会写成\n1 2 3 clickLog (e) { console.log(e) } 这样可能会引发this的指向问题\n组件状态\r一个前提：在React hook出来之前，函数式组件是没有自己的状态的，所以我们统一通过类组件来讲解\n初始化状态 视图读取初始状态 修改状态 视图使用新状态自动更新 初始化状态\r通过class的实例属性state来初始化 state的值是一个对象结构，表示一个组件可以有多个数据状态 1 2 3 4 5 6 7 8 9 10 11 12 import React from \u0026#34;react\u0026#34; class Home extends React.Component { state = { count: 1 } render () { return \u0026lt;button\u0026gt;点击\u0026lt;/button\u0026gt; } } export default Home 读取状态\r通过this.state来获取状态 1 2 3 4 5 6 7 8 9 10 11 12 import React from \u0026#34;react\u0026#34; class Home extends React.Component { state = { count: 1 } render () { return \u0026lt;button\u0026gt;{this.state.count}\u0026lt;/button\u0026gt; } } export default Home 修改状态\r语法 this.setState({ 要修改的部分数据 }) setState方法作用 修改state中的数据状态 更新UI 思想 数据驱动视图，也就是只要修改数据状态，那么页面就会自动刷新，无需手动操作dom 注意事项 不要直接修改state中的值，必须通过setState方法进行修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import React from \u0026#34;react\u0026#34; class Home extends React.Component { state = { count: 1 } addCount = () =\u0026gt; { this.setState({ count: this.state.count + 1 }) } render () { return \u0026lt;\u0026gt; \u0026lt;span\u0026gt;{this.state.count}\u0026lt;/span\u0026gt; \u0026lt;button onClick={this.addCount}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; } } export default Home this指向问题\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import React from \u0026#34;react\u0026#34; class Home extends React.Component { constructor() { super() // 使用bind修正clickLog1中this的指向问题 // 相当于在类组件初始化阶段来修正回调函数的this指向 // 永远指向当前组件实例对象 this.clickLog = this.clickLog.bind(this) } clickLog () { // 此时打印为 undefined，那么修改state数据就会报错 console.log(this) } render () { // 这里的this指的是当前组件的实例对象 console.log(\u0026#39;render:\u0026#39;, this) return \u0026lt;\u0026gt; \u0026lt;button onClick={this.clickLog}\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; } } export default Home 推介写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import React from \u0026#34;react\u0026#34; class Home extends React.Component { clickLog = () =\u0026gt; { console.log(this) } render () { return \u0026lt;\u0026gt; \u0026lt;button onClick={this.clickLog}\u0026gt;点击1\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; this.clickLog()}\u0026gt;点击2\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; this.clickLog(true)}\u0026gt;点击3\u0026lt;/button\u0026gt; \u0026lt;button onClick={(e) =\u0026gt; this.clickLog(e, true)}\u0026gt;点击4\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; } } export default Home React的状态不可变\r不要直接修改状态的值，而是基于当前状态创建新的状态值\n错误的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 state = { count : 0, list: [1,2,3], person: { name:\u0026#39;jack\u0026#39;, age:18 } } // 直接修改简单类型Number this.state.count++ ++this.state.count this.state.count += 1 this.state.count = 1 // 直接修改数组 this.state.list.push(123) this.state.list.spice(1,1) // 直接修改对象 this.state.person.name = \u0026#39;rose\u0026#39; 正确的写法\n1 2 3 4 5 6 7 8 9 this.setState({ count: this.state.count + 1 list: [...this.state.list, 4], person: { ...this.state.person, // 覆盖原来的属性 就可以达到修改对象中属性的目的 name: \u0026#39;rose\u0026#39; } }) 表单处理\r使用React处理表单元素，一般有两种方式：\n受控组件 （推荐使用） 非受控组件 （了解） 受控组件\r什么是受控组件？ input框自己的状态被React组件状态控制 React组件的状态的地方是在state中，input表单元素也有自己的状态是在value中 React将state与表单元素的值（value）绑定到一起，由state的值来控制表单元素的值，从而保证单一数据源特性\n实现步骤\n在组件的state中声明一个组件的状态数据 将状态数据设置为input标签元素的value属性的值 为input添加change事件，在事件处理程序中，通过事件对象e获取到当前文本框的值（即用户当前输入的值） 调用setState方法，将文本框的值作为state状态的最新值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import React from \u0026#34;react\u0026#34; class Home extends React.Component { state = { text: \u0026#39;\u0026#39; } changeText = (e) =\u0026gt; { this.setState({ // 通过事件对象e来获取用户当前输入的值 text: e.target.value }) } render () { return \u0026lt;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={this.state.text} onChange={this.changeText} /\u0026gt; \u0026lt;/\u0026gt; } } export default Home 非受控表单组件\r非受控组件就是通过手动操作dom的方式获取文本框的值，文本框的状态不受react组件的state中的状态控制，直接通过原生dom获取输入框的值\n实现步骤\n导入createRef 函数 调用createRef函数，创建一个ref对象，存储到名为msgRef的实例属性中 为input添加ref属性，值为msgRef 在按钮的事件处理程序中，通过msgRef.current即可拿到input对应的dom元素，而其中msgRef.current.value拿到的就是文本框的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import React, { createRef } from \u0026#34;react\u0026#34; class Home extends React.Component { msgRef = createRef() changeText = () =\u0026gt; { console.log(\u0026#39;value:\u0026#39;, this.msgRef.current.value) } render () { return \u0026lt;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={this.msgRef} /\u0026gt; \u0026lt;button onClick={this.changeText}\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; } } export default Home 阶段小练习\r项目demo\n完成tab点击切换激活状态交互 完成发表评论功能 完成删除评论功能 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 import \u0026#39;./index.css\u0026#39; import avatar from \u0026#39;./images/avatar.png\u0026#39; import React from \u0026#39;react\u0026#39; // 时间格式化 function formatDate(time) { return `${time.getFullYear()}-${time.getMonth()}-${time.getDate()}` } class App extends React.Component { state = { author: \u0026#39;战斗暴龙兽\u0026#39;, // hot: 热度排序 time: 时间排序 tabs: [ { id: 1, name: \u0026#39;热度\u0026#39;, type: \u0026#39;hot\u0026#39; }, { id: 2, name: \u0026#39;时间\u0026#39;, type: \u0026#39;time\u0026#39; } ], active: \u0026#39;hot\u0026#39;, list: [ { id: 1, author: \u0026#39;刘德华\u0026#39;, comment: \u0026#39;给我一杯忘情水\u0026#39;, time: new Date(\u0026#39;2021-10-10 09:09:00\u0026#39;), // 1: 点赞 0：无态度 -1:踩 attitude: 1 }, { id: 2, author: \u0026#39;周杰伦\u0026#39;, comment: \u0026#39;哎哟，不错哦\u0026#39;, time: new Date(\u0026#39;2021-10-11 09:09:00\u0026#39;), // 1: 点赞 0：无态度 -1:踩 attitude: 0 }, { id: 3, author: \u0026#39;五月天\u0026#39;, comment: \u0026#39;不打扰，是我的温柔\u0026#39;, time: new Date(\u0026#39;2021-10-11 10:09:00\u0026#39;), // 1: 点赞 0：无态度 -1:踩 attitude: -1 } ], comment: \u0026#39;\u0026#39; } // 切换tab页 changeTab = (type) =\u0026gt; { this.setState({ active: type }) } // 输入评论 changeComment = (e) =\u0026gt; { this.setState({ comment: e.target.value }) } // 发表评论 addComment = (e) =\u0026gt; { this.setState({ // 插入评论列表 list: [ ...this.state.list, { id: this.state.list.length + 1, author: this.state.author, comment: e.target.value, time: new Date(), attitude: 0 } ], // 清空评论 comment: \u0026#39;\u0026#39; }) } // 删除评论 deleteComment = (comment) =\u0026gt; { this.setState({ // 插入评论列表 list: this.state.list.filter(item =\u0026gt; { // 判断删除的评论是否是自己发布 // 是则删除 if (comment.author === this.state.author) { return item.id !== comment.id } else { // 否则不删除 return item } }) }) } render() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;comment-container\u0026#34;\u0026gt; {/* 评论数 */} \u0026lt;div className=\u0026#34;comment-head\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{this.state.list.length} 评论\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {/* 排序 */} \u0026lt;div className=\u0026#34;tabs-order\u0026#34;\u0026gt; \u0026lt;ul className=\u0026#34;sort-container\u0026#34;\u0026gt; { this.state.tabs.map(tab =\u0026gt; ( \u0026lt;li key={tab.id} className={tab.type === this.state.active ? \u0026#39;on\u0026#39; : \u0026#39;\u0026#39;} onClick={() =\u0026gt; this.changeTab(tab.type)} \u0026gt;按{tab.name}排序\u0026lt;/li\u0026gt; )) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; {/* 添加评论 */} \u0026lt;div className=\u0026#34;comment-send\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;user-face\u0026#34;\u0026gt; \u0026lt;img className=\u0026#34;user-head\u0026#34; src={avatar} alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;textarea-container\u0026#34;\u0026gt; \u0026lt;textarea cols=\u0026#34;80\u0026#34; rows=\u0026#34;5\u0026#34; placeholder=\u0026#34;发条友善的评论\u0026#34; className=\u0026#34;ipt-txt\u0026#34; value={this.state.comment} onChange={this.changeComment} /\u0026gt; \u0026lt;button className=\u0026#34;comment-submit\u0026#34; onClick={this.addComment}\u0026gt;发表评论\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;comment-emoji\u0026#34;\u0026gt; \u0026lt;i className=\u0026#34;face\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span className=\u0026#34;text\u0026#34;\u0026gt;表情\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {/* 评论列表 */} \u0026lt;div className=\u0026#34;comment-list\u0026#34;\u0026gt; { this.state.list.map(item =\u0026gt; ( \u0026lt;div className=\u0026#34;list-item\u0026#34; key={item.id}\u0026gt; \u0026lt;div className=\u0026#34;user-face\u0026#34;\u0026gt; \u0026lt;img className=\u0026#34;user-head\u0026#34; src={avatar} alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;comment\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;user\u0026#34;\u0026gt;{item.author}\u0026lt;/div\u0026gt; \u0026lt;p className=\u0026#34;text\u0026#34;\u0026gt;{item.comment}\u0026lt;/p\u0026gt; \u0026lt;div className=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;time\u0026#34;\u0026gt;{formatDate(item.time)}\u0026lt;/span\u0026gt; \u0026lt;span className={item.attitude === 1 ? \u0026#39;like liked\u0026#39; : \u0026#39;like\u0026#39;}\u0026gt; \u0026lt;i className=\u0026#34;icon\u0026#34;/\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span className={item.attitude === -1 ? \u0026#39;hate hated\u0026#39; : \u0026#39;hate\u0026#39;}\u0026gt; \u0026lt;i className=\u0026#34;icon\u0026#34;/\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;reply btn-hover\u0026#34; onClick={() =\u0026gt; this.deleteComment(item)}\u0026gt;删除\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; )) } \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;) } } export default App 组件通信\r为了能让各组件之间可以进行互相沟通，数据传递，这个过程就是组件通信\n父子关系 - 最重要的 兄弟关系 - 自定义事件模式产生技术方法 eventBus / 通过共同的父组件通信 其它关系 - mobx / redux / zustand 父传子\r实现步骤\n父组件提供要传递的数据 - state 给子组件标签添加属性值为 state中的数据 子组件中通过 props 接收父组件中传过来的数据 类组件使用this.props获取props对象 函数式组件直接通过参数获取props对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import React from \u0026#34;react\u0026#34; // 子组件1(函数式子组件) function ChildrenComponentFunction (props) { return \u0026lt;\u0026gt; \u0026lt;div\u0026gt;{props.msg}\u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; } // 子组件2(类子组件) class ChildrenComponentClass extends React.Component { render () { return \u0026lt;\u0026gt; \u0026lt;div\u0026gt; {this.props.msg} \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; } } // 父组件 class Home extends React.Component { state = { message: \u0026#39;你好\u0026#39; } render () { return \u0026lt;\u0026gt; \u0026lt;ChildrenComponentFunction msg={this.state.message} /\u0026gt; \u0026lt;ChildrenComponentClass msg={this.state.message} /\u0026gt; \u0026lt;/\u0026gt; } } export default Home props说明\r1. props是只读对象（readonly）\n根据单项数据流的要求，子组件只能读取props中的数据，不能进行修改\n2. props可以传递任意数据\n数字、字符串、布尔值、数组、对象、函数、JSX\n子传父\r口诀： 父组件给子组件传递回调函数，子组件调用\n实现步骤\n父组件提供一个回调函数 - 用于接收数据 将函数作为属性的值，传给子组件 子组件通过props调用 回调函数 将子组件中的数据作为参数传递给回调函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import React from \u0026#34;react\u0026#34; // 子组件1(函数式子组件) function ChildrenComponentFunction (props) { const chickFuncComponent = () =\u0026gt; { props.changeMsg(\u0026#39;函数式子组件\u0026#39;) } return \u0026lt;\u0026gt; \u0026lt;div onClick={chickFuncComponent}\u0026gt;{props.msg}\u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; } // 子组件2(类子组件) class ChildrenComponentClass extends React.Component { chickClassComponent = () =\u0026gt; { this.props.changeMsg(\u0026#39;类子组件\u0026#39;) } render () { return \u0026lt;\u0026gt; \u0026lt;div onClick={this.chickClassComponent}\u0026gt; {this.props.msg} \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; } } // 父组件 class Home extends React.Component { state = { message: \u0026#39;你好\u0026#39; } // 提供回调函数 changeMsg = (newMsg) =\u0026gt; { this.setState({ message: newMsg }) } render () { return \u0026lt;\u0026gt; \u0026lt;ChildrenComponentFunction msg={this.state.message} changeMsg={this.changeMsg} /\u0026gt; \u0026lt;ChildrenComponentClass msg={this.state.message} changeMsg={this.changeMsg} /\u0026gt; \u0026lt;/\u0026gt; } } export default Home 兄弟组件传参\r思路: SonB-\u0026gt;Father-\u0026gt;SonA\n实现步骤\n将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态\n提供共享状态 提供操作共享状态的方法 要接收数据状态的子组件通过 props 接收数据\n要传递数据状态的子组件通过props接收方法，调用方法传递数据\n子组件1和子组件2互为兄弟组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import React from \u0026#34;react\u0026#34; // 子组件1 function ChildrenComponentFunction1 ({ msg, changeMsg }) { const sendMessage = () =\u0026gt; { changeMsg(msg + \u0026#39;==\u0026#39;) } return \u0026lt;\u0026gt; \u0026lt;div onClick={sendMessage}\u0026gt;组件1\u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; } // 子组件2 function ChildrenComponentFunction2 ({ msg }) { return \u0026lt;\u0026gt; \u0026lt;div\u0026gt;组件2\u0026lt;/div\u0026gt;\u0026lt;span\u0026gt;{msg}\u0026lt;/span\u0026gt; \u0026lt;/\u0026gt; } // 父组件 class Home extends React.Component { state = { message: \u0026#39;初始值\u0026#39; } changeMsg = (msg) =\u0026gt; { this.setState({ message: msg }) } render () { return \u0026lt;\u0026gt; \u0026lt;ChildrenComponentFunction1 msg={this.state.message} changeMsg={this.changeMsg} /\u0026gt; \u0026lt;ChildrenComponentFunction2 msg={this.state.message} /\u0026gt; \u0026lt;/\u0026gt; } } export default Home 跨组件传参\r如果采用一层一层通过props往下传递就会很繁琐，有时候自己都不知道接收到的props里有什么，所以不推介这种做法\n实现步骤\n创建Context对象 导出 Provider 和 Consumer对象\n1 const { Provider, Consumer } = createContext() 使用Provider包裹上层组件提供数据\n1 2 3 \u0026lt;Provider value={this.state.message}\u0026gt; {/* 根组件 */} \u0026lt;/Provider\u0026gt; 需要用到数据的组件使用Consumer包裹获取数据\n1 2 3 \u0026lt;Consumer \u0026gt; {value =\u0026gt; /* 基于 context 值进行渲染*/} \u0026lt;/Consumer\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import React, { createContext } from \u0026#34;react\u0026#34; const { Provider, Consumer } = createContext() // 子组件1 function ChildrenComponentFunction1 () { return \u0026lt;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildrenComponentFunction2 /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; } // 子组件2 function ChildrenComponentFunction2 () { return \u0026lt;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildrenComponentFunction3 /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; } // 子组件3 function ChildrenComponentFunction3 () { return \u0026lt;\u0026gt; \u0026lt;Consumer\u0026gt; {value =\u0026gt; \u0026lt;div\u0026gt;组件3{value}\u0026lt;/div\u0026gt;} \u0026lt;/Consumer\u0026gt; \u0026lt;/\u0026gt; } // 父组件 class Home extends React.Component { state = { message: \u0026#39;初始值\u0026#39; } changeMsg = (msg) =\u0026gt; { this.setState({ message: msg }) } render () { return ( \u0026lt;div\u0026gt; \u0026lt;Provider value={this.state.message}\u0026gt; \u0026lt;ChildrenComponentFunction1 /\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/div\u0026gt; ) } } export default Home 期间遇到过一个问题，错误写法如下\n1 2 3 4 5 6 7 8 // 子组件3 function ChildrenComponentFunction3 () { return \u0026lt;\u0026gt; \u0026lt;Consumer\u0026gt; \u0026lt;div\u0026gt;组件3\u0026lt;/div\u0026gt;{value =\u0026gt; \u0026lt;div\u0026gt;{value}\u0026lt;/div\u0026gt;} \u0026lt;/Consumer\u0026gt; \u0026lt;/\u0026gt; } 实际上，Consumer期望一个函数作为子元素，此函数接收上下文值作为参数并返回一个React节点。\n阶段小练习\r要求：App为父组件用来提供列表数据 ，ListItem为子组件用来渲染列表数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import React from \u0026#34;react\u0026#34; // 子组件 function ChildrenComponentFunction ({ messageList, deleteMsg }) { const deleteParentMsg = (id) =\u0026gt; { deleteMsg(id) } return \u0026lt;\u0026gt; {messageList.map(item =\u0026gt; \u0026lt;div key={item.id}\u0026gt;{item.message}\u0026lt;button onClick={() =\u0026gt; deleteParentMsg(item.id)}\u0026gt;删除\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;)} \u0026lt;/\u0026gt; } // 父组件 class Home extends React.Component { state = { messageList: [ { id: 1, message: \u0026#39;信息1\u0026#39; }, { id: 2, message: \u0026#39;信息2\u0026#39; }, { id: 3, message: \u0026#39;信息3\u0026#39; } ] } deleteMsg = (id) =\u0026gt; { this.setState({ messageList: this.state.messageList.filter(item =\u0026gt; item.id !== id) }) } render () { return ( \u0026lt;div\u0026gt; \u0026lt;ChildrenComponentFunction messageList={this.state.messageList} deleteMsg={this.deleteMsg} /\u0026gt; \u0026lt;/div\u0026gt; ) } } export default Home Hooks基础\r上面使用的主要是类组件来实现数据状态存储以及更新，接下来我们将改为函数式组件\nHooks的本质：一套能够使函数组件更强大，更灵活的“钩子”\nuseState\ruseState为函数组件提供状态（state）\n使用步骤\n导入 useState 函数 调用 useState 函数，并传入状态的初始值 从useState函数的返回值中，拿到状态和修改状态的方法 在JSX中展示状态 调用修改状态的方法更新状态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import React, { useState } from \u0026#34;react\u0026#34; function Home () { // 参数：状态初始值比如,传入 0 表示该状态的初始值为 0 // 返回值：数组,包含两个值：1 状态值（state） 2 修改该状态的函数（setState） const [count, updateCount] = useState(0) return \u0026lt;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; updateCount(count - 1)}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt; {count}\u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; updateCount(count + 1)}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div \u0026gt; \u0026lt;/\u0026gt; } export default Home 状态的读取和修改\r读取状态\n该方式提供的状态，是函数内部的局部变量，可以在函数内的任意位置使用\n修改状态\nupdateCount是一个函数，参数表示最新的状态值 调用该函数后，将使用新值替换旧值 修改状态后，由于状态发生变化，会引起视图变化 组件更新的过程\r函数组件使用 useState hook 后的执行过程，以及状态值的变化\n组件第一次渲染 从头开始执行该组件中的代码逻辑 调用 useState(0) 将传入的参数作为状态初始值，即：0 渲染组件，此时，获取到的状态 count 值为： 0 组件第二次渲染 点击按钮，调用 updateCount(count + 1) 修改状态，因为状态发生改变，所以，该组件会重新渲染 组件重新渲染时，会再次执行该组件中的代码逻辑 再次调用 useState(0)，此时 React 内部会拿到最新的状态值而非初始值，比如，该案例中最新的状态值为 1 再次渲染组件，此时，获取到的状态 count 值为：1 注意：useState 的初始值(参数)只会在组件第一次渲染时生效。也就是说，以后的每次渲染，useState 获取到都是最新的状态值，React 组件会记住每次最新的状态值\n使用规则\ruseState 函数可以执行多次，每次执行互相独立，每调用一次为函数组件提供一个状态 注意事项 只能出现在函数组件或者其他hook函数中 不能嵌套在if/for/其它函数中（react按照hooks的调用顺序识别每一个hook） 可以通过开发者工具查看hooks状态 错误写法\n1 2 3 4 5 6 7 8 9 let num = 1 function List(){ num++ if(num / 2 === 0){ const [name, setName] = useState(\u0026#39;cp\u0026#39;) } const [list,setList] = useState([]) } // 俩个hook的顺序不是固定的，这是不可以的！！！ useEffect\r什么是副作用\n副作用是相对于主作用来说的，一个函数除了主作用，其他的作用就是副作用。对于 React 组件来说，主作用就是根据数据（state/props）渲染 UI，除此之外都是副作用（比如，手动修改 DOM）\n常见的副作用\n数据请求 ajax发送 手动修改dom localStorage操作 useEffect函数的作用就是为react函数组件提供副作用处理的！\nuseEffect为react函数组件提供副作用处理\n使用步骤\n导入 useEffect 函数 调用 useEffect 函数，并传入回调函数 在回调函数中编写副作用处理（dom操作） 修改数据状态 检测副作用是否生效 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import React, { useState, useEffect } from \u0026#34;react\u0026#34; function Home () { const [count, updateCount] = useState(0) useEffect(() =\u0026gt; { // 渲染dom document.title = count }) return \u0026lt;\u0026gt; \u0026lt;div onClick={() =\u0026gt; updateCount(count + 1)}\u0026gt; 已经点击了{count}次 \u0026lt;/div \u0026gt; \u0026lt;/\u0026gt; } export default Home 不添加依赖项\n组件首次渲染执行一次，以及不管是哪个状态更改引起组件更新时都会重新执行\n组件初始渲染 useState里的数据发生更新 useEffect是基于React组件的渲染生命周期来工作的。当组件的props或state发生变化，触发了重新渲染，之后useEffect会根据其依赖数组来决定是否执行\n添加空数组\n组件只在首次渲染时执行一次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import React, { useState, useEffect } from \u0026#34;react\u0026#34; function Home () { const [count, updateCount] = useState(0) useEffect(() =\u0026gt; { // 渲染dom document.title = count }, []) return \u0026lt;\u0026gt; \u0026lt;div onClick={() =\u0026gt; updateCount(count + 1)}\u0026gt; 已经点击了{count}次 \u0026lt;/div \u0026gt; \u0026lt;/\u0026gt; } export default Home 添加特定依赖项\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import React, { useState, useEffect } from \u0026#34;react\u0026#34; function Home () { const [count, updateCount] = useState(0) const [name, setName] = useState(\u0026#39;张三\u0026#39;) useEffect(() =\u0026gt; { console.log(\u0026#39;重新执行\u0026#39;) }, [count]) return \u0026lt;\u0026gt; \u0026lt;button onClick={() =\u0026gt; updateCount(count + 1)}\u0026gt; 已经点击了{count}次 \u0026lt;/button \u0026gt; \u0026lt;button onClick={() =\u0026gt; setName(name + \u0026#39;==\u0026#39;)}\u0026gt; 名字:{name} \u0026lt;/button \u0026gt; \u0026lt;/\u0026gt; } export default Home 清理副作用\r如果想要清理副作用 可以在副作用函数中的末尾return一个新的函数，在新的函数中编写清理副作用的逻辑\n注意执行时机为：\n组件卸载时自动执行 组件更新时，下一个useEffect副作用函数执行之前自动执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import React, { useState, useEffect } from \u0026#34;react\u0026#34; function Home () { const [count, setCount] = useState(0) useEffect(() =\u0026gt; { const timerId = setInterval(() =\u0026gt; { setCount(count + 1) }, 1000) return () =\u0026gt; { // 用来清理副作用的事情 clearInterval(timerId) } }, [count]) return ( \u0026lt;div\u0026gt; {count} \u0026lt;/div\u0026gt; ) } export default Home 阶段小练习\r需求描述： 自定义hook函数，可以自动同步到本地LocalStorage\n1 2 3 4 5 6 7 function useStorage (key, value) { const [message, setMessage] = useState(value) useEffect(() =\u0026gt; { localStorage.setItem(key, message) }, [key, message]) return [message, setMessage] } Hook进阶\ruseState\r回调函数的参数\n使用场景\n参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过计算才能获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用\n语法\n1 2 3 const [name, setName] = useState(()=\u0026gt;{ // 编写计算逻辑 return \u0026#39;计算之后的初始值\u0026#39; }) 语法规则\n回调函数return出去的值将作为 name 的初始值 回调函数中的逻辑只会在组件初始化的时候执行一次 语法选择\n如果就是初始化一个普通的数据 直接使用 useState(普通数据) 即可 如果要初始化的数据无法直接得到需要通过计算才能获取到，使用useState(()=\u0026gt;{}) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import React, { useState, useEffect } from \u0026#34;react\u0026#34; function ChildrenComponent (props) { const [count, setCount] = useState(() =\u0026gt; { // 经过计算 return props.count * 2 + 9 }) return \u0026lt;\u0026gt; \u0026lt;div\u0026gt;{count}\u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; } function Home () { return ( \u0026lt;\u0026gt; \u0026lt;ChildrenComponent count={2} /\u0026gt; \u0026lt;/\u0026gt; ) } export default Home useEffect\r发送网络请求\n使用场景\n如何在useEffect中发送网络请求，并且封装同步 async await操作\n语法要求\n不可以直接在useEffect的回调函数外层直接包裹 await ，因为异步会导致清理函数无法立即返回\n错误写法\n1 2 3 4 useEffect(async ()=\u0026gt;{ const res = await axios.get(\u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39;) console.log(res) },[]) 正确写法\n在内部单独定义一个函数，然后把这个函数包装成同步\n需要配置json格式的数据，这里未展示\n1 2 3 4 5 6 7 useEffect(()=\u0026gt;{ async function fetchData(){ const res = await axios.get(\u0026#39;http://localhost:10020/user/list\u0026#39;) console.log(res) } fetchData() },[]) 或者\n1 2 3 4 5 6 7 useEffect(() =\u0026gt; { async function getUserList() { const res = await fetch(\u0026#39;http://localhost:10020/user/list\u0026#39;) console.log(\u0026#39;userList:\u0026#39;, await res.json()) } getUserList() }, []) useRef\r使用场景\n在函数组件中获取真实的dom元素对象或者是组件对象\n使用步骤\n导入 useRef 函数 执行 useRef 函数并传入null，返回值为一个对象 内部有一个current属性存放拿到的dom对象（组件实例） 通过ref 绑定 要获取的元素或者组件 获取dom\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026#39;use client\u0026#39; import { log } from \u0026#39;console\u0026#39; import React, { useEffect, useRef } from \u0026#39;react\u0026#39; function Home() { const btn = useRef(null) useEffect(() =\u0026gt; { setInterval(() =\u0026gt; { console.log(btn.current) }, 1000) }, []) return ( \u0026lt;button type=\u0026#34;button\u0026#34; ref={btn}\u0026gt; Default \u0026lt;/button\u0026gt; ) } export default Home 这里和前面的非受控组件非常类似\n获取组件实例\n函数组件由于没有实例，不能使用ref获取，如果想获取组件实例，必须是类组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026#39;use client\u0026#39; import React, { useEffect, useRef } from \u0026#39;react\u0026#39; class HelloComponent extends React.Component { render() { return ( \u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt; Default \u0026lt;/button\u0026gt; ) } } function Home() { const btn = useRef(null) useEffect(() =\u0026gt; { setInterval(() =\u0026gt; { console.log(btn.current) }, 1000) }, []) return \u0026lt;HelloComponent ref={btn} /\u0026gt; } export default Home useContext\r实现步骤\n使用createContext 创建Context对象 在顶层组件通过Provider 提供数据 在底层组件通过useContext函数获取数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026#39;use client\u0026#39; import React, { createContext, useContext } from \u0026#39;react\u0026#39; const Context = createContext(\u0026#39;\u0026#39;) // 子组件1 function ChildComponent1() { return \u0026lt;ChildComponent2 /\u0026gt; } // 子组件2 function ChildComponent2() { const msg = useContext(Context) return ( \u0026lt;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; className=\u0026#34;text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 me-2 mb-2 dark:bg-blue-600 dark:hover:bg-blue-700 focus:outline-none dark:focus:ring-blue-800\u0026#34;\u0026gt; {msg} \u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } // 父组件 function Home() { return ( \u0026lt;Context.Provider value=\u0026#34;这是传递的信息\u0026#34;\u0026gt; \u0026lt;ChildComponent1 /\u0026gt; \u0026lt;/Context.Provider\u0026gt; ) } export default Home 效果等同于\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026#39;use client\u0026#39; import React, { createContext } from \u0026#39;react\u0026#39; const Context = createContext(\u0026#39;\u0026#39;) // 子组件1 function ChildComponent1() { return \u0026lt;ChildComponent2 /\u0026gt; } // 子组件2 function ChildComponent2() { return ( \u0026lt;Context.Consumer\u0026gt; {(value) =\u0026gt; ( \u0026lt;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt; {value} \u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; )} \u0026lt;/Context.Consumer\u0026gt; ) } // 父组件 function Home() { return ( \u0026lt;Context.Provider value=\u0026#34;这是传递的信息\u0026#34;\u0026gt; \u0026lt;ChildComponent1 /\u0026gt; \u0026lt;/Context.Provider\u0026gt; ) } export default Home ReactRouter\r环境配置\r1 2 3 4 5 6 7 8 9 10 11 # 创建react项目 yarn create vite react-router --template react # 安装所有依赖包 yarn # 启动项目 yarn dev # 安装react-router包 yarn add react-router-dom@6 基本使用\r需求: 准备俩个按钮，点击不同按钮切换不同组件内容的显示\n实现步骤：\n导入必要的路由router内置组件 准备俩个React组件 按照路由的规则进行路由配置 这里以Home和About为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 引入必要的内置组件 import { BrowserRouter, Routes, Route, Link, Router } from \u0026#39;react-router-dom\u0026#39; import Home from \u0026#34;./components/Home\u0026#34; import { About } from \u0026#39;./components/About\u0026#39; function App () { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 配置路由规则 */} \u0026lt;BrowserRouter\u0026gt; \u0026lt;Link to={\u0026#39;/home\u0026#39;} \u0026gt;首页\u0026lt;/Link\u0026gt; \u0026lt;Link to={\u0026#39;/about\u0026#39;} \u0026gt;关于\u0026lt;/Link\u0026gt; \u0026lt;Routes\u0026gt; {/* 首页路由 */} \u0026lt;Route path=\u0026#39;/home\u0026#39; element={\u0026lt;Home /\u0026gt;} /\u0026gt; {/* 关于页路由 */} \u0026lt;Route path=\u0026#39;/about\u0026#39; element={\u0026lt;About /\u0026gt;} /\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/div\u0026gt; ) } export default App 核心内置组件\rBrowserRouter\r作用: 包裹整个应用，一个React应用只需要使用一次\n模式\nHashRouter 实现方式:监听url hash值实现 路由url表现:http://localhost:3000/#/about BrowserRouter 实现方式:h5的 history.pushState API实现 路由url表现:http://localhost:3000/about Link\r作用: 用于指定导航链接，完成声明式的路由跳转 类似于 \u0026lt;router-link/\u0026gt;\n1 \u0026lt;Link to={\u0026#39;/home\u0026#39;} \u0026gt;首页\u0026lt;/Link\u0026gt; 这里to属性用于指定路由地址，表示要跳转到哪里去，Link组件最终会被渲染为原生的a链接\nRoutes\r作用: 提供一个路由出口，组件内部会存在多个内置的Route组件，满足条件的路由会被渲染到组件内部，类比 router-view\nRoute\r作用: 用于定义路由路径和渲染组件的对应关系 [element：因为react体系内 把组件叫做react element]\n1 2 3 4 5 6 \u0026lt;Routes\u0026gt; {/* 首页路由 */} \u0026lt;Route path=\u0026#39;/home\u0026#39; element={\u0026lt;Home /\u0026gt;} /\u0026gt; {/* 关于页路由 */} \u0026lt;Route path=\u0026#39;/about\u0026#39; element={\u0026lt;About /\u0026gt;} /\u0026gt; \u0026lt;/Routes\u0026gt; 其中path属性用来指定匹配的路径地址，element属性指定要渲染的组件，图中配置的意思为: 当url上访问的地址为 /about 时，当前路由发生匹配，对应的About组件渲染\n编程式导航\r概念: 通过js编程的方式进行路由页面跳转，比如说从首页跳转到关于页\n实现步骤：\n导入一个 useNavigate 钩子函数 执行 useNavigate 函数 得到 跳转函数 在事件中执行跳转函数完成路由跳转 1 2 3 4 5 6 7 8 9 10 11 12 import { useNavigate } from \u0026#34;react-router-dom\u0026#34; function Home () { const navigate = useNavigate() return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; navigate(\u0026#39;/about\u0026#39;)}\u0026gt;跳转About页面\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default Home 注: 如果在跳转时不想添加历史记录，可以添加额外参数replace 为true\n1 navigate(\u0026#39;/about\u0026#39;, { replace: true } 路由传参\r场景：跳转路由的同时，有时候要需要传递参数\nsearchParams传参\r就是问号传参\n1 2 3 4 5 6 7 8 9 10 11 12 import { useNavigate } from \u0026#34;react-router-dom\u0026#34; function Home () { const navigate = useNavigate() return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; navigate(\u0026#39;/about?name=张三\u0026#39;)}\u0026gt;跳转About页面\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default Home 获取参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useEffect } from \u0026#34;react\u0026#34; import { useSearchParams } from \u0026#34;react-router-dom\u0026#34; export function About () { let [searchParams] = useSearchParams() useEffect(() =\u0026gt; { const name = searchParams.get(\u0026#39;name\u0026#39;) console.log(name) }, []) return ( \u0026lt;div\u0026gt; 这里是About页面 \u0026lt;/div\u0026gt; ) } params传参\r就是路径传参\n首先需要修改如下配置，否则/about/1001匹配不上/about，会报错No routes matched location \u0026quot;/about/1001\u0026quot;\n1 \u0026lt;Route path=\u0026#39;/about/:id\u0026#39; element={\u0026lt;About /\u0026gt;} /\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 import { useNavigate } from \u0026#34;react-router-dom\u0026#34; function Home () { const navigate = useNavigate() return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; navigate(\u0026#39;/about/1001\u0026#39;)}\u0026gt;跳转About页面\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default Home 获取参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { useEffect } from \u0026#34;react\u0026#34; import { useParams } from \u0026#34;react-router-dom\u0026#34; export function About () { let params = useParams() useEffect(() =\u0026gt; { console.log(params.id) }, []) return ( \u0026lt;div\u0026gt; 这里是About页面 \u0026lt;/div\u0026gt; ) } 嵌套路由\r嵌套路由非常常用，在我们做的很多的管理后台系统中，通常我们都会设计一个Layout组件，在它内部实现嵌套路由\n实现步骤：\nApp.js中定义嵌套路由声明 Layout组件内部通过 指定二级路由出口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { BrowserRouter, Routes, Route } from \u0026#39;react-router-dom\u0026#39; import Home from \u0026#34;./components/Home\u0026#34; import \u0026#39;./App.css\u0026#39; import LeftComponent from \u0026#39;./components/Left\u0026#39; import ContentComponent from \u0026#39;./components/Content\u0026#39; function App () { return ( \u0026lt;div className=\u0026#34;App\u0026#34; \u0026gt; {/* 配置路由规则 */} \u0026lt;BrowserRouter\u0026gt; \u0026lt;Routes\u0026gt; {/* 首页路由 */} \u0026lt;Route path=\u0026#39;/home\u0026#39; element={\u0026lt;Home /\u0026gt;} \u0026gt; \u0026lt;Route path=\u0026#39;left\u0026#39; element={\u0026lt;LeftComponent /\u0026gt;} /\u0026gt; \u0026lt;Route path=\u0026#39;content\u0026#39; element={\u0026lt;ContentComponent /\u0026gt;} /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/div\u0026gt; ) } export default App 配置路由出口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Link, Outlet } from \u0026#34;react-router-dom\u0026#34; const bgColor = { height: \u0026#39;100vh\u0026#39;, width: \u0026#39;100%\u0026#39;, backgroundColor: \u0026#39;grey\u0026#39; } function Home () { return ( \u0026lt;div style={bgColor}\u0026gt; \u0026lt;Link to=\u0026#39;/home/left\u0026#39; \u0026gt;左侧\u0026lt;/Link\u0026gt; \u0026lt;Link to=\u0026#39;/home/content\u0026#39; \u0026gt;正文\u0026lt;/Link\u0026gt; \u0026lt;Outlet /\u0026gt; \u0026lt;/div \u0026gt; ) } export default Home 默认二级路由\r场景: 应用首次渲染完毕就需要显示的二级路由\n实现步骤:\n给默认二级路由标记index属性 把原本的路径path属性去掉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { BrowserRouter, Routes, Route } from \u0026#39;react-router-dom\u0026#39; import Home from \u0026#34;./components/Home\u0026#34; import \u0026#39;./App.css\u0026#39; import LeftComponent from \u0026#39;./components/Left\u0026#39; import ContentComponent from \u0026#39;./components/Content\u0026#39; function App () { return ( \u0026lt;div className=\u0026#34;App\u0026#34; \u0026gt; {/* 配置路由规则 */} \u0026lt;BrowserRouter\u0026gt; \u0026lt;Routes\u0026gt; {/* 首页路由 */} \u0026lt;Route path=\u0026#39;/home\u0026#39; element={\u0026lt;Home /\u0026gt;} \u0026gt; \u0026lt;Route path=\u0026#39;left\u0026#39; element={\u0026lt;LeftComponent /\u0026gt;} /\u0026gt; \u0026lt;Route index element={\u0026lt;ContentComponent /\u0026gt;} /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/div\u0026gt; ) } export default App 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Link, Outlet } from \u0026#34;react-router-dom\u0026#34; const bgColor = { height: \u0026#39;100vh\u0026#39;, width: \u0026#39;100%\u0026#39;, backgroundColor: \u0026#39;grey\u0026#39; } function Home () { return ( \u0026lt;div style={bgColor}\u0026gt; \u0026lt;Link to=\u0026#39;/home/left\u0026#39; \u0026gt;左侧\u0026lt;/Link\u0026gt; \u0026lt;Link to=\u0026#39;/home/content\u0026#39; \u0026gt;正文\u0026lt;/Link\u0026gt; \u0026lt;Outlet /\u0026gt; \u0026lt;/div \u0026gt; ) } export default Home 404路由配置\r场景：当url的路径在整个路由配置中都找不到对应的path，使用404兜底组件进行渲染\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { BrowserRouter, Routes, Route } from \u0026#39;react-router-dom\u0026#39; import Home from \u0026#34;./components/Home\u0026#34; import \u0026#39;./App.css\u0026#39; import LeftComponent from \u0026#39;./components/Left\u0026#39; import ContentComponent from \u0026#39;./components/Content\u0026#39; import NotFoundComponent from \u0026#39;./components/NotFound\u0026#39; function App () { return ( \u0026lt;div className=\u0026#34;App\u0026#34; \u0026gt; {/* 配置路由规则 */} \u0026lt;BrowserRouter\u0026gt; \u0026lt;Routes\u0026gt; {/* 首页路由 */} \u0026lt;Route path=\u0026#39;/home\u0026#39; element={\u0026lt;Home /\u0026gt;} \u0026gt; \u0026lt;Route path=\u0026#39;left\u0026#39; element={\u0026lt;LeftComponent /\u0026gt;} /\u0026gt; \u0026lt;Route index element={\u0026lt;ContentComponent /\u0026gt;} /\u0026gt; \u0026lt;/Route\u0026gt; {/* 兜底路由 404 */} \u0026lt;Route path=\u0026#39;*\u0026#39; element={\u0026lt;NotFoundComponent /\u0026gt;} /\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/div\u0026gt; ) } export default App 1 2 3 4 5 6 7 8 9 10 11 function NotFoundComponent () { return ( \u0026lt;\u0026gt; \u0026lt;div\u0026gt; 资源已经走丢了...... \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; ) } export default NotFoundComponent 集中式路由配置\r场景: 当我们需要路由权限控制点时候, 对路由数组做一些权限的筛选过滤，所谓的集中式路由配置就是用一个数组统一把所有的路由对应关系写好替换 本来的Roues组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import { BrowserRouter, Routes, Route, useRoutes } from \u0026#39;react-router-dom\u0026#39; import Home from \u0026#34;./components/Home\u0026#34; import \u0026#39;./App.css\u0026#39; import LeftComponent from \u0026#39;./components/Left\u0026#39; import ContentComponent from \u0026#39;./components/Content\u0026#39; import NotFoundComponent from \u0026#39;./components/NotFound\u0026#39; // 假设这是服务器响应的路由信息 const routeList = [{ path: \u0026#39;/home\u0026#39;, element: \u0026lt;Home /\u0026gt;, children: [ { element: \u0026lt;ContentComponent /\u0026gt;, // index设置为true 变成默认的二级路由 index: true, }, { path: \u0026#39;left\u0026#39;, element: \u0026lt;LeftComponent /\u0026gt;, }, ], }, // 增加n个路由对应关系 { path: \u0026#39;*\u0026#39;, element: \u0026lt;NotFoundComponent /\u0026gt;, }] // 2. 使用useRoutes方法传入routesList生成Routes组件 function WrapperRoutes () { let element = useRoutes(routeList) return element } function App () { return ( \u0026lt;div className=\u0026#34;App\u0026#34; \u0026gt; {/* 配置路由规则 */} \u0026lt;BrowserRouter\u0026gt; {/* 替换之前的Routes组件 */} \u0026lt;WrapperRoutes /\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/div\u0026gt; ) } export default App 阶段小练习\r实现一个layout布局页面，这里我就不在乎什么样式了\nApp.css\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 * { margin: 0; padding: none; } .App { height: 100vh; width: 100%; } .left { height: 100vh; width: 20%; /* background-color: green; */ float: left; } .content { height: 100vh; width: 80%; /* background-color: red; */ float: left; } App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import { BrowserRouter, Routes, Route, useRoutes } from \u0026#39;react-router-dom\u0026#39; import Home from \u0026#34;./components/Home\u0026#34; import \u0026#39;./App.css\u0026#39; import LeftComponent from \u0026#39;./components/Left\u0026#39; import ContentComponent from \u0026#39;./components/Content\u0026#39; import NotFoundComponent from \u0026#39;./components/NotFound\u0026#39; // 假设这是服务器响应的路由信息 const routeList = [{ path: \u0026#39;/home\u0026#39;, element: \u0026lt;Home /\u0026gt;, children: [ { path: \u0026#39;content/:id\u0026#39;, element: \u0026lt;ContentComponent /\u0026gt;, // index设置为true 变成默认的二级路由 index: true, }, { path: \u0026#39;left\u0026#39;, element: \u0026lt;LeftComponent /\u0026gt;, }, ], }, // 增加n个路由对应关系 { path: \u0026#39;*\u0026#39;, element: \u0026lt;NotFoundComponent /\u0026gt;, }] // 2. 使用useRoutes方法传入routesList生成Routes组件 function WrapperRoutes () { let element = useRoutes(routeList) return element } function App () { return ( \u0026lt;div className=\u0026#34;App\u0026#34; \u0026gt; {/* 配置路由规则 */} \u0026lt;BrowserRouter\u0026gt; {/* 替换之前的Routes组件 */} \u0026lt;WrapperRoutes /\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/div\u0026gt; ) } export default App Left.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { useNavigate } from \u0026#34;react-router-dom\u0026#34; function LeftComponent () { const navigate = useNavigate() return ( \u0026lt;\u0026gt; \u0026lt;button onClick={() =\u0026gt; navigate(\u0026#39;/home/content/1\u0026#39;)}\u0026gt;跳转1\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; navigate(\u0026#39;/home/content/2\u0026#39;)}\u0026gt;跳转2\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default LeftComponent Home.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import LeftComponent from \u0026#39;./Left\u0026#39; import ContentComponent from \u0026#39;./Content\u0026#39; function Home () { return ( \u0026lt;\u0026gt; \u0026lt;div className=\u0026#39;left\u0026#39; \u0026gt; \u0026lt;LeftComponent /\u0026gt; \u0026lt;/div \u0026gt; \u0026lt;div className=\u0026#39;content\u0026#39;\u0026gt; \u0026lt;ContentComponent /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; ) } export default Home Content\n1 2 3 4 5 6 7 8 9 10 11 12 import { useParams } from \u0026#34;react-router-dom\u0026#34; function ContentComponent () { const params = useParams() return ( \u0026lt;\u0026gt; 这些是正文{params.id} \u0026lt;/\u0026gt; ) } export default ContentComponent 在React中，当有多个input元素时，可以通过创建一个通用的事件处理器来提高代码的复用性和可维护性。这种做法通常涉及到使用事件对象的target属性，该属性包含了触发事件的元素以及其相关的信息，如元素的name属性和当前的value。\n下面是一个示例代码，展示了如何使用一个共享的handleChange函数来处理多个input元素的状态更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import React, { useState } from \u0026#39;react\u0026#39;; function LoginForm() { const [formState, setFormState] = useState({ username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39; }); const handleChange = (event) =\u0026gt; { const { name, value } = event.target; setFormState({ ...formState, [name]: value, }); }; return ( \u0026lt;form\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label htmlFor=\u0026#34;username\u0026#34;\u0026gt;Username:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; name=\u0026#34;username\u0026#34; value={formState.username} onChange={handleChange} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label htmlFor=\u0026#34;password\u0026#34;\u0026gt;Password:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; value={formState.password} onChange={handleChange} /\u0026gt; \u0026lt;/div\u0026gt; {/* 其他表单元素和提交按钮 */} \u0026lt;/form\u0026gt; ); } export default LoginForm; 在这个例子中，formState是一个对象，包含了username和password的值。handleChange函数接收event参数，从中提取name和value属性，然后使用解构赋值和计算属性名来更新formState。\n每个input元素都有一个name属性，该属性的值与formState对象中的键相对应。同时，每个input元素的value属性被设置为formState中相应的值，以保持组件受控状态。onChange属性则指向handleChange函数，确保每次输入变化时都会调用此函数并更新状态。\n这种方法不仅提高了代码的复用性，还使得添加更多的input字段变得更加容易，因为只需要增加input标签并指定name属性即可。\n","date":"2024-07-07T00:00:00Z","image":"http://localhost:1313/p/react/202412212156937_hu16306072263746271548.png","permalink":"http://localhost:1313/p/react/","title":"React"},{"content":"开启WSL\r参考文章\n基本配置\r打开设置，选中应用\n选择程序和功能\n选择启用或关闭Windows功能\n勾选Hyper-v和适用于Linux的Windows子系统，然后重启电脑\n安装Linux子系统\r注意使用管理员权限运行cmd或者powershell\n1 2 3 4 # 下载或者更新 wsl --update # 重新启动 wsl --shutdown 前往微软商店下载Linux子系统\n搜索Linux，安装心仪的系统，这里以ubuntu为例\n启动系统后，会需要新建用户\n输入自定义用户名以及密码，即可新建用户\n配置docker\r配置docker过程查看博客\n以下是配置后的结果\n启动了两个容器，一个nginx，一个redis\n输入http://localhost:80/访问nginx界面\n客户端连接Redis成功\n配置ssh\r输入密码后切换为root用户\n1 sudo su 执行以下命令\n卸载WSL上自带的openssh并重装\n1 2 3 4 5 apt-get update apt-get remove openssh-server apt-get install openssh-server 修改ssh的配置\n1 vim /etc/ssh/sshd_config 先按住shift : 输入set nu，回车即可显示行数\n找到PermitRootLogin，改为yes\n将如下位置的注释取消掉\n然后保存并退出\n1 2 3 service ssh status service ssh start ip直接写127.0.0.1即可\n配置用户名、密码\n","date":"2024-06-02T00:00:00Z","image":"http://localhost:1313/p/%E5%BC%80%E5%90%AFwsl/202412211452323_hu12307168600953461512.png","permalink":"http://localhost:1313/p/%E5%BC%80%E5%90%AFwsl/","title":"WSL"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;template\u0026gt; \u0026lt;div style=\u0026#34;display: flex;\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;att\u0026#34; v-for=\u0026#34;(item,index) in com\u0026#34;\u0026gt; \u0026lt;div @click=\u0026#34;changeIndex(index)\u0026#34;\u0026gt;{{item.name}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;component :is=\u0026#34;isCom\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, ref} from \u0026#34;vue\u0026#34;; import ACom from \u0026#34;@/view/ACom.vue\u0026#34;; import BCom from \u0026#34;@/view/BCom.vue\u0026#34;; import CCom from \u0026#34;@/view/CCom.vue\u0026#34;; let isCom=ref(ACom); let com = reactive([ { name: \u0026#39;A组件\u0026#39;, comName: ACom }, { name: \u0026#39;B组件\u0026#39;, comName: BCom }, { name: \u0026#39;C组件\u0026#39;, comName: CCom }]); let changeIndex=(index:number)=\u0026gt;{ isCom.value=com[index].comName } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; #att div { width: 50px; height: 30px; border: 1px solid black; text-align: center; line-height: 30px; margin: 10px 10px; cursor: pointer; } \u0026lt;/style\u0026gt; 控制台警告如下\n1 2 3 4 5 HomeView.vue?t=1689771528237:70 [Vue warn]: Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`. Component that was made reactive: {__name: \u0026#39;ACom\u0026#39;, __hmrId: \u0026#39;2b2bca80\u0026#39;, __file: \u0026#39;D:/project/jetBrains/idea/antd-demo/src/view/ACom.vue\u0026#39;, setup: ƒ, render: ƒ} at \u0026lt;HomeView onVnodeUnmounted=fn\u0026lt;onVnodeUnmounted\u0026gt; ref=Ref\u0026lt; null \u0026gt; \u0026gt; at \u0026lt;RouterView\u0026gt; at \u0026lt;App\u0026gt; 这是因为reactive 会进行proxy 代理 而我们组件代理之后毫无用处 节省性能开销 推荐我们使用shallowRef 或者 markRaw 跳过proxy 代理\n修改如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;template\u0026gt; \u0026lt;div style=\u0026#34;display: flex;\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;att\u0026#34; v-for=\u0026#34;(item,index) in com\u0026#34;\u0026gt; \u0026lt;div @click=\u0026#34;changeIndex(item,index)\u0026#34;\u0026gt;{{ item.name }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;component :is=\u0026#34;isCom\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {markRaw, reactive, ref, shallowRef} from \u0026#34;vue\u0026#34;; import ACom from \u0026#34;@/view/ACom.vue\u0026#34;; import BCom from \u0026#34;@/view/BCom.vue\u0026#34;; import CCom from \u0026#34;@/view/CCom.vue\u0026#34;; let isCom = shallowRef(ACom); let active=ref(0); let com = reactive([ { name: \u0026#39;A组件\u0026#39;, comName: markRaw(ACom) }, { name: \u0026#39;B组件\u0026#39;, comName: markRaw(BCom) }, { name: \u0026#39;C组件\u0026#39;, comName: markRaw(CCom) }]); let changeIndex = (item,index) =\u0026gt; { isCom.value=item.comName active.value=index; } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; #att div { width: 50px; height: 30px; border: 1px solid black; text-align: center; line-height: 30px; margin: 10px 10px; cursor: pointer; } \u0026lt;/style\u0026gt; ","date":"2024-06-01T00:00:00Z","image":"http://localhost:1313/p/11.%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/11.%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/","title":"11.动态组件"},{"content":"插槽就是子组件中的提供给父组件使用的一个占位符，用 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的标签。\n匿名插槽\r1.在子组件放置一个插槽\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, ref} from \u0026#39;vue\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 2.父组件使用插槽 在父组件给这个插槽填充内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;Children\u0026gt; \u0026lt;template v-slot\u0026gt; \u0026lt;div\u0026gt;123\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Children\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {markRaw, reactive, ref, shallowRef} from \u0026#34;vue\u0026#34;; import Children from \u0026#34;@/view/Children.vue\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 具名插槽\r具名插槽其实就是给插槽取个名字。一个子组件可以放多个插槽，而且可以放在不同的地方，而父组件填充内容时，可以根据这个名字把内容填充到对应插槽中\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;foot\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;Children\u0026gt; \u0026lt;template v-slot:header\u0026gt; \u0026lt;div\u0026gt;this is header\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot\u0026gt; \u0026lt;div\u0026gt;this is slot\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:foot\u0026gt; \u0026lt;div\u0026gt;this is foot\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Children\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {markRaw, reactive, ref, shallowRef} from \u0026#34;vue\u0026#34;; import Children from \u0026#34;@/view/Children.vue\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 插槽简写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;Children\u0026gt; \u0026lt;template #header\u0026gt; \u0026lt;div\u0026gt;this is header\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #default\u0026gt; \u0026lt;div\u0026gt;this is slot\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #foot\u0026gt; \u0026lt;div\u0026gt;this is foot\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Children\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {markRaw, reactive, ref, shallowRef} from \u0026#34;vue\u0026#34;; import Children from \u0026#34;@/view/Children.vue\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 作用域插槽\r在子组件动态绑定参数 派发给父组件的slot去使用\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div v-for=\u0026#34;item in 100\u0026#34;\u0026gt; \u0026lt;slot :data=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 通过结构方式取值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;Children\u0026gt; \u0026lt;template #header\u0026gt; \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #default=\u0026#34;{ data }\u0026#34;\u0026gt; \u0026lt;div\u0026gt;{{ data }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #footer\u0026gt; \u0026lt;div\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Children\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {markRaw, reactive, ref, shallowRef} from \u0026#34;vue\u0026#34;; import Children from \u0026#34;@/view/Children.vue\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 动态插槽\r插槽可以是一个变量名\n1 2 3 4 5 6 7 8 \u0026lt;Dialog\u0026gt; \u0026lt;template #[name]\u0026gt; \u0026lt;div\u0026gt; 23 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Dialog\u0026gt; const name = ref(\u0026#39;header\u0026#39;) ","date":"2024-06-01T00:00:00Z","image":"http://localhost:1313/p/12.%E6%8F%92%E6%A7%BDslot/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/12.%E6%8F%92%E6%A7%BDslot/","title":"12.插槽slot"},{"content":"异步组件\r在大型应用中，我们可能需要将应用分割成小一些的代码块 并且减少主包的体积，这时候就可以使用异步组件\n顶层await\r在setup语法糖里面 使用方法\n\u0026lt;script setup\u0026gt; 中可以使用顶层 await。结果代码会被编译成 async setup()\n1 2 3 \u0026lt;script setup\u0026gt; const post = await fetch(`/api/post/1`).then(r =\u0026gt; r.json()) \u0026lt;/script\u0026gt; 父组件引用子组件 通过defineAsyncComponent加载异步配合import 函数模式便可以分包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { reactive, ref, markRaw, toRaw, defineAsyncComponent } from \u0026#39;vue\u0026#39; const Dialog = defineAsyncComponent(() =\u0026gt; import(\u0026#39;../../components/Dialog/index.vue\u0026#39;)) //完整写法 const AsyncComp = defineAsyncComponent({ // 加载函数 loader: () =\u0026gt; import(\u0026#39;./Foo.vue\u0026#39;), // 加载异步组件时使用的组件 loadingComponent: LoadingComponent, // 展示加载组件前的延迟时间，默认为 200ms delay: 200, // 加载失败后展示的组件 errorComponent: ErrorComponent, // 如果提供了一个 timeout 时间限制，并超时了 // 也会显示这里配置的报错组件，默认值是：Infinity timeout: 3000 }) suspense\r\u0026lt;suspense\u0026gt; 组件有两个插槽。它们都只接收一个直接子节点。default 插槽里的节点会尽可能展示出来。如果不能，则展示 fallback 插槽里的节点。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;Suspense\u0026gt; \u0026lt;template #default\u0026gt; \u0026lt;Dialog\u0026gt; \u0026lt;template #default\u0026gt; \u0026lt;div\u0026gt;我在哪儿\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Dialog\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #fallback\u0026gt; \u0026lt;div\u0026gt;loading...\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; 案例\r在数据请求到达之前，显示骨架，在获取到数据后，替换骨架 public/data.json\n1 2 3 4 5 6 7 8 { \u0026#34;user\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;哆啦A梦\u0026#34;, \u0026#34;age\u0026#34;: 15, \u0026#34;url\u0026#34;: \u0026#34;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp7.itc.cn%2Fq_70%2Fimages03%2F20200924%2F6a36f60e6c034d78b93901b57afca05d.jpeg\u0026amp;refer=http%3A%2F%2Fp7.itc.cn\u0026amp;app=2002\u0026amp;size=f9999,10000\u0026amp;q=a80\u0026amp;n=0\u0026amp;g=0n\u0026amp;fmt=auto?sec=1656899135\u0026amp;t=c53658ab441623ce626434ff0b974318\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;大雄的好朋友\u0026#34; } } SkeletonVue.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;att\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;span\u0026gt;姓名:正在请求中...\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;span\u0026gt;年龄:正在请求中...\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; 头像:\u0026lt;img alt=\u0026#34;正在请求中...\u0026#34; src=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; 简介:\u0026lt;span\u0026gt;正在请求中...\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Sync.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;att\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;span\u0026gt;姓名:{{ user.name }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;span\u0026gt;年龄:{{ user.age }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; 头像:\u0026lt;img :src=\u0026#34;user.url\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; 简介:\u0026lt;span\u0026gt;{{ user.desc }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {ref} from \u0026#34;vue\u0026#34;; import axios from \u0026#34;axios\u0026#34;; interface UserProps { user: { name: string, age: number, url: string; desc: string } } const {data} = await axios.get\u0026lt;UserProps\u0026gt;(\u0026#39;./data.json\u0026#39;) const user = ref\u0026lt;{ name: string, age: number, url: string; desc: string }\u0026gt;(); user.value = data.user console.log(\u0026#39;data:\u0026#39;, data); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .header \u0026gt; img { width: 50px; height: 50px; } \u0026lt;/style\u0026gt; APP.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;template #default\u0026gt; \u0026lt;Sync\u0026gt; \u0026lt;/Sync\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #fallback\u0026gt; \u0026lt;SkeletonVue\u0026gt; \u0026lt;/SkeletonVue\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineAsyncComponent, reactive, ref} from \u0026#34;vue\u0026#34;; import SkeletonVue from \u0026#34;@/view/SkeletonVue.vue\u0026#34;; const Sync = defineAsyncComponent(() =\u0026gt; import(\u0026#39;@/view/Sync.vue\u0026#39;)) \u0026lt;/script\u0026gt; ","date":"2024-06-01T00:00:00Z","image":"http://localhost:1313/p/13.%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81%E5%88%86%E5%8C%85suspense/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/13.%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%E4%BB%A3%E7%A0%81%E5%88%86%E5%8C%85suspense/","title":"13.异步组件代码分包suspense"},{"content":"Teleport Vue 3.0新特性之一。 Teleport 是一种能够将我们的模板渲染至指定DOM节点，不受父级style、v-show等属性影响，但data、prop数据依旧能够共用的技术；类似于 React 的 Portal。 主要解决的问题 因为Teleport节点挂载在其他指定的DOM节点下，完全不受父级style样式影响\n使用方法\r通过to 属性 插入指定元素位置 to=\u0026ldquo;body\u0026rdquo; 便可以将Teleport 内容传送到指定位置\n1 2 3 \u0026lt;Teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;Loading\u0026gt;\u0026lt;/Loading\u0026gt; \u0026lt;/Teleport\u0026gt; 也可以自定义传送位置 支持 class id等 选择器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;modal\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;dialog\u0026#34;\u0026gt; \u0026lt;header class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;div\u0026gt;我是弹框\u0026lt;/div\u0026gt; \u0026lt;el-icon\u0026gt; \u0026lt;CloseBold /\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; 我是内容12321321321 \u0026lt;/main\u0026gt; \u0026lt;footer class=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;el-button size=\u0026#34;small\u0026#34;\u0026gt;取消\u0026lt;/el-button\u0026gt; \u0026lt;el-button size=\u0026#34;small\u0026#34; type=\u0026#34;primary\u0026#34;\u0026gt;确定\u0026lt;/el-button\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#39;ts\u0026#39;\u0026gt; import { ref, reactive } from \u0026#39;vue\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;less\u0026#34; scoped\u0026gt; .dialog { width: 400px; height: 400px; background: #141414; display: flex; flex-direction: column; position: absolute; left: 50%; top: 50%; margin-left: -200px; margin-top: -200px; .header { display: flex; color: #CFD3DC; border-bottom: 1px solid #636466; padding: 10px; justify-content: space-between; } .main { flex: 1; color: #CFD3DC; padding: 10px; } .footer { border-top: 1px solid #636466; padding: 10px; display: flex; justify-content: flex-end; } } \u0026lt;/style\u0026gt; 多个使用场景\r1 2 3 4 5 6 \u0026lt;Teleport to=\u0026#34;.modal1\u0026#34;\u0026gt; \u0026lt;Loading\u0026gt;\u0026lt;/Loading\u0026gt; \u0026lt;/Teleport\u0026gt; \u0026lt;Teleport to=\u0026#34;.modal2\u0026#34;\u0026gt; \u0026lt;Loading\u0026gt;\u0026lt;/Loading\u0026gt; \u0026lt;/Teleport\u0026gt; 动态控制teleport\r使用disabled 设置为 true则 to属性不生效 false 则生效\n1 2 3 \u0026lt;teleport :disabled=\u0026#34;true\u0026#34; to=\u0026#39;body\u0026#39;\u0026gt; \u0026lt;A\u0026gt;\u0026lt;/A\u0026gt; \u0026lt;/teleport\u0026gt; 源码解析\r在创建teleport 组件的时候会经过patch 方法 然后调用teleport 的process 方法 主要是创建 更新 和删除的逻辑 他通过 resolveTarget 函数 获取了props.to 和 querySelect 获取 了目标元素 然后判断是否有disabled 如果有则 to 属性不生效 否则 挂载新的位置 新节点disabled 为 true 旧节点disabled false 就把子节点移动回容器 如果新节点disabled 为 false 旧节点为true 就把子节点移动到目标元素 遍历teleport 子节点进行unmount方法去移除 ","date":"2024-06-01T00:00:00Z","image":"http://localhost:1313/p/14.teleport%E4%BC%A0%E9%80%81%E7%BB%84%E4%BB%B6/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/14.teleport%E4%BC%A0%E9%80%81%E7%BB%84%E4%BB%B6/","title":"14.Teleport传送组件"},{"content":"内置组件keep-alive\r有时候我们不希望组件被重新渲染影响使用体验；或者处于性能考虑，避免多次重复渲染降低性能。而是希望组件可以缓存下来,维持当前的状态。这时候就需要用到keep-alive组件。 开启keep-alive 生命周期的变化\n初次进入时： onMounted\u0026gt; onActivated 退出后触发 deactivated 再次进入只会触发 onActivated 事件挂载的方法等，只执行一次的放在 onMounted中；组件每次进去执行的方法放在 onActivated中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- 基本 --\u0026gt; \u0026lt;keep-alive\u0026gt; \u0026lt;component :is=\u0026#34;view\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;!-- 多个条件判断的子组件 --\u0026gt; \u0026lt;keep-alive\u0026gt; \u0026lt;comp-a v-if=\u0026#34;a \u0026gt; 1\u0026#34;\u0026gt;\u0026lt;/comp-a\u0026gt; \u0026lt;comp-b v-else\u0026gt;\u0026lt;/comp-b\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;!-- 和 `\u0026lt;transition\u0026gt;` 一起使用 --\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;keep-alive\u0026gt; \u0026lt;component :is=\u0026#34;view\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;/transition\u0026gt; include 和 exclude\n1 \u0026lt;keep-alive :include=\u0026#34;\u0026#34; :exclude=\u0026#34;\u0026#34; :max=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/keep-alive\u0026gt; include 和 exclude 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示： max\n1 2 3 \u0026lt;keep-alive :max=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;view\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/keep-alive\u0026gt; keep-alive 源码讲解\r源码目录runtime-core/src/components/KeepAlive.ts\nprops\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 props: { include: [String, RegExp, Array], // 配置了该属性，那么只有名称匹配的组件会被缓存 exclude: [String, RegExp, Array], // 配置了该属性，那么任何名称匹配的组件都不会被缓存 max: [String, Number]// 最多可以缓存多少组件实例 }, setup(props: KeepAliveProps, { slots }: SetupContext) { const instance = getCurrentInstance()! const sharedContext = instance.ctx as KeepAliveContext }) const { include, exclude, max } = props //如果include 子组件名称 不包含， 和 exclude包含的名字 就不该缓存 直接返回 if ( (include \u0026amp;\u0026amp; (!name || !matches(include, name))) || (exclude \u0026amp;\u0026amp; name \u0026amp;\u0026amp; matches(exclude, name)) ) { current = vnode return rawVNode } 1 2 3 4 5 6 7 8 9 10 watch( () =\u0026gt; [props.include, props.exclude], ([include, exclude]) =\u0026gt; { //props 是响应式的 所以这个操作需要在做一遍 include \u0026amp;\u0026amp; pruneCache(name =\u0026gt; matches(include, name)) exclude \u0026amp;\u0026amp; pruneCache(name =\u0026gt; !matches(exclude, name)) }, // prune post-render after `current` has been updated { flush: \u0026#39;post\u0026#39;, deep: true } ) 缓存设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //KeepAlive 组件的缓存管理 const cache: Cache = new Map() const keys: Keys = new Set() let pendingCacheKey: CacheKey | null = null //缓存函数 const cacheSubtree = () =\u0026gt; { // fix #1621, the pendingCacheKey could be 0 if (pendingCacheKey != null) { cache.set(pendingCacheKey, getInnerChild(instance.subTree)) } } //KeepLive 组件中对缓存的管理时，首先会在组件的 onMounted 或 onUpdated 生命周期钩子函数中设置缓存，如下代码所示： onMounted(cacheSubtree) onUpdated(cacheSubtree) //Vnode 的key 作为缓存的key pendingCacheKey = key //KeepLive组件返回的函数中根据 vnode 对象的 key 去缓存中查找是否有缓存的组件， //如果缓存存在，则继承组件实例，并将用于描述组件的 vnode 对象标记为 COMPONENT_KEPT_ALIVE， //这样渲染器就不会重新创建新的组件实例；如果缓存不存在，则将 vnode 对象的key 添加到 keys 集合中 if (cachedVNode) { // 如果缓存中存在缓存的组件 vnode.el = cachedVNode.el vnode.component = cachedVNode.component //无须创建组件实例，继承缓存的组件即可 if (vnode.transition) { // 如果组件上有动画，处理动画 setTransitionHooks(vnode, vnode.transition!) } // 标记Vnode 不会重新渲染 vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE // make this key the freshest keys.delete(key) keys.add(key) } else { //将 vnode 的key 添加到 keys 集合中，keys 集合用户维护缓存组件的 key keys.add(key) // prune oldest entry if (max \u0026amp;\u0026amp; keys.size \u0026gt; parseInt(max as string, 10)) { pruneCacheEntry(keys.values().next().value) } } 生命周期\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 //隐藏容器 const storageContainer = createElement(\u0026#39;div\u0026#39;) //在实例上注册两个钩子函数 activate， deactivate sharedContext.activate = (vnode, container, anchor, isSVG, optimized) =\u0026gt; { const instance = vnode.component! move(vnode, container, anchor, MoveType.ENTER, parentSuspense) // props 可能会发生变化，因此需要执行 patch 过程 patch( instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized ) queuePostRenderEffect(() =\u0026gt; { instance.isDeactivated = false if (instance.a) { invokeArrayFns(instance.a) } const vnodeHook = vnode.props \u0026amp;\u0026amp; vnode.props.onVnodeMounted if (vnodeHook) { invokeVNodeHook(vnodeHook, instance.parent, vnode) } }, parentSuspense) if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) { // Update components tree devtoolsComponentAdded(instance) } } sharedContext.deactivate = (vnode: VNode) =\u0026gt; { const instance = vnode.component! //将组件移动到隐藏容器中 //在 “卸载” 组件时，并不是真正的卸载，而是调用 move 方法，将组件搬运到一个隐藏的容器中 move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense) queuePostRenderEffect(() =\u0026gt; { if (instance.da) { invokeArrayFns(instance.da) } const vnodeHook = vnode.props \u0026amp;\u0026amp; vnode.props.onVnodeUnmounted if (vnodeHook) { invokeVNodeHook(vnodeHook, instance.parent, vnode) } instance.isDeactivated = true }, parentSuspense) if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) { // Update components tree devtoolsComponentAdded(instance) } } ","date":"2024-06-01T00:00:00Z","image":"http://localhost:1313/p/15.keepalive%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/15.keepalive%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6/","title":"15.keepalive缓存组件"},{"content":"transition动画组件\r自定义过渡 class 类名\rtrasnsition props\nenter-from-class enter-active-class enter-to-class leave-from-class leave-active-class leave-to-class 自定义过度时间 单位毫秒 你也可以分别指定进入和离开的持续时间： 1 2 \u0026lt;transition :duration=\u0026#34;1000\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt; \u0026lt;transition :duration=\u0026#34;{ enter: 500, leave: 800 }\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;flag=!flag\u0026#34;\u0026gt;点击{{ flag ? \u0026#39;隐藏\u0026#39; : \u0026#39;显示\u0026#39; }}\u0026lt;/button\u0026gt; \u0026lt;transition leave-from-class=\u0026#34;leaveFrom\u0026#34; leave-active-class=\u0026#34;leaveActive\u0026#34; leave-to-class=\u0026#34;leaveTo\u0026#34; enter-from-class=\u0026#34;enterFrom\u0026#34; enter-active-class=\u0026#34;enterActive\u0026#34; enter-to-class=\u0026#34;enterTo\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;att\u0026#34; v-if=\u0026#34;flag\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineAsyncComponent, reactive, ref} from \u0026#34;vue\u0026#34;; import A from \u0026#39;./A.vue\u0026#39; const flag = ref\u0026lt;boolean\u0026gt;(true) \u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#34;scss\u0026#34;\u0026gt; #att { margin: 10px 10px; width: 300px; height: 300px; background: red; } .leaveFrom{ margin: 10px 10px; width: 300px; height: 300px; background: red; } .leaveActive{ transition: all 1.5s ease; } .leaveTo{ margin: 10px 10px; width: 0; height: 0; background: red; } .enterTo{ margin: 10px 10px; width: 300px; height: 300px; background: red; } .enterActive{ transition: all 1s linear; } .enterFrom{ margin: 10px 10px; width: 0; height: 0; background: red; } \u0026lt;/style\u0026gt; 通过自定义class 结合css动画库animate css\n1 npm install animate.css 官网 引入\n1 import \u0026#39;animate.css\u0026#39; 使用方法 官方文档 Animate.css | A cross-browser library of CSS animations.\n1 2 3 4 5 6 \u0026lt;transition leave-active-class=\u0026#34;animate__animated animate__bounceInLeft\u0026#34; enter-active-class=\u0026#34;animate__animated animate__bounceInRight\u0026#34; \u0026gt; \u0026lt;div v-if=\u0026#34;flag\u0026#34; class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;flag=!flag\u0026#34;\u0026gt;点击{{ flag ? \u0026#39;隐藏\u0026#39; : \u0026#39;显示\u0026#39; }}\u0026lt;/button\u0026gt; \u0026lt;transition leave-active-class=\u0026#34;animate__animated animate__bounceInLeft\u0026#34; enter-active-class=\u0026#34;animate__animated animate__bounceInRight\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;att\u0026#34; v-if=\u0026#34;flag\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineAsyncComponent, reactive, ref} from \u0026#34;vue\u0026#34;; import A from \u0026#39;./A.vue\u0026#39; import \u0026#39;animate.css\u0026#39; const flag = ref\u0026lt;boolean\u0026gt;(true) \u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#34;scss\u0026#34;\u0026gt; #att { margin: 10px 10px; width: 300px; height: 300px; background: red; } .leaveFrom{ margin: 10px 10px; width: 300px; height: 300px; background: red; } .leaveActive{ transition: all 1.5s ease; } .leaveTo{ margin: 10px 10px; width: 0; height: 0; background: red; } .enterTo{ margin: 10px 10px; width: 300px; height: 300px; background: red; } .enterActive{ transition: all 1s linear; } .enterFrom{ margin: 10px 10px; width: 0; height: 0; background: red; } \u0026lt;/style\u0026gt; 3.transition 生命周期8个\r1 2 3 4 5 6 7 8 @before-enter=\u0026#34;beforeEnter\u0026#34; //对应enter-from @enter=\u0026#34;enter\u0026#34;//对应enter-active @after-enter=\u0026#34;afterEnter\u0026#34;//对应enter-to @enter-cancelled=\u0026#34;enterCancelled\u0026#34;//显示过度打断 @before-leave=\u0026#34;beforeLeave\u0026#34;//对应leave-from @leave=\u0026#34;leave\u0026#34;//对应enter-active @after-leave=\u0026#34;afterLeave\u0026#34;//对应leave-to @leave-cancelled=\u0026#34;leaveCancelled\u0026#34;//离开过度打断 当只用 JavaScript 过渡的时候，在 enter 和 leave 钩子中必须使用 done 进行回调 结合gsap 动画库使用 GreenSock\n1 npm install gsap -S 引入\n1 import gsap from \u0026#39;gsap\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 const beforeEnter = (el: Element) =\u0026gt; { console.log(\u0026#39;进入之前from\u0026#39;, el); } const Enter = (el: Element,done:Function) =\u0026gt; { console.log(\u0026#39;过度曲线\u0026#39;); setTimeout(()=\u0026gt;{ done() },3000) } const AfterEnter = (el: Element) =\u0026gt; { console.log(\u0026#39;to\u0026#39;); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;flag=!flag\u0026#34;\u0026gt;点击{{ flag ? \u0026#39;隐藏\u0026#39; : \u0026#39;显示\u0026#39; }}\u0026lt;/button\u0026gt; \u0026lt;transition @beforeEnter=\u0026#34;enterFrom\u0026#34; @enter=\u0026#34;enterActive\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;att\u0026#34; v-if=\u0026#34;flag\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineAsyncComponent, reactive, ref} from \u0026#34;vue\u0026#34;; import A from \u0026#39;./A.vue\u0026#39; import \u0026#39;animate.css\u0026#39; import gsap from \u0026#39;gsap\u0026#39; const flag = ref\u0026lt;boolean\u0026gt;(true) let enterFrom=(el:Element)=\u0026gt;{ gsap.set(el,{ width:0, height:0 }); } let enterActive=(el:Element,done:gsap.Callback)=\u0026gt;{ gsap.to(el,{ width:300, height:300 }); } \u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#34;scss\u0026#34;\u0026gt; #att { margin: 10px 10px; width: 300px; height: 300px; background: red; } \u0026lt;/style\u0026gt; 4.appear\r通过这个属性可以设置初始节点过度 就是页面加载完成就开始动画 对应三个状态\n1 2 3 4 appear-active-class=\u0026#34;\u0026#34; appear-from-class=\u0026#34;\u0026#34; appear-to-class=\u0026#34;\u0026#34; appear ","date":"2024-06-01T00:00:00Z","image":"http://localhost:1313/p/16.transition%E5%8A%A8%E7%94%BB%E7%BB%84%E4%BB%B6/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/16.transition%E5%8A%A8%E7%94%BB%E7%BB%84%E4%BB%B6/","title":"16.transition动画组件"},{"content":"transitiongroup过度列表\r单个节点 多个节点，每次只渲染一个 那么怎么同时渲染整个列表，比如使用 v-for？在这种场景下，我们会使用 \u0026lt;transition-group\u0026gt; 组件。在我们深入例子之前，先了解关于这个组件的几个特点： 默认情况下，它不会渲染一个包裹元素，但是你可以通过 tag attribute 指定渲染一个元素。 过渡模式不可用，因为我们不再相互切换特有的元素。 内部元素总是需要提供唯一的 key attribute 值。 CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。 1 2 3 4 5 6 7 8 9 10 \u0026lt;transition-group\u0026gt; \u0026lt;div style=\u0026#34;margin: 10px;\u0026#34; :key=\u0026#34;item\u0026#34; v-for=\u0026#34;item in list\u0026#34;\u0026gt;{{ item }\u0026lt;/div\u0026gt; \u0026lt;/transition-group\u0026gt; const list = reactive\u0026lt;number[]\u0026gt;([1, 2, 4, 5, 6, 7, 8, 9]) const Push = () =\u0026gt; { list.push(123) } const Pop = () =\u0026gt; { list.pop() } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;Push\u0026#34;\u0026gt;插入\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;Pop\u0026#34;\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;transition-group\u0026gt; \u0026lt;div style=\u0026#34;margin: 10px;\u0026#34; :key=\u0026#34;item\u0026#34; v-for=\u0026#34;item in list\u0026#34;\u0026gt;{{ item }}\u0026lt;/div\u0026gt; \u0026lt;/transition-group\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineAsyncComponent, reactive, ref} from \u0026#34;vue\u0026#34;; import \u0026#39;animate.css\u0026#39; const list = reactive\u0026lt;number[]\u0026gt;([1, 2, 3]) const Push = () =\u0026gt; { list.push(list.length+1) } const Pop = () =\u0026gt; { list.pop() } \u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#34;scss\u0026#34;\u0026gt; .box{ display: flex; flex-wrap: wrap; } \u0026lt;/style\u0026gt; 2.列表的移动过渡\rlodash\n1 2 npm install lodash -S npm install @types/lodash -D \u0026lt;transition-group\u0026gt; 组件还有一个特殊之处。除了进入和离开，它还可以为定位的改变添加动画。只需了解新增的 v-move 类就可以使用这个新功能，它会应用在元素改变定位的过程中。像之前的类名一样，它的前缀可以通过 name attribute 来自定义，也可以通过 move-class attribute 手动设置 下面代码很酷炫\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;shuffle\u0026#34;\u0026gt;Shuffle\u0026lt;/button\u0026gt; \u0026lt;transition-group class=\u0026#34;wraps\u0026#34; name=\u0026#34;mmm\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;cell\u0026#34; v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt;{{ item.number }}\u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#39;ts\u0026#39;\u0026gt; import _ from \u0026#39;lodash\u0026#39; import { ref } from \u0026#39;vue\u0026#39; let items = ref(Array.apply(null, { length: 81 } as number[]).map((_, index) =\u0026gt; { return { id: index, number: (index % 9) + 1 } })) const shuffle = () =\u0026gt; { items.value = _.shuffle(items.value) } \u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#34;less\u0026#34;\u0026gt; .wraps { display: flex; flex-wrap: wrap; width: calc(25px * 10 + 9px); .cell { width: 25px; height: 25px; border: 1px solid #ccc; list-style-type: none; display: flex; justify-content: center; align-items: center; } } .mmm-move { transition: transform 0.8s ease; } \u0026lt;/style\u0026gt; 3.状态过度\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input step=\u0026#34;20\u0026#34; v-model=\u0026#34;num.current\u0026#34; type=\u0026#34;number\u0026#34;/\u0026gt; \u0026lt;div\u0026gt;{{ num.tweenedNumber.toFixed(0) }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#39;ts\u0026#39;\u0026gt; import {reactive, watch} from \u0026#39;vue\u0026#39; import gsap from \u0026#39;gsap\u0026#39; const num = reactive({ tweenedNumber: 0, current: 0 }) watch(() =\u0026gt; num.current, (newVal) =\u0026gt; { gsap.to(num, { duration: 1, tweenedNumber: newVal }) }) \u0026lt;/script\u0026gt; ","date":"2024-06-01T00:00:00Z","image":"http://localhost:1313/p/17.transitiongroup%E8%BF%87%E6%B8%A1%E5%88%97%E8%A1%A8/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/17.transitiongroup%E8%BF%87%E6%B8%A1%E5%88%97%E8%A1%A8/","title":"17.transitiongroup过渡列表"},{"content":"Dubbo\r本次使用JDK17、Dubbo3\nJDK8与Dubbo3.1.x以前的版本匹配，在使用Zookeeper注册作为注册中心时，消费者会出现节点已经存在的异常 JDK17与Dubbo3.1.x之前的版本搭配使用会出现如下问题 JDK9之后的深反射问题，需要通过JVM参数配置解决 1 2 3 4 5 6 7 -Dio.netty.tryReflectionSetAccessible-true --add-opens java.base/jdk.internal.misc=ALL - UNNAMED --add-opens java.base/java.nio=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED Dubbo3.2.0.beat4以前的版本使用的是Spring5.2.x不能支持JDK17会产生如下异常 Unsupported class file major version 61 [major 61对应17 ] 版本需要升级到Dubbo3.2.0.beat5以上版本 ","date":"2024-06-01T00:00:00Z","image":"http://localhost:1313/p/dubbo/202412212113029_hu18190609839385902043.png","permalink":"http://localhost:1313/p/dubbo/","title":"Dubbo"},{"content":"多级缓存\r传统缓存的问题\r传统的缓存策略一般是请求到达Tomcat后，先查询Redis,如果未命中则查询数据库，存在下面的问题: 请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈 Redis缓存失效时，会对数据库产生冲击 多级缓存方案\r多级缓存就是充分利用请求处理的每个环节,分别添加缓存，减轻Tomcat压力，提升服务性能: 减轻了tomcat的压力，避免了对数据库的压力，需要在nginx内部实现对于redis、tomcat访问的业务代码\n将来会将nginx部署为集群 JVM进程缓存(Tomcat缓存) Lua语法入门 实现多级缓存 缓存同步策略 环境配置\rMySQL\r后期做数据同步需要用到MySQL的主从功能，所以需要大家在虚拟机中，利用Docker来运行一个MySQL容器。\n为了方便后期配置MySQL，我们先准备两个目录，用于挂载容器的数据和配置文件目录：\n1 2 3 4 5 6 # 进入/tmp目录 cd /tmp # 创建文件夹 mkdir mysql # 进入mysql目录 cd mysql 运行命令\r在/tmp/mysql/conf目录添加一个my.cnf文件，作为mysql的配置文件：\n1 2 # 创建文件 touch /tmp/mysql/conf/my.cnf 文件内容如下\n1 2 3 4 5 [mysqld] skip-name-resolve character_set_server=utf8 datadir=/var/lib/mysql server-id=1000 1 2 3 4 5 6 7 8 9 10 docker run \\ -p 3307:3306 \\ --name mysql-demo \\ -v $PWD/conf:/etc/mysql/conf.d \\ -v $PWD/logs:/logs \\ -v $PWD/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ --privileged \\ -d \\ mysql:5.7.25 重启容器\n1 docker restart mysql-demo navicat新建连接 新建数据库 执行sql\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; DROP TABLE IF EXISTS `tb_item`; CREATE TABLE `tb_item` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \u0026#39;商品id\u0026#39;, `title` varchar(264) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \u0026#39;商品标题\u0026#39;, `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;商品名称\u0026#39;, `price` bigint(20) NOT NULL COMMENT \u0026#39;价格（分）\u0026#39;, `image` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \u0026#39;商品图片\u0026#39;, `category` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \u0026#39;类目名称\u0026#39;, `brand` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \u0026#39;品牌名称\u0026#39;, `spec` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \u0026#39;规格\u0026#39;, `status` int(1) NULL DEFAULT 1 COMMENT \u0026#39;商品状态 1-正常，2-下架，3-删除\u0026#39;, `create_time` datetime NULL DEFAULT NULL COMMENT \u0026#39;创建时间\u0026#39;, `update_time` datetime NULL DEFAULT NULL COMMENT \u0026#39;更新时间\u0026#39;, PRIMARY KEY (`id`) USING BTREE, INDEX `status`(`status`) USING BTREE, INDEX `updated`(`update_time`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 50002 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = \u0026#39;商品表\u0026#39; ROW_FORMAT = COMPACT; INSERT INTO `tb_item` VALUES (10001, \u0026#39;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4\u0026#39;, \u0026#39;SALSA AIR\u0026#39;, 16900, \u0026#39;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp\u0026#39;, \u0026#39;拉杆箱\u0026#39;, \u0026#39;RIMOWA\u0026#39;, \u0026#39;{\\\u0026#34;颜色\\\u0026#34;: \\\u0026#34;红色\\\u0026#34;, \\\u0026#34;尺码\\\u0026#34;: \\\u0026#34;26寸\\\u0026#34;}\u0026#39;, 1, \u0026#39;2019-05-01 00:00:00\u0026#39;, \u0026#39;2019-05-01 00:00:00\u0026#39;); INSERT INTO `tb_item` VALUES (10002, \u0026#39;安佳脱脂牛奶 新西兰进口轻欣脱脂250ml*24整箱装*2\u0026#39;, \u0026#39;脱脂牛奶\u0026#39;, 68600, \u0026#39;https://m.360buyimg.com/mobilecms/s720x720_jfs/t25552/261/1180671662/383855/33da8faa/5b8cf792Neda8550c.jpg!q70.jpg.webp\u0026#39;, \u0026#39;牛奶\u0026#39;, \u0026#39;安佳\u0026#39;, \u0026#39;{\\\u0026#34;数量\\\u0026#34;: 24}\u0026#39;, 1, \u0026#39;2019-05-01 00:00:00\u0026#39;, \u0026#39;2019-05-01 00:00:00\u0026#39;); INSERT INTO `tb_item` VALUES (10003, \u0026#39;唐狮新品牛仔裤女学生韩版宽松裤子 A款/中牛仔蓝（无绒款） 26\u0026#39;, \u0026#39;韩版牛仔裤\u0026#39;, 84600, \u0026#39;https://m.360buyimg.com/mobilecms/s720x720_jfs/t26989/116/124520860/644643/173643ea/5b860864N6bfd95db.jpg!q70.jpg.webp\u0026#39;, \u0026#39;牛仔裤\u0026#39;, \u0026#39;唐狮\u0026#39;, \u0026#39;{\\\u0026#34;颜色\\\u0026#34;: \\\u0026#34;蓝色\\\u0026#34;, \\\u0026#34;尺码\\\u0026#34;: \\\u0026#34;26\\\u0026#34;}\u0026#39;, 1, \u0026#39;2019-05-01 00:00:00\u0026#39;, \u0026#39;2019-05-01 00:00:00\u0026#39;); INSERT INTO `tb_item` VALUES (10004, \u0026#39;森马(senma)休闲鞋女2019春季新款韩版系带板鞋学生百搭平底女鞋 黄色 36\u0026#39;, \u0026#39;休闲板鞋\u0026#39;, 10400, \u0026#39;https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/29976/8/2947/65074/5c22dad6Ef54f0505/0b5fe8c5d9bf6c47.jpg!q70.jpg.webp\u0026#39;, \u0026#39;休闲鞋\u0026#39;, \u0026#39;森马\u0026#39;, \u0026#39;{\\\u0026#34;颜色\\\u0026#34;: \\\u0026#34;白色\\\u0026#34;, \\\u0026#34;尺码\\\u0026#34;: \\\u0026#34;36\\\u0026#34;}\u0026#39;, 1, \u0026#39;2019-05-01 00:00:00\u0026#39;, \u0026#39;2019-05-01 00:00:00\u0026#39;); INSERT INTO `tb_item` VALUES (10005, \u0026#39;花王（Merries）拉拉裤 M58片 中号尿不湿（6-11kg）（日本原装进口）\u0026#39;, \u0026#39;拉拉裤\u0026#39;, 38900, \u0026#39;https://m.360buyimg.com/mobilecms/s720x720_jfs/t24370/119/1282321183/267273/b4be9a80/5b595759N7d92f931.jpg!q70.jpg.webp\u0026#39;, \u0026#39;拉拉裤\u0026#39;, \u0026#39;花王\u0026#39;, \u0026#39;{\\\u0026#34;型号\\\u0026#34;: \\\u0026#34;XL\\\u0026#34;}\u0026#39;, 1, \u0026#39;2019-05-01 00:00:00\u0026#39;, \u0026#39;2019-05-01 00:00:00\u0026#39;); DROP TABLE IF EXISTS `tb_item_stock`; CREATE TABLE `tb_item_stock` ( `item_id` bigint(20) NOT NULL COMMENT \u0026#39;商品id，关联tb_item表\u0026#39;, `stock` int(10) NOT NULL DEFAULT 9999 COMMENT \u0026#39;商品库存\u0026#39;, `sold` int(10) NOT NULL DEFAULT 0 COMMENT \u0026#39;商品销量\u0026#39;, PRIMARY KEY (`item_id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = COMPACT; INSERT INTO `tb_item_stock` VALUES (10001, 99996, 3219); INSERT INTO `tb_item_stock` VALUES (10002, 99999, 54981); INSERT INTO `tb_item_stock` VALUES (10003, 99999, 189); INSERT INTO `tb_item_stock` VALUES (10004, 99999, 974); INSERT INTO `tb_item_stock` VALUES (10005, 99999, 18649); SET FOREIGN_KEY_CHECKS = 1; 基本工程下载 nginx配置 在nginx目录下，运行命令启动nginx\n1 start nginx.exe 访问页面http://localhost/item.html?id=10001 现在，页面是假数据展示的。我们需要向服务器发送ajax请求，查询商品数据。 打开控制台，可以看到页面有发起ajax查询数据 而这个请求地址同样是80端口，所以被当前的nginx反向代理了。 查看nginx的conf目录下的nginx.conf文件 其中的关键配置如下： 其中的192.168.150.101是我的虚拟机IP，也就是我的Nginx业务集群要部署的地方： 完整内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; keepalive_timeout 65; upstream nginx-cluster{ server 192.168.150.101:8081; } server { listen 80; server_name localhost; location /api { proxy_pass http://nginx-cluster; } location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 本地进程缓存\r缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类: 分布式缓存，例如Redis:\n优点:存储容量更大、可靠性更好、可以在集群间共享 缺点:访问缓存有网络开销 场景:缓存数据量较大、可靠性要求较高、需要在集群间共享 进程本地缓存，例如HashMap、GuavaCache: 优点:读取本地内存,没有网络开销，速度更快 缺点:存储容量有限、可靠性较低、无法共享 场景:性能要求较高，缓存数据量较小 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test void testBasicOps() { // 创建缓存对象 Cache\u0026lt;String, String\u0026gt; cache = Caffeine.newBuilder().build(); // 存数据 cache.put(\u0026#34;gf\u0026#34;, \u0026#34;迪丽热巴\u0026#34;); // 取数据，不存在则返回null String gf = cache.getIfPresent(\u0026#34;gf\u0026#34;); System.out.println(\u0026#34;gf = \u0026#34; + gf); // 取数据，不存在则去数据库查询 String defaultGF = cache.get(\u0026#34;defaultGF\u0026#34;, key -\u0026gt; { // 这里可以去数据库根据 key查询value return \u0026#34;柳岩\u0026#34;; }); System.out.println(\u0026#34;defaultGF = \u0026#34; + defaultGF); } Caffeine提供了三种缓存驱逐策略:\n基于容量:设置缓存的数量上限\n1 2 3 4 5 // 创建缓存对象 Cache\u0026lt;String, String\u0026gt; cache = Caffeine.newBuilder() // 设置缓存大小上限为 1 .maximumSize(1) .build(); 基于时间:设置缓存的有效时间\n1 2 3 4 5 // 创建缓存对象 Cache\u0026lt;String, String\u0026gt; cache = Caffeine.newBuilder() // 设置缓存有效期为 10 秒 .expireAfterWrite(Duration.ofSeconds(1)) .build(); 基于引用:设置缓存为软引用或弱引用,利用GC来回收缓存数据。性能较差,不建议使用。 在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后， 或者在空闲时间完成对失效数据的驱逐。\n实现商品的查询的本地进程缓存\n利用Caffeine实现下列需求:\n给根据id查询商品的业务添加缓存，缓存未命中时查询数据库 给根据id查询商品库存的业务添加缓存，缓存未命中时查询数据库 缓存初始大小为100 缓存上限为10000 新建配置类 这里10_000其实是指10000，下划线的作用是分隔数字，方便阅读，不加也行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Configuration public class CaffeineConfig { @Bean public Cache\u0026lt;Long, Item\u0026gt; itemCache(){ return Caffeine.newBuilder() .initialCapacity(100) .maximumSize(10_000) .build(); } @Bean public Cache\u0026lt;Long, ItemStock\u0026gt; stockCache(){ return Caffeine.newBuilder() .initialCapacity(100) .maximumSize(10_000) .build(); } } 查询api添加缓存\n它首先检查给定 id 对应的缓存项是否存在（即 ItemStock 是否在缓存中）。 如果缓存中存在该 id 对应的 ItemStock，则直接从缓存中获取并返回结果。 如果缓存中不存在该 id 对应的 ItemStock，则执行传递给 get 方法的第二个参数——一个函数式接口（key -\u0026gt; stockService.getById(key)）。这个函数会被用来计算并返回需要缓存的值，即通过调用 stockService.getById(key) 查询数据库以获取 ItemStock 对象。 在从数据库获取到 ItemStock 后，Caffeine 会将其放入缓存，并将该对象作为结果返回。 虽然代码片段中没有显式地进行“存入缓存”的操作，但在首次查询不存在于缓存中的 id 时，Caffeine 自动完成了从数据库加载数据并缓存这一过程。后续对该 id 的查询将会命中缓存，从而避免了对数据库的重复访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @RestController @RequestMapping(\u0026#34;item\u0026#34;) public class ItemController { @Autowired private Cache\u0026lt;Long, Item\u0026gt; itemCache; @Autowired private Cache\u0026lt;Long, ItemStock\u0026gt; stockCache; // 注入Bean @Autowired private IItemService itemService; @Autowired private IItemStockService stockService; @GetMapping(\u0026#34;list\u0026#34;) public PageDTO queryItemPage( @RequestParam(value = \u0026#34;page\u0026#34;, defaultValue = \u0026#34;1\u0026#34;) Integer page, @RequestParam(value = \u0026#34;size\u0026#34;, defaultValue = \u0026#34;5\u0026#34;) Integer size) { // 分页查询商品 Page\u0026lt;Item\u0026gt; result = itemService.query() .ne(\u0026#34;status\u0026#34;, 3) .page(new Page\u0026lt;\u0026gt;(page, size)); // 查询库存 List\u0026lt;Item\u0026gt; list = result.getRecords().stream().peek(item -\u0026gt; { ItemStock stock = stockService.getById(item.getId()); item.setStock(stock.getStock()); item.setSold(stock.getSold()); }).collect(Collectors.toList()); // 封装返回 return new PageDTO(result.getTotal(), list); } @PostMapping public void saveItem(@RequestBody Item item) { itemService.saveItem(item); } @PutMapping public void updateItem(@RequestBody Item item) { itemService.updateById(item); } @PutMapping(\u0026#34;stock\u0026#34;) public void updateStock(@RequestBody ItemStock itemStock) { stockService.updateById(itemStock); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public void deleteById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { itemService.update().set(\u0026#34;status\u0026#34;, 3).eq(\u0026#34;id\u0026#34;, id).update(); } @GetMapping(\u0026#34;/{id}\u0026#34;) public Item findById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { // 如果缓存存在，则直接返回，不存在则查数据库 return itemCache.get(id, key -\u0026gt; itemService.query() .ne(\u0026#34;status\u0026#34;, 3).eq(\u0026#34;id\u0026#34;, key) .one() ); } @GetMapping(\u0026#34;/stock/{id}\u0026#34;) public ItemStock findStockById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { // 如果缓存存在，则直接返回，不存在则查数据库 return stockCache.get(id, key -\u0026gt; stockService.getById(key)); } } 访问http://localhost:8081/item/10001，多次刷新，但日志只打印了一次sql，说明查的是缓存\n同理访问http://localhost:8081/item/stock/10001\nLua语法入门\r基础\r1.在Linux虚拟机的任意目录下，新建一-个hello.lua文件\n1 touch hello.lua 2.添加下面的内容\n1 print(\u0026#34;Hello World!\u0026#34;) 3.运行\n1 lua hello.lua 数据类型 描述 nil 这个最简单，只有值nil属于该类，表示一个无效值(在条件表达式中相当于false)。 boolean 包含两个值: false和true number 表示双精度类型的实浮点数 string 字符串由一对双引号或单引号来表示 function 由C或Lua编写的函数 table Lua中的表(table) 其实是一个\u0026quot;关联数组\u0026quot; (associative arrays)，数组的索引可以是数字、字符串或表类型。在Lua里，table的创建是通过\u0026quot;构造表达式\u0026quot;来完成，最简单构造表达式是{},用来创建一 个空表。 可以使用type关键字来判断变量的类型\n1 print(type(\u0026#34;hello\u0026#34;)) 声明变量\nlocal代表局部变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- 声明字符串 local str = \u0026#39;hello\u0026#39; -- 声明数字 local num = 21 -- 声明布尔类型 local flag = true -- 声明数组 key为索引的table local arr = {\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;go\u0026#39;} -- 声明table，类似于java中的map local map={ name = \u0026#39;jack\u0026#39; , gender = \u0026#39;男\u0026#39;} -- 访问数组，lua数组的角标从1开始 print(arr[1]) -- 访问table print(map[\u0026#39;name\u0026#39;]) print(map.name) -- 字符串拼接 local helloworld=\u0026#39;Hello \u0026#39; .. \u0026#39;World!\u0026#39; 遍历\n1 2 3 4 5 6 7 8 9 10 11 12 -- 遍历数组 local arr = {\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;go\u0026#39;} -- ipairs代表解析数组 for key,value in ipairs(arr) do print(key,value) end -- 遍历map local map={ name = \u0026#39;jack\u0026#39; , gender = \u0026#39;男\u0026#39;} -- 遍历table for key,value in pairs(map) do print(key,value) end 执行结果如下 函数\r定义函数的语法\n1 2 3 4 5 6 7 8 9 10 11 function 函数名(arg1,arg2...,arg3) -- 函数体 return 返回值 end -- 例如，定义一个函数 function printArr(arr) for key,value in ipairs(arr) do print(key,value) end end printArr({\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;go\u0026#39;}) 条件控制\r1 2 3 4 5 6 if(布尔表达式) then -- [为true时，执行的语句] else -- [为false时，执行的语句] end 逻辑操作符，and,or,not 如、A and B、A orB、not B\n1 2 3 4 5 6 7 8 9 10 11 12 function printArr(arr) if(not arr) then print(\u0026#39;参数不能为nil\u0026#39;) return nil end for key,value in ipairs(arr) do print(key,value) end end local lang={\u0026#39;java\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;go\u0026#39;} printArr(lang) printArr(nil) 多级缓存\rOpenRestry\r安装\r官网 OpenResty是-个基于Nginx的高性能Web平台，用于方便地搭建能够处理超高并发、扩展性极高的动态Web应用、Web服务和动态网关。具备下列特点:\n具备Nginx的完整功能 基于Lua语言进行扩展，集成了大量精良的Lua库、第三方模块 允许使用Lua自定义业务逻辑、自定义库 首先要安装OpenResty的依赖开发库，执行命令： 1 yum install -y pcre-devel openssl-devel gcc --skip-broken 安装OpenResty仓库\n1 yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo 如果提示说命令不存在，则运行：\n1 yum install -y yum-utils 然后再重复上面的命令 安装OpenResty 然后就可以像下面这样安装软件包，比如 openresty：\n1 yum install -y openresty 安装opm工具 opm是OpenResty的一个管理工具，可以帮助我们安装一个第三方的Lua模块。 如果你想安装命令行工具 opm，那么可以像下面这样安装 openresty-opm 包：\n1 yum install -y openresty-opm 配置nginx\n1 vi /etc/profile 在最下面加入两行：\n1 2 export NGINX_HOME=/usr/local/openresty/nginx export PATH=${NGINX_HOME}/sbin:$PATH NGINX_HOME：后面是OpenResty安装目录下的nginx的目录 然后让配置生效：\n1 source /etc/profile 所以运行方式与nginx基本一致：\n1 2 3 4 5 6 # 启动nginx nginx # 重新加载配置 nginx -s reload # 停止 nginx -s stop nginx的默认配置文件注释太多，影响后续我们的编辑，这里将nginx.conf中的注释部分删除，保留有效部分。 修改/usr/local/openresty/nginx/conf/nginx.conf文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #user nobody; worker_processes 1; error_log logs/error.log; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 8081; server_name localhost; location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 在Linux的控制台输入命令以启动nginx：\n1 nginx 然后访问页面：http://192.168.56.10:8081，注意ip地址替换为你自己的虚拟机IP： 入门\r访问http://localhost/item.html?id=10001商品详情页，发送的请求是http://localhost/api/item/10001 nginx在捕获到/api请求后，转给了虚拟机8081，而刚刚部署的OpenRestry在8081，这里OpenRestry需要做一些业务处理 步骤一:修改nginx.conf文件 1.在nginx.conf的http 下面，添加对OpenResty的Lua模块的加载:\n1 2 3 4 #加载lua模块 lua_package_path \u0026#34;/usr/local/openresty/lualib/?.lua;;\u0026#34;; #加载c模块 lua_package_cpath \u0026#34;/usr/local/openresty/lualib/?.so;;\u0026#34;; 2.在nginx.conf的server 下面，添加对/api/item这个路径的监听:\n1 2 3 4 5 6 location /api/item { #响应类型，这里返回json default_type application/json; #响应数据由lua/item.lua这个文件来决定 content_by_lua_file lua/item.lua; } 在nginx目录下新建文件夹lua lua目录下新建文件item.lua 编写如下内容 1 2 -- 返回一条假数据，这里的ngx.say()函数就是把数据写入Response中 ngx.say(\u0026#39;{\u0026#34;id\u0026#34;:10001,\u0026#34;name\u0026#34;:\u0026#34;普通行李箱\u0026#34;}\u0026#39;) 重新加载配置 1 nginx -s reload 可以看到lua脚本已经生效了\n请求参数\rOpenResty提供了各种API用来获取不同类型的请求参数: 案例 获取请求路径中的商品id信息，拼接到json结果中返回\n1 2 3 4 5 6 location ~ /api/item/(\\d+) { #响应类型，这里返回json default_type application/json; #响应数据由lua/item.lua这个文件来决定 content_by_lua_file lua/item.lua; } 封装http请求工具\r案例 这里要修改item.lua,满足下面的需求:\n获取请求参数中的id 根据id向Tomcat服务发送请求，查询商品信息 根据id向Tomcat服务发送请求，查询库存信息 组装商品信息、库存信息，序列化为JSON格式并返回 nginx发送http请求\n/path是指具体的请求路径，如/item/10001\n返回响应的内容包括\nresp.status 响应状态码 resp.header 响应头，是一个table resp.body 响应体，就是响应数据 1 2 3 4 5 6 7 8 local resp=ngx.location.capture(\u0026#39;/path\u0026#39;,{ -- 请求方式 method=ngx.HTTP_GET, -- get方式传参 args={a=1,b=2}, -- post方式传参 body=\u0026#34;c=3\u0026amp;d=4\u0026#34; }) 注意:这里的path是路径，并不包含IP和端口。这个请求会被nginx内部的server监听并处理。 但是我们希望这个请求发送到Tomcat服务器，所以还需要编写一个server来对这个路径做反向代理:\n1 2 3 location /item { proxy_pass http://192.168.56.1:8081; } 封装通用http请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- 封装函数，发送http请求 local function read_http(path,params) local resp=ngx.location.capture(path,{ method=ngx.HTTP_GET, args=params, }) if not resp then -- 记录错误信息，返回404 ngx.log(ngx.ERR,\u0026#34;http not found,path: \u0026#34;,path,\u0026#34;, args: \u0026#34;,args) ngx.exit(404) end return resp.body end -- 导出方法 local _M={ read_http=read_http } return _M 再次请求即可 咱先理一下请求的过程\n首先nginx里的html发送ajax请求http://localhost/api/item/10001 nginx反向代理给192.168.56.10:8081 而虚拟机的openresty由item.lua来处理这个请求 item.lua通过封装好的请求工具发送请求 而openresty本身也具有nginx的功能，将请求反向代理到windows主机上 后端接收到请求，响应数据 现在数据还不完整，还需要查询库存信息返回，此时只有商品信息\n需要将json数据转换成lua中的table(也就是DTO)\nOpenResty提供了一个cjson的模块用来处理JSON的序列化和反序列化。\n1 2 3 4 5 6 7 8 9 10 11 12 -- 导入cjson库 local cjson=require(\u0026#34;cjson\u0026#34;) -- 序列化 local obj={ name=\u0026#34;jack\u0026#34;, age=21 } local json=cjson.encode(obj) -- 反序列化 local json=\u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;jack\u0026#34;,\u0026#34;age\u0026#34;:21}\u0026#39; local obj=cjson.decode(json) print(obj.name) 编写item.lua\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 -- 导入cjson库 local cjson=require(\u0026#34;cjson\u0026#34;) -- 导入请求工具common -- 这里common.lua正好在lualib目录下，所以可以直接导入;如果不是，则需要写上路径 local common=require(\u0026#34;common\u0026#34;) local read_http=common.read_http -- 获取路径参数 local id=ngx.var[1] -- 查询商品信息 local itemJson=read_http(\u0026#34;/item/\u0026#34;..id,nil) -- 查询库存信息 local stockJson=read_http(\u0026#34;/item/stock/\u0026#34;..id,nil) -- dto转换 -- json数据转换成lua中的table local item=cjson.decode(itemJson) local stock=cjson.decode(stockJson) -- 组合数据 item.stock=stock.stock item.sold=stock.sold -- 返回结果 ngx.say(cjson.encode(item)) 重启OpenResty，再次查看请求，库存信息已经出现\n1 nginx -s reload Tomcat集群的负载均衡\r既然要配置负载均衡，那请求就不能只指向一个ip了，需要配置集群 **查询缓存过程:**查询8081，如果缓存存在则直接返回，如果不存在，在查询数据库之后，存入进程缓存中，下次即可从进程缓存获取数据 但是，进程缓存无法共享，就是8081的进程缓存无法与8082共享 我们希望查询商品id为10001在第一次查询之后永远都有缓存，该如何做？ 我们必须要让10001的请求每次都查询同一台服务器，这样就可以让缓存一直生效 修改nginx负载均衡算法\n对请求uri采用hash算法，使在请求相同的商品时能走到同一台服务器 配置集群 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #user nobody; worker_processes 1; error_log logs/error.log; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 加载lua模块 lua_package_path \u0026#34;/usr/local/openresty/lualib/?.lua;;\u0026#34;; # 加载c模块 lua_package_cpath \u0026#34;/usr/local/openresty/lualib/?.so;;\u0026#34;; upstream tomcat-cluster{ hash $request-uri; server 192.168.56.1:8081; server 192.168.56.1:8082; } server { listen 8081; server_name localhost; location /item { proxy_pass http://tomcat-cluster; } location ~ /api/item/(\\d+) { #响应类型，这里返回json default_type application/json; #响应数据由lua/item.lua这个文件来决定 content_by_lua_file lua/item.lua; } location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 继续复制一台Springboot实例，并启动 访问http://localhost/item.html?id=10002和http://localhost/item.html?id=10001\n负载均衡已实现，而在多次访问时，并没有mysql日志打印，说明是查询缓存得到的数据 添加Redis需求\r但是按照多级缓存的设想，并不是优先查询Tomcat，而是优先查询Redis，在Redis缓存未命中时，再去查询Tomcat\n冷启动与缓存预热\r冷启动:服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询 时添加缓存，可能会给数据库带来较大压力。 缓存预热:在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。 我们数据量较少，可以在启动时将所有数据都放入缓存中。\n使用Docker安装Redis\n1 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 添加Redis依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置Redis地址\n1 2 3 spring: redis: host: 192.168.56.10 编写Redis初始化类\n1 2 3 4 5 6 7 8 9 @Component public class RedisHandler implements InitializingBean { @Autowired private StringRedisTemplate template; @Override public void afterPropertiesSet() throws Exception { // 初始化缓存 } } 我的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 server: port: 8081 spring: application: name: itemservice datasource: url: jdbc:mysql://192.168.56.10:3307/heima?useSSL=false username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver redis: host: 192.168.56.10 port: 6379 mybatis-plus: type-aliases-package: com.heima.item.pojo configuration: map-underscore-to-camel-case: true global-config: db-config: update-strategy: not_null id-type: auto logging: level: com.heima: debug pattern: dateformat: HH:mm:ss:SSS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import com.fasterxml.jackson.databind.ObjectMapper; import com.heima.item.pojo.Item; import com.heima.item.pojo.ItemStock; import com.heima.item.service.IItemService; import com.heima.item.service.IItemStockService; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.stereotype.Component; import java.util.List; @Component public class RedisHandler implements InitializingBean { @Autowired private StringRedisTemplate template; @Autowired private IItemService itemService; @Autowired private IItemStockService stockService; // Spring自带的序列化工具 private static final ObjectMapper MAPPER = new ObjectMapper(); @Override public void afterPropertiesSet() throws Exception { // 初始化缓存 // 1.查询商品信息 List\u0026lt;Item\u0026gt; itemList = itemService.list(); // 2.存入缓存 for (Item item : itemList) { // 将item序列化成json String json = MAPPER.writeValueAsString(item); // 存入缓存 template.opsForValue().set(\u0026#34;item:id:\u0026#34;+item.getId(),json); } // 3.查询库存信息 List\u0026lt;ItemStock\u0026gt; stockList = stockService.list(); // 2.存入缓存 for (ItemStock stock : stockList) { // 将item序列化成json String json = MAPPER.writeValueAsString(stock); // 存入缓存 template.opsForValue().set(\u0026#34;item:stock:id:\u0026#34;+stock.getId(),json); } } } 访问http://localhost/item.html?id=10004界面，实现了缓存预热的功能 查询Redis缓存\rOpenResty优先查询Redis，Redis缓存未命中，再查询Tomcat OpenResty的Redis模块 OpenResty提供了操作Redis的模块，我们只要引入该模块就能直接使用: 引入Redis模块，并初始化Redis对象\n1 2 3 4 5 6 -- 引入redis模块 local redis = requirl(\u0026#34;resty.redis\u0026#34;) -- 初始化Redis对象 local red = redis:new( ) -- 设置Redis超时时间 red:set_timeouts(1000, 1000, 1000) 封装函数，用来释放Redis连接，其实是放入连接池\n1 2 3 4 5 6 7 8 9 10 11 -- 关闭redi s连接的工具方法，其实是放入连接池 local function close_redis(red) -- 连接的空闲时间，单位是毫秒 local pool_max_idle_time = 10000 -- 连接池大小 local pool_size = 100 local ok,err = red:set_keepalive(pool_max_idle_time,pool_size) if not ok then ngx.log(ngx.ERR，\u0026#34;放入Redis连接池失败: \u0026#34;,err) end end 封装函数，从Redis读数据并返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 -- 查询redis的方法ip和port是redi s地址，key是查询的key local function read_redis(ip, port, key) -- 获取一个连接 local ok，err = red:connect(ip,port) if not ok then ngx.log(ngx.ERR，\u0026#34;连接redis失败: \u0026#34;,err) return nil end -- 查询redis local resp, err = red:get(key) -- 查询失败处理 if not resp then ngx.log(ngx.ERR，\u0026#34;查询Redis失败: \u0026#34; ,err,\u0026#34;, key = \u0026#34;，key) end -- 查询成功，但是得到的数据为空 if resp == ngx.null then resp = nil ngx.log(ngx.ERR，\u0026#34;查询Redis数据为空， key = \u0026#34;,key) end close_redis(red) return resp end 在common.lua下处理如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 -- 导入redis local redis=require(\u0026#34;resty.redis\u0026#34;) -- 初始化redis local red=redis:new() red:set_timeouts(1000,1000,1000) -- 关闭redis连接的工具方法，其实是放入连接池 local function close_redis(red) local pool_max_idle_time = 10000 -- 连接的空闲时间，单位是毫秒 local pool_size = 100 --连接池大小 local ok, err = red:set_keepalive(pool_max_idle_time, pool_size) if not ok then ngx.log(ngx.ERR, \u0026#34;放入redis连接池失败: \u0026#34;, err) end end -- 查询redis的方法 ip和port是redis地址，key是查询的key local function read_redis(ip, port, key) -- 获取一个连接 local ok, err = red:connect(ip, port) if not ok then ngx.log(ngx.ERR, \u0026#34;连接redis失败 : \u0026#34;, err) return nil end -- 查询redis local resp, err = red:get(key) -- 查询失败处理 if not resp then ngx.log(ngx.ERR, \u0026#34;查询Redis失败: \u0026#34;, err, \u0026#34;, key = \u0026#34; , key) end --得到的数据为空处理 if resp == ngx.null then resp = nil ngx.log(ngx.ERR, \u0026#34;查询Redis数据为空, key = \u0026#34;, key) end close_redis(red) return resp end -- 封装函数，发送http请求 local function read_http(path,params) local resp=ngx.location.capture(path,{ method=ngx.HTTP_GET, args=params, }) if not resp then -- 记录错误信息，返回404 ngx.log(ngx.ERR,\u0026#34;http not found,path: \u0026#34;,path,\u0026#34;, args: \u0026#34;,args) ngx.exit(404) end return resp.body end -- 导出方法 local _M={ read_http=read_http, read_redis=read_redis } return _M 在item.lua下封装一个read_data函数，优先查询redis，redis未命中再查询tomcat\n查询商品和库存，都调用read_data函数\n1 2 3 4 5 6 7 8 9 10 11 -- 封装函数，先查询redis，再查询http local function read_data(key, path, par ams) -- 查询redis local resp = read_redis(\u0026#34;127.0.0.1\u0026#34;,6379,key) -- 判断redis是否命中 if not resp then -- Redis查询失败，查询http resp = read_http(path, par ams) end return resp end item.lua\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 -- 导入cjson库 local cjson=require(\u0026#34;cjson\u0026#34;) -- 导入请求工具common -- 这里common.lua正好在lualib目录下，所以可以直接导入;如果不是，则需要写上路径 local common=require(\u0026#34;common\u0026#34;) local read_http=common.read_http local read_redis=common.read_redis -- 封装查询函数 function read_data(key,path,params) -- 查询redis local resp=read_redis(\u0026#34;127.0.0.1\u0026#34;,6379,key) -- 判断查询结果 if not resp then -- redis查询失败，尝试查询tomcat ngx.log(\u0026#34;redis查询失败，尝试查询tomcat：\u0026#34;,key) resp=read_http(path,params) end return resp end -- 获取路径参数 local id=ngx.var[1] -- 查询商品信息 local itemJson=read_data(\u0026#34;item:id:\u0026#34;..id , \u0026#34;/item/\u0026#34;..id , nil) -- 查询库存信息 local stockJson=read_data(\u0026#34;item:stock:id:\u0026#34;..id , \u0026#34;/item/stock/\u0026#34;..id , nil) -- dto转换 -- json数据转换成lua中的table local item=cjson.decode(itemJson) local stock=cjson.decode(stockJson) -- 组合数据 item.stock=stock.stock item.sold=stock.sold -- 返回结果 ngx.say(cjson.encode(item)) 更新Redis数据，重新查看网页，发现已经变成22寸了 Nginx本地缓存\r优先查询OpenResty本地缓存，其次是Redis，最后是Tomcat\nOpenResty为Nginx提供了shard dict的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。\n开启共享字典，在nginx.conf的http下添加配置 1 2 # 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m lua_shared_dict item_cache 150m; 操作共享字典 1 2 3 4 5 6 -- 获取本地缓存对象 local item_cache=ngx.shared.item_cache -- 存储，指定key、value、过期时间，单位s，默认为0代表永不过期 item_cache:set(\u0026#39;key\u0026#39;,\u0026#39;value\u0026#39;,1000) -- 读取 local val=item_cache:get(\u0026#39;key\u0026#39;) 修改item.lua，优先查询nginx本地缓存，其次是redis、tomcat、mysql\n查询Redis、Tomcat成功后，将缓存信息写入本地缓存，并设置有效期\n商品基本信息设置为有效期30min\n库存信息设置为有效期1min\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 -- 导入cjson库 local cjson=require(\u0026#34;cjson\u0026#34;) -- 导入请求工具common -- 这里common.lua正好在lualib目录下，所以可以直接导入;如果不是，则需要写上路径 local common=require(\u0026#34;common\u0026#34;) local read_http=common.read_http local read_redis=common.read_redis local item_cache=ngx.shared.item_cache -- 封装查询函数 function read_data(key,expire,path,params) -- 查询本地缓存 local val=item_cache:get(key) if not val then ngx.log(ngx.ERR,\u0026#34;本地缓存查询失败，尝试查询redis，key:\u0026#34;,key) -- 查询redis val=read_redis(\u0026#34;127.0.0.1\u0026#34;,6379,key) -- 判断查询结果 if not val then -- redis查询失败，尝试查询tomcat ngx.log(ngx.ERR,\u0026#34;redis查询失败，尝试查询tomcat，key:\u0026#34;,key) val=read_http(path,params) end end -- 查询成功，把数据写入本地缓存 item_cache:set(key,val,expire) return val end -- 获取路径参数 local id=ngx.var[1] -- 查询商品信息 local itemJson=read_data(\u0026#34;item:id:\u0026#34;..id,1800,\u0026#34;/item/\u0026#34;..id,nil) -- 查询库存信息 local stockJson=read_data(\u0026#34;item:stock:id:\u0026#34;..id,60,\u0026#34;/item/stock/\u0026#34;..id,nil) -- dto转换 -- json数据转换成lua中的table local item=cjson.decode(itemJson) local stock=cjson.decode(stockJson) -- 组合数据 item.stock=stock.stock item.sold=stock.sold -- 返回结果 ngx.say(cjson.encode(item)) 缓存同步\r缓存数据同步的常见方式有三种:\n设置有效期:给缓存设置有效期，到期后自动删除。再次查询时更新 优势:简单、方便 缺点:时效性差，缓存过期之前可能不-致 场景:更新频率较低，时效性要求低的业务 同步双写: 在修改数据库的同时，直接修改缓存 优势:时效性强，缓存与数据库强一致 缺点:有代码侵入,耦合度高; 场景:对一致性、时效性要求较高的缓存数据 异步通知:修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据 优势:低耦合，可以同时通知多个缓存服务 缺点:时效性一般，可能存在中间不一致状态 场景:时效性要求-般，有多个服务需要同步 基于MQ的异步通知 基于Canal的异步通知 Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下:\nMySQL master将数据变更写入二进制日志( binary log)，其中记录的数据叫做binary log events MySQL slave将master的binary log events拷贝到它的中继日志(relay log) MySQL slave重放relay log中事件,将数据变更反映它自己的数据 初识Canal\rCanal就是把自己伪装成MySQL的一个slave节 点,从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。 开启MySQL主从\r修改配置文件\n1 /tmp/mysql/conf/my.cnf 添加内容\n1 2 log-bin=/var/lib/mysql/mysql-bin binlog-do-db=heima 重启mysql\n1 docker restart mysql-demo 设置用户权限\r接下来添加一个用于数据同步的用户，出于安全的考虑，这里仅提供对heima这个库的操作权限\n1 2 3 create user canal@\u0026#39;%\u0026#39; IDENTIFIED by \u0026#39;canal\u0026#39;; GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO \u0026#39;canal\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;canal\u0026#39;; FLUSH PRIVILEGES; 执行成功后，查看到该用户 如果从库的position小于主库的position，则证明有数据需要同步\n创建网络\r我们需要创建一个网络，将MySQL、Canal、MQ放到同一个Docker网络中：\n1 docker network create heima 让mysql加入这个网络：\n1 docker network connect heima mysql-demo 然后运行命令创建Canal容器：\n1 2 3 4 5 6 7 8 9 10 11 docker run -p 11111:11111 --name canal \\ -e canal.destinations=heima \\ -e canal.instance.master.address=mysql-demo:3306 \\ -e canal.instance.dbUsername=canal \\ -e canal.instance.dbPassword=canal \\ -e canal.instance.connectionCharset=UTF-8 \\ -e canal.instance.tsdb.enable=true \\ -e canal.instance.gtidon=false \\ -e canal.instance.filter.regex=heima\\\\..* \\ --network heima \\ -d canal/canal-server:v1.1.5 说明:\n-p 11111:11111：这是canal的默认监听端口 -e canal.instance.master.address=mysql:3306：数据库地址和端口，如果不知道mysql容器地址，可以通过docker inspect 容器id来查看 -e canal.instance.dbUsername=canal：数据库用户名 -e canal.instance.dbPassword=canal ：数据库密码 -e canal.instance.filter.regex=：要监听的表名称 表名称监听支持的语法： 1 2 3 4 5 6 7 8 mysql 数据解析关注的表，Perl正则表达式. 多个正则之间以逗号(,)分隔，转义符需要双斜杠(\\\\) 常见例子： 1. 所有表：.* or .*\\\\..* 2. canal schema下所有表： canal\\\\..* 3. canal下的以canal打头的表：canal\\\\.canal.* 4. canal schema下的一张表：canal.test1 5. 多个规则组合使用然后以逗号隔开：canal\\\\..*,mysql.test1,mysql.test2 查看是否互联成功\n1 2 3 4 docker exec -it canal /bin/bash # 查看运行日志 more /home/admin/canal-server/logs/canal/canal.log more /home/admin/canal-server/logs/heima/heima.log 监听Canal实现缓存同步\r导入依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;top.javatool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;canal-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.1-RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写配置\n1 2 3 4 5 canal: # canal实例名称，要跟canal-server运行时设置的destination一致 destination: heima # canal地址 server: 192.168.56.10:11111 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import com.heima.item.pojo.Item; import org.springframework.stereotype.Component; import top.javatool.canal.client.annotation.CanalTable; import top.javatool.canal.client.handler.EntryHandler; @Component @CanalTable(\u0026#34;tb_item\u0026#34;) public class ItemHandler implements EntryHandler\u0026lt;Item\u0026gt; { @Override public void insert(Item item) { // 新增数据到redis } @Override public void update(Item before, Item after) { // 更新redis数据 // 更新本地数据 } @Override public void delete(Item item) { // 删除redis数据 // 清理本地缓存 } } 此时Canal还无法将表的字段映射到对应的DTO，需要添加Canal的注解进行指定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import lombok.Data; import org.springframework.data.annotation.Id; import org.springframework.data.annotation.Transient; import java.util.Date; @Data @TableName(\u0026#34;tb_item\u0026#34;) public class Item { /** * 商品id */ @TableId(type = IdType.AUTO) @Id private Long id; /** * 商品名称 */ private String name; /** * 商品标题 */ private String title; /** * 价格（分） */ private Long price; /** * 商品图片 */ private String image; /** * 分类名称 */ private String category; /** * 品牌名称 */ private String brand; /** * 规格 */ private String spec; /** * 商品状态 1-正常，2-下架 */ private Integer status; /** * 创建时间 */ private Date createTime; /** * 更新时间 */ private Date updateTime; @Transient @TableField(exist = false) private Integer stock; @Transient @TableField(exist = false) private Integer sold; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @Component public class RedisHandler implements InitializingBean { @Autowired private StringRedisTemplate template; @Autowired private IItemService itemService; @Autowired private IItemStockService stockService; private static final ObjectMapper MAPPER = new ObjectMapper(); @Override public void afterPropertiesSet() throws Exception { // 初始化缓存 // 1.查询商品信息 List\u0026lt;Item\u0026gt; itemList = itemService.list(); // 2.存入缓存 for (Item item : itemList) { // 将item序列化成json String json = MAPPER.writeValueAsString(item); // 存入缓存 template.opsForValue().set(\u0026#34;item:id:\u0026#34;+item.getId(),json); } // 3.查询库存信息 List\u0026lt;ItemStock\u0026gt; stockList = stockService.list(); // 2.存入缓存 for (ItemStock stock : stockList) { // 将item序列化成json String json = MAPPER.writeValueAsString(stock); // 存入缓存 template.opsForValue().set(\u0026#34;item:stock:id:\u0026#34;+stock.getId(),json); } } /** * 保存项目 * * @param item 项目 */ public void saveItem(Item item){ // 将item序列化成json String json = null; try { json = MAPPER.writeValueAsString(item); } catch (JsonProcessingException e) { throw new RuntimeException(e); } template.opsForValue().set(\u0026#34;item:id:\u0026#34;+item.getId(),json); } /** * 按 ID 删除项目 * * @param id */ public void removeItemById(Long id){ template.delete(\u0026#34;item:id:\u0026#34;+id); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import com.github.benmanes.caffeine.cache.Cache; import com.heima.item.config.RedisHandler; import com.heima.item.pojo.Item; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import top.javatool.canal.client.annotation.CanalTable; import top.javatool.canal.client.handler.EntryHandler; @Slf4j @Component @CanalTable(\u0026#34;tb_item\u0026#34;) public class ItemHandler implements EntryHandler\u0026lt;Item\u0026gt; { @Autowired private RedisHandler redisHandler; @Autowired private Cache\u0026lt;Long,Item\u0026gt; itemCache; @Override public void insert(Item item) { // 新增数据到JVM进程缓存 log.info(\u0026#34;新增数据到JVM进程缓存\u0026#34;); itemCache.put(item.getId(),item); // 新增数据到redis log.info(\u0026#34;新增数据到redis\u0026#34;); redisHandler.saveItem(item); } @Override public void update(Item before, Item after) { // 更新JVM进程缓存 log.info(\u0026#34;更新JVM进程缓存\u0026#34;); itemCache.put(after.getId(),after); // 更新redis数据 log.info(\u0026#34;更新redis数据\u0026#34;); redisHandler.saveItem(after); } @Override public void delete(Item item) { // 删除JVM进程缓存 log.info(\u0026#34;删除JVM进程缓存\u0026#34;); itemCache.invalidate(item.getId()); // 删除redis数据 log.info(\u0026#34;删除redis数据\u0026#34;); redisHandler.removeItemById(item.getId()); } } 访问http://localhost:8081/进行后台管理，修改数据后，访问http://localhost:8081/item/10001和redis发现数据已经修改\n","date":"2024-06-01T00:00:00Z","image":"http://localhost:1313/p/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu4898064707681593350.jpg","permalink":"http://localhost:1313/p/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/","title":"多级缓存"},{"content":"谷粒商城\r创建模块\rgulimall-product gulimall-order gulimall-ware gulimall-coupon gulimall-member 创建数据库\rgulimall_pms(商品) gulimall_oms(订单) gulimall_sms(营销) gulimall_ums(用户) gulimall_wms(库存) 人人开源\rnpm使用10.16.3版本 代码生成器链接 后端链接 前端链接\n","date":"2024-06-01T00:00:00Z","image":"http://localhost:1313/p/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu4898064707681593350.jpg","permalink":"http://localhost:1313/p/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/","title":"谷粒商城"},{"content":"Redis\r单点Redis的问题\r数据丢失问题 Redis是内存存储，服务重启可能会丢失数据 并发能力问题 单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景 故障恢复问题 如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段 存储能力问题 Redis基于内存，单节点能存储的数据量难以满足海量数据需求 解决方案\n数据丢失问题 实现Redis数据持久化 并发能力问题 搭建主从集群，实现读写分离(提高并发能力，实现高可用，进一步避免宕机导致的数据丢失) 故障恢复问题 利用Redis哨兵，实现健康检测和自动恢复 存储能力问题 搭建分片集群，利用插槽机制实现动态扩容 Redis持久化\rRDB\rRDB全称Redis Database Backup file ( Redis数据备份文件)，也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件,恢复数据。\n快照文件称为RDB文件，默认是保存在当前运行目录。\n1 2 3 4 5 6 redis-cli # 由Redis主进程来执行RDB，会阻塞其他命令 # 而将数据备份到磁盘中的速度又很慢，不推介这种方法 save # 子进程在后台异步执行RDB，避免主进程受到影响 bgsave Redis停机时，会自动进行一次RDB备份\n1 2 3 4 5 6 7 8 9 10 11 C:\\Users\\Administrator\u0026gt;redis-cli # 测试redis连接 127.0.0.1:6379\u0026gt; ping PONG # 存数据 127.0.0.1:6379\u0026gt; set num 123 OK # 取数据 127.0.0.1:6379\u0026gt; get num \u0026#34;123\u0026#34; 127.0.0.1:6379\u0026gt; 停止Redis，日志打印如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 D:\\Redis\u0026gt;redis-server.exe redis.windows.conf _._ _.-``__ \u0026#39;\u0026#39;-._ _.-`` `. `_. \u0026#39;\u0026#39;-._ Redis 3.0.504 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ \u0026#39;\u0026#39;-._ ( \u0026#39; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|\u0026#39;` _.-\u0026#39;| Port: 6379 | `-._ `._ / _.-\u0026#39; | PID: 3204 `-._ `-._ `-./ _.-\u0026#39; _.-\u0026#39; |`-._`-._ `-.__.-\u0026#39; _.-\u0026#39;_.-\u0026#39;| | `-._`-._ _.-\u0026#39;_.-\u0026#39; | http://redis.io `-._ `-._`-.__.-\u0026#39;_.-\u0026#39; _.-\u0026#39; |`-._`-._ `-.__.-\u0026#39; _.-\u0026#39;_.-\u0026#39;| | `-._`-._ _.-\u0026#39;_.-\u0026#39; | `-._ `-._`-.__.-\u0026#39;_.-\u0026#39; _.-\u0026#39; `-._ `-.__.-\u0026#39; _.-\u0026#39; `-._ _.-\u0026#39; `-.__.-\u0026#39; [3204] 15 Apr 21:11:30.427 # Server started, Redis version 3.0.504 [3204] 15 Apr 21:11:30.443 * DB loaded from disk: 0.000 seconds [3204] 15 Apr 21:11:30.443 * The server is now ready to accept connections on port 6379 [3204] 15 Apr 21:12:39.581 # User requested shutdown... [3204] 15 Apr 21:12:39.581 * Saving the final RDB snapshot before exiting. [3204] 15 Apr 21:12:39.581 * DB saved on disk [3204] 15 Apr 21:12:39.581 # Redis is now ready to exit, bye bye... 这里有一句Saving the final RDB snapshot before exiting.\nRedis将文件保存在运行目录中\n我这是windows系统，如果是linux则使用ls、ll 但是我们担心如果突然宕机还没来得及持久化怎么办，我们更加希望隔一段时间持久化一次\nRedis内部有触发RDB的机制，可以在redis.conf文件中找到， 格式如下:\n1 2 3 4 5 # 900秒内，如果至少一个key被修改，则执行bgsave # 如果是save \u0026#34;\u0026#34; 则表示禁用Redis save 900 1 save 300 10 save 60 10000 RDB的其他配置也可以在配置文件中设置\n1 2 3 4 5 6 # 是否压缩，建议不开启，压缩也会消耗CPU，磁盘不值钱 rdbcompression yes # RDB文件名称 dbfilename dump.rdb # 文件保存的路径 dir ./ bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。 fork采用的是copy-on-write技术: 当主进程执行读操作时,访问共享内存; 当主进程执行写操作时，则会拷贝一份数据，执行写操作。 总结\rRDB方式bgsave的基本流程?\nfork主进程得到一-个子进程，共享内存空间 子进程读取内存数据并写入新的RDB文件 用新RDB文件替换旧的RDB文件。 RDB会在什么时候执行? save 60 1000代表什么含义? 默认是服务停止时。 代表60秒内至少执行1000次修改则触发RDB RDB的缺点? RDB执行间隔时间长，两次RDB之间写入数据有丟失的风险 fork子进程、压缩、写出RDB文件都比较耗时 AOF\rAOF全称为Append Only File ( 追加文件)。Redis处理的每-一个写命令都会记录在AOF文件，可以看做是命令日志文件。\n如果需要恢复数据，将日志文件里的命令全部执行一遍即可 AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF:\n1 2 3 4 # 是否开启A0F功能，默认是no appendonly no # AOF文件的名称 appendfilename \u0026#34;appendonly.aof\u0026#34; AOF的命令记录的频率也可以通过redis.conf文件来配:\n1 2 3 4 5 6 # 表示每执行一次写命令，立即记录到AOF文件 appendfsync always # 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案 appendfsync everysec # 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘 appendfsync no 由于AOF记录的是命令操作，而不是直接记录值，所以会比RDB文件大很多 因为是记录命令, AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一-次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。 Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置:\n1 2 3 4 # AOF文件比上次文件增长超过多少百分比则触发重写 auto-aof-rewrite-percentage 100 # AOF文件体积最小多大以上才触发重写 auto-aof-rewrite-min-size 64mb RDB和AOF各有自己的优缺点，如果对数据安全性要求较高,在实际开发中往往会结合两者来使用。 Redis主从\r单节点Redis的并发能力是有上限的，要近一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。 开启RDB，关闭AOF\n一主二从 A（B、C） 一个master两个slave/replica\n1 2 3 4 5 6 # 禁用RDB # save \u0026#34;\u0026#34; save 900 1 save 300 10 save 60 10000 appendonly no windows\rwindows配置redis集群查看该博客\n主节点 从节点 从节点只能读数据，不能写数据 关闭主节点后，从节点的状态 重启主节点后，从节点的状态 linux\r接下来演示docker配置redis集群，参考博客链接 可以看到本地已经拉取了redis镜像 在/root目录下新建一个redis.conf文件和data目录 data用以存储redis持久化文件，redis.conf作为redis的配置文件，这里配置主从集群，所以需要新建三个conf和data，目录及文件如下 redis-7001.conf下载链接\n启动容器，这里使用7001作为端口号\n1 2 3 4 5 6 docker run --name redis-master \\ -v /root/redis/redis-7001.conf:/etc/redis/redis.conf \\ -v /root/redis/data:/data \\ -dp 7001:6379 \\ redis:latest \\ redis-server /etc/redis/redis.conf 配置文件直接复制7001即可，反正将来也是以容器为单位启动，不会造成端口冲突，但是虚拟机(宿主机)的端口映射则不能都写7001了\n7001端口已经被master占据了，剩下两个slave使用7002、7003\n修改对应的持久化目录 redis-7001.conf文件中添加如下配置\n1 2 slave-announce-ip 192.168.56.10 slave-announce-port 7001 redis-7002.conf、redis-7003.conf也是一样\n1 2 slave-announce-ip 192.168.56.10 slave-announce-port 7002 1 2 slave-announce-ip 192.168.56.10 slave-announce-port 7003 启动slave\n在启动 slave 的命令中需要指出其 slaveof 于谁，这种是临时方案，重启失效\n永久方案是在conf文件中配置slaveof \u0026lt;master_ip\u0026gt; \u0026lt;master_port\u0026gt;\nredis5.0之后新增replicaof效果和slaveof 一样\n1 2 3 4 5 6 docker run --name redis-slave1 \\ -v /root/redis/redis-7002.conf:/etc/redis/redis.conf \\ -v /root/redis/data:/data \\ -dp 7002:6379 \\ redis:latest \\ redis-server /etc/redis/redis.conf --slaveof 192.168.56.10 7001 1 2 3 4 5 6 docker run --name redis-slave2 \\ -v /root/redis/redis-7003.conf:/etc/redis/redis.conf \\ -v /root/redis/data:/data \\ -dp 7003:6379 \\ redis:latest \\ redis-server /etc/redis/redis.conf --slaveof 192.168.56.10 7001 关系查看\n1 docker exec -it redis-master redis-cli info replication 1 docker exec -it redis-slave1 redis-cli info replication 1 docker exec -it redis-slave2 redis-cli info replication slave1 slave2 此时停止master\n1 docker stop redis-master 尝试向slave中写入数据\n1 2 3 docker exec -it redis-slave1 /bin/bash redis-cli set name tigerhhzz11 向master中写入数据，在slave中读出 数据同步原理\r步骤\r主从第一次同步是全量同步 master怎么知道slave是否是第一次请求数据呢？这里会用到两个很重要的概念:\nReplication id:简称replid, 是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid,slave则会继承master节点的replid\noffset:偏移量,随着记录在repl_baklog 中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset,说明slave数据落后于master,需要更新。\n因此slave做数据同步,必须向master声明自己的replication id和offset, master才可以判断到底需要同步哪些数据\nmaster需要根据replid判断slave节点是否是第一次来做数据同步，replid不一致就是第一次做数据同步 查看容器日志 可以查看容器日志，数据同步步骤请看总结\n1 docker logs redis-master 1 docker logs redis-slave1 1 docker logs redis-slave2 总结\rslave节点请求增量同步 master节点判断replid,发现不一致, 拒绝增量同步 master将完整内存数据生成RDB，发送RDB到slave slave清空本地数据，加载master的RDB master将RDB期间的命令记录在repl_baklog,并持续将log中的命令发送给slave slave执行接收到的命令，保持与master之间的同步 增量同步\r主从第一次同步是全量同步,但如果slave重启后同步，则执行增量同步 repl_baklog本质是一个环形数组，slave与master数据之间的差异=master-slave（图中红色线段的部分）\n当数据记完一圈后，会覆盖掉上次的内容继续往下记载，slave也会继续跟着master往后同步数据\n但是这样就存在无法进行增量同步的情况\nrepl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致数据被覆盖,则无法实现增量同步，只能再次全量同步。\n如果master已经覆盖掉上一次的内容，开始记入第二圈的数据，而slave由于某种原因宕机，导致master覆盖的数据并没有同步完成 此时就只能做全量同步了，无法进行增量同步\n应当尽可能的减少全量同步，因为它的性能较差。或许可以进一步优化全量同步的性能\n可以从以下几个方面来优化Redis主从就集群:\n在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。\n(避免磁盘读写，采用网络传输，适用于磁盘较慢、网络较快的情况)\nRedis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO\n适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复,尽可能避免全量同步\n限制一个master上的slave节点数量，如果实在是太多slave,则可以采用主-从-从链式结构，减少master压力 总结\r简述全量同步和增量同步区别?\n全量同步: master将完整 内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_ baklog, 逐个发送给slave。 增量同步: slave提交自己的offset到master, master获取repl_ baklog中 从offset之后的命令给slave 什么时候执行全量同步? slave节点第一次连接master节点时 slave节点断开时间太久，repl_baklog中的offset已经被覆盖时 什么时候执行增量同步? slave节点断开又恢复,并且在repl_baklog中 能找到offset时 Redis哨兵\r哨兵的作用和工作原理\rslave节点宕机恢复后可以找master节点同步数据，如果master节点宕机怎么办?\nmaster节点如果宕机，那么此时用户无法进行redis数据写入的操作，可用性下降了\n我们需要去监控集群中的节点状态，在master节点挂掉之后，选一个新的master，增进挂掉的master重启后，作为slave Redis提供了哨兵(Sentinel) 机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下: 监控: Sentinel 会不断检查您的master和slave是否按预期工作 自动故障恢复:如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主 通知: Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端 服务状态监控\rSentinel基于心跳机制监测服务状态,每隔1秒向集群的每个实例发送ping命令:\n主观下线:如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。 客观下线:若超过指定数量( quorum)的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。 选举新的master\r一旦发现master故障，sentinel需 要在salve中选择- -一个作为新的master,选择依据是这样的:\n首先会判断slave节点与master节点断开时间长短，如果超过指定值( down-after-milliseconds * 10)则会排除该slave节点 然后判断slave节点的slave-priority值, 越小优先级越高，如果是0则永不参与选举 如果slave-prority一样，则判断slave节点的effset值， 越大说明数据越新，优先级越高 最后是判断slave节点的运行id大小，越小优先级越高。 实现故障转移\r当选中了其中一个slave为新的master后(例如slave1)，故障的转移的步骤如下:\nsentinel给 备选的slave1节点发送slaveof no one命令,让该节点成为master sentinel给所有其它slave发送slaveof 192.168.150.101 7002命令，让这些slave成为新master的从节点，开始从新的master上同步数据。 最后，sentinel将故障节点标记为slave,当故障节点恢复后会自动成为新的master的slave节点 总结\rSentinel的三个作用是什么?\n监控 故障转移 通知 Sentinel如何判断一个redis实例是否健康? 每隔1秒发送一次ping命令，如果超过一定时间没有 相向则认为是主观下线 如果大多数sentinel都认为实例主观下线，则判定服务下线 故障转移步骤有哪些? 首先选定一个slave作为新的master,执行slaveof no one 然后让所有节点都执行slaveof 新master 修改故障节点配置，添加slaveof 新master 搭建哨兵集群\r手动创建sentinel下的s1、s2、s3，然后配置sentinel.conf文件 1 2 3 4 5 port 27001 sentinel announce-ip 192.168.56.10 sentinel monitor redis-master 192.168.56.10 7001 2 sentinel down-after-milliseconds redis-master 5000 sentinel failover-timeout redis-master 60000 解读：\nport 27001：是当前sentinel实例的端口 sentinel monitor redis-master192.168.56.10 7001 2：指定主节点信息 redis-master：主节点名称，自定义，任意写 192.168.56.10 7001：主节点的ip和端口 2：选举master时的quorum值 启动sentinel的jar包 启动三个sentinel容器\n1 2 3 4 5 docker run --name sentinel-1 \\ -v /root/redis/sentinel/sentinel1.conf:/etc/redis/sentinel.conf \\ -dp 27001:26379 \\ redis:latest \\ redis-sentinel /etc/redis/sentinel.conf 1 2 3 4 5 docker run --name sentinel-2 \\ -v /root/redis/sentinel/sentinel2.conf:/etc/redis/sentinel.conf \\ -dp 27002:26379 \\ redis:latest \\ redis-sentinel /etc/redis/sentinel.conf 1 2 3 4 5 docker run --name sentinel-3 \\ -v /root/redis/sentinel/sentinel3.conf:/etc/redis/sentinel.conf \\ -dp 27003:26379 \\ redis:latest \\ redis-sentinel /etc/redis/sentinel.conf 关系查看\n1 docker exec -it sentinel-1 redis-cli -h 192.168.56.10 -p 27001 info sentinel 注意目录对应关系，如果在运行容器时，将conf路径写错了，则可能出现如下情况 此时停止redis-master节点，查看sentinel日志\n1 2 docker stop redis-master docker logs sentinel-1 解决办法，直接挂载整个目录，而不是只挂载某个conf文件，注意权限设置为777，目录和文件都要设置\nchmod 777 -R \u0026lt;file\u0026gt; 1 2 3 4 5 docker run --name sentinel-1 \\ -v /root/redis/sentinel/s1:/etc/redis \\ -dp 27001:26379 \\ redis:latest \\ redis-sentinel /etc/redis/sentinel.conf 1 2 3 4 5 docker run --name sentinel-2 \\ -v /root/redis/sentinel/s2:/etc/redis \\ -dp 27002:26379 \\ redis:latest \\ redis-sentinel /etc/redis/sentinel.conf 1 2 3 4 5 docker run --name sentinel-3 \\ -v /root/redis/sentinel/s3:/etc/redis \\ -dp 27003:26379 \\ redis:latest \\ redis-sentinel /etc/redis/sentinel.conf 但是日志打印还有一个警告 1:X 21 Apr 2024 23:33:24.072 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128. 解决办法\n1 vim /etc/sysctl.conf 文件新增如下内容\n1 2 net.core.somaxconn = 1024 vm.overcommit_memory = 1 添加完成后，刷新内核参数，立即生效\n1 /sbin/sysctl -p 但是我这里并没有生效，所以采用如下方法\n1 2 3 4 5 docker run --name sentinel-1 --sysctl net.core.somaxconn=1024 \\ -v /root/redis/sentinel/s1:/etc/redis \\ -dp 27001:26379 \\ redis:latest \\ redis-sentinel /etc/redis/sentinel.conf 1 2 3 4 5 docker run --name sentinel-2 --sysctl net.core.somaxconn=1024 \\ -v /root/redis/sentinel/s2:/etc/redis \\ -dp 27002:26379 \\ redis:latest \\ redis-sentinel /etc/redis/sentinel.conf 1 2 3 4 5 docker run --name sentinel-3 --sysctl net.core.somaxconn=1024 \\ -v /root/redis/sentinel/s3:/etc/redis \\ -dp 27003:26379 \\ redis:latest \\ redis-sentinel /etc/redis/sentinel.conf 问题已经解决 停掉redis-master\n查看sentinel日志\n1 docker logs sentinel-3 查看redis节点状态，发现7003确实成为master了\n1 docker exec -it redis-slave2 redis-cli info replication 重启7001，发现原来的master变成slave了 RedisTemplate的哨兵模式\r新建项目，导入依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 server: port: 8080 logging: level: io.lettuce.core: debug pattern: dateformat: yyyy-MM-dd HH:mm:ss:SSS spring: data: redis: sentinel: # 指定master 节点名称 master: mymaster # 指定redis-sentinel集群信息 nodes: - 192.168.56.10:27001 - 192.168.56.10:27002 - 192.168.56.10:27003 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RestController public class TestController { private StringRedisTemplate redisTemplate; @Autowired public TestController(StringRedisTemplate redisTemplate) { this.redisTemplate = redisTemplate; } @GetMapping(\u0026#34;/get/{key}\u0026#34;) public String get(@PathVariable String key) { return redisTemplate.opsForValue().get(key); } @GetMapping(\u0026#34;/set/{key}/{value}\u0026#34;) public String set(@PathVariable String key,@PathVariable String value) { redisTemplate.opsForValue().set(key,value); return \u0026#34;success\u0026#34;; } } 配置Redis读写分离\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @SpringBootApplication public class RedisDemoApplication { public static void main(String[] args) { SpringApplication.run(RedisDemoApplication.class, args); } /** * 配置Redis的读写策略，实现master写入、slave读取(读写分离 * MASTER:从主节点读取 * MASTER_PREFERRED: 优先从master节点读取，master不可用才读取replica * REPLICA:从slave (replica) 节点读取 * REPLICA_PREFERRED: 优先从slave (replica) 节点读取，所有的slave都不可用才读取master) * * @return {@link LettuceClientConfigurationBuilderCustomizer} */ @Bean public LettuceClientConfigurationBuilderCustomizer configurationBuilderCustomizer(){ return clientConfigurationBuilder -\u0026gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED); } } 报错io.lettuce.core.RedisCommandExecutionException: ERR No such master with that name\n名称改为redis-master，与sentinel.conf文件中的配置保持一致 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 server: port: 8080 logging: level: io.lettuce.core: debug pattern: dateformat: yyyy-MM-dd HH:mm:ss:SSS spring: data: redis: sentinel: # 指定master 节点名称 master: redis-master # 指定redis-sentinel集群信息 nodes: - 192.168.56.10:27001 - 192.168.56.10:27002 - 192.168.56.10:27003 访问http://localhost:8080/get/name(得有一个叫name的数据) 可以看到这里通过7002来获取数据 访问http://localhost:8080/set/name/333 可以看到这里通过7003来设置数据 重启redis-slave2\n1 docker restart redis-slave2 此时slave1(7002)被选为master 7003为replica 使用idea连接虚拟机\nDeployment-\u0026gt;Configuration 新建SFTP 查看虚拟机文件\nDeployment-\u0026gt;Browse Remote Host 右侧就可以看到虚拟机的文件信息了 打开命令窗口\n点击Tools-\u0026gt;Start SSH Session Redis分片集群\r我们知道单节点的Redis内存不要设置过高，在内存的持久化或者数据同步的时候会导致大量的IO，性能会下降\n但是如果内存降低之后无法存储海量的数据怎么办？\n解决了高并发读，高并发写怎么解决？\n分片集群结构\r主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决:\n海量数据存储问题 高并发写的问题 使用分片集群可以解决.上述问题，分片集群特征: 集群中有多个master,每个master保存不同数据 每个master都可以有多个slave节点 master之间通过ping监测彼此健康状态 客户端请求可以访问集群任意节点，最终都会被转发到正确节点 此时不再需要哨兵机制了，master节点之间可以互相监控各自的状态\n集群结构如下表所示\n序号 角色 容器名称 网络模式 地址及端口 1 master master-cluster-1 host 192.168.56.10:8001 2 master master-cluster-2 host 192.168.56.10:8002 3 master master-cluster-3 host 192.168.56.10:8003 4 slave slave-cluster-1 host 192.168.56.10:9001 5 slave slave-cluster-2 host 192.168.56.10:9002 6 slave slave-cluster-3 host 192.168.56.10:9003 在/root/redis-cluster下新建配置文件redis.conf 并打开以下两处的注释\n1 2 3 4 # 开启 cluster 功能，即分布式系统功能 cluster-enabled yes # 指定其需要的配置文件名称 cluster-config-file nodes-6379.conf 重命名redis.conf为redis1.conf，并复制成其他五份redis2.conf、redis3.conf、redis4.conf、redis5.conf、redis6.conf\n这6份配置文件内容完全相同\n更改文件之后记得上传 停止之前运行的redis、sentinel容器\n1 docker stop redis-master redis-slave1 redis-slave2 sentinel-1 sentinel-2 sentinel-3 1 2 3 4 5 6 docker run --name master-cluster-1 \\ --network host \\ -v /root/redis-cluster/redis1.conf:/etc/redis/redis.conf \\ -v /root/redis-cluster/data/8001:/data \\ -d redis:latest redis-server /etc/redis/redis.conf \\ --port 8001 1 2 3 4 5 6 docker run --name master-cluster-2 \\ --network host \\ -v /root/redis-cluster/redis2.conf:/etc/redis/redis.conf \\ -v /root/redis-cluster/data/8002:/data \\ -d redis:latest redis-server /etc/redis/redis.conf \\ --port 8002 1 2 3 4 5 6 docker run --name master-cluster-3 \\ --network host \\ -v /root/redis-cluster/redis3.conf:/etc/redis/redis.conf \\ -v /root/redis-cluster/data/8003:/data \\ -d redis:latest redis-server /etc/redis/redis.conf \\ --port 8003 1 2 3 4 5 6 docker run --name slave-cluster-1 \\ --network host \\ -v /root/redis-cluster/redis4.conf:/etc/redis/redis.conf \\ -v /root/redis-cluster/data/9001:/data \\ -d redis:latest redis-server /etc/redis/redis.conf \\ --port 9001 1 2 3 4 5 6 docker run --name slave-cluster-2 \\ --network host \\ -v /root/redis-cluster/redis5.conf:/etc/redis/redis.conf \\ -v /root/redis-cluster/data/9002:/data \\ -d redis:latest redis-server /etc/redis/redis.conf \\ --port 9002 1 2 3 4 5 6 docker run --name slave-cluster-3 \\ --network host \\ -v /root/redis-cluster/redis6.conf:/etc/redis/redis.conf \\ -v /root/redis-cluster/data/9003:/data \\ -d redis:latest redis-server /etc/redis/redis.conf \\ --port 9003 6 个节点启动后，它们仍是 6 个独立的 Redis，通过 redis-cli --cluster create 命令可将 6个节点创建为一个分布式系统。–cluster replicas 1 指定每个 master 会带有一个slave 副本。\n所以前三个是主，后三个是从\n1 2 docker exec -it master-cluster-1 /bin/bash redis-cli --cluster create --cluster-replicas 1 192.168.56.10:8001 192.168.56.10:8002 192.168.56.10:8003 192.168.56.10:9001 192.168.56.10:9002 192.168.56.10:9003 查看节点信息\n1 redis-cli -c -p 8003 cluster nodes 这样就可以查看到节点的信息了\n散列插槽\rRedis会把每一个master节 点映射到0~16383共16384个插槽(hashslot) 上，查看集群信息时就能看到: 我们这里插槽分布如下\n端口 插槽范围 8001 0-5460 8002 5461-10922 8003 10923-16383 数据key不是与节点绑定,而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况: key中包含\u0026quot;{}\u0026quot;,且\u0026quot;{}\u0026ldquo;中至少包含1个字符， \u0026ldquo;{}\u0026ldquo;中的部分是有效部分 key中不包含\u0026rdquo;{}\u0026rdquo; ，整个key都是有效部分 例如: key是num,那么就根据num计算,如果是{itcast}num,则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余,得到的结果就是slot值。 连接redis\n注意这里一定要加-c，代表集群模式\n1 redis-cli -c -p 8001 redis会先算出插槽的值，最后找到对应的ip及端口，存储(获取)对应redis实例里的数据 Redis如何判断某个key应该在哪个实例?\n将16384个插槽分配到不同的实例 根据key的有 效部分计算哈希值，对16384取余余数作为插槽，寻找插槽所在实例即可 如何将同一类数据固定的保存在同一个Redis实例? 这一类数据使用相同的有效部分，例如key都以{typeld}为前缀，这样{a}name、{a}gender就能都存储在8003端口上 集群伸缩\rredis-cli \u0026ndash;cluster提供了很多操作集群的命令，可以通过下面方式查看:\n1 2 docker exec -it master-cluster-1 /bin/bash redis-cli --cluster help 向集群中添加一个新的master节点,并向其中存储num = 10 需求 启动一个新的redis实例，端口为8004 添加8004到之前的集群，并作为一个master节点 给8004节点分配插槽，使得num这个key可以存储到8004实例 分析，这里有几个关键点\n新增redis(master)实例到集群 分配插槽，使其能够存储num作为key(hashkey为2765) 参考博客 复制一份redis7.conf文件\n1 2 3 4 5 6 docker run --name master-cluster-4 \\ --network host \\ -v /root/redis-cluster/redis7.conf:/etc/redis/redis.conf \\ -v /root/redis-cluster/data/8004:/data \\ -d redis:latest redis-server /etc/redis/redis.conf \\ --port 8004 可以看到集群节点里并没有新建的8004\n1 2 docker exec -it master-cluster-1 /bin/bash redis-cli -c -p 8003 cluster nodes 查看帮助文档\n1 redis-cli --cluster help 添加节点到集群\n1 redis-cli --cluster add-node 192.168.56.10:8004 192.168.56.10:8003 再次查看集群信息，可以看到8004是作为master的，但是并没有给它分配插槽\n1 redis-cli -c -p 8003 cluster nodes 接下来需要为8004分配至少0~2765的插槽，这里就直接分配前3000个了 输入yes\n再次查看节点信息，可以看到已经分配了0-2999的插槽\n1 redis-cli -p 8004 cluster nodes 试一下获取num，可以看到是从8004上获取的数据\n1 redis-cli -c -p 8001 练习\n删除8004节点 转移插槽 删除节点，可以看到8004节点已经被移除\n1 redis-cli --cluster del-node 192.168.56.10:8004 969b40741ba2c93557ff9013a774f98322f77ba0 删除容器 1 2 docker rm -f master-cluster-4 docker ps 故障转移\r自动故障转移\r当集群中有一个master宕机会发生什么呢? 重新启动8002 可以看到8002变成了master，而9002变成了slaver，实现了自动故障转移\n手动故障转移\r利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下: 手动的Failover支持三种不同模式:\n缺省:默认的流程，如图1~6步 force:省略了对offset的一致性校验 takeover:直接执行第5步，忽略数据一致性、忽略master状态和其它master的意见 练习\n手动故障转移，让8002重新变成master 1 CLUSTER FAILOVER 看到8002重新变成master RedisTemplate\rRedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致:\n引入redis的starter依赖 配置分片集群地址 配置读写分离 与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 # 配置分片集群 spring: data: redis: cluster: # 指定分片集群的每一个节点信息 nodes: - 192.168.56.10:8001 - 192.168.56.10:8002 - 192.168.56.10:8003 - 192.168.56.10:9001 - 192.168.56.10:9002 - 192.168.56.10:9003 访问http://localhost:8080/get/a\n查看日志，通过9003获取到a 查看节点信息\n9003的master是8003\n1 redis-cli -c -p 8003 cluster nodes 访问http://localhost:8080/set/a/666\n通过8003去set值 ","date":"2024-04-24T00:00:00Z","image":"http://localhost:1313/p/redis/202412212127078_hu4531965899873210678.png","permalink":"http://localhost:1313/p/redis/","title":"Redis"},{"content":"Docker概念\r镜像:相当于容器的模板 容器:可以理解成轻量级的虚拟机 镜像仓库:存放镜像的仓库，官方的镜像仓库 https://hub.docker.com/ 以下内容可能会使用到某些文件下载链接\n可以使用镜像来不断创建容器，而镜像仓库则是存放镜像的地方\n命令\r官网文档\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 查看帮助文档 docker --help # 查看某一个命令的用法，如 pull docker pull --help # 下列命令中，[]括起来的可写可不写 # 下载镜像 标签如版本等，如果不指定标签，则默认是latest，如果不指定仓库，则默认是官方仓库 docker pull [镜像仓库/]镜像名[:标签] # 查看镜像 docker images [选项] # 衍生 # 使用帮助手册查看参数 docker images --help # 查看镜像id docker images -q # 查看所有镜像 docker images -a # 查看所有镜像id # docker images -aq/docker images -a -q # 列出镜像名为mysql的镜像 # 例子 docker images --filter=reference=\u0026#39;busy*:*libc\u0026#39; # REPOSITORY TAG IMAGE ID CREATED SIZE # busybox uclibc e02e811dd08f 5 weeks ago 1.09 MB # busybox glibc 21c16b6787c6 5 weeks ago 4.19 MB docker images --filter=reference=\u0026#39;mysql\u0026#39; # 列出容器信息 # 默认显示正在运行的信息 docker ps [选项] # 显示全部容器 docke ps -a # 列出所有退出状态的容器 docker ps -f status=exited # 列出所有退出状态的容器id docker ps -qf status=exited 容器\r容器继续运行的条件\r正常情况下docker容器运行必须有一个前台进程，如果没有前台进程执行，容器认为空闲，就会自动退出\n1 2 3 4 5 6 7 8 9 10 11 12 # 创建并运行容器 docker run [OPTIONS] IMAGES [COMMAND] [ARG...] # options 选项，重点关注-d,-p,-v,-e,--restart # images 镜像信息，推介使用 镜像名:tag 的写法 # command 创建容器后要执行的命令 # ars command命令的参数 # 如 docker run nginx:latest # 容器运行后执行 ls命令 docker run nginx:latest ls docker run nginx:latest ls -a docker run -d nginx:latest ls -a 容器的运行方式\r后台运行 docker run nginx:latest 默认运行 docker run -d nginx:latest 交互式运行 docker run -it nginx:latest -i 以交互模式运行容器，通常与-t一起使用\n-t 启动容器后，为容器分配一个命令行，通常与-i一起使用\n主要在学习阶段和调试的时候会使用到，并且一般容器的执行命令会使用bash,这样才能在进入容器后去执行命令\ndocker run -it nginx:latest bash如果这样执行，则会覆盖nginx镜像默认的执行命令，此时并不会运行nginx，而是进入容器内部执行bash脚本\n退出交互式exit\n删除容器\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 docker rm [选项] [容器ID或容器名...] # 例如 删除id为\u0026#34;d34295b85f69\u0026#34;的容器 docker rm d34295b85f69 # 删除id为\u0026#34;d34295b85f69\u0026#34;和\u0026#34;c0c9bf25c6a7\u0026#34;的容器 # 容器id使用空格隔开 docker rm d34295b85f69 c0c9bf25c6a7 # 运行中的容器无法直接删除，解决办法 # 1.停止运行容器，然后删除 # 2.强制删除 docker rm -f c0c9bf25c6a7 # $()命令替换 ls $(pwd) # pwd 会显示当前目录 # ls $(pwd) 会打印当前目录下的内容 # 删除所有容器 docker rm $(docker ps -aq) # 强制删除所有容器 docker rm -f $(docker ps -aq) # 删除所有非运行状态的容器 docker rm $(docker ps -f status=exited -q) 进入容器执行命令\r1 2 3 4 5 6 7 docker exec [选项] 容器ID或容器名 命令[参数...] # 如 docker exec 容器id ls docker exec 295731ae1fdf pwd # 但是一次只能携带一个命令，是否可以使用交互式的方式 docke exec -it 295731ae1fdf bash # 使用curl的方式来查看nginx容器是否运行 curl http://127.0.0.1 查看容器日志\r1 2 3 4 5 6 7 docker logs [选项] 容器ID或容器名 docker logs 295731ae1fdf # 持续输出容器中的日志 # 执行完并不会返回，而是会等待是否有新的日志 docker logs -f 295731ae1fdf # 查看最近的20条日志 docker logs -n 20 295731ae1fdf 容器文件拷贝\r使用docker cp命令来实现容器与宿主机之间文件和目录的相互拷贝\n1 2 3 4 5 6 # 把容器的文件拷贝到宿主机中 docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH # docker cp 295731ae1fdf:/usr/share/nginx/html/index.html /home/index.html # 把宿主机的文件拷贝到容器中 docker cp [OPTIONS] SRC_PATH CONTAINER:DEST_PATH # docker cp /home/cp_test 295731ae1fdf:/home/cp_test 停止容器\r1 2 docker stop [容器ID或容器名...] # docker stop 295731ae1fdf 运行容器\r1 2 docker start [容器ID或容器名...] # docker start 295731ae1fdf run命令详解\r1 2 3 4 5 6 7 8 9 10 11 -p # 将宿主机的端口映射到docker容器端口，通过宿主机的端口访问容器端口 # 发布一个端口 docker run -p 宿主机端口:容器端口 镜像名 #发布多个端口 docker run -p 宿主机端口1:容器端口1 -p 宿主机端口2:容器端口2 镜像名 # 怎么知道容器需要发布哪些端口呢？ # 1.DockerHub的介绍 # 2.构建容器的DockerFile(EXPOSE 80) -v # 数据卷 数据卷\r为什么要使用数据卷？\n需要把容器中的数据持久化保存 需要在宿主机和容器之间完成数据共享 将宿主机目录或文件挂载到容器中，实现宿主机和容器之间的数据共享和持久化\n-v\r-p 对外端口发布，即端口映射 -v 数据卷 -e 设置环境变量 \u0026ndash;name 容器命名 \u0026ndash;restart 容器退出后的重启策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 docker run -v 数据卷别名:容器目录[:读写权限] 镜像名 docker run -d -p 80:80 -v nginx_html:/usr/share/nginx/html nginx # 查看数据卷信息 docker inspect fcbc47e85323 # 其中有一段信息如下 \u0026#34;Mounts\u0026#34;: [ { \u0026#34;Type\u0026#34;: \u0026#34;volume\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;nginx_html\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/var/lib/docker/volumes/nginx_html/_data\u0026#34;, \u0026#34;Destination\u0026#34;: \u0026#34;/usr/share/nginx/html\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Mode\u0026#34;: \u0026#34;z\u0026#34;, \u0026#34;RW\u0026#34;: true, \u0026#34;Propagation\u0026#34;: \u0026#34;\u0026#34; } # Type为volume，表示数据卷，Source即为我们数据卷的路径 # 可以cd到/var/lib/docker/volumes/nginx_html/_data里ls看一下，对应的是nginx中/usr/share/nginx/html的内容 # 列出数据卷 docker volume ls # 查看数据卷详情 # 这里nginx_html是别名 docker volume inspect nginx_html docker volume inspect 06f4db3290e6759861b085989a859257121aac46ad30e35fe26a1904f8ff7aea # 创建数据卷 # volume_test为数据卷的名字 docker volume create volume_test # 删除数据卷 docker volume rm volume_test # 如果需要删除的数据卷正在被使用，是没有办法直接删除的 # 强制删除容器然后删除数据卷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 手动安装jdk 也可以使用docker安装jdk # docker安装jdk在后文 # 在/usr/local 目录下安装jdk cd /usr/local wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz tar -zxvf jdk-17_linux-x64_bin.tar.gz # 将jdk-17改名为java mv jdk-17.0.10 jdk17 # 进入profile文件，按i进入编辑模式 vim /etc/profile # 在文件最下方添加 export JAVA_HOME=/usr/local/jdk17 export PATH=$PATH:$JAVA_HOME/bin; export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar; # 按下Esc退出编辑模式 # 下一步按住shift 再按俩次 z 键，保存配置文件信息 # 重新加载环境变量 source /etc/profile # cd / java -version 练习 将某html挂载到nginx目录下进行显示\n第一个80端口是宿主机的端口，第二个80端口是容器nginx的端口\n将宿主机的/home/html/index.html挂载到容器的/usr/share/nginx/html/index.html\n不过一般不会直接挂载html，一般挂载整个目录，包括html、css、js等\n1 docker run -d -p 80:80 -v /home/html/index.html:/usr/share/nginx/html/index.html nginx 访问http://虚拟机ip:80/\n如果我们将宿主机的/home/html/index.html改变内容，再次访问nginx，是否会发生变化\n-e\r容器中某些变量不能直接写死，需要让使用者在创建容器的时候指定，这种情况镜像中一般是定义环境变量来使用。例如mysql容器的root密码。遇到这种镜像创建的容器我就可以使用-e来设置环境变量的值。 用法如下\n1 docker run -e 变量名=变量值 镜像名 练习\n后台运行mysql容器 容器中的mysql可以被外部连接 mysql容器的数据需要持久化存储，不能因为容器被删除而丢失 mysql的root用户密码设置为root 1 docker run -d -p 3306:3306 -v /home/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root mysql:8.0.20 \u0026ndash;name\r容器命名 练习 发布一个nginx页面，为容器命名为nginx-test\n1 docker run -d -p 81:80 --name nginx-test -v /home/html:/usr/share/nginx/html nginx \u0026ndash;restart\r容器退出后的自动重启策略\n1 2 3 4 5 docker run --restart 重启策略 镜像名 # no 不自动重启 # always 总自动重启 # on-failure[:max-retries] 仅在非正常退出时，自动重启 # unless-stopped 容器会在退出后自动重启，除非手动停止 其他镜像和容器命令\r1 2 3 4 5 6 7 8 # 查看镜像详细内容 docker images inspect [OPTIONS] IMAGE [IMAGE...] docker image inspect 7614ae9453d1 # 查看容器中的进程 docker top CONTAINER[ps CONTAINER] docker top redis # 查看容器详细内容 docker inspect 51764b94357b 运行jar包\r1 2 3 4 5 6 7 8 9 10 11 12 13 # docker拉取java17 docker pull openjdk:17-jdk # 运行jar包 java -jar xxx.jar # 根据application.properties来穿参数 # 运行时参数，比如运行端口为8080，mysql的密码为root java -jar xxx.jar --server.port=8080 --spring.datasource.username=root --spring.datasource.password=root docker run -d \\ -p 8080:8080 \\ -v /usr/blog:/usr/blog \\ --restart always \\ --name jar_test \\ openjdk:17-jdk java -jar /usr/blog/demo-0.0.1-SNAPSHOT.jar 网络\r1 docker inspect mysql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 查看运行的容器 docker ps -f name=jar_test # 进入容器内部 docker exec -it jar_test bash # ping mysql试试 ping 172.17.0.3 # 创建网络 docker network create 网络名 # 列出网络信息 docker network ls # 加入网络有两种方式 # 1.在创建容器时加入 docker run --network 网络名 镜像名 # 2.容器创建后加入 docker network connect [选项] 网络名 容器名或容器id # 查看网络详情 docker network inspect 网络名或网络id docker run -d \\ -p 8080:8080 \\ -v /usr/blog:/usr/blog \\ --network blog_test jar_test --restart always \\ --name jar_test \\ openjdk:17-jdk java -jar /usr/blog/demo-0.0.1-SNAPSHOT.jar \\ \u0026#34;--spring.datasource.url=jdbc:mysql://mysql:3306/test?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;zeroDateTimeBehavior=convertToNull\u0026amp;serverTimezone=UTC\u0026amp;useSSL=false\u0026amp;zeroDateTimeBehavior=CONVERT_TO_NULL\u0026amp;allowPublicKeyRetrieval=true\u0026#34; # 在加入同一个网络后，这里spring.datasource.url并没有写ip地址了，而是写的容器名称mysql DockerFile\r基本语法\r不区分大小写，但是最好习惯大写 基本以FROM开头 #开头代表注释 练习 自定义一个镜像，运行容器后输出helloworld(如:echo helloworld) 1 2 FROM centos:7 CMD [\u0026#34;echo\u0026#34;,\u0026#34;helloworld\u0026#34;] 将文件编译成镜像\n使用-t可以指定镜像的名字和标签、-f指定基于哪个dockerfile文件来进行构建镜像、.表示文件在当前路径下\n1 2 3 docker build -t hello:1.0 -f HelloWorld . # 测试是否成功 docker run hello:1.0 FROM\r用来定义基础镜像\n作用时机:构建镜像的时候\n1 2 FROM 镜像名:标签名 FROM centos:7 CMD\r用来定义容器运行时的默认命令，可以在docker run的时候覆盖掉CMD中定义的命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 CMD [\u0026#34;命令1\u0026#34;,\u0026#34;参数1\u0026#34;,\u0026#34;参数2\u0026#34;] # CMD [\u0026#34;echo\u0026#34;,\u0026#34;helloworld\u0026#34;] # 这种形式可以解析环境变量 # CMD echo hello$HOME # 这种也可以解析环境变量 # CMD [\u0026#34;sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;hello $HOME\u0026#34;] # 如果在一个dockerfile中有多个CMD，则只执行最后一个CMD FROM centos:7 CMD [\u0026#34;echo\u0026#34;,\u0026#34;helloworld\u0026#34;] CMD echo hello,java CMD echo hello,vue # 测试一下 docker build -t hello:2.0 -f HelloWorld . ENV\r用来定义环境变量\nENV 变量名=\u0026quot;变量值\u0026quot; 如ENV DIR=\u0026quot;/root\u0026quot;\n作用时机为构建镜像时\n1 ENV DIR=\u0026#34;/root\u0026#34; 需求：要求对打印内容进行改造，需要实现可以打印任意内容，具体内容在运行容器的时候通过环境变量的方式去指定\n1 2 3 FROM centos:7 ENV NAME=\u0026#34;小花\u0026#34; CMD echo hello,$NAME 编译测试\n1 2 3 4 docker build -t test01:1.0 -f Test01 . docker run test01:1.0 # 也可以在运行时指定环境变量 docker run -e NAME=小红 test01:1.0 WORKDIR\r用于设置当前工作的目录，如果该目录不存在会自动创建。\n1 2 WORKDIR 目录 WORKDIR /root/app 示例1\npwd打印出来是什么？\n1 2 3 4 5 FROM centos:7 WORKDIR /a WORKDIR b WORKDIR c CMD pwd pwd打印/a/b/c 示例2\nWORKDIR指定目录的父目录不存在会怎么样？\nWORKDIR /a/b/c\n如果指定目录的父目录不存在，会自动创建 示例3 WORKDIR指定的目录是否能使用环境变量\n1 2 3 4 FROM centos:7 ENV PATH=\u0026#34;/a\u0026#34; WORKDIR $PATH CMD pwd WORKDIR指定的目录可以使用环境变量\nRUN\r用来在构建过程中要执行的命令\n而CMD则是在容器运行时执行命令\n1 RUN echo abc 练习\n定义一个CONTENT变量,默认值为hellodocker, 在镜像的/app目录下创建一个sg目录，在其中创建一个content.txt文件, 文件的内容为CQNTENT变量的值。容器启动时打印content.txt的内容\n1 2 3 4 5 # 如果是sh脚本，则可以这么实现 export CONTENT=\u0026#34;hellodocker\u0026#34; mkdir -p /app/sg echo \u0026#34;$CONTENT\u0026#34; \u0026gt; /app/sg/content.txt cat /app/sg/content.txt 如何改成DockerFile的写法\n1 2 3 4 5 FROM centos:7 ENV CONTENT=\u0026#34;hellodocker\u0026#34; WORKDIR /app/sg RUN echo \u0026#34;$CONTENT\u0026#34; \u0026gt; /app/sg/content.txt CMD cat /app/sg/content.txt 测试\n1 2 3 4 5 6 docker build -t test01:1.0 -f Test01 . docker run test01:1.0 # 或者 docker run -it test01:1.0 bash ls cat content.txt 思考\n1 2 [root@10 dockerfile_test]# docker run -e CONTENT=java test01:1.0 hellodocker 为什么docker run -e CONTENT=java test01:1.0的时候，输出的不是java\n因为只有CMD是在docker运行时执行，而其他指令如ENV、RUN等是在构建镜像时执行\n所以输出的还是hellodocker\nADD\r把构建上下文的文件或者网络文件添加到镜像\n如果文件是压缩包则自动解压，但是需要根据情况，如果是本地压缩包大概率没问题\n但如果是网络上的如oss压缩包可能又不会解压，需要根据实际情况来定\n作用时机为构建镜像的时候\n1 2 3 4 5 ADD 原路径 目标路径 ADD xxx.tar.gz . # 随便找一个 html+js+css的网页 # 使用如下命令将html目录打成html.tar.gz压缩包 tar zcvf html.tar.gz html 练习 在构建目录下存放一个gz压缩包， 构建镜像的时候把这个包添加到镜像的/app录下解压，然后把其中的dist目录的内容存放到存放在nginx的htmI目录下，声明开放80端口\ndockerfile:Test01\n1 2 3 4 5 6 FROM nginx:latest WORKDIR /app ADD html.tar.gz . RUN tar -xzvf html.tar.gz RUN cp -r html/* /usr/share/nginx/html CMD [\u0026#34;nginx\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;daemon off;\u0026#34;] 测试\n1 docker build -t test01:1.0 -f Test01 . 报错如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [+] Building 0.4s (6/7) docker:default =\u0026gt; [internal] load build definition from Test01 0.0s =\u0026gt; =\u0026gt; transferring dockerfile: 217B 0.0s =\u0026gt; [internal] load metadata for docker.io/library/nginx:latest 0.0s =\u0026gt; [internal] load .dockerignore 0.0s =\u0026gt; =\u0026gt; transferring context: 2B 0.0s =\u0026gt; [1/4] FROM docker.io/library/nginx:latest 0.0s =\u0026gt; [2/4] WORKDIR /app 0.0s =\u0026gt; ERROR [3/4] RUN tar -xzvf html.tar.gz 0.3s ------ \u0026gt; [3/4] RUN tar -xzvf html.tar.gz: 0.263 tar (child): html.tar.gz: Cannot open: No such file or directory 0.263 tar (child): Error is not recoverable: exiting now 0.263 tar: Child returned status 2 0.263 tar: Error is not recoverable: exiting now ------ Test01:3 -------------------- 1 | FROM nginx:latest 2 | WORKDIR /app 3 | \u0026gt;\u0026gt;\u0026gt; RUN tar -xzvf html.tar.gz 4 | RUN cp html/* /usr/share/nginx/html 5 | CMD [\u0026#34;nginx\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;daemon off;\u0026#34;] -------------------- ERROR: failed to solve: process \u0026#34;/bin/sh -c tar -xzvf html.tar.gz\u0026#34; did not complete successfully: exit code: 2 可以看到是在解压tar.gz包的时候报错了，好像是没有找到文件 那怎么调试呢？现在镜像都没构建，更别说进入到容器内部查看文件是否存在了\n将Test01改成如下内容\n注释掉报错部分，先创建镜像，然后进入容器内部查看报错原因\n1 2 3 4 5 6 FROM nginx:latest WORKDIR /app ADD html.tar.gz . #RUN tar -xzvf html.tar.gz #RUN cp -r html/* /usr/share/nginx/html CMD [\u0026#34;nginx\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;daemon off;\u0026#34;] 构建成功\n1 2 3 4 5 docker build -t test01:1.0 -f Test01 . docker run -it test01:1.0 bash # ls发现tar.gz已经被自动解压了 # 说明ADD一个压缩包，会自动解压 ls 最终将dockerFile改为如下\n1 2 3 4 5 FROM nginx:latest WORKDIR /app ADD html.tar.gz . RUN cp -r html/* /usr/share/nginx/html CMD [\u0026#34;nginx\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;daemon off;\u0026#34;] 构建后运行镜像\n因为我虚拟机已经运行了一个nginx容器了，所以80端口已经被占用了，这里指定的端口是81\n1 docker run -d -p 81:80 --name=dockerfile_test01 test01:1.0 访问链接，这里docker1是指虚拟机的ip\n我这里是因为配了主机的hosts文件\nhosts文件路径：C:\\Windows\\System32\\drivers\\etc hosts文件\n1 192.168.56.10 docker1 http://docker1:81/ EXPOSE\r暴露需要发布的端口，让镜像使用者知道应该发布哪些端口\n1 2 EXPOSE 端口1 端口2 EXPOSE 80 8080 dockerfile\n1 2 3 4 5 6 FROM nginx:latest WORKDIR /app ADD html.tar.gz . RUN cp -r html/* /usr/share/nginx/html EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;daemon off;\u0026#34;] COPY\r从构建上下文中复制内容到镜像中\n1 2 COPY 原路径 目标路径 COPY html.tar.gz . COPY的作用和ADD好像非常类似，具体如何抉择？\nADD可以下载网络文件,并且可以自动解压 COPY就是单纯的拷贝 练习 在构建目录下存放一个html.tar.gz包，构建镜像的时候把这个包复制到镜像的/app目录下解压，然后把其中的dist目录的内容存放到存放在nginx的htmI目录下，声明开放80端口 1 2 3 4 5 6 7 FROM nginx:latest WORKDIR /app COPY html.tar.gz . RUN tar -xzvf html.tar.gz RUN cp -r html/* /usr/share/nginx/html EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;daemon off;\u0026#34;] ENTRYPOINT\r用来定义容器运行时的默认命令。docker run的时候无法覆盖ENTRYPOINT里的内容。\n运行时机在运行容器的时候\n1 2 ENTRYPOINT [\u0026#34;命令1\u0026#34;,\u0026#34;参数1\u0026#34;,\u0026#34;参数2\u0026#34;] ENTRYPOINT [\u0026#34;echo\u0026#34;,\u0026#34;helloworld\u0026#34;] 实际使用\n实际使用往往是存在部分命令不能更改，也存在部分命令可以被更改\n比如java -jar aaa.jar\n我们希望java -jar这部分命令是固定的，无法在运行时被修改\n而jar包的名称可以在运行时修改\n1 2 ENTRYPOINT [\u0026#34;java\u0026#34;,\u0026#34;-jar\u0026#34;] CMD [\u0026#34;aaa.jar\u0026#34;] 练习 在上个案例要求的基础上，还要求容器的nginx的启动命令不能在运行容器时被覆盖\n分析一下这个练习\n1 docker run -d -p 82:80 test01:1.0 bash 执行上述命令后，容器处于退出状态Exited 为啥呢？因为bash将dockerfile最后一行的cmd命令覆盖了CMD [\u0026quot;nginx\u0026quot;,\u0026quot;-g\u0026quot;,\u0026quot;daemon off;\u0026quot;]\n1 2 3 4 5 6 7 FROM nginx:latest WORKDIR /app COPY html.tar.gz . RUN tar -xzvf html.tar.gz RUN cp -r html/* /usr/share/nginx/html EXPOSE 80 ENTRYPOINT [\u0026#34;nginx\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;daemon off;\u0026#34;] 1 2 docker build -t entrypoint_test02:1.0 -f Test01 . docker run -d -p 82:80 entrypoint_test02:1.0 bash 发现容器依然没有运行，查看容器日志\n1 2 3 4 docker run -d -p 82:80 entrypoint_test02:1.0 bash #fa075623cdbf3d01ead7b405c8d61b224e0f70e9fffcdb2a3c5bd91100ecd35d docker logs fa075623cdbf3d #nginx: invalid option: \u0026#34;bash\u0026#34; 因为此时在nginx容器内执行了bash命令，nginx无法识别\n优化部署流程\r我们希望后端的镜像当中就包含了后端的jar包，镜像启动的时候默认就是会启动该jar包，前端的镜像中就包含了前端的包\n基础版\r配置nginx反向代理\r/etc/nginx/conf.d/default.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 server { listen 80; listen [::]:80; server_name localhost; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } location ^~/api/{ proxy_pass http://192.168.56.10:8080/; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache\u0026#39;s document root # concurs with nginx\u0026#39;s one # #location ~ /\\.ht { # deny all; #} } 主要是添加如下代码\n1 2 3 4 5 ... location ^~/api/{ proxy_pass http://192.168.56.10:8080/; } ... 1 2 3 4 5 6 7 8 9 10 11 12 # 我这里的nginx的镜像名为nginx-test docker inspect volume nginx-test # \u0026#34;Mounts\u0026#34;: [ # { # \u0026#34;Type\u0026#34;: \u0026#34;bind\u0026#34;, # \u0026#34;Source\u0026#34;: \u0026#34;/home/html\u0026#34;, # \u0026#34;Destination\u0026#34;: \u0026#34;/usr/share/nginx/html\u0026#34;, # \u0026#34;Mode\u0026#34;: \u0026#34;\u0026#34;, # \u0026#34;RW\u0026#34;: true, # \u0026#34;Propagation\u0026#34;: \u0026#34;rprivate\u0026#34; # } # ], 而nginx镜像配置的数据卷在宿主机的路径为/home/html，所以我们将前端文件放在宿主机的/home/html路径下\n1 2 3 4 5 6 7 8 9 ll #total 16 #drwxr-xr-x. 2 root root 57 Mar 24 13:13 assets #-rw-r--r--. 1 root root 1169 Mar 24 15:07 default.conf #-rw-r--r--. 1 root root 456 Mar 24 13:13 index.html #-rw-r--r--. 1 root root 834 Mar 24 14:06 nginx.conf #-rw-r--r--. 1 root root 1497 Mar 20 23:01 vite.svg pwd #/home/html 到时候前端输入虚拟机ip:80/就会显示/home/html/index.html文件 如http://192.168.56.10:80/显示前端页面\n运行后端\r注意更换自己mysql的账号和密码\n1 2 3 4 5 6 docker run -d \\ -p 8080:8080 \\ -v /usr/blog:/usr/blog \\ --restart always \\ --name jar_test \\ openjdk:17-jdk java -jar /usr/blog/demo.jar --spring.datasource.username=root --spring.datasource.password=123456 这里将jar包放在了/usr/blog下，也可以自己定义路径\nMySQL\r还需要配置mysql,新建一个test数据库\n1 2 3 4 5 6 7 8 9 10 11 create table user ( id int auto_increment comment \u0026#39;用户编号\u0026#39; primary key, username varchar(20) null comment \u0026#39;账号\u0026#39;, password varchar(20) null comment \u0026#39;密码\u0026#39;, nick_name varchar(20) null comment \u0026#39;昵称\u0026#39;, avatar varchar(255) null comment \u0026#39;头像\u0026#39; ) comment \u0026#39;用户表\u0026#39;; INSERT INTO test.user (id, username, password, nick_name, avatar) VALUES (1, \u0026#39;admin\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;默认昵称\u0026#39;, null); 优化\rdockerfile\n1 2 3 4 5 6 FROM openjdk:17-jdk WORKDIR /app ADD demo.jar . EXPOSE 8080 ENTRYPOINT [\u0026#34;java\u0026#34;,\u0026#34;-jar\u0026#34;] CMD [\u0026#34;demo.jar\u0026#34;] 1 2 3 4 5 6 7 8 9 10 cd /usr/dockerfile_test docker build -t demo_jar:1 -f /usr/dockerfile_test/demo_jar . # network 添加到同一个网络 # mysql也需要 docker run -d \\ -p 8080:8080 \\ --network blog_test \\ --restart always \\ --name jar_demo \\ demo_jar:1 前端\ndemo_ngxin是dockerfile文件\nblog-vue下则是前端文件 1 2 3 4 5 6 FROM nginx:latest WORKDIR /app COPY blog-vue . RUN cp -r dist/* /usr/share/nginx/html EXPOSE 80 ENTRYPOINT [\u0026#34;nginx\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;daemon off;\u0026#34;] 1 2 3 4 5 6 7 docker build -t blog_vue:1 -f demo_nginx . docker run -d \\ -p 80:80 \\ --restart always \\ -d \\ --name blog_vue \\ blog_vue:1 访问发现后端接口404，是因为基于nginx镜像FROM nginx:latest，这里反向代理依然需要配置\n解决方法：进入blog_vue容器内部重新配置反向代理\n1 docker exec -it blog_vue bash 镜像推送到镜像仓库\r注册Docker Hub账号\r官网:https://hub.docker.com/\n登录镜像仓库\r1 2 docker login # 然后输入账号密码即可登录 构建镜像\r1 2 docker build -t username/镜像名:tag . # username是Docker Hub的帐号 给镜像打上标签\r以便于与Docker Hub上的仓库关联\n1 2 3 # 第一个镜像名是本地的镜像名 # 第二个镜像名是Docker Hub仓库中的镜像名 docker tag username/镜像名:tag username/镜像名:tag 推送镜像\r1 docker push username/镜像名:tag DockerCompose\r入门\rDockerCompose是用来定义和运行一个或多个容器(通常都是多个)运行和应用的工具\n当前版本的Docker不需要单独安装\n1 2 docker compose version # 查看版本 1 2 3 4 5 services: test: image: nginx:latest test2: image: nginx:latest 1 2 3 4 5 6 # 运行以上定义的所有镜像 docker compose up # -d 后台运行 docker compose up -d # 会停止并删除yaml中运行的容器 docker compose down 元素\rcommand 覆盖容器启动后的默认指令 environment 指定环境变量，相当于run的-e选项 image 用来指定镜像 networks 指定网络, 相当于run的\u0026ndash;network ports 用来指定要发布的端口 ，相当于run的-p volumes 用来指定数据卷， 相当于-V restart 用来指定重启策略,相当于\u0026ndash;restart docker-compose.yml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 services: # mysql blog_mysql: image: mysql:8.0.20 # 已经存在的数据卷 mysql_data volumes: - mysql_data:/var/lib/mysql ports: - 3306:3306 environment: MYSQL_ROOT_PASSWORD: 123456 restart: always networks: - blog_net # redis blog_redis: image: redis:latest volumes: - redis_data:/data ports: - 6379:6379 restart: always command: [\u0026#39;redis-server\u0026#39;,\u0026#39;--appendonly\u0026#39;,\u0026#39;yes\u0026#39;] networks: - blog_net # 后端服务 sg_blog: image: sb_blog:01 ports: - 8080:8080 networks: - blog_net restart: always # 前端服务 sg_blog_vue: image: sb_blog_vue:01 ports: - 80:80 restart: always networks: blog_net: volumes: mysql_data: # 表示数据卷已经存在，不需要自动创建 external: true redis_data: external: true 设置好docker-compose.yaml后\n1 2 docker compose up -d docker compose down ","date":"2024-04-21T00:00:00Z","image":"http://localhost:1313/p/docker/dbc-docker-desktop-home_hu5165119418789691799.webp","permalink":"http://localhost:1313/p/docker/","title":"Docker"},{"content":"Seata\r概念\r事务的ACID原则\r原子性 事务中的所有操作，要么全部成功,要么全部失败 一致性 要保证数据库内部完整性约束、声明性约束 隔离性 对同一资源操作的事务不能同时发生 持久性 对数据库做的一切修改将永久保存,不管是否出现故障 案例\r微服务下单业务，在下单时会调用订单服务，创建订单并写入数据库。然后订单服务调用账户服务和库存服务:\n账户服务负责扣减用户余额 库存服务负责扣减商品库存 我们希望创建订单、扣减余额、扣件商品库存三个操作同时成功或者失败 这里新建三个数据库 sentinel_account\n1 2 3 4 5 6 7 8 9 10 11 create table account_tbl ( id int auto_increment comment \u0026#39;账户编号\u0026#39; primary key, user_id varchar(255) null comment \u0026#39;用户编号\u0026#39;, money int(11) unsigned default 0 null comment \u0026#39;余额\u0026#39; ) comment \u0026#39;账户表\u0026#39; charset = utf8 row_format = COMPACT; INSERT INTO sentinel_account.account_tbl (id, user_id, money) VALUES (1, \u0026#39;user202103032042012\u0026#39;, 1000); sentinel_order\n1 2 3 4 5 6 7 8 9 10 11 create table order_tbl ( id int auto_increment comment \u0026#39;订单编号\u0026#39; primary key, user_id varchar(255) null comment \u0026#39;用户编号\u0026#39;, commodity_code varchar(255) null comment \u0026#39;商品编码\u0026#39;, count int default 0 null comment \u0026#39;数量\u0026#39;, money int default 0 null comment \u0026#39;金额\u0026#39; ) comment \u0026#39;订单表\u0026#39; charset = utf8 row_format = COMPACT; sentinel_storage\n1 2 3 4 5 6 7 8 9 10 11 12 13 create table storage_tbl ( id int auto_increment comment \u0026#39;库存编号\u0026#39; primary key, commodity_code varchar(255) null comment \u0026#39;商品编码\u0026#39;, count int(11) unsigned default 0 null comment \u0026#39;库存数量\u0026#39;, constraint commodity_code unique (commodity_code) ) comment \u0026#39;库存表\u0026#39; charset = utf8 row_format = COMPACT; INSERT INTO sentinel_storage.storage_tbl (id, commodity_code, count) VALUES (1, \u0026#39;100202003032041\u0026#39;, 10); 基础项目的链接 调用client实现扣余额、扣库存 使用ApiFox测试订单创建请求 看看数据，发现该商品还剩下10个 我们直接买20个，正常来讲库存不足应该要失败，这次用户要跟账户表保持一致 报错 刷新之后发现，库存表数量没变(扣减失败)，但是账户表金额被扣了 它们每个服务是独立的，各自提交自己的事务，所以并没有达成事务的一致 总结：在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务， 要保证所有分支事务最终状态一致,这样的事务就是分布式事务。\n理论知识\rCAP定理\r1998年，加州大学的计算机科学家Eric Brewer提出，分布式系统有三个指标:\nConsistency (一致性) Availability (可用性) Partition tolerance (分区容错性) Eric Brewer说，分布式系统无法同时满足这三个指标。这个结论就叫做CAP定理。 一致性\rConsistency (一致性) :用户访问分布式系统中的任意节点,得到的数据必须一致 可用性\rAvailability (可用性) :用户访问集群中的任意健康节点,必须能得到响应，而不是超时或拒绝 分区容错\rPartition (分区) :因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。 Tolerance (容错) :在集群出现分区时,整个系统也要持续对外提供服务 总结\r分布式系统节点通过网络连接，一定会出现分区问题(P)，当分区出现时，系统的一致性(C)和可用性(A)就无法同时满足\n思考\relasticsearch集群是CP还是AP? ES集群出现分区时，故障节点会被剔除集群，数据分片会重新分配到其它节点，保证数据一致。因此是低可用性，高一致性，属于CP\nBASE理论\rBASE理论是对CAP的一种解决思路,包含三个思想: Basically Available(基本可用) :分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。 SoftState (软状态) :在一定时间内，允许出现中间状态，比如临时的不一致状态。 Eventually Consistent (最终一致性) :虽然无法保证强-致性,但是在软状态结束后，最终达到数据一致。 而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论: AP模式:各子事务分别执行和提交,允许出现结果不一致,然后采用弥补措施恢复数据即可，实现最终一致。 CP模式:各个子事务执行后互相等待，同时提交,同时回滚,达成强一致。但事务等待过程中,处于弱可用状态。因为会锁定资源导致无法访问\n分布式事务模型\r解决分布式事务，各个子系统之间必须能感知到彼此的事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者(子系统事务)。 这里的子系统事务，称为分支事务;有关联的各个分支事务在一起称为全局事务\n初识Seata\rSeata架构\rSeata事务管理中有三个重要的角色:\nTC (Transaction Coordinator) -事务协调者:维护全局和分支事务的状态，协调全局事务提交或回滚。 TM (Transaction Manager) -事务管理器:定义全局事务的范围、开始全局事务、提交或回滚全局事务。 RM (Resource Manager) -资源管理器:管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。 Seata提供了四种不同的分布式事务解决方案: XA模式:强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入 TCC模式:最终一致的分阶段事务模式，有业务侵入 AT模式:最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式 SAGA模式:长事务模式，有业务侵入 安装Seata\r下载\r前往Github下载，这里选择seata-server-1.7.0的版本\n配置nacos为注册中心和配置中心\rapplication.example.yml的配置很全，我们copy需要的配置到application.yml即可 修改后的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 # Copyright 1999-2019 Seata.io Group. # # Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. server: port: 7091 spring: application: name: seata-server logging: config: classpath:logback-spring.xml file: path: ${user.home}/logs/seata extend: logstash-appender: destination: 127.0.0.1:4560 kafka-appender: bootstrap-servers: 127.0.0.1:9092 topic: logback_to_logstash console: user: username: seata password: seata seata: config: # support: nacos 、 consul 、 apollo 、 zk 、 etcd3 type: nacos nacos: server-addr: 127.0.0.1:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c # group: SEATA_GROUP group: DEFAULT_GROUP username: nacos password: nacos context-path: ##if use MSE Nacos with auth, mutex with username/password attribute #access-key: #secret-key: data-id: seataServer.properties registry: # support: nacos 、 eureka 、 redis 、 zk 、 consul 、 etcd3 、 sofa type: nacos preferred-networks: 30.240.* nacos: application: seata-server server-addr: 127.0.0.1:8848 # group: SEATA_GROUP group: DEFAULT_GROUP namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c cluster: default username: nacos password: nacos context-path: ##if use MSE Nacos with auth, mutex with username/password attribute #access-key: #secret-key: store: # support: file 、 db 、 redis mode: db # server: # service-port: 8091 #If not configured, the default is \u0026#39;${server.port} + 1000\u0026#39; security: secretKey: SeataSecretKey0c382ef121d778043159209298fd40bf3850a017 tokenValidityInMilliseconds: 1800000 ignore: urls: /,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.jpeg,/**/*.ico,/api/v1/auth/login 在nacos中新增配置 配置文件可以查看 新增配置如下 下面除了db外的配置都是默认的，写到nacos是为了方便后期修改，db之外的配置不写也没事\n这里的driverClassName我用的是com.mysql.cj.jdbc.Driver，注意修改成自己的数据库名、账号、密码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 数据存储方式，db代表数据库 store.mode=db store.db.datasource=druid store.db.dbType=mysql store.db.driverClassName=com.mysql.cj.jdbc.Driver store.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true\u0026amp;rewriteBatchedStatements=true store.db.user=root store.db.password=123456 store.db.minConn=5 store.db.maxConn=30 store.db.globalTable=global_table store.db.branchTable=branch_table store.db.queryLimit=100 store.db.lockTable=lock_table store.db.maxWait=5000 # 事务、日志等配置 server.recovery.committingRetryPeriod=1000 server.recovery.asynCommittingRetryPeriod=1000 server.recovery.rollbackingRetryPeriod=1000 server.recovery.timeoutRetryPeriod=1000 server.maxCommitRetryTimeout=-1 server.maxRollbackRetryTimeout=-1 server.rollbackRetryTimeoutUnlockEnable=false server.undo.logSaveDays=7 server.undo.logDeletePeriod=86400000 # 客户端与服务端传输方式 transport.serialization=seata transport.compressor=none # 关闭metrics功能，提高性能 metrics.enabled=false metrics.registryType=compact metrics.exporterList=prometheus metrics.exporterPrometheusPort=9898 db配置，注意这里新增一个undo_log表，该表的建表语句在sql中不存在\n完整sql如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 -- -------------------------------- The script used when storeMode is \u0026#39;db\u0026#39; -------------------------------- -- the table to store GlobalSession data CREATE TABLE IF NOT EXISTS `global_table` ( `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `status` TINYINT NOT NULL, `application_id` VARCHAR(32), `transaction_service_group` VARCHAR(32), `transaction_name` VARCHAR(128), `timeout` INT, `begin_time` BIGINT, `application_data` VARCHAR(2000), `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`xid`), KEY `idx_status_gmt_modified` (`status` , `gmt_modified`), KEY `idx_transaction_id` (`transaction_id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; -- the table to store BranchSession data CREATE TABLE IF NOT EXISTS `branch_table` ( `branch_id` BIGINT NOT NULL, `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `resource_group_id` VARCHAR(32), `resource_id` VARCHAR(256), `branch_type` VARCHAR(8), `status` TINYINT, `client_id` VARCHAR(64), `application_data` VARCHAR(2000), `gmt_create` DATETIME(6), `gmt_modified` DATETIME(6), PRIMARY KEY (`branch_id`), KEY `idx_xid` (`xid`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; -- the table to store lock data CREATE TABLE IF NOT EXISTS `lock_table` ( `row_key` VARCHAR(128) NOT NULL, `xid` VARCHAR(128), `transaction_id` BIGINT, `branch_id` BIGINT NOT NULL, `resource_id` VARCHAR(256), `table_name` VARCHAR(32), `pk` VARCHAR(36), `status` TINYINT NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;0:locked ,1:rollbacking\u0026#39;, `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`row_key`), KEY `idx_status` (`status`), KEY `idx_branch_id` (`branch_id`), KEY `idx_xid` (`xid`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; CREATE TABLE IF NOT EXISTS `distributed_lock` ( `lock_key` CHAR(20) NOT NULL, `lock_value` VARCHAR(20) NOT NULL, `expire` BIGINT, primary key (`lock_key`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (\u0026#39;AsyncCommitting\u0026#39;, \u0026#39; \u0026#39;, 0); INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (\u0026#39;RetryCommitting\u0026#39;, \u0026#39; \u0026#39;, 0); INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (\u0026#39;RetryRollbacking\u0026#39;, \u0026#39; \u0026#39;, 0); INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (\u0026#39;TxTimeoutCheck\u0026#39;, \u0026#39; \u0026#39;, 0); -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 而且业务数据库也需要增加该表 双击seata-server.bat启动即可 服务已经注册到nacos中了 注意命名空间，我们springboot的demo是public的，所以需要将seata的命名空间改为public 基本使用\r引入依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-seata\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在微服务中新增如下配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 seata: registry: type: nacos nacos: server-addr: localhost:8848 namespace: public group: DEFAULT_GROUP # tc服务在nacos的注册名称 application: seata-server username: nacos password: nacos # 事务组，根据这个获取tc服务的cluster名称 tx-service-group: seata-demo service: # 事务组与TC服务cluster的映射关系 vgroup-mapping: seata-demo: SH 完整的配置如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 server: port: 8070 spring: application: name: account-service cloud: nacos: config: server-addr: localhost:8848 discovery: server-addr: localhost:8848 config: import: nacos:nacos-config-example.properties?refresh=true datasource: # 数据库驱动： driver-class-name: com.mysql.cj.jdbc.Driver # 数据库连接地址 name: defaultDataSource # 数据库用户名\u0026amp;密码： username: root password: 123456 # 数据源名称 url: jdbc:mysql://localhost:3306/sentinel_account?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8 mybatis-plus: configuration: # 配置mybatis-plus 打印sql日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # mybatis-plus下划线转驼峰配置，默认为true map-underscore-to-camel-case: true # xml文件路径 mapper-locations: classpath:/mapper/**/*.xml # 配置mybatis-plus 包路径 type-aliases-package: com.example.account.entity seata: registry: type: nacos nacos: server-addr: localhost:8848 namespace: public group: DEFAULT_GROUP # tc服务在nacos的注册名称 application: seata-server username: nacos password: nacos # 事务组，根据这个获取tc服务的cluster名称 tx-service-group: seata-demo service: # 事务组与TC服务cluster的映射关系 vgroup-mapping: seata-demo: SH 如果需要锁定一个服务，我们需要确定以下四个配置\n命名空间 服务分组 服务名称 集群名称 集群如下 再改一下seata的配置，配置SH集群 我们并没有在微服务的application文件中配置cluster 并不能在registry下直接配置cluster 正确做法是配置事务组，将事务分组，比如account、order、storage将来会被同一个tc集群管理，所以需要将它们配置到同一个事务组下\n再根据事务组获取到映射关系，最终找到集群名称\n这部分涉及到了seata的高可用，暂时不用过多深究 启动服务 启动微服务后，seata控命令窗口打印日志如下\n1 RM register success,message:RegisterRMRequest{resourceIds=\u0026#39;jdbc:mysql://localhost:3306/sentinel_account\u0026#39;, version=\u0026#39;1.7.0-native-rc2\u0026#39;, applicationId=\u0026#39;account-service\u0026#39;, transactionServiceGroup=\u0026#39;seata-demo\u0026#39;, extraData=\u0026#39;null\u0026#39;},channel:[id: 0xc06aa8c5, L:/192.168.56.1:8091 - R:/192.168.56.1:57929],client version:1.7.0-native-rc2 动手实践\rXA模式\r概念\rXA规范是x/Open组织定义的分布式事务处理(DTP, Distributed Transaction Processing)标准，XA规范描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对XA规范提供了支持。XA模式是一种强一致性、低可用性的模式 正常情况 异常情况 Seata中的XA模式\rseata的XA模式做了一些调整,但大体相似 RM一阶段的工作:\n注册分支事务到TC 执行分支业务sq|但不提交 报告执行状态到TC TC二阶段的工作: TC检测各分支事务执行状态 ​\ta.如果都成功，通知所有RM提交事务 ​\tb.如果有失败，通知所有RM回滚事务 RM二阶段的工作: 接收TC指令，提交或回滚事务 总结\rXA模式的优点是什么?\n事务的强一致性,满足ACID原则。 常用数据库都支持，实现简单，并且没有代码侵入 XA模式的缺点是什么? 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差 依赖关系型数据库实现事务(如redis就无法实现) 实现XA模式\r修改application.yml文件，开启XA模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 seata: registry: type: nacos nacos: server-addr: localhost:8848 namespace: public group: DEFAULT_GROUP # tc服务在nacos的注册名称 application: seata-server username: nacos password: nacos # 事务组，根据这个获取tc服务的cluster名称 tx-service-group: seata-demo service: # 事务组与TC服务cluster的映射关系 vgroup-mapping: seata-demo: SH # 开启XA模式 data-source-proxy-mode: XA 给发起全局事务的入口方法添加@GlobalTransactional注解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Slf4j @Service public class OrderServiceImpl implements OrderService { private final AccountClient accountClient; private final StorageClient storageClient; private final OrderMapper orderMapper; public OrderServiceImpl(AccountClient accountClient, StorageClient storageClient, OrderMapper orderMapper) { this.accountClient = accountClient; this.storageClient = storageClient; this.orderMapper = orderMapper; } @Override @GlobalTransactional public Long create(Order order) { // 创建订单 orderMapper.insert(order); try { // 扣用户余额 accountClient.deduct(order.getUserId(), order.getMoney()); // 扣库存 storageClient.deduct(order.getCommodityCode(), order.getCount()); } catch (FeignException e) { log.error(\u0026#34;下单失败，原因:{}\u0026#34;, e.contentUTF8(), e); throw new RuntimeException(e.contentUTF8(), e); } return order.getId(); } } 重启服务并测试 运行前的数据 运行后的数据 可以看到实现了全局事务\nAT模式\r概念\rAT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。 阶段一RM的工作:\n注册分支事务 记录undo-log (数据快照) 执行业务sql并提交 报告事务状态 阶段二提交时RM的工作: 删除undo-log即可\n阶段二回滚时RM的工作: 根据undo-log恢复数据到更新前 案例如下 一个分支业务的SQL是这样的:\n1 update tb account set money = money- 10 where id = 1 总结\r简述AT模式与XA模式最大的区别是什么?\nXA模式一阶段不提交事务，锁定资源; AT模式一阶段直接提交，不锁定资源。 XA模式依赖数据库机制实现回滚; AT模式利用数据快照实现数据回滚。 XA模式强一致; AT模式最终一致 AT模式的脏写问题\r事务1在提交事务之后，紧接着被事务2获取到了锁，而事务1的全局事务需要回滚，则此时事务1会将money恢复到100，但是影响到了事务2的操作\n原因就是事务没有做到隔离，解决方式就是引入全局锁，标记对某行数据的拥有权，在事务提交前，其他事务无法修改 事务1在提交事务后，释放DB锁；而DB锁马上被事务2获取到了，但全局事务锁在事务1手上，事务2拿不到\n而DB锁在事务2手上，事务1拿不到，此时产生了死锁，但由于获取全局事务锁的过程有重试机制，任务超时会回滚并释放DB锁\n这时事务1获取到了DB锁 有一个问题，如果在事务1的1.3~2.1过程中，有一个不被seata管理的事务修改了值，也会产生脏写问题 在保存快照时，保存两份数据，一个是修改前的，一个是修改后的\n当释放全局锁时，对比修改后的数据，如果不一致，说明在这段时间有其他事务修改了数据\n这就没办法了，只能人工介入，这是比较极端的情况\n总结\rAT模式的优点:\n一阶段完成直接提交事务,释放数据库资源，性能比较好 利用全局锁实现读写隔离 没有代码侵入,框架自动完成回滚和提交 AT模式的缺点: 两阶段之间属于软状态，属于最终一致 框架的快照功能会影响性能,但比XA模式要好很多 步骤\r新建两张表，其中lock_table导入到TC服务关联的数据库，undo_log表导入到微服务关联的数据库，这些操作在Seata配置阶段已经做过了\n修改application.yml，将事务模式改为AT即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 seata: registry: type: nacos nacos: server-addr: localhost:8848 namespace: public group: DEFAULT_GROUP # tc服务在nacos的注册名称 application: seata-server username: nacos password: nacos # 事务组，根据这个获取tc服务的cluster名称 tx-service-group: seata-demo service: # 事务组与TC服务cluster的映射关系 vgroup-mapping: seata-demo: SH data-source-proxy-mode: AT 重启服务测试\nTCC模式\r概念\rTCC模式与AT模式非常相似,每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复，而非自动恢复(生成快照)。需要实现三个方法:\nTry: 资源的检测和预留; Confirm: 完成资源操作业务;要求Try成功Confirm一定要能成功。 Cancel: 预留资源释放,可以理解为try的反向操作。 总结\rTCC模式的每个阶段是做什么的?\nTry:资源检查和预留 Confirm:业务执行和提交 Cancel:预留资源的释放 TCC的优点是什么? 一阶段完成直接提交事务,释放数据库资源,性能好 相比AT模型，无需生成快照，无需使用全局锁，性能最强 不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库 TCC的缺点是什么? 有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦 软状态，事务是最终一致 需要考虑Confirm和Cancel的失败情况，做好幂等处理。(失败后，seata会重试，需要考虑重复处理的情况) 案例\r需求如下:\n修改account-service,编写try、confirm、 cancel逻辑 try业务:添加冻结金额，扣减可用金额 confirm业务:删除冻结金额 cancel业务:删除冻结金额，恢复可用金额 保证confirm、cancel接口的幂等性（业务接口不会因为重复调用出现问题） 允许空回滚 拒绝业务悬挂 有几个需要注意的点，资源预留是为了修改目标数据的值，但是新增订单是一个新增逻辑，这并不适合TCC模式，用AT模式就很好了\n扣减余额和扣减库存可以使用TCC模式，在一个分布式事务当中既有TCC模式又有AT模式可以么？\n答案是可以的\n空回滚问题\r当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚,就是空回滚。这里并没有进行资源预留也无法进行回滚，但是这里也不能进行报错，否则Seata会认为cancel失败，应该返回正常结束。 业务悬挂\r此时阻塞的业务终于畅通了，但是这个事务已经提交了，后续既没有进行confirm也没有执行cancel\n对于已经空回滚的业务，如果以后继续执行try,就永远不可能confirm或cancel,这就是业务悬挂。应当阻止执行空回滚后的try操作，避免悬挂 为了避免空回滚，应该在cancel判断是否进行了try\n为了避免业务悬挂，应该在try判断是否进行了cancel\n这样就必须在数据库里记录当前状态，判断当前是在try？还是在confirm或者cancel？\n1 2 3 4 5 6 7 8 9 10 -- auto-generated definition create table accoutn_freeze_tbl_8 ( xid varchar(188) not null comment \u0026#39;事务编号\u0026#39; primary key, user_id varchar(255) null comment \u0026#39;用户编号`\u0026#39;, freeze_money int unsigned default 0 null comment \u0026#39;冻结金额\u0026#39;, state int null comment \u0026#39;事务状态(0:try、1:confirm、2:cancel)\u0026#39; ) comment \u0026#39;冻结金额表\u0026#39;; try业务\r记录冻结金额和事务状态到account_ freeze表 扣减account表可用金额 confirm业务\r根据xid删除account_freeze表的冻结记录\ncancel业务\r修改account_ freeze表,冻结金额为0，state为2 修改account表，恢复可用金额 如何判断是否空回滚\rcancel业务中，根据xid查询account_freeze,如果为null则说明try还没做，需要空回滚\n如何避免是否业务悬挂\rtry业务中，根据xid查询account_freeze如果已经存在则证明Cancel已经执行，拒绝执行try业务\n代码实现\rTCC的Try、Confirm、 Cancel方法都需要在接口中基于注解来声明，语法如下:\nname指定try方法、commitMethod指定confirm方法、rollbackMethod指定cancel方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 public interface AccountTCCService { /** * 从用户账户中扣款 * * @param userId 用户 ID * @param money 钱 */ @TwoPhaseBusinessAction(name = \u0026#34;deduct\u0026#34;, commitMethod = \u0026#34;confirm\u0026#34;, rollbackMethod = \u0026#34;cancel\u0026#34;) void deduct(@BusinessActionContextParameter(paramName = \u0026#34;userId\u0026#34;) String userId, @BusinessActionContextParameter(paramName = \u0026#34;money\u0026#34;) int money); boolean confirm(BusinessActionContext context); boolean cancel(BusinessActionContext context); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Data @TableName(\u0026#34;account_freeze_tbl\u0026#34;) public class AccountFreeze { @TableId(type = IdType.INPUT) private String xid; private String userId; private Integer freezeMoney; private Integer state; public static abstract class State { public final static int TRY = 0; public final static int CONFIRM = 1; public final static int CANCEL = 2; } } 1 2 public interface AccountFreezeMapper extends BaseMapper\u0026lt;AccountFreeze\u0026gt; { } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @Slf4j @Service public class AccountTCCServiceImpl implements AccountTCCService { private final AccountMapper accountMapper; private final AccountFreezeMapper accountFreezeMapper; @Autowired public AccountTCCServiceImpl(AccountMapper accountMapper, AccountFreezeMapper accountFreezeMapper) { this.accountMapper = accountMapper; this.accountFreezeMapper = accountFreezeMapper; } /** * 扣除金额 * TCC try方法 * * @param userId 用户 ID * @param money 钱 */ @Transactional @Override public void deduct(String userId, int money) { // 获取事务id String xid = RootContext.getXID(); // 数据库字段设置为unsigned int，所以不能为负数 // 1.扣减金额 accountMapper.deduct(userId,money); // 2.记录冻结金额、事务状态 AccountFreeze accountFreeze = new AccountFreeze(); accountFreeze.setUserId(userId); accountFreeze.setFreezeMoney(money); accountFreeze.setState(AccountFreeze.State.TRY); accountFreeze.setXid(xid); accountFreezeMapper.insert(accountFreeze); } /** * 确认 * TCC confirm方法 * * @param context 上下文 * @return boolean */ @Override public boolean confirm(BusinessActionContext context) { // 获取事务id String xid = context.getXid(); // 删除了一条数据 return accountFreezeMapper.deleteById(xid)==1; } /** * 取消 * TCC cancel方法 * * @param context 上下文 * @return boolean */ @Override public boolean cancel(BusinessActionContext context) { // 查询冻结记录 String xid = context.getXid(); AccountFreeze accountFreeze = accountFreezeMapper.selectById(xid); // 1.恢复可用余额 accountMapper.refund(accountFreeze.getUserId(),accountFreeze.getFreezeMoney()); // 2.将冻结金额清零，状态设置为CANCEL accountFreeze.setFreezeMoney(0); accountFreeze.setState(AccountFreeze.State.CANCEL); int count = accountFreezeMapper.updateById(accountFreeze); return count==1; } } 以上是基本内容\n接下来增加对于空回滚和业务悬挂的判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @Slf4j @Service public class AccountTCCServiceImpl implements AccountTCCService { private final AccountMapper accountMapper; private final AccountFreezeMapper accountFreezeMapper; @Autowired public AccountTCCServiceImpl(AccountMapper accountMapper, AccountFreezeMapper accountFreezeMapper) { this.accountMapper = accountMapper; this.accountFreezeMapper = accountFreezeMapper; } /** * 扣除金额 * TCC try方法 * * @param userId 用户 ID * @param money 钱 */ @Transactional @Override public void deduct(String userId, int money) { // 获取事务id String xid = RootContext.getXID(); // 判断业务悬挂 AccountFreeze selectedById = accountFreezeMapper.selectById(xid);) if(selectedById!=null){ // cancel已经执行过 return; } // 数据库字段设置为unsigned int，所以不能为负数 // 1.扣减金额 accountMapper.deduct(userId,money); // 2.记录冻结金额、事务状态 AccountFreeze accountFreeze = new AccountFreeze(); accountFreeze.setUserId(userId); accountFreeze.setFreezeMoney(money); accountFreeze.setState(AccountFreeze.State.TRY); accountFreeze.setXid(xid); accountFreezeMapper.insert(accountFreeze); } /** * 确认 * TCC confirm方法 * * @param context 上下文 * @return boolean */ @Override public boolean confirm(BusinessActionContext context) { // 获取事务id String xid = context.getXid(); // 删除了一条数据，删除数据本来就是幂等性的 return accountFreezeMapper.deleteById(xid)==1; } /** * 取消 * TCC cancel方法 * * @param context 上下文 * @return boolean */ @Override public boolean cancel(BusinessActionContext context) { // 查询冻结记录 String xid = context.getXid(); String userId = context.getActionContext(\u0026#34;userId\u0026#34;).toString(); AccountFreeze accountFreeze = accountFreezeMapper.selectById(xid); // 空回滚的判断 if(accountFreeze==null){ // 记录空回滚的数据 accountFreeze.setUserId(userId); accountFreeze.setFreezeMoney(0); accountFreeze.setState(AccountFreeze.State.CANCEL); accountFreeze.setXid(xid); accountFreezeMapper.insert(accountFreeze); return true; } // 幂等性判断 if(accountFreeze.getState()==AccountFreeze.State.CANCEL){ // 已经执行过cancel方法了，无需重复执行 return true; } // 1.恢复可用余额 accountMapper.refund(accountFreeze.getUserId(),accountFreeze.getFreezeMoney()); // 2.将冻结金额清零，状态设置为CANCEL accountFreeze.setFreezeMoney(0); accountFreeze.setState(AccountFreeze.State.CANCEL); int count = accountFreezeMapper.updateById(accountFreeze); return count==1; } } Saga模式\rSaga模式是SEATA提供的长事务解决方案。也分为两个阶段:\n一阶段:直接提交本地事务 二阶段:成功则什么都不做;失败则通过编写补偿业务来回滚 Saga模式的缺点是没有隔离性 Saga模式优点: 事务参与者可以基于事件驱动实现异步调用，吞吐高 一阶段直接提交事务，无锁，性能好 不用编写TCC中的三个阶段，实现简单 缺点: 软状态持续时间不确定，时效性差 没有锁，没有事务隔离，会有脏写 模式对比\r","date":"2024-04-16T00:00:00Z","image":"http://localhost:1313/p/seata/202412212130408_hu17591647894307890052.png","permalink":"http://localhost:1313/p/seata/","title":"Seata"},{"content":"Resilience4j\r项目搭建\r熔断限流框架\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;properties\u0026gt; \u0026lt;spring-boot.version\u0026gt;3.0.2\u0026lt;/spring-boot.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;2022.0.0-RC2\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.30\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-circuitbreaker-resilience4j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 可直接导入spring-cloud-starter-circuitbreaker-resilience4j依赖或者导入resilience4j-spring-boot3\naop的依赖一定要导入\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.resilience4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;resilience4j-spring-boot3\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 server: port: 8080 spring: application: name: resilience4j-demo # 配置Resilience4j resilience4j: # 重试机制 retry: # 定义多个重试策略实例 instances: # 充实策略实例名称 retryApi: # 最大重试次数 max-attempts: 3 # 每次重试等待1s wait-duration: 1s # 断路器 circuitbreaker: # 定义多个断路器实例 instances: # 第一个断路器实例名称 circuitBreakerApi: # 健康监测 register-health-indicator: true # 滑动窗口大小 sliding-window-size: 10 # 但断路器处于半开状态时，允许的最大调用次数为3 permitted-number-of-calls-in-half-open-state: 3 # 滑动窗口类型 sliding-window-type: time_based # 断路器打开的最小请求数 minimum-number-of-calls: 5 # 断路器打开的时间 wait-duration-in-open-state: 5s # 失败率达到20%时，断路器打开 failure-rate-threshold: 20 # 事件缓冲区大小 event-consumer-buffer-size: 10 # 配置限流 ratelimiter: # 定义多个限流策略实例 instances: # 第一个限流策略实例名称 flowLimitApi: # 在一个特定的时间周期内，允许的最大请求数量为（QPS为1） limit-for-period: 1 # 这个时间周期的长度是1秒，即每1秒会重置请求计数 limit-refresh-period: 1s # 当请求超过限制时，客户端应立即收到超时的响应，而不等待处理 timeout-duration: 100ms 配置RestTemplate，待会测试失败重试机制，我这里就直接放在启动类下了\n1 2 3 4 5 6 7 8 9 10 @SpringBootApplication public class Resilience4jDemoApplication { public static void main(String[] args) { SpringApplication.run(Resilience4jDemoApplication.class, args); } @Bean public RestTemplate restTemplate() { return new RestTemplate(); } } 统一返回格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Data @AllArgsConstructor @NoArgsConstructor public class JsonData { /** * 状态码 0 表示成功，1表示处理中，-1表示失败 */ private Integer code; /** * 数据 */ private Object data; /** * 描述 */ private String msg; // 成功，传入数据 public static JsonData buildSuccess() { return new JsonData(0, null, null); } // 成功，传入数据 public static JsonData buildSuccess(Object data) { return new JsonData(0, data, null); } // 失败，传入描述信息 public static JsonData buildError(String msg) { return new JsonData(-1, null, msg); } // 失败，传入描述信息,状态码 public static JsonData buildError(String msg, Integer code) { return new JsonData(code, null, msg); } } 新建TestController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import com.example.utils.JsonData; import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker; import io.github.resilience4j.ratelimiter.annotation.RateLimiter; import io.github.resilience4j.retry.annotation.Retry; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import java.util.Random; @Slf4j @RestController public class TestController { private RestTemplate restTemplate; @Autowired public TestController(RestTemplate restTemplate) { this.restTemplate = restTemplate; } /** * 测试重试 * * @return {@link JsonData} */ @Retry(name = \u0026#34;retryApi\u0026#34;,fallbackMethod = \u0026#34;fallback\u0026#34;) @GetMapping(\u0026#34;/test1\u0026#34;) public JsonData test1() { log.info(\u0026#34;test1 received\u0026#34;); // 访问一个不存在的地址 String forObject = restTemplate.getForObject(\u0026#34;http://localhost:8085/test1\u0026#34;, String.class); return JsonData.buildSuccess(\u0026#34;test1\u0026#34;); } /** * 测试熔断 * * @return {@link JsonData} */ @CircuitBreaker(name = \u0026#34;circuitBreakerApi\u0026#34;,fallbackMethod = \u0026#34;fallback\u0026#34;) @GetMapping(\u0026#34;/test2\u0026#34;) public JsonData test2() { int i = new Random().nextInt(100); // 40%的可能报异常，超过20%则熔断 if(i\u0026gt;60){ throw new RuntimeException(\u0026#34;Unexpected Exception\u0026#34;); } return JsonData.buildSuccess(\u0026#34;test2\u0026#34;); } /** * 测试限流 * * @return {@link JsonData} */ @RateLimiter(name = \u0026#34;flowLimitApi\u0026#34;,fallbackMethod = \u0026#34;fallback\u0026#34;) @GetMapping(\u0026#34;/test3\u0026#34;) public JsonData test3() { return JsonData.buildSuccess(\u0026#34;test3\u0026#34;); } /** * fallback * * @param throwable 可投掷 * @return {@link JsonData} */ private JsonData fallback(Throwable throwable){ log.error(\u0026#34;fallback:\u0026#34;,throwable); return JsonData.buildError(throwable.getMessage()); } } 重试测试\r查看日志 熔断测试\r限流测试\r快速访问 ","date":"2024-04-15T00:00:00Z","image":"http://localhost:1313/p/resilience4j/202412212128271_hu11873971746138901050.png","permalink":"http://localhost:1313/p/resilience4j/","title":"Resilience4j"},{"content":"server.port启动端口不生效\r配置里写的端口是8088，然而启动的依然是8080 首先清理一下缓存 发现没什么用\nmaven clean后重新编译\n依然没用\n转properties，有用\n我这里是装过了插件，可能是由于插件的影响 ","date":"2024-04-11T00:00:00Z","image":"http://localhost:1313/p/server.port%E5%90%AF%E5%8A%A8%E7%AB%AF%E5%8F%A3%E4%B8%8D%E7%94%9F%E6%95%88/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/server.port%E5%90%AF%E5%8A%A8%E7%AB%AF%E5%8F%A3%E4%B8%8D%E7%94%9F%E6%95%88/","title":"server.port启动端口不生效"},{"content":"Sentinel\r初识Sentinel\r雪崩问题\r故障的服务D，会导致服务A的tomcat资源耗尽\n微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。 解决雪崩问题的常见方式有四种:\n超时处理:设定超时时间，请求超过-定时间没有响应就返回错误信息，不会无休止等待 舱壁模式:限定每个业务能使用的线程数,避免耗尽整个tomcat的资源，因此也叫线程隔离。 熔断降级:由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。 流量控制:限制业务访问的QPS，避免服务因流量的突增而故障。 技术选型\r同类型的框架还有Resilience4j、Polly、Envoy等\n安装Sentinel\rSentinel下载地址，选择sentinel-dashboard-xxx.jar，自己新建一个startup.txt\n1 java -jar sentinel-dashboard-1.8.5.jar 然后将startup.txt后缀改为bat，双击运行\n或者自定义启动端口号\n1 java -Dserver.port=8718 -jar sentinel-dashboard-1.8.5.jar 账号密码默认是sentinel 配置开机自启动 博客链接\n创建项目\r在order服务导入sentinel依赖，并配置application.properties 然后访问一下order服务的controller http://localhost:8090/order/1\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 # 配置控制台地址 spring.cloud.sentinel.transport.dashboard=localhost:8089 sentinel主要采用线程池隔离、熔断降级、流量控制的方式来解决雪崩问题\n簇点链路\r簇点链路:就是项目内的调用链路,链路中被监控的每个接口就是一个资源。 默认情况下sentinel会监控SpringMVC的每一个端点(Endpoint) ，因此SpringMVC的每一个端点(Endpoint)就是调用链路中的一-个资源。 流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则: 需求:给/order/{orderld}这个资源设置流控规则，QPS不能超过5。然后进行压力测试。 流控模式\r在添加限流规则时，点击高级选项，可以选择三种流控模式:\n直接:统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式 关联:统计与当前资源相关的另一一个资源，触发阈值时，对当前资源限流 链路:统计从指定链路访问到本资源的请求，触发阈值时,对指定链路限流 关联模式\r统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流 使用场景:比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁,产生竞争。业务需求是有限支付和更新订单的业务,因此当修改订单业务触发阈值时，需要对查询订单业务限流，防止影响到更新订单的业务。 需求\n在OrderController新建两个端点: /order/query和/order/update, 无需实现业务 配置流控规则，当/order/update资源被访问的QPS超过5时，对/order/query请求限流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @RefreshScope @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @GetMapping(\u0026#34;/{id}\u0026#34;) public Orders findOne(@PathVariable Integer id) { Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; } @GetMapping(\u0026#34;/query\u0026#34;) public String query() { return \u0026#34;查询订单成功\u0026#34;; } @GetMapping(\u0026#34;/update\u0026#34;) public String update() { return \u0026#34;更新订单成功\u0026#34;; } } 然后访问一下 http://localhost:8090/order/query 和 http://localhost:8090/order/update、\n对/order/query添加流控 对update压力测试，限流query\n满足下面条件可以使用关联模式:\n两个有竞争关系的资源 一个优先级较高，一个优先级较低，我们希望当优先级高的触发阈值时，对优先级低的进行限流 链路模式\r链路模式:只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。 例如有两条请求链路: /test1 -\u0026gt; /common /test2 -\u0026gt; /common 如果只希望统计从/test2进入到/common的请求，则可以这样配置: 需求:有查询订单和创建订单业务,两者都需要查询商品。针对从查询订单进入到查询商品的请求统计并设置限流。 步骤:\n在OrderService 中添加一个queryGoods方法，不用实现业务 在OrderController中 ，改造/order/query端点，调用OrderService中的queryGoods方法 在OrderController中 添加一个/order/save的端 点,调用OrderService的queryGoods方法 给queryGoods设 置限流规则,从/order/query进 入queryGoods的方法限制QPS必须小于2 1 2 3 4 5 6 7 8 @Service public class OrdersServiceImpl extends ServiceImpl\u0026lt;OrdersMapper, Orders\u0026gt; implements OrdersService{ @Override public void queryGoods() { System.out.println(\u0026#34;查询商品成功\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @RefreshScope @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @GetMapping(\u0026#34;/{id}\u0026#34;) public Orders findOne(@PathVariable Integer id) { Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; } @GetMapping(\u0026#34;/query\u0026#34;) public String query() { ordersService.queryGoods(); return \u0026#34;查询订单成功\u0026#34;; } @GetMapping(\u0026#34;/update\u0026#34;) public String update() { return \u0026#34;更新订单成功\u0026#34;; } @GetMapping(\u0026#34;/save\u0026#34;) public String save() { ordersService.queryGoods(); return \u0026#34;创建订单成功\u0026#34;; } } 而service中的queryGoods()并没有被sentinel监控，无法配置限流规则，所以应该对其进行监控 Sentinel默认只标记Controller中的方法为资源，如果要标记其它方法，需要利用@SentinelResource注解\n1 2 3 4 5 6 7 8 9 @Service public class OrdersServiceImpl extends ServiceImpl\u0026lt;OrdersMapper, Orders\u0026gt; implements OrdersService{ @SentinelResource(\u0026#34;goods\u0026#34;) @Override public void queryGoods() { System.out.println(\u0026#34;查询商品成功\u0026#34;); } } Sentinel默认会将Controller方法做context整合,导致链路模式的流控失效 当 Sentinel 默认开启 web-context-unify 时，会将所有 Controller 方法的上下文路径进行整合，这意味着所有通过 Controller 的调用都会被视作一个统一的资源路径，这可能会导致链路模式下的流控规则失效。 具体来说，假设你有一个服务内部有多个接口相互调用形成了一条调用链路，如 /save -\u0026gt; /goods 和 /query -\u0026gt; /goods，如果你想要针对 /query 调用到 /goods 的这条特定调用链路设置流量控制，那么在 context 整合的情况下，Sentinel 无法区分这两个不同的调用链路，因为它们在上下文路径上都被视为同一个资源。 需要修改application.properties,添加配置\n1 2 3 4 # 配置控制台地址 spring.cloud.sentinel.transport.dashboard=localhost:8089 # 关闭 context 整合 spring.cloud.sentinel.web-context-unify=false 如果不关闭context整合，所有的controller会被认为是同一个根链路发展而来的子链路\n访问一下 http://localhost:8090/order/query 和 http://localhost:8090/order/save 删除其他的流控规则 使用Jmeter进行压力测试 /order/save /order/query 总结 直接:对当前资源限流 关联:高优先级资源触发阈值，对低优先级资源限流。 链路:阈值统计时，只统计从指定资源进入当前资源的请求是对请求来源的限流\n流控效果\r概念\r流控效果是指请求达到流控阈值时应该采取的措施，包括三种:\n快速失败:达到阈值后，新的请求会被立即拒绝并拋出FlowException异常。是默认的处理方式。 warm up:预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一-个较小值逐渐增加到最大阈值。 排队等待:让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长 预热模式warm up\rwarm up也叫预热模式，是应对服务冷启动的一种方案。threshold为最大阈值，coldFactor为冷启动因子，请求阈值初始值是threshold/coldFactor,持续指定时长后，逐渐提高到threshold值。而coldFactor的默认值是3. 例如，我设置QPS的threshold为10，预热时间为5秒,那么初始阈值就是10/3，也就是3,然后在5秒后逐渐增长到10 需求 给/order/{id}这个资源设置限流,最大QPS为10,利用warm up效果,预热时长为5秒 排队等待\r当请求超过QPS阈值时，快速失败和warm up会拒绝新的请求并抛出异常。而排队等待则是让所有请求进入一个队列中,然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长,则会被拒绝。 例如: QPS=5,意味着每200ms处理一个队列中的请求; timeout = 2000， 意味着预期等待超过2000ms的请求会被拒绝并抛出异常 需求 给/order/{id}这个资源设置限流，最大QPS为10， 利用排队的流控效果，超时时长设置为5s 而Jmeter配置的QPS是15，如果按照之前的情况（直接失败），则会有5个QPS无法处理 到后面请求超时则会直接失败 总结\r流控效果有哪些？\n快速失败: QPS超过阈值时，拒绝新的请求 warm up: QPS超过阈值时，拒绝新的请求; QPS阈值是逐渐提升的，可以避免冷启动时高并发导致服务宕机。 排队等待:请求会进入队列，按照阈值允许的时间间隔依次执行请求;如果请求预期等待时长大于超时时间，直接拒绝 热点参数限流\r之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是分别统计参数值相同的请求,判断是否超过QPS阈值。 案例\n给/order/{id}这个资源添加热点参数限流，规则如下:\n默认的热点参数规则是每1秒请求量不超过2 给1这个参数设置例外:每1秒请求量不超过4 给2这个参数设置例外:每1秒请求量不超过10 需要注意的是热点参数限流对默认的SpringMVC资源无效，只有通过@SentinelResource注解声明的资源才能生效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RefreshScope @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @SentinelResource(\u0026#34;hot\u0026#34;) @GetMapping(\u0026#34;/{id}\u0026#34;) public Orders findOne(@PathVariable Integer id) { Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; } } 可以看到/order/1的QPS是4 可以看到/order/2的QPS是10，全部通过 可以看到/order/3的QPS是默认阈值，即2 隔离和降级\r虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。而要将这些故障控制在一定范围，避免雪崩，就要靠线程隔离(舱壁模式)和熔断降级手段了。\n不管是线程隔离还是熔断降级,都是对客户端(调用方，示例中的服务A)的保护。 SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel。\n修改OrderService的application.properties文件，开启Feign的Sentinel功能 1 feign.sentinel.enabled=true 给FeignClient编写失败后的降级逻辑，但调用的服务异常时，返回备用方案 方式一: FallbackClass,无法对远程调用的异常做处理 方式二: FallbackFactory,可以对远程调用的异常做处理，我们选择这种 在feign-api项目中定义类，实现FallbackFactory 不少教程导入的是hystrix包下的FallbackFactory，但是sentinel已经不再使用hystrix依赖了，而openfeign包下也有一个FallbackFactory\n不确定是不是这个原因导致后文报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Slf4j public class UserClientFallbackFactory implements FallbackFactory\u0026lt;UserFeignClient\u0026gt; { @Override public UserFeignClient create(Throwable cause) { return new UserFeignClient() { @Override public User findOne(Integer id) { log.info(\u0026#34;findOne方法异常，执行降级逻辑\u0026#34;); return new User(); } }; } } 在feign-api项目中将UserClientFallbackFactory注册为一个Bean: 这里没有加@Configuration注解是因为在OrderApplication配置了@EnableFeignClients 1 2 3 4 5 6 7 8 9 10 public class FeignClientConfiguration { @Bean public Logger.Level feignLogLevel() { return Logger.Level.BASIC; } @Bean public UserClientFallbackFactory userClientFallbackFactory() { return new UserClientFallbackFactory(); } } 1 2 3 4 5 6 7 8 9 10 11 12 @EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class, basePackageClasses = { UserFeignClient.class }) @EnableDiscoveryClient @MapperScan(\u0026#34;com.example.order.mapper\u0026#34;) @SpringBootApplication public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } } 在feign-api项目中的UserClient接口中使用UserClientFallbackFactory: 1 2 3 4 5 @FeignClient(value = \u0026#34;user-service\u0026#34;,fallbackFactory = UserClientFallbackFactory.class) public interface UserFeignClient { @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User findOne(@PathVariable(value = \u0026#34;id\u0026#34;) Integer id); } 1 2 3 4 5 6 7 org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name \u0026#39;consumerController\u0026#39;: Unsatisfied dependency expressed through field \u0026#39;providerClient\u0026#39;: Error creating bean with name \u0026#39;feignSentinelBuilder\u0026#39; defined in class path resource [com/alibaba/cloud/sentinel/feign/SentinelFeignAutoConfiguration.class]: Post-processing of merged bean definition failed Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name \u0026#39;feignSentinelBuilder\u0026#39; defined in class path resource [com/alibaba/cloud/sentinel/feign/SentinelFeignAutoConfiguration.class]: Post-processing of merged bean definition failed Caused by: java.lang.IllegalStateException: Failed to introspect Class [com.alibaba.cloud.sentinel.feign.SentinelFeign$Builder] from ClassLoader [jdk.internal.loader.ClassLoaders$AppClassLoader@63947c6b] Caused by: java.lang.NoClassDefFoundError: org/springframework/cloud/openfeign/FeignClientFactory Caused by: java.lang.ClassNotFoundException: org.springframework.cloud.openfeign.FeignClientFactory at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641) ~[na:na] at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188) ~[na:na] 这里整合feign各种报错，估计是版本原因\n我尝试使用2.3.12.RELEASE的springboot是可以实现feign + nacos + sentinel的(还是jdk17)\ndemo链接放到github上了，链接\n做了个springboot3、nacos、openfeign、sentinel的demo，还是上面的这个链接，请切换boot3版本\nspringboot3报错解决，不使用UserClientFallbackFactory，删除该文件，feign.sentinel.enabled配置也删除\n使用@SentinelResource配合blockHandler属性 在服务被调用方新增\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\u0026#34;provider\u0026#34;) public class ProviderController { @SentinelResource(value = \u0026#34;providerQuery\u0026#34;,blockHandler = \u0026#34;blockHandler\u0026#34;) @GetMapping(\u0026#34;/query\u0026#34;) public String query(){ return \u0026#34;query...\u0026#34;; } public static String blockHandler(BlockException e) { return \u0026#34;请稍后再试！\u0026#34;; } } 添加流控规则 访问provider服务 访问provider自然是没有问题的，关键是consumer那边怎么样 可以，也被限流了\n需要注意的是blockHandler指定的方法返回值要和被标记@SentinelResource的方法(这里是query)保持一致，得是String\n否则会报错如下\n1 com.alibaba.csp.sentinel.slots.block.flow.FlowException: null 我们希望能同意来配置，而不是每个类都写一个单独的限流方法\n1 2 3 4 5 6 7 8 9 10 11 /** * 全局限流处理 * @author: 不是菜狗爱编程 * @date: 2024/04/10/7:27 * @description: */ public class GlobeBlockException { public static String blockHandler(BlockException e) { return \u0026#34;您访问太频繁了，请稍后再试！\u0026#34;; } } 1 2 3 4 5 6 7 8 9 @RestController @RequestMapping(\u0026#34;provider\u0026#34;) public class ProviderController { @SentinelResource(value = \u0026#34;providerQuery\u0026#34;,blockHandlerClass = GlobeBlockException.class, blockHandler = \u0026#34;blockHandler\u0026#34;) @GetMapping(\u0026#34;/query\u0026#34;) public String query(){ return \u0026#34;query...\u0026#34;; } } 以上代码在github中，链接\n注意切换boot3分支，main分支使用的是2.3.12.RELEASE版本springboot，2.3.12.RELEASE版本springboot可以正常使用自定义FallbackFactory类\n以上是关于大概的解法，下面展示order和user模块的写法 user模块 注意这里设置的blockHandler方法参数要比@SentinelResource标记的方法参数多一个BlockException，其它参数保持一致\n1 2 3 4 5 public class GlobeBlockException { public static User blockHandler(@PathVariable Integer id,BlockException e) { return new User(); } } 1 2 3 4 5 6 7 8 9 10 11 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private UserService userService; @SentinelResource(value = \u0026#34;userQueryById\u0026#34;,blockHandlerClass = GlobeBlockException.class,blockHandler = \u0026#34;blockHandler\u0026#34;) @GetMapping(\u0026#34;/{id}\u0026#34;) public User findOne(@PathVariable Integer id) { return userService.getById(id); } } 又出现一个问题，springboot启动多个user实例，但是sentinel设置限流规则后只对其中一个实例有效 看sentinel界面\n在这里设置多个即可 order也有效 线程隔离\r左侧是线程隔离，右侧是信号量隔离 对比 将原本的QPS换成线程数即可 需求 给UserClient的查询用户接口设置流控规则，线程数不能超过2。然后利用jemeter测试。 这里的请求都是正常，因为之前配置了降级的逻辑，所以会直接返回一个空的user对象，而不是报错\n熔断降级\r概念\r熔断降级是解决雪崩问题的重要手段。其思路是由断路器统计服务调用的异常比例、慢请求比例，如果超出阈值则会熔断该服务。即拦截访问该服务的一切请求;而当服务恢复时,断路器会放行访问该服务的请求。 熔断策略\u0026ndash;慢调用\r断路器熔断策略有三种:慢调用、异常比例、异常数 慢调用:业务的响应时长(RT)大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。例如: 解读: RT超过500ms的调用是慢调用，统计最近10000ms内的请求，如果请求量超过10次,并且慢调用比例不低于0.5则触发熔断，熔断时长为5秒。然后进入half-open状态,放行一次请求做测试。 需求\n给UserClient的查询用户接口设置降级规则，慢调用的RT阈值为50ms,统计时间为1秒，最小请求数量为5，失败阈值比例为0.4,熔断时长为5\n为了增加业务耗时，可以设置Thread.sleep(60) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private UserService userService; @SentinelResource(value = \u0026#34;userQueryById\u0026#34;,blockHandlerClass = GlobeBlockException.class,blockHandler = \u0026#34;blockHandler\u0026#34;) @GetMapping(\u0026#34;/{id}\u0026#34;) public User findOne(@PathVariable Integer id) { try { Thread.sleep(60); } catch (InterruptedException e) { throw new RuntimeException(e); } return userService.getById(id); } } 此时我们正常的响应时间是71ms 快速访问多次后熔断，熔断之后已经不再去尝试了，而是直接返回失败结果，这里的时间为4ms 服务的调用方响应如下 针对多实例也有效 熔断策略\u0026ndash;异常比例、异常数\r异常比例或异常数:统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值(或超过指定异常数) ,则触发熔断。例如: 解读:统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于0.5,则触发熔断，熔断时长为5秒。然后进入half-open状态，放行一次 请求做测试。\n故意抛出异常即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private UserService userService; @SentinelResource(value = \u0026#34;userQueryById\u0026#34;,blockHandlerClass = GlobeBlockException.class,blockHandler = \u0026#34;blockHandler\u0026#34;) @GetMapping(\u0026#34;/{id}\u0026#34;) public User findOne(@PathVariable Integer id) { if(id==2){ throw new RuntimeException(\u0026#34;抛出异常了\u0026#34;); } return userService.getById(id); } } 如果觉得直接返回报错不太友好，可以使用@RestControllerAdvice来进行统一的异常处理，这里不过多介绍这个注解，先看看熔断是否生效 再看看order服务调用是否正常 总结\rSentinel熔断降级的策略有哪些? 慢调用比例:超过指定时长的调用为慢调用，统计单位时长内慢调用的比例，超过阈值则熔断 异常比例:统计单位时长内异常调用的比例，超过阈值则熔断 异常数:统计单位时长内异常调用的次数,超过阈值则熔断\n授权规则\r当时在gateway网关的时候有做过过滤，可以阻止某些请求通过网关路由到微服务\n但如果有一天微服务的地址及端口被泄露出去了，请求就可能不通过网关，直接访问服务的的地址，这个时候微服务就很危险了 授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。 白名单:来源(origin) 在白名单内的调用者允许访问 黑名单:来源(origin)在黑名单内的调用者不允许访问 例如，我们限定只允许从网关来的请求访问order-service，不允许浏览器来直接访问,那么流控应用中就填写网关的名称. 这里的流控应用其实不是指的网关服务的名称，而是指的orign请求来源的名称 Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的。 而sentinel默认情况下，从gateway和浏览器到达的orign名称都是default，无法对网关和浏览器进行区分 所以需要实现RequestOriginParser该接口来自定义实现，比如\n1 2 3 4 5 6 7 8 9 10 11 @Component public class HeaderOriginParser implements RequestOriginParser { @Override public String parse0rigin(HttpServletRequest request) { String origin = request. getHeader(\u0026#34;origin\u0026#34;) ; if(Str ingUtils. isEmpty(origin)){ return \u0026#34;blank\u0026#34;; } return origin; } } 但现实是网关和浏览器默认都没有origin请求头，而我们给网关来的请求添加上origin即可\n网关过滤器AddRequestHeader可以实现，这里直接写成默认过滤器，所有经过网关的请求都添加上origin头\n1 2 3 4 5 6 spring: cloud: gateway: default-filters: #添加名为origin的请求头，值为gateway -AddRequestHeader=origin,gateway 所以流控应用就填gateway，注意这里的值，即gateway不要暴露了 理论结束，实践开始 order服务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Slf4j @Component public class HeadOriginParser implements RequestOriginParser { @Override public String parseOrigin(HttpServletRequest httpServletRequest) { // 获取请求头 String origin = httpServletRequest.getHeader(\u0026#34;origin\u0026#34;); // 判空 if(!StringUtils.hasLength(origin)){ // origin为空 origin=\u0026#34;blank\u0026#34;; } log.info(\u0026#34;当前请求:{},origin请求头:{}\u0026#34;,httpServletRequest.getRequestURI(),origin); return origin; } } 网关服务配置，主要是- AddRequestHeader=origin,gateway\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/** default-filters: # - AddRequestHeader=color,this is red - AddRequestHeader=origin,gateway 通过网关服务访问 直接访问 自定义异常结果\r默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口 判断这里异常的类型，然后返回自定义结果 而BlockException包含很多个子类，分别对应不同的场景: 具体写法可参考 order服务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Component public class SentinelBlockHandler implements BlockExceptionHandler { @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws Exception { String msg = \u0026#34;未知异常\u0026#34;; int status = 429; if (e instanceof FlowException) { msg = \u0026#34;请求被限流了! \u0026#34;; } else if (e instanceof DegradeException) { msg = \u0026#34;请求被降级了! \u0026#34;; } else if (e instanceof ParamFlowException) { msg = \u0026#34;热点参数限流! \u0026#34;; } else if (e instanceof AuthorityException) { msg = \u0026#34;请求没有权限! \u0026#34;; status = 401; } httpServletResponse.setContentType(\u0026#34;application/json;charset=utf-8\u0026#34;); httpServletResponse.setStatus(status); httpServletResponse.getWriter().println(\u0026#34;{\\\u0026#34;message\\\u0026#34;: \\\u0026#34;\u0026#34; + msg + \u0026#34;\\\u0026#34;， \\\u0026#34;status\\\u0026#34;: \u0026#34; + status + \u0026#34;}\u0026#34;); } } 重启服务后新建授权规则 也可以使用@SentinelResource注解方式\n1 2 3 4 5 6 7 8 9 10 11 @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { @Autowired private OrdersService ordersService; @SentinelResource(value = \u0026#34;orderFindOne\u0026#34;,blockHandlerClass = GlobeBlockException.class,blockHandler = \u0026#34;blockHandler\u0026#34;) @GetMapping(\u0026#34;/{id}\u0026#34;) public Orders findOne(@PathVariable Integer id) { return ordersService.queryByOrderId(id); } } 1 2 3 4 5 6 7 @Slf4j public class GlobeBlockException { public static Orders blockHandler(@PathVariable Integer id, BlockException e) { log.error(\u0026#34;当前服务繁忙，请稍后再试\u0026#34;); return new Orders(); } } 配置授权规则 虽然只能返回与使用@SentinelResource注解标注的方法相同的返回值类型，但是在springboot的restful风格的api中，我们通常会统一返回结果 如JsonData或者R等统一返回值类型\n规则持久化\r概念\rSentinel的控制台规则管理有三种模式:\n原始模式: Sentinel的默认模式，将规则保存在内存,重启服务会丢失。 pull模式 push模式 pull模式\rpull模式:控制台将配置的规则推送到Sentinel客户端,而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。 由于是定时轮询读取，所以存在时效性问题，导致了服务中规则不一致的问题\npush模式\rpush模式:控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户 端监听Nacos,获取配置变更的推送消息，完成本地配置更新。 总结\rSentinel的三种配置管理模式是什么?\n原始模式:保存在内存 pull模式:保存在本地文件或数据库，定时去读取 push模式:保存在nacos，监听变更实时更新 实现push模式\r参考博客 push模式实现最为复杂，依赖于nacos,并且需要修改Sentinel控制台源码。 引入依赖\n1 2 3 4 5 6 7 8 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.csp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sentinel-datasource-nacos\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-sentinel-datasource\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置nacos地址\n示例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 spring: cloud: sentinel: datasource: flow: nacos: # nacos地址 server-addr: localhost:8848 dataId: orderservice-flow-rules groupId: SENTINEL_GROUP #还可以是: degrade(降级)、authority(授权)、 param-flow(参数限流) rule-type: flow # 如果需要多个配置，继续添加即可，如下所示 degrade: nacos: server-addr: localhost:8848 dataId: orderservice-degrade-rules groupId: SENTINEL_GROUP rule-type: degrade 以上是配置格式，接下来正式配置user\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 server: port: 8080 spring: application: name: user-service cloud: nacos: config: file-extension: properties namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c prefix: ${spring.application.name} server-addr: localhost:8848 discovery: cluster-name: JS ephemeral: false namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c server-addr: localhost:8848 sentinel: transport: dashboard: localhost:8089 web-context-unify: false datasource: flow: nacos: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c data-id: user-service-sentinel group-id: DEFAULT_GROUP data-type: json #还可以是: degrade(降级)、authority(授权)、 param-flow(参数限流) rule-type: flow config: import: nacos:${spring.cloud.nacos.config.prefix}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}?refresh=true profiles: active: dev 上面配置中，sentinel规则配置到nacos dataId为user-service-sentinel的配置中了\n1 2 3 4 5 6 7 8 9 10 [ { \u0026#34;resource\u0026#34;: \u0026#34;userQueryById\u0026#34;, \u0026#34;controlBehavior\u0026#34;: 0, \u0026#34;count\u0026#34;: 5, \u0026#34;grade\u0026#34;: 1, \u0026#34;limitApp\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;strategy\u0026#34;: 0 } ] 以上配置是指\nresource：资源名。 limitApp：来源应用。 grade：阈值类型。0 表示线程数，1 表示是QPS。 count：单机阈值。 strategy：流控模式。0 表示直接，1 表示关联，2 表示链路。 controlBehavior：流控效果。0 表示快速失败，1 表示Warm up，2 表示排队等待。 clusterMode：是否集群。false 表示否，true 表示是。 这里选择resource为userQueryById，因为@SentinelResource标记资源为userQueryById还记得吗？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private UserService userService; @SentinelResource(value = \u0026#34;userQueryById\u0026#34;,blockHandlerClass = GlobeBlockException.class,blockHandler = \u0026#34;blockHandler\u0026#34;) @GetMapping(\u0026#34;/{id}\u0026#34;) public User findOne(@PathVariable Integer id) { if(id==2){ throw new RuntimeException(\u0026#34;抛出异常了\u0026#34;); } return userService.getById(id); } } 测试一下是否可行 order也没问题 重启服务，查看sentinel控制台，规则是否还存在 但是有个需要注意的点，这是sentinel读nacos配置的规则，而在sentinel中配置的规则，不能同步到nacos\n如果需要让sentinel的配置同步到nacos，nacos修改的配置sentinel也能获取到，则需要修改sentinel-dashboard.jar的源码了\n网上也有教程\n","date":"2024-04-10T00:00:00Z","image":"http://localhost:1313/p/sentinel/202412212132620_hu11153553383465729626.png","permalink":"http://localhost:1313/p/sentinel/","title":"Sentinel"},{"content":"SpringCloud\r服务的注册发现\rHttp请求\r微服务远程调用可以采用Http和RPC的方式\n项目搭建\r注册RestTemplate，通过RestTemplate来实现http请求调用其他服务\n新建一个空项目，名为cloud-demo 在cloud-demo下新建一个order项目和user项目(这里采用jdk17新建springboot3工程) cloud-demo/pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;cloud-demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;cloud-demo\u0026lt;/description\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;order\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;user\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;3.0.2\u0026lt;/spring-boot.version\u0026gt; \u0026lt;spring-cloud-alibaba.version\u0026gt;2022.0.0.0-RC2\u0026lt;/spring-cloud-alibaba.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;2022.0.0-RC2\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;mysql.version\u0026gt;8.3.0\u0026lt;/mysql.version\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;mybatis-plus.version\u0026gt;3.5.5\u0026lt;/mybatis-plus.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mysql.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-alibaba.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;/project\u0026gt; user/pom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;user\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;user\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;user\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; order与user一样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;order\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;order\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;order\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; user/application.properties\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 spring.application.name=user-service # 应用服务 WEB 访问端口 server.port=8080 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/cloud-user?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8 # 数据库用户名\u0026amp;密码： spring.datasource.username=root spring.datasource.password=123456 # 数据源名称 spring.datasource.name=defaultDataSource # 配置mybatis-plus 打印sql日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # xml文件路径 mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml # 配置mybatis-plus 包路径 mybatis-plus.type-aliases-package=com.example.user.domain # 配置全局默认主键类型，实体类不用加@TableId(value =\u0026#34;id\u0026#34;,type = IdType.AUTO) mybatis-plus.global-config.db-config.id-type=auto order/application.properties\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 spring.application.name=order-service # 应用服务 WEB 访问端口 server.port=8090 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/cloud-order?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8 # 数据库用户名\u0026amp;密码： spring.datasource.username=root spring.datasource.password=123456 # 数据源名称 spring.datasource.name=defaultDataSource # 配置mybatis-plus 打印sql日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # xml文件路径 mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml # 配置mybatis-plus 包路径 mybatis-plus.type-aliases-package=com.example.order.domain # 配置全局默认主键类型，实体类不用加@TableId(value =\u0026#34;id\u0026#34;,type = IdType.AUTO) mybatis-plus.global-config.db-config.id-type=auto 这里使用idea自带的数据库管理工具来新建数据库 user数据库如下，输入cloud-user，order同理cloud-order\n右键数据库，选择创建表 1 2 3 4 5 6 7 8 9 10 11 12 13 create table user ( id int auto_increment comment \u0026#39;用户编号\u0026#39;, username varchar(20) null comment \u0026#39;账号\u0026#39;, address varchar(50) null comment \u0026#39;地址\u0026#39;, constraint user_pk primary key (id) ) comment \u0026#39;用户表\u0026#39;; INSERT INTO `cloud-user`.user (id, username, address) VALUES (1, \u0026#39;admin\u0026#39;, \u0026#39;湖北\u0026#39;); INSERT INTO `cloud-user`.user (id, username, address) VALUES (2, \u0026#39;zhangsan\u0026#39;, \u0026#39;湖南\u0026#39;); INSERT INTO `cloud-user`.user (id, username, address) VALUES (3, \u0026#39;lisi\u0026#39;, \u0026#39;山西\u0026#39;); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 create table `orders` ( id int auto_increment comment \u0026#39;订单编号\u0026#39;, name varchar(20) null comment \u0026#39;名称\u0026#39;, price decimal null comment \u0026#39;价格\u0026#39;, num int null comment \u0026#39;数量\u0026#39;, user_id int null comment \u0026#39;用户编号\u0026#39;, constraint order_pk primary key (id) ) comment \u0026#39;订单表\u0026#39;; INSERT INTO `cloud-order`.`orders` (id, name, price, num, user_id) VALUES (1, \u0026#39;小米手机\u0026#39;, 4999, 1, 1); INSERT INTO `cloud-order`.`orders` (id, name, price, num, user_id) VALUES (2, \u0026#39;华为手机\u0026#39;, 5999, 3, 1); INSERT INTO `cloud-order`.`orders` (id, name, price, num, user_id) VALUES (3, \u0026#39;魅族手机\u0026#39;, 3999, 2, 2); INSERT INTO `cloud-order`.`orders` (id, name, price, num, user_id) VALUES (4, \u0026#39;OPPO手机\u0026#39;, 4000, 1, 3); 我们的需求是:根据订单id查询订单的同时，把订单所属的用户信息一起返回\n这里就是MyBatisX一键生成mapper、service代码了\n这里需要注意个问题表名不要叫order，order属于数据库的关键字，选择orders 编写controller代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { @Autowired private OrdersService ordersService; @PostMapping public Boolean save(@RequestBody Orders orders) { return ordersService.saveOrUpdate(orders); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public Boolean delete(@PathVariable Integer id) { return ordersService.removeById(id); } @GetMapping public List\u0026lt;Orders\u0026gt; findAll() { return ordersService.list(); } @GetMapping(\u0026#34;/{id}\u0026#34;) public Orders findOne(@PathVariable Integer id) { return ordersService.getById(id); } @GetMapping(\u0026#34;/page\u0026#34;) public Page\u0026lt;Orders\u0026gt; findPage(@RequestParam Integer pageNum, @RequestParam Integer pageSize) { return ordersService.page(new Page\u0026lt;\u0026gt;(pageNum, pageSize)); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private UserService userService; @PostMapping public Boolean save(@RequestBody User user) { return userService.saveOrUpdate(user); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public Boolean delete(@PathVariable Integer id) { return userService.removeById(id); } @GetMapping public List\u0026lt;User\u0026gt; findAll() { return userService.list(); } @GetMapping(\u0026#34;/{id}\u0026#34;) public User findOne(@PathVariable Integer id) { return userService.getById(id); } @GetMapping(\u0026#34;/page\u0026#34;) public Page\u0026lt;User\u0026gt; findPage(@RequestParam Integer pageNum, @RequestParam Integer pageSize) { return userService.page(new Page\u0026lt;\u0026gt;(pageNum, pageSize)); } } 输入http://localhost:8080/user/1即可访问到user的结果\n输入http://localhost:8090/order/1即可访问到order的结果\n根据订单id查询订单的同时，把订单所属的用户信息一起返回 需求可以转变为 在OrderController中请求一下user的结果，然后封装返回 配置Order服务的RestTemplate\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; /** * Http请求调用配置 * @author: 不是菜狗爱编程 * @date: 2024/04/04/8:40 * @description: */ @Configuration public class HttpConfig { /** * 创建RestTemplate并注入spring容器 * * @return {@link RestTemplate} */ @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } } 复制User实体类到Order服务\n1 2 3 4 5 6 7 8 @Data @AllArgsConstructor @NoArgsConstructor public class User implements Serializable { private Integer id; private String username; private String address; } Order服务新增一个User属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @TableName(value =\u0026#34;orders\u0026#34;) @Data public class Orders implements Serializable { @TableId(type = IdType.AUTO) private Integer id; private String name; private Integer price; private Integer num; private Integer userId; @TableField(exist = false) private User user; @TableField(exist = false) private static final long serialVersionUID = 1L; } 修改OrdersController方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { private static final String USER_SERVICE_URL=\u0026#34;http://localhost:8080/user/\u0026#34;; @Autowired private OrdersService ordersService; @Autowired private RestTemplate restTemplate; @GetMapping(\u0026#34;/{id}\u0026#34;) public Orders findOne(@PathVariable Integer id) { Orders orders = ordersService.getById(id); User user = restTemplate.getForObject(USER_SERVICE_URL + orders.getUserId(), User.class); orders.setUser(user); return orders; } } 访问http://localhost:8090/order/1 以上，实现了跨入服务的远程调用\nEureka\r概念\r服务提供者: 一次业务中，被其它微服务调用的服务。(提供接口给其它微服务) 服务消费者: 一次业务中，调用其它微服务的服务。(调用其它微服务提供的接口) 以上代码的实现中，User是服务的提供者，Order是服务的消费者 代码中使用硬编码将url写在代码中，将来如果部署成集群，则硬编码应该怎么办？ 应该选择哪一台？选的那一台实例是否依然正常？ Eureka、Nacos可以实现上述需求 在每一个服务启动时，将自己的服务信息注册到Eureka中，这时候Eureka中已经存储了相关的Order和User服务的信息\n在Order服务调用User服务时，Order服务前往Eureka中找到User服务的url\n那怎么知道找到的User服务是否依然正常运行？\n服务会每30s向Eureka发送心跳，如果心跳停止，说明服务异常 在Eureka架构中，微服务角色有两类:\nEurekaServer: 服务端，注册中心 记录服务信息 心跳监控 EurekaClient: 客户端 Provider: 服务提供者，例如案例中的user-service 注册自己的信息到EurekaServer 每隔30秒向EurekaServer发送心跳 consumer:服务消费者，例如案例中的order-service 根据服务名称从EurekaServer拉取服务列表 基于服务列表做负载均衡，选中一个微服务后发起远程调用 搭建Eureka服务\r引入依赖 编写启动类，添加@EnableEurekaServer注解 配置application.properties cloud-demo/pom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;cloud-demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;cloud-demo\u0026lt;/description\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;order\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;user\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;eureka\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;3.0.2\u0026lt;/spring-boot.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;2022.0.0-RC2\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;mysql.version\u0026gt;8.3.0\u0026lt;/mysql.version\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;mybatis-plus.version\u0026gt;3.5.5\u0026lt;/mybatis-plus.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mysql.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;/project\u0026gt; eureka/pom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;eureka\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;eureka\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;eureka\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 1 2 3 4 5 6 7 @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); } } 1 2 3 4 5 6 7 8 9 10 # 应用服务 WEB 访问端口 server.port=8070 # 是否将自己注册到注册中心 eureka.client.register-with-eureka=false # 是否从EurekaServer抓取已有的注册信息，默认为true。 单节点无所谓， 集群必须设置为true才能配合ribbon使用负载均衡 eureka.client.fetch-registry=false eureka.client.service-url.defaultZone=http://localhost:${server.port}/eureka/ # 关闭自我保护机制 eureka.server.enable-self-preservation=false eureka.server.eviction-interval-timer-in-ms=2000 Eureka配置成功，只是此时并没有服务注册到Eureka\n服务注册\r配置user和order，将服务注册进eureka\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 eureka.instance.hostname=${spring.application.name} # 是否显示ip eureka.instance.prefer-ip-address=true #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒) eureka.instance.lease-renewal-interval-in-seconds=3 #Eureka,服务端在收到最后-次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务 eureka.instance.lease-expiration-duration-in-seconds=5 eureka.client.service-url.defaultZone=http://localhost:8070/eureka/ 可以看到此时服务已经注册到Eureka了，但这些服务都是一个实例，启动多个实例试试 如果找不到Services，可以在View - Tool Windows处添加 右键服务，选择Copy Configuration 1 2 # 配置服务启动端口 -Dserver.port=8081 右键启动该实例 前往Eureka页面查看 服务发现\r我们希望Order服务调用User服务时，前往Eureka注册中心获取到User服务的信息\n而不是使用硬编码的形式写死User服务的ip和端口\n修改OrderService的代码，修改访问的url路径，用服务名代替ip、端口: 1 String url = \u0026#34;http://user-service/user/\u0026#34; + order.getUserId(); 在order-service项目的启动类OrderApplication中的RestTemplate添加负载均衡注解: 1 2 3 4 5 @Bean @LoadBalanced public RestTempLate restTempLate() { return new RestTemplate() ; } 在启动类山添加@EnableDiscoveryClient注解 修改HttpConfig的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration public class HttpConfig { /** * 创建RestTemplate并注入spring容器 * * @return {@link RestTemplate} */ @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } } 修改OrdersController代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { @Autowired private OrdersService ordersService; @Autowired private RestTemplate restTemplate; @GetMapping(\u0026#34;/{id}\u0026#34;) public Orders findOne(@PathVariable Integer id) { Orders orders = ordersService.getById(id); User user = restTemplate.getForObject(\u0026#34;http://user-service/user/\u0026#34; + orders.getUserId(), User.class); orders.setUser(user); return orders; } } 如果报错No instances available for user-service\n请查看博客 如果依然不能解决，请查看application.properties里是否配置了如下内容，如果是，删除后重启即可解决\n1 2 # 是否从EurekaServer抓取已有的注册信息，默认为true。 单节点无所谓， 集群必须设置为true才能配合ribbon使用负载均衡 eureka.client.fetch-registry=false 这样就可以通过服务名的方式来完成服务之间的调用，哪怕服务启动了多个实例\n负载均衡\r基础\rRibbon实现负载均衡 Ribbon是如何实现负载均衡的呢？ 添加了@LoadBalanced注解后，表明该RestTemplate发起的请求，需要被Ribbon来拦截处理\n而拦截的动作是LoadBalancerInterceptor来完成的\nidea中按两下shift后搜索即可 而LoadBalancerInterceptor类实现了ClientHttpRequestInterceptor接口 它会去拦截由客户端发起的Http请求，而RestTemplate正是一个发Http请求的客户端\nLoadBalancerInterceptor类实现了intercept方法\n在LoadBalancerInterceptor打断点调试一下，debug运行Order\n发现请求确实被LoadBalancerInterceptor拦截了 可以看到Order服务发起了一个Http请求，Url是http://user-service/user/1 执行完String serviceName = originalUri.getHost();代码之后，获取到了主机名user-service 进入loadBalancer.execute方法，继续执行 发现这里已经获取到User服务的ip了，我们运行了多个User服务的实例，这里大家可能看到的是8080或者8090\n是在这一行代码上获取到了User服务 那它怎么知道或者按什么规则来获取的其中一个User服务呢？\n继续进去，发现可能是在loadBalancer.choose获取到的 再往里走就是一个接口了ReactiveLoadBalancer\n按住Ctrl H查看这个接口的实现类 这里Eureka默认的调度机制其实是轮询 策略\r通过定义IRule实现可以修改负载均衡规则，有两种方式: 代码方式:在配置类中，定义一个新的IRule:(全局配置，不管调用哪个服务，都会采用这个负载均衡规则)\n1 2 3 4 @Bean pubtic IRuLe randomRuLe() { return new RandomRuLe(); } 第二种配置方案是properties，而这种方法是针对每个服务来配置负载均衡规则\n1 2 #负载均衡规则 user-service.ribbon.NFLoadBalancerRuLeCLassName=com.netflix.Loadbalancer.RandomRuLe 饥饿加载\rRibbon默认是采用懒加载，即第一 次访问时才会去创建LoadBalanceClient, 请求时间会很长。 而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载\n1 2 3 4 # 开启饥饿加载 ribbon.eager-load.enabled=true # 对指定服务饥饿加载 ribbon.eager-load.clients=user-service Nacos\r安装\rSpringBoot、SpringCloud、Alibaba版本对应关系 Nacos下载 选择2.2.1版本的Naocs nacos-2.2.1/bin/startup.cmd用vscode或者记事本打开 双击发现闪退，在结尾处加上如下代码\n1 2 pause endlocal 再次双击，查看到报错信息，找到博客\n还需要配置conf目录下的application.properties\nnacos.core.auth.default.token.secret.key 这个参数必须配置为base64编码而且不能小于32位，随便找个在线网站编码一下即可 重新启动nacos 账号密码都是nacos 在父工程中配置pom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;3.0.2\u0026lt;/spring-boot.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;2022.0.0\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;spring-cloud-alibaba.version\u0026gt;2022.0.0.0-RC2\u0026lt;/spring-cloud-alibaba.version\u0026gt; \u0026lt;spring-cloud-netflix.version\u0026gt;2.2.0.RELEASE\u0026lt;/spring-cloud-netflix.version\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;nacos-client.version\u0026gt;1.4.4\u0026lt;/nacos-client.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-netflix.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.nacos\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nacos-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${nacos-client.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-alibaba.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; Order和User服务的pom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; application.properties\n1 2 3 4 5 6 7 # 端口 server.port=8090 # 服务名 spring.application.name=order-service spring.cloud.nacos.discovery.server-addr=localhost:8848 spring.cloud.nacos.config.server-addr=localhost:8848 spring.cloud.nacos.config.import-check.enabled=false 测试一下负载均衡是否可用\n此时还没有意识到事情的严重性，然后就一直报错了\n解决报错\r查看博客\n因为Netflix的组件从2020年开始停止维护，因此spring cloud会逐渐弃用他家的组件,Ribbon就在其中\n依然没有解决该错误后，前往官网查看，发现官方给了例子\n但是版本跟我们的有区别\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.nacos\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nacos-client\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.nacos\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nacos-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 注意，我我们在父pom里配置了nacos-client的版本\n我使用官方例子的版本1.1.0和1.2.0报错如下\n1 java.lang.NoClassDefFoundError: com/alibaba/nacos/client/logging/NacosLogging 上网查询资料发现应该是版本不匹配，后打开依赖分析，发现有一堆依赖都不匹配 nacos-client版本改为1.4.4后以上报错解决，但是依然无法实现RestTemplate调用服务\n问题也是出在依赖上\n1 2 3 4 5 6 7 8 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-loadbalancer\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- \u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;/dependency\u0026gt;--\u0026gt; 将spring-cloud-starter-netflix-ribbon改为spring-cloud-loadbalancer，这里无需写版本号\n启动后解决问题\n依赖\r重新给一遍pom依赖，这里我使用的版本并不需要使用bootstrap.properties文件来配置，application.properties足矣 网上有说需要导入spring-cloud-starter-bootstrap依赖，我们这里并不需要 cloud-demo/pom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;cloud-demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;cloud-demo\u0026lt;/description\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;order\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;user\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;3.0.2\u0026lt;/spring-boot.version\u0026gt; \u0026lt;spring-cloud-alibaba.version\u0026gt;2022.0.0.0-RC2\u0026lt;/spring-cloud-alibaba.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;2022.0.0-RC2\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;mysql.version\u0026gt;8.3.0\u0026lt;/mysql.version\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;mybatis-plus.version\u0026gt;3.5.5\u0026lt;/mybatis-plus.version\u0026gt; \u0026lt;nacos-client.version\u0026gt;1.4.4\u0026lt;/nacos-client.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.nacos\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nacos-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${nacos-client.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mysql.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-alibaba.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;/project\u0026gt; order/pom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;order\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;order\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;order\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-loadbalancer\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.nacos\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nacos-client\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.nacos\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nacos-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;17\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;17\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;com.example.order.OrderApplication\u0026lt;/mainClass\u0026gt; \u0026lt;skip\u0026gt;true\u0026lt;/skip\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;repackage\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;repackage\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;netflix-candidates\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Netflix Candidates\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://artifactory-oss.prod.netflix.net/artifactory/maven-oss-candidates\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/project\u0026gt; user依赖也是一样 application.properties\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 应用服务 WEB 访问端口 server.port=8090 # 服务名 spring.application.name=order-service # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/cloud-order?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8 # 数据库用户名\u0026amp;密码： spring.datasource.username=root spring.datasource.password=123456 # 数据源名称 spring.datasource.name=defaultDataSource # 配置mybatis-plus 打印sql日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # xml文件路径 mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml # 配置mybatis-plus 包路径 mybatis-plus.type-aliases-package=com.example.order.domain spring.cloud.nacos.discovery.server-addr=localhost:8848 spring.cloud.nacos.config.server-addr=localhost:8848 spring.cloud.nacos.config.import-check.enabled=false 项目Gitee地址，切换到nacos分支即可 测试发现，负载均衡也可以使用\n服务分级存储模型\r入门\r每个服务启动多个实例，将这些实例划分到不同的集群\n服务调用尽可能选择本地集群的服务，跨集群调用延迟较高\n本地集群不可访问时，再去访问其它集群 点击Nacos服务 \u0026quot;详情\u0026quot; 集群是default，即没有集群 配置集群属性\n修改application.properties，添加如下内容\n1 2 # 配置集群名称，也就是机房位置，例如JS(江苏) spring.cloud.nacos.discovery.cluster-name=JS 在Nacos控制台看到集群的变化 再起一个User服务实例，现在是3个User服务实例了 将UserApplication1和UserApplication2设置到JS江苏集群，将UserApplication3设置到HN湖南集群\n启动UserApplication1和UserApplication2，然后将集群改为HN，启动UserApplication3即可 总结 Nacos服务分级存储模型\n一级是服务，例如userservice 二级是集群，例如杭州或上海 三级是实例，例如杭州机房的某台部署了userservice的服务器 服务集群属性\r这样配置还不算完，我们需要让Order服务调用User服务时，优先选择本地集群 这里并没有优先使用JS的User服务，依然采用的是轮询方案\n服务在选择实例时，是由负载均衡决定的，这里并没有配置，所以采用的是默认轮询\n1 2 3 4 # 负载均衡规则 userservice: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule 实现以上配置之后即可完成实现优先访问本地集群的服务\n实测之后发现只能在较低版本的Nacos中生效，高版本的Nacos已经取消了对Ribbon的支持\n解决办法查看博客,实测可行\n但是随着Spring Cloud Gateway或者其他更先进的API Gateway的广泛应用，以及服务网格（Service Mesh）架构的发展\n例如采用Istio或阿里云的ASM（Application Service Mesh），这种跨可用区或跨集群的流量调度通常会交由服务网格层面处理，而非仅仅依赖客户端SDK内置的负载均衡机制\n那么可能需要转向服务网格或Spring Cloud Gateway级别的路由规则定义，所以负载均衡应该由网关服务来承担，而非消费服务自身\n权重设置\r实际部署中会出现这样的场景: 服务器设备性能有差异，部分实例所在机器性能较好，另一些较差， 我们希望性能好的机器承担更多的用户请求 Nacos提供了权重配置来控制访问频率,权重越大则访问频率越高 步骤\n在Nacos控制台可以设置实例的权重值，首先选中实例后面的编辑按钮 将权重设置为0.1,测试可以发现8081被访问到的频率大大降低（权重值位于0~1之间） 那这个时候理论上，8081的访问次数应该是8080的1/10，测试发现确实如此，权重配置已经生效\n权重设置为0，则该服务不会被访问到\n这种特性可以用以服务的版本升级\n正常情况下是不会重启某个服务来实现版本升级的，此时用户还在访问呢，如何在用户无感知的前提下实现版本升级呢？\n在服务启动多个实例的情况下，如8081、8082、8083 可以先将8081的实例权重设置为0，渐渐的8081就不会承担用户请求了，此时用户是无感知的 这个时候对8081停机之后进行升级，然后重启，权重先设置小一点，如果用户请求没有bug，就可以增大权重实现升级了\n环境隔离\rNacos中服务存储和数据存储的最外层都是一个名为命名空间(namespace)的东西，用来做最外层隔离\nNamespace \u0026gt; Group \u0026gt; Service(服务) \u0026gt; 集群 \u0026gt; 实例\nGroup 用作分组，可以将相关度较高的业务划分为一个组 此时就可以看到dev命名空间了，但是里面没有任何服务啊\n需要去代码层面添加命名空间配置 1 2 # 命名空间id spring.cloud.nacos.discovery.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c 重启order服务\n发现在dev下可以看到order服务，而user服务仍然还在public下 测试一下能否调用\n不行 报错如下\n1 java.lang.IllegalStateException: No instances available for userservice 没有找到可用的实例，因为它们处在不同的命名空间下\nNacos注册中心原理\r服务的消费者并不是每次都去拉去提供者的信息，而是会将拉去的服务列表进行缓存\n而一直不拉取服务也不行，因为服务提供者的信息可能变化，所以需要每隔一段时间比如30s拉取一次\n但是Nacos和Eureka还有一些差别在健康检测方面\nNacos会将所有的服务提供者分为临时实例和非临时实例，所有实例默认都是临时实例 临时实例在Nacos中的健康检测是心跳检测，临时实例每隔一段时间向Nacos发送心跳，但频率会比Eureka的快一些\n一旦心跳检测出现异常、不跳了，Nacos就会将其在服务列表中直接剔除\n非临时实例不需要做心跳检测，而是Nacos主动发请求询问实例是否正常\nNacos不会将非临时实例在服务列表中剔除，而是会等待其恢复健康\nNacos和Eureka在消费者方面也有一些区别，Eureka会每隔30s拉取一次服务\n但如果在30s内，有提供者的实例异常，消费者是不知道的呀，此时就会出问题\nNacos会主动将提供者变更的消息推送给消费者\nEureka主要是采用pull，而Nacos是pull和push结合\n1 2 # 是否是临时实例 spring.cloud.nacos.discovery.ephemeral=false 停止服务 Nacos支持服务端主动检测提供者状态:临时实例采用心跳模式，非临时实例采用主动检测模式\n临时实例心跳不正常会被剔除，非临时实例则不会被剔除 Nacos支持服务列表变更的消息推送模式，服务列表更新更及时 Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式; Eureka采用AP方式 Nacos与eureka的共同点 都支持服务注册和服务拉取 都支持服务提供者心跳方式做健康检测 配置管理\r将一些配置信息放在Nacos上，如数据库、MyBatis，而且这些配置可以动态刷新，无需重启项目\n一般写的是开关类型的配置，如赋值true就开启某个活动 在 Nacos Spring Cloud 中，dataId 的完整格式如下：\n1 ${prefix}-${spring.profiles.active}.${file-extension} prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。 spring.profiles.active 即为当前环境对应的 profile，详情可以参考 Spring Boot文档。 注意：当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension} file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。 Nacos配置管理的依赖我们已经引入\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 这里我就直接把application.properties中的DB配置和MyBatis配置写进来了 order-service-dev.properties\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/cloud-order?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8 # 数据库用户名\u0026amp;密码： spring.datasource.username=root spring.datasource.password=123456 # 数据源名称 spring.datasource.name=defaultDataSource # 配置mybatis-plus 打印sql日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # xml文件路径 mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml # 配置mybatis-plus 包路径 mybatis-plus.type-aliases-package=com.example.order.domain user-service-dev.properties\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/cloud-user?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8 # 数据库用户名\u0026amp;密码： spring.datasource.username=root spring.datasource.password=123456 # 数据源名称 spring.datasource.name=defaultDataSource # 配置mybatis-plus 打印sql日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # xml文件路径 mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml # 配置mybatis-plus 包路径 mybatis-plus.type-aliases-package=com.example.user.domain order/application.properties\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 应用服务 WEB 访问端口 server.port=8090 # 服务名 spring.application.name=order-service # nacos服务发现 spring.cloud.nacos.discovery.server-addr=localhost:8848 # 配置集群名称，也就是机房位置，例如JS(江苏) spring.cloud.nacos.discovery.cluster-name=JS # 命名空间id spring.cloud.nacos.discovery.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c # 是否是临时实例 spring.cloud.nacos.discovery.ephemeral=false # nacos服务配置 spring.cloud.nacos.config.server-addr=localhost:8848 #spring.cloud.nacos.config.import-check.enabled=false spring.cloud.nacos.config.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c # dataId前缀 spring.cloud.nacos.config.prefix=${spring.application.name} # 环境 (前缀-环境.后缀 如user-dev.properties) spring.profiles.active=dev # dataId后缀 spring.cloud.nacos.config.file-extension=properties spring.config.import=nacos:${spring.cloud.nacos.config.prefix}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}?refresh=true user/application.properties\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 应用服务 WEB 访问端口 server.port=8080 # 服务名 spring.application.name=user-service # nacos服务发现 spring.cloud.nacos.discovery.server-addr=localhost:8848 # 配置集群名称，也就是机房位置，例如JS(江苏) spring.cloud.nacos.discovery.cluster-name=JS # 命名空间id spring.cloud.nacos.discovery.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c # 是否是临时实例 spring.cloud.nacos.discovery.ephemeral=false # nacos服务配置 spring.cloud.nacos.config.server-addr=localhost:8848 spring.cloud.nacos.config.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c # dataId前缀 spring.cloud.nacos.config.prefix=${spring.application.name} # 环境 (前缀-环境.后缀 如user-dev.properties) spring.profiles.active=dev # dataId后缀 spring.cloud.nacos.config.file-extension=properties spring.config.import=nacos:${spring.cloud.nacos.config.prefix}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}?refresh=true 注意之前配置过spring.cloud.nacos.config.import-check.enabled=false，需要删掉。 还有spring.cloud.nacos.config.namespace一定要指定，因为我们不是配置在默认的public，而是自己新建的dev。 否则在启动项目时会找不到DB配置信息报错\nspring.cloud.nacos.discovery.ephemeral=false这个也要加上（因为已经在前面被注册成非临时实例了） 否则会爆错Current service DEFAULT_GROUP@@order-service is persistent service, can\u0026rsquo;t register ephemeral instance 意思是“DEFAULT_GROUP@@order-service”这个服务是一个持久化服务，不能注册为临时实例。\n配置热更新\rNacos中的配置文件变更后，微服务无需重启就可以感知。不过需要通过下面两种配置实现:\n方式一:在@Value注入的变量所在类上添加注解@RefreshScope 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @RefreshScope @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { @Autowired private OrdersService ordersService; @Autowired private RestTemplate restTemplate; @Value(\u0026#34;${author.name}\u0026#34;) private String name; @Value(\u0026#34;${author.date}\u0026#34;) private String date; @Value(\u0026#34;${author.description}\u0026#34;) private String description; @GetMapping(\u0026#34;/{id}\u0026#34;) public Map\u0026lt;String,Object\u0026gt; findOne(@PathVariable Integer id) { Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Orders orders = ordersService.getById(id); User user = restTemplate.getForObject(\u0026#34;http://user-service/user/\u0026#34; + orders.getUserId(), User.class); orders.setUser(user); map.put(\u0026#34;orders\u0026#34;,orders); map.put(\u0026#34;name\u0026#34;,name); map.put(\u0026#34;date\u0026#34;,date); map.put(\u0026#34;description\u0026#34;,description); return map; } } 在order-service-dev.properties新增配置\n1 2 3 author.name=不是菜狗爱编程 author.date=2024/04/04/9:13 author.description=暂无描述 重启项目后，访问配置 修改配置后，不重启项目\n1 2 3 author.name=不是菜狗爱编程 author.date=2024/04/05/9:13 author.description=第一次发布 方式二:使用@ConfigurationProperties注解 新建Author.java 1 2 3 4 5 6 7 8 9 10 @Data @Component @AllArgsConstructor @NoArgsConstructor @ConfigurationProperties(prefix = \u0026#34;author\u0026#34;) public class Author { private String name; private String date; private String description; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RefreshScope @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { @Autowired private OrdersService ordersService; @Autowired private RestTemplate restTemplate; @Autowired private Author author; @GetMapping(\u0026#34;/{id}\u0026#34;) public Map\u0026lt;String,Object\u0026gt; findOne(@PathVariable Integer id) { Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Orders orders = ordersService.getById(id); User user = restTemplate.getForObject(\u0026#34;http://user-service/user/\u0026#34; + orders.getUserId(), User.class); orders.setUser(user); map.put(\u0026#34;orders\u0026#34;,orders); map.put(\u0026#34;author\u0026#34;,author); return map; } } 依然可以实现动态更新配置 多环境配置共享\rnacos/order-service-dev.properties\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/cloud-order?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8 # 数据库用户名\u0026amp;密码： spring.datasource.username=root spring.datasource.password=123456 # 数据源名称 spring.datasource.name=defaultDataSource # 配置mybatis-plus 打印sql日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # xml文件路径 mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml # 配置mybatis-plus 包路径 mybatis-plus.type-aliases-package=com.example.order.domain nacos/order-service.properties\n1 2 3 author.name=不是菜狗爱编程 author.date=2024/04/05/9:13 author.description=第一次发布 配置如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 应用服务 WEB 访问端口 server.port=8090 # 服务名 spring.application.name=order-service # nacos服务发现 spring.cloud.nacos.discovery.server-addr=localhost:8848 # 配置集群名称，也就是机房位置，例如JS(江苏) spring.cloud.nacos.discovery.cluster-name=JS # 命名空间id spring.cloud.nacos.discovery.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c # 是否是临时实例 spring.cloud.nacos.discovery.ephemeral=false # nacos服务配置 spring.cloud.nacos.config.server-addr=localhost:8848 spring.cloud.nacos.config.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c # dataId前缀 spring.cloud.nacos.config.prefix=${spring.application.name} # 环境 (前缀-环境.后缀 如user-dev.properties) spring.profiles.active=dev # dataId后缀 spring.cloud.nacos.config.file-extension=properties spring.config.import[0]=optional:nacos:${spring.cloud.nacos.config.prefix}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}?refresh=true spring.config.import[1]=optional:nacos:${spring.cloud.nacos.config.prefix}.${spring.cloud.nacos.config.file-extension}?refresh=true 如果使用yml的方式\n1 2 3 4 5 spring: config: import: - optional:nacos:order-service.${spring.cloud.nacos.config.file-extension}?refresh=true - optional:nacos:order-service-dev.${spring.cloud.nacos.config.file-extension}?refresh=true 持久化\r将nacos持久化到数据库\n**注意**先导出一份配置，待会持久化到mysql之后导入之前的配置 打开SQL执行界面 注意不要直接执行，需要新建数据库，这里命令为nacos_config\n1 use nacos_config 注意账号、密码不要写错 否则会报错如下 导入之前的配置（order-service-dev.properties、order-service.properties、user-service-dev.properties） 可以看到数据库里已经保存了该配置的数据 Feign\r入门\rfeign是一个http客户端\n先来看我们以前利用RestTemplate发起远程调用的代码:\n1 User user = restTemplate.getForObject(\u0026#34;http://user-service/user/\u0026#34; + orders.getUserId(), User.class); 存在下面的问题:\n代码可读性差，编程体验不统一 参数复杂URL难以维护 Feign是一个声明式的http客户端，官方地址: https://github.com/OpenFeign/feign 其作用就是帮助我们优雅的实现http请求的发送,解决上面提到的问题。 启动类上添加@EnableFeignClients注解 @FeignClient(\u0026quot;provider-service\u0026quot;)注解指定服务名，并复制服务发布者的controller方法到interface里，如 1 2 3 4 5 @FeignClient(\u0026#34;provider-service\u0026#34;) public interface ProviderClient { @GetMapping(\u0026#34;/provider/{string}\u0026#34;) public String echo(@PathVariable(value = \u0026#34;string\u0026#34;) String string); } 然后注入ProviderClient即可使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController @RequestMapping(\u0026#34;consumer\u0026#34;) public class ConsumerController { @Autowired private ProviderClient providerClient; @GetMapping(\u0026#34;/{str}\u0026#34;) public Map\u0026lt;String, Object\u0026gt; echo(@PathVariable String str) { Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); String provider = providerClient.echo(str); map.put(\u0026#34;provider\u0026#34;,provider); map.put(\u0026#34;consumer\u0026#34;,\u0026#34;this is consumer,\u0026#34;+str); return map; } } 现在尝试一下，\n原本的RestTemplate代码可以删掉了\n1 2 3 4 5 //@Bean //@LoadBalanced //public RestTemplate restTemplate(){ // return new RestTemplate(); //} 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 @EnableFeignClients @EnableDiscoveryClient @MapperScan(\u0026#34;com.example.order.mapper\u0026#34;) @SpringBootApplication public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } } 这里的配置需要注意一下，容易出问题\n@FeignClient指定了服务名\n@GetMapping(\u0026quot;/user/{id}\u0026quot;)这里一定要和被调用服务controller里写的一样才行，那边User服务类上有@RequestMapping(\u0026quot;user\u0026quot;)注解 所以这里@GetMapping(\u0026quot;/{id}\u0026quot;)前面一定要加/user\n方法名，返回值一定都得一样，建议直接去复制UserController即可\n1 2 3 4 5 @FeignClient(\u0026#34;user-service\u0026#34;) public interface UserFeignClient { @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User findOne(@PathVariable(value = \u0026#34;id\u0026#34;) Integer id); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RefreshScope @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @GetMapping(\u0026#34;/{id}\u0026#34;) public Orders findOne(@PathVariable Integer id) { Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; } } 这样就很优雅了\nSpringBoot3新特性\rSpringBoot3新特性内置声明式HTTP客户端，这里浅试一下\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-webflux\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @EnableFeignClients @EnableDiscoveryClient @SpringBootApplication public class ConsumerApplication { public static void main(String[] args) { SpringApplication.run(ConsumerApplication.class, args); } @Bean public ProviderFluxClient userRestClient() { WebClient client = WebClient.builder() .baseUrl(\u0026#34;http://localhost:8080\u0026#34;) .build(); HttpServiceProxyFactory factory = HttpServiceProxyFactory.builder(WebClientAdapter.forClient(client)) .build(); return factory.createClient(ProviderFluxClient.class); } } 1 2 3 4 5 @HttpExchange(\u0026#34;/provider\u0026#34;) public interface ProviderFluxClient { @GetExchange(\u0026#34;/{string}\u0026#34;) Flux\u0026lt;String\u0026gt; echo(@PathVariable(value = \u0026#34;string\u0026#34;) String string); } 1 2 3 4 5 6 7 8 9 10 11 12 13 @RestController @RequestMapping(\u0026#34;consumer\u0026#34;) public class ConsumerController { @Autowired private ProviderFluxClient providerFluxClient; @GetMapping(\u0026#34;/{str}\u0026#34;) public String echo(@PathVariable String str) { providerFluxClient.echo(str).subscribe( data -\u0026gt; System.out.println(\u0026#34;data:\u0026#34; + data) ); return \u0026#34;this is consumer,\u0026#34; + str; } } 还是回到主题feign来\nFeign自定义配置\r1 2 3 4 5 6 # springboot默认日志日志级别 logging.level.com.example=debug # default是全局配置，如果写服务名称，则是针对某个微服务的配置 # 日志级别是 full #spring.cloud.openfeign.client.config.default.logger-level=full spring.cloud.openfeign.client.config.user-service.logger-level=full 也可以使用java代码配置\n1 2 3 4 5 6 7 8 import feign.Logger; import org.springframework.context.annotation.Bean; public class FeignClientConfiguration { @Bean public Logger.Level feignLogLevel(){ return Logger.Level.BASIC; } } 如果希望这个配置在全局生效，在启动类上配置如下\n1 @EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class) 如果希望针对某个服务生效\n1 @FeignClient(value = \u0026#34;user-service\u0026#34;,configuration = FeignClientConfiguration.class) 正常使用Basic即可，调试错误用Full，日志会对性能有影响\n性能优化\rFeign底层的客户端实现:\nURLConnection:默认实现，不支持连接池 Apache HttpClient:支持连接池 OKHttp:支持连接池 添加如下依赖 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 # springboot默认日志日志级别 logging.level.com.example=debug spring.cloud.openfeign.client.config.user-service.logger-level=basic # 开启对httpclient的支持 spring.cloud.openfeign.httpclient.enabled=true # 最大连接数200 spring.cloud.openfeign.httpclient.max-connections=200 # 每个路径的最大连接数 spring.cloud.openfeign.httpclient.max-connections-per-route=50 这两个值max-connections和max-connections-per-route的最佳选择还是需要使用压测工具来针对自己项目测试得出\n最佳实践\rFeign的最佳实践\n方式一(继承):给消费者的FeignClient和提供者的controller定义统-的父接口作为标准。 缺点 服务紧耦合 父接口参数列表中的映射不会被继承 方式二( 抽取) :将FeignClient抽取为独立模块,并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用 缺点 引用了过多的api，或许order只需要引入user的一两个api即可，但是现在却全部引入了 尝试一下方式二，现在再新建两个项目common和feign-api，将一些公共类抽取到common中，如实体类User或者Order common/pom.xml\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 @Data @AllArgsConstructor @NoArgsConstructor public class Order { private Integer id; private String name; private Integer price; private Integer num; private Integer userId; private User user; } 1 2 3 4 5 6 7 8 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer id; private String username; private String address; } feign-api/pom.xml\n导入common依赖\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;common\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1 2 3 4 5 @FeignClient(value = \u0026#34;user-service\u0026#34;) public interface UserFeignClient { @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User findOne(@PathVariable(value = \u0026#34;id\u0026#34;) Integer id); } 1 2 3 4 5 6 7 8 import feign.Logger; import org.springframework.context.annotation.Bean; public class FeignClientConfiguration { @Bean public Logger.Level feignLogLevel(){ return Logger.Level.BASIC; } } order/pom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-loadbalancer\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.nacos\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nacos-client\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.nacos\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nacos-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1 2 3 4 5 6 7 8 9 @EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class) @EnableDiscoveryClient @MapperScan(\u0026#34;com.example.order.mapper\u0026#34;) @SpringBootApplication public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.example.common.entity.User; import com.example.feign.api.UserFeignClient; import com.example.order.domain.Orders; import com.example.order.service.OrdersService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.*; import java.util.List; @RefreshScope @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @GetMapping(\u0026#34;/{id}\u0026#34;) public Orders findOne(@PathVariable Integer id) { Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; } } 启动确报错\n1 Consider defining a bean of type \u0026#39;com.example.feign.api.UserFeignClient\u0026#39; in your configuration. 因为包扫描的问题，order服务的默认包扫描在com.example.order下，但是feign-api的包在com.example.feign.api下 建议选第二种\n1 2 3 4 5 6 7 8 9 10 11 12 @EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class, basePackageClasses = { UserFeignClient.class }) @EnableDiscoveryClient @MapperScan(\u0026#34;com.example.order.mapper\u0026#34;) @SpringBootApplication public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } } 再次启动即可 Gateway\r入门\r为什么需要网关? 网关功能:\n身份认证和权限校验 服务路由、 负载均衡 请求限流 在SpringCloud中网关的实现包括两种: gateway zuul Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是 基于Spring5中提供的WebFlux,属于响应式编程的实现，具备更好的性能。 项目创建\rgateway/pom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-loadbalancer\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; gateway/application.yml\n注意这里网关一定要和order、user服务加入到同一个nacos命名空间，否则会报503\n而且要添加spring-cloud-loadbalancer的依赖，否则也会报503\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/** server: port: 8888 可以看到已经成功路由到order服务了\n整个流程如下图所示 路由配置包括\n路由id:路由的唯一标示. 路由目标(uri):路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡 路由断言(predicates):判断路由的规则, 路由过滤器(filters):对请求或响应做处理 路由断言工厂\r我们在配置文件中写的断言规则只是字符串,这些字符串会被Predicate Factory读取并处理,转变为路由判断的条件 例如Path=/user/**是按照路径匹配，这个规则是由org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来处理的 详细查看spring官网\n这里试一下After，如果不知道时间格式怎么写，可以使用如下方法打印\n1 2 3 4 5 @Test void contextLoads() { ZonedDateTime now = ZonedDateTime.now(); System.out.println(\u0026#34;now = \u0026#34; + now); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/** - After=2024-04-07T07:43:30.566635800+08:00[Asia/Shanghai] server: port: 8888 当路由中没有匹配的路由，就会报404无法路由\n路由过滤器\rGatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/** filters: # 添加请求头 - AddRequestHeader=color,this is red server: port: 8888 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RefreshScope @RestController @RequestMapping(\u0026#34;order\u0026#34;) public class OrdersController { @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @GetMapping(\u0026#34;/{id}\u0026#34;) public Orders findOne(@PathVariable Integer id,@RequestHeader(\u0026#34;color\u0026#34;) String color) { System.out.println(\u0026#34;color = \u0026#34; + color); Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; } } 通过网关路由到order服务，order服务控制台打印color = this is red\n如果希望配置所有网关都配置该过滤器，可以使用默认过滤器\n默认过滤器对所有路由都生效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/** # 默认过滤器 default-filters: - AddRequestHeader=color,this is red server: port: 8888 全局过滤器\r全局过滤器的作用也是处理一-切进 入网关的请求和微服务响应，与GatewayFilter的作用一样。\n区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现。\n感觉和default-filters很像，但是如果需要自定义一些复杂的逻辑，就得使用GatewayFilter了\n定义方式是实现GatewayFilter接口 1 2 3 4 5 6 7 8 9 10 public interface GlobalFilter { /** * Process the Web request and (optionally) delegate to the next {@code WebFilter} * through the given {@link GatewayFilterChain}. * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026lt;Void\u0026gt;} to indicate when request processing is complete */ Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); } 需求 定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件:\n参数中是否有authorization authorization参数值是否为admin 在gateway服务下新建AuthorizationFilter并实现GlobalFilter接口\n整体步骤如下\n1 2 3 4 5 6 7 8 9 10 public class AuthorizationFilter implements GlobalFilter { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 获取请求参数 // 获取参数中的authorization参数 // 判断参数值是否等于admin // 是，则放行。否，则拦截 return null; } } 具体实现如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 过滤器优先级，越小越高 @Order(1) @Component public class AuthorizationFilter implements GlobalFilter { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 获取请求参数 ServerHttpRequest request = exchange.getRequest(); MultiValueMap\u0026lt;String, String\u0026gt; queryParams = request.getQueryParams(); // 获取参数中的 authorization 参数 String authorization = queryParams.getFirst(\u0026#34;authorization\u0026#34;); // 判断参数值是否等于admin if(\u0026#34;admin\u0026#34;.equals(authorization)){ // 是，则放行 return chain.filter(exchange); } // 设置状态码 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // 否，则拦截 return exchange.getResponse().setComplete(); } } 除了通过@Order注解来定义过滤器优先级，还可以实现Ordered接口来重写getOrder方法定义过滤器优先级\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Component public class AuthorizationFilter implements GlobalFilter , Ordered { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 获取请求参数 ServerHttpRequest request = exchange.getRequest(); MultiValueMap\u0026lt;String, String\u0026gt; queryParams = request.getQueryParams(); // 获取参数中的 authorization 参数 String authorization = queryParams.getFirst(\u0026#34;authorization\u0026#34;); // 判断参数值是否等于admin if(\u0026#34;admin\u0026#34;.equals(authorization)){ // 是，则放行 return chain.filter(exchange); } // 设置状态码 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // 否，则拦截 return exchange.getResponse().setComplete(); } @Override public int getOrder() { return 1; } } 访问http://localhost:8888/order/1 访问http://localhost:8888/order/1?authorization=admin 过滤器执行顺序\r请求进入网关会碰到三类过滤器:当前路由的过滤器、DefaultFilter. GlobalFilter 请求路由后，会将当前路由过滤器和DefaultFjlter、GlobalFilter, 合并到一个过滤器链(集合)中，排序后依次执行每个过滤器\n在GatewayFilterAdapter中GatewayFilter被适配成了GatewayFilter\n网关中的所有过滤器最终都是GatewayFilter 过滤器执行顺序\n每一个过滤器都必须指定一个int类型的order值， order值越小， 优先级越高，执行顺序越靠前。 GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定 路由过滤器和defaultFilter的order由Spring指定,默认是按照声明顺序从1递增。 当过滤器的order值一样时， 会按照defaultFilter \u0026gt;路由过滤器\u0026gt; GlobalFilter的顺序执行。 跨域问题处理\r网关是基于WebFlux来实现的，之前的Servlet Api就无法使用了 跨域:域名不一致就是跨域，主要包括:\n域名不同: www.taobao.com 和www.taobao.org和www.jd.com和miaosha.jd.com 域名相同，端口不同: localhost:8080和localhost8081 跨域问题:浏览器禁止请求的发起者与服务端发生跨域ajax请求,请求被浏览器拦截的问题 网关处理跨域采用的同样是CORS方案,并且只需要简单配置即可实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;pre\u0026gt; spring: cloud: gateway: globalcors: # 全局的跨域处理 add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题 corsConfigurations: \u0026#39;[/**]\u0026#39;: allowedOrigins: # 允许哪些网站的跨域请求 - \u0026#34;http://localhost:8090\u0026#34; - \u0026#34;http://www.leyou.com\u0026#34; allowedMethods: # 允许的跨域ajax的请求方式 - \u0026#34;GET\u0026#34; - \u0026#34;POST\u0026#34; - \u0026#34;DELETE\u0026#34; - \u0026#34;PUT\u0026#34; - \u0026#34;OPTIONS\u0026#34; allowedHeaders: \u0026#34;*\u0026#34; # 允许在请求中携带的头信息 allowCredentials: true # 是否允许携带cookie maxAge: 360000 # 这次跨域检测的有效期 \u0026lt;/pre\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; axios.get(\u0026#34;http://localhost:10010/user/1?authorization=admin\u0026#34;) .then(resp =\u0026gt; console.log(resp.data)) .catch(err =\u0026gt; console.log(err)) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 使用VS Code启动 配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 spring: cloud: gateway: globalcors: # 全局的跨域处理 add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题 corsConfigurations: \u0026#39;[/**]\u0026#39;: allowedOrigins: # 允许哪些网站的跨域请求 - \u0026#34;http://localhost:8090\u0026#34; - \u0026#34;http://www.leyou.com\u0026#34; allowedMethods: # 允许的跨域ajax的请求方式 - \u0026#34;GET\u0026#34; - \u0026#34;POST\u0026#34; - \u0026#34;DELETE\u0026#34; - \u0026#34;PUT\u0026#34; - \u0026#34;OPTIONS\u0026#34; allowedHeaders: \u0026#34;*\u0026#34; # 允许在请求中携带的头信息 allowCredentials: true # 是否允许携带cookie maxAge: 360000 # 这次跨域检测的有效期 没用，依然报错跨域问题\n由于spring-framework从5.3.0版本开始，关于CORS跨域配置类 CorsConfiguration中将 allowedOrigins 变量名修改为 allowedOriginPatterns\n所以，如果项目中 spring-framework 版本高于5.3.0，请使用如下配置代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/** default-filters: - AddRequestHeader=color,this is red globalcors: # 全局的跨域处理 add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题 corsConfigurations: \u0026#39;[/**]\u0026#39;: allowedOriginPatterns: # 允许哪些网站的跨域请求 - \u0026#34;http://localhost:8090\u0026#34; - \u0026#34;http://localhost:5500\u0026#34; - \u0026#34;http://www.leyou.com\u0026#34; allowedMethods: # 允许的跨域ajax的请求方式 - \u0026#34;GET\u0026#34; - \u0026#34;POST\u0026#34; - \u0026#34;DELETE\u0026#34; - \u0026#34;PUT\u0026#34; - \u0026#34;OPTIONS\u0026#34; allowedHeaders: \u0026#34;*\u0026#34; # 允许在请求中携带的头信息 allowCredentials: true # 是否允许携带cookie maxAge: 360000 # 这次跨域检测的有效期,一定时间内不需要在验证跨域，直接访问 server: port: 8888 ","date":"2024-04-10T00:00:00Z","image":"http://localhost:1313/p/springcloud/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/springcloud/","title":"SpringCloud"},{"content":"RabbitMQ\r以下具体内容参考自黑马程序员课程微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式微服务全技术栈课程\n初识MQ\r同步调用\r微服务间基于Feign的调用就属于同步方式，存在一些问题。业务代码耦合严重，除此之外对性能影响也很严重，因为需要等待被调用的服务返回结果。 不仅如此，而且如果被调用的服务中，有某个服务挂了，则整个服务调用都会出现问题。 异步调用\r异步调用常见实现就是事件驱动模式 优势\n前三个解决了同步调用的问题\n服务解耦，现在只需要发送成功事件即可，不需要更改业务代码 性能提高，吞吐量升高， 服务没有强依赖，无需担心级联失败问题 流量削峰，broker能起到缓冲的作用，右侧的服务则按照自身能力来获取broker的事件 劣势 异步通信的缺点\n依赖于Broker的可靠性、安全性、吞吐能力 架构复杂了，业务没有明显的流程线，不好追踪管理 MQ选型\r安装步骤省略 rabbitmq的管理界面的端口为15672 http://localhost:15672 管理员的账号和密码是guest\nOverview\rOverview是总览，可以看到MQ的节点信息，当前为单节点运行，并不存在集群\nConnections\r无论是消息的发布者还是消息的消费者都需要与MQ建立连接\nChannels\rChannels是通道，在建立连接后需要创建Channels通道，然后消息的发布者和消息的消费者才能基于Channels完成消息的发布和消费\nExchanges\rExchanges交换机用于接收来自生产者的消息，将它们推入队列\nQueues\rQueues队列用来做消息存储\nAdmin\rMQ架构\r常见消息模型\r基本消息队列和工作消息队列没有使用到交换机，属于简单队列模型\n基本消息队列(BasicQueue) 工作消息队列(WorkQueue) 发布订阅( Publish、Subscribe )，又根据交换机类型不同分为三种 Fanout Exchange:广播 Direct Exchange:路由 Topic Exchange:主题 基本消息队列\r这里建立的项目结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 rabbitmq-demo ├─consumer │ └─src │ ├─main │ │ └─resources │ └─test └─publisher └─src ├─main │ ├─java │ └─resources └─test 父级pom\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rabbitmq-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;rabbitmq-demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;rabbitmq-demo\u0026lt;/description\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;consumer\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;publisher\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;3.0.2\u0026lt;/spring-boot.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;/project\u0026gt; publisher\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rabbitmq-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;publisher\u0026lt;/artifactId\u0026gt; \u0026lt;name\u0026gt;publisher\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;publisher\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.amqp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-rabbit-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;/project\u0026gt; consumer与publisher一样，改名字即可\n发送和监听消息的示例代码如下\n需要注意的是：RabbitMQ的端口是5672，管理页面端口才是15672，这里端口需要写5672\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import org.junit.jupiter.api.Test; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * RabbitMQ发送消息测试 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/8:11 * @description: */ class SendMessageTest { @Test void sendMessageTest() throws IOException, TimeoutException { // 1.建立连接 ConnectionFactory factory = new ConnectionFactory(); // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码 factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setVirtualHost(\u0026#34;/\u0026#34;); factory.setUsername(\u0026#34;tong\u0026#34;); factory.setPassword(\u0026#34;123456\u0026#34;); // 1.2.建立连接 Connection connection = factory.newConnection(); // 2.创建通道Channel Channel channel = connection.createChannel(); // 3.创建队列 String queueName = \u0026#34;simple.queue\u0026#34;; channel.queueDeclare(queueName, false, false, false, null); // 4.发送消息 String message = \u0026#34;hello, rabbitmq!\u0026#34;; channel.basicPublish(\u0026#34;\u0026#34;, queueName, null, message.getBytes()); System.out.println(\u0026#34;发送消息成功：【\u0026#34; + message + \u0026#34;】\u0026#34;); // 5.关闭通道和连接 channel.close(); connection.close(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import com.rabbitmq.client.*; import org.junit.jupiter.api.Test; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * RabbitMQ监听消息测试 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/8:11 * @description: */ class ListenMessageTest { @Test void listenMessageTest() throws IOException, TimeoutException { // 1.建立连接 ConnectionFactory factory = new ConnectionFactory(); // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码 factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setVirtualHost(\u0026#34;/\u0026#34;); factory.setUsername(\u0026#34;tong\u0026#34;); factory.setPassword(\u0026#34;123456\u0026#34;); // 1.2.建立连接 Connection connection = factory.newConnection(); // 2.创建通道Channel Channel channel = connection.createChannel(); // 3.创建队列 String queueName = \u0026#34;simple.queue\u0026#34;; channel.queueDeclare(queueName, false, false, false, null); // 4.订阅消息 channel.basicConsume(queueName, true, new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { // 5.处理消息 String message = new String(body); System.out.println(\u0026#34;接收到消息：【\u0026#34; + message + \u0026#34;】\u0026#34;); } }); System.out.println(\u0026#34;等待接收消息。。。。\u0026#34;); } } 基本消息队列的消息发送流程:\n建立connection 创建channel 利用channel声明队列 利用channel向队列发送消息 基本消息队列的消息接收流程: 建立connection 创建channel 利用channel声明队列 定义consumer的消费行为handleDelivery() 利用channel将消费者与队列绑定 SpringAMQP\r特征\n侦听器容器，用异步处理入站消息 用于发送和接收消息的RabbitTemplate RabbitAdmin用于自动声明队列，交换机和绑定关系 案例流程如下 在父工程中引入spring-amqp的依赖 在publisher服务中利用RabbitTemplate发送消息到simple.queue这个队列 在consumer服务中编写消费逻辑，绑定simple.queue这个队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import org.junit.jupiter.api.Test; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * RabbitMQ发送消息测试 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/8:11 * @description: */ @SpringBootTest class SendMessageTest { @Autowired private RabbitTemplate rabbitTemplate; @Test void sendMessageWithRabbitMqTemplateTest(){ String queueName=\u0026#34;simple.queue\u0026#34;; String message=\u0026#34;你好，这是【RabbitTemplate】发送的消息\u0026#34;; rabbitTemplate.convertAndSend(queueName,message); } } application.properties\n1 2 3 4 5 6 7 8 # 主机名 192.168.XXX.XXX spring.rabbitmq.host=localhost # 端口 spring.rabbitmq.port=5672 # 虚拟主机 spring.rabbitmq.virtual-host=/ spring.rabbitmq.username=tong spring.rabbitmq.password=123456 点击simple.queue\nconsumer工程的properties也同样配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Slf4j @Component public class RabbitMqListener { /** * 简单队列侦听器 * 消息发送者发送的是字符串，所以这边也适用字符串来接收 * @param message 消息 */ @RabbitListener(queues = {\u0026#34;simple.queue\u0026#34;}) public void simpleQueueListener(String message){ log.info(\u0026#34;接收到的消息为:{}\u0026#34;,message); } } 启动consumer工程后接收到消息\n发现消息消失了，因为这是MQ的机制，阅后即焚，消息不可重复消费\n工作消息队列\r两个消费者共同消费生产者发布的消息，由于消息阅后即焚的特性，所以只能消费者1消费一部分消息，消费者2消费一部分消息 但是当发布的消息过多，两个消费者的能力不足，则多余的消息就会堆积在队列里 当队列存储的消息达到上限时，则会发生消息丢失\n工作队列，可以提高消息处理速度，避免队列消息堆积 实现思路如下\n在publisher服务中定义测试方法，每秒产生50条消息，发送到simple.queue的 在consumer服务中定义两个消息监听者，都监听simple.queue队列 消费者1每秒处理50条消息，消费者2每秒处理10条消息 所以照理来说，消费者应该能在1s内消费完消息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @SpringBootTest class SendMessageTest { @Autowired private RabbitTemplate rabbitTemplate; /** * 使用工作队列测试发送消息 * * @throws InterruptedException 中断异常 */ @Test void sendMessageWithWorkQueueTest() throws InterruptedException { String queueName=\u0026#34;simple.queue\u0026#34;; String message=\u0026#34;你好，这是消息\u0026#34;; for (int i = 0; i \u0026lt; 50; i++) { rabbitTemplate.convertAndSend(queueName,message+i); Thread.sleep(20); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Slf4j @Component public class RabbitMqListener { /** * 工作队列侦听器1 * * @param message 消息 */ @RabbitListener(queues = {\u0026#34;simple.queue\u0026#34;}) public void workQueueListener1(String message) throws InterruptedException { log.info(\u0026#34;工作队列侦听器1:接收到的消息为:{}\u0026#34;,message); Thread.sleep(20); } /** * 工作队列侦听器2 * * @param message 消息 */ @RabbitListener(queues = {\u0026#34;simple.queue\u0026#34;}) public void workQueueListener2(String message) throws InterruptedException { log.info(\u0026#34;工作队列侦听器2:接收到的消息为:{}\u0026#34;,message); Thread.sleep(200); } } 打印日志如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 2024-04-02T21:31:56.431+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息0 2024-04-02T21:31:56.456+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息1 2024-04-02T21:31:56.518+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息3 2024-04-02T21:31:56.580+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息5 2024-04-02T21:31:56.641+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息2 2024-04-02T21:31:56.641+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息7 2024-04-02T21:31:56.705+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息9 2024-04-02T21:31:56.767+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息11 2024-04-02T21:31:56.830+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息13 2024-04-02T21:31:56.845+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息4 2024-04-02T21:31:56.893+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息15 2024-04-02T21:31:56.956+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息17 2024-04-02T21:31:57.018+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息19 2024-04-02T21:31:57.049+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息6 2024-04-02T21:31:57.081+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息21 2024-04-02T21:31:57.145+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息23 2024-04-02T21:31:57.208+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息25 2024-04-02T21:31:57.253+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息8 2024-04-02T21:31:57.269+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息27 2024-04-02T21:31:57.333+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息29 2024-04-02T21:31:57.397+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息31 2024-04-02T21:31:57.458+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息10 2024-04-02T21:31:57.460+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息33 2024-04-02T21:31:57.522+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息35 2024-04-02T21:31:57.584+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息37 2024-04-02T21:31:57.651+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息39 2024-04-02T21:31:57.662+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息12 2024-04-02T21:31:57.710+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息41 2024-04-02T21:31:57.775+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息43 2024-04-02T21:31:57.837+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息45 2024-04-02T21:31:57.867+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息14 2024-04-02T21:31:57.900+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息47 2024-04-02T21:31:57.963+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息49 2024-04-02T21:31:58.070+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息16 2024-04-02T21:31:58.276+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息18 2024-04-02T21:31:58.481+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息20 2024-04-02T21:31:58.687+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息22 2024-04-02T21:31:58.889+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息24 2024-04-02T21:31:59.096+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息26 2024-04-02T21:31:59.301+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息28 2024-04-02T21:31:59.507+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息30 2024-04-02T21:31:59.712+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息32 2024-04-02T21:31:59.917+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息34 2024-04-02T21:32:00.119+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息36 2024-04-02T21:32:00.321+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息38 2024-04-02T21:32:00.525+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息40 2024-04-02T21:32:00.730+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息42 2024-04-02T21:32:00.946+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息44 2024-04-02T21:32:01.150+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息46 2024-04-02T21:32:01.353+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息48 根据日志打印的时间得知，消息处理的时间为5s，但我们预计的时间是1s\n这是因为由于rabbitmq的预取机制，会在消息消费前先平分获取到消息，但消息被消费者A获取后，其他的消费者就无法再消费这些消息了\n所以这里可以看到工作队列侦听器1和工作队列侦听器2都各自消费了25条消息，且工作队列侦听器1消费的是奇数，工作队列侦听器2则是偶数\n添加如下配置即可解决\n1 2 3 4 5 6 7 8 9 10 11 12 # 应用服务 WEB 访问端口 server.port=8090 # 主机名 192.168.XXX.XXX spring.rabbitmq.host=localhost # 端口 spring.rabbitmq.port=5672 # 虚拟主机 spring.rabbitmq.virtual-host=/ spring.rabbitmq.username=tong spring.rabbitmq.password=123456 # 每次只取一条消息，处理完成再获取下一条 spring.rabbitmq.listener.simple.prefetch=1 发布、订阅\r概念\r发布订阅模式与之前案例的区别就是允许将同一消息发送给多个消费者。实现方式是加入了exchange (交换机)。\n常见exchange类型包括:\nFanout: 广播 Direct: 路由 Topic: 话题 注意: exchange负责消息路由，而不负责存储，路由失败则消息丢失 Fanout 发布订阅\rFanout Exchange会将接收到的消息路由到每一个跟其绑定的queue\n实现思路如下:\n在consumer服务中，利用代码声明队列、交换机，并将两者绑定 在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2 在publisher中编写测试方法，向fanout.exchange发送消息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * FanoutExchange配置 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/21:49 * @description: */ @Configuration public class FanoutExchangeConfig { /** * fanout交换机 * * @return {@link FanoutExchange} */ @Bean public FanoutExchange fanoutExchange() { return new FanoutExchange(\u0026#34;fanout.exchange\u0026#34;); } /** * fanout队列1 * * @return {@link Queue} */ @Bean public Queue fanoutQueue1() { return new Queue(\u0026#34;fanoutQueue1\u0026#34;); } /** * fanout队列2 * * @return {@link Queue} */ @Bean public Queue fanoutQueue2() { return new Queue(\u0026#34;fanoutQueue2\u0026#34;); } /** * 绑定队列1 * * @param fanoutQueue1 扇出队列1 * @param fanoutExchange 扇出交换 * @return {@link Binding} */ @Bean public Binding buildingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange) { return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); } /** * 绑定队列2 * * @param fanoutQueue2 扇出队列1 * @param fanoutExchange 扇出交换 * @return {@link Binding} */ @Bean public Binding buildingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange) { return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange); } } 配置交换机和队列以及它们的绑定关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Configuration public class FanoutExchangeConfig { /** * fanout交换机 * * @return {@link FanoutExchange} */ @Bean public FanoutExchange fanoutExchange() { return new FanoutExchange(\u0026#34;fanout.exchange\u0026#34;); } /** * fanout队列1 * * @return {@link Queue} */ @Bean public Queue fanoutQueue1() { return new Queue(\u0026#34;fanoutQueue1\u0026#34;); } /** * fanout队列2 * * @return {@link Queue} */ @Bean public Queue fanoutQueue2() { return new Queue(\u0026#34;fanoutQueue2\u0026#34;); } /** * 绑定队列1 * * @param fanoutQueue1 扇出队列1 * @param fanoutExchange 扇出交换 * @return {@link Binding} */ @Bean public Binding buildingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange) { return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); } /** * 绑定队列2 * * @param fanoutQueue2 扇出队列1 * @param fanoutExchange 扇出交换 * @return {@link Binding} */ @Bean public Binding buildingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange) { return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Slf4j @Component public class RabbitMqListener { /** * fanout队列侦听器1 * * @param message 消息 */ @RabbitListener(queues = {\u0026#34;fanoutQueue1\u0026#34;}) public void fanoutQueueListener1(String message){ log.info(\u0026#34;fanout队列侦听器1:接收到的消息为:{}\u0026#34;,message); } /** * fanout队列侦听器2 * * @param message 消息 */ @RabbitListener(queues = {\u0026#34;fanoutQueue2\u0026#34;}) public void fanoutQueueListener2(String message){ log.info(\u0026#34;fanout队列侦听器2:接收到的消息为:{}\u0026#34;,message); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @SpringBootTest class SendMessageTest { @Autowired private RabbitTemplate rabbitTemplate; /** * 使用Fanout交换机测试发送消息 * * @throws InterruptedException 中断异常 */ @Test void sendMessageWithFanoutExchangeTest() throws InterruptedException { String exchangeName=\u0026#34;fanout.exchange\u0026#34;; String message=\u0026#34;你好，这是消息\u0026#34;; for (int i = 0; i \u0026lt; 50; i++) { rabbitTemplate.convertAndSend(exchangeName,\u0026#34;\u0026#34;,message+i); Thread.sleep(20); } } } DirectExchange\rDirect Exchange会将接收到的消息根据规则路由到指定的Queue,因此称为路由模式(routes) 。\n每一个Queue都与Exchange设置一个BindingKey\n发布者发送消息时，指定消息的RoutingKey\nExchange将消息路由到BindingKey与消息RoutingKey一致的队列\n需要注意：一个队列，可以绑定多个key\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Slf4j @Component public class RabbitMqListener { /** * direct队列侦听器1 * * @param message 消息 */ @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;directQueue1\u0026#34;), exchange = @Exchange(value = \u0026#34;direct.exchange\u0026#34;,type = ExchangeTypes.DIRECT), key = {\u0026#34;red\u0026#34;,\u0026#34;blue\u0026#34;} )) public void directQueueListener1(String message){ log.info(\u0026#34;direct队列侦听器1:接收到的消息为:{}\u0026#34;,message); } /** * direct队列侦听器2 * * @param message 消息 */ @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;directQueue2\u0026#34;), exchange = @Exchange(value = \u0026#34;direct.exchange\u0026#34;,type = ExchangeTypes.DIRECT), key = {\u0026#34;yellow\u0026#34;,\u0026#34;blue\u0026#34;} )) public void directQueueListener2(String message){ log.info(\u0026#34;direct队列侦听器2:接收到的消息为:{}\u0026#34;,message); } } 启动consumer项目，前往rabbitmq网页。发现direct.exchange交换机和directQueue1、directQueue2队列已经声明了\n查看绑定关系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest class SendMessageTest { @Autowired private RabbitTemplate rabbitTemplate; /** * 使用Direct交换机测试发送消息 * * @throws InterruptedException 中断异常 */ @Test void sendMessageWithDirectExchangeTest(){ String exchangeName = \u0026#34;direct.exchange\u0026#34;; String[] routingKeys={\u0026#34;yellow\u0026#34;,\u0026#34;red\u0026#34;,\u0026#34;blue\u0026#34;}; for (String routingKey : routingKeys) { rabbitTemplate.convertAndSend(exchangeName, routingKey, \u0026#34;消息是:\u0026#34;+routingKey); } } } 日志打印如下\n1 2 3 4 direct队列侦听器2:接收到的消息为:消息是:yellow direct队列侦听器1:接收到的消息为:消息是:red direct队列侦听器1:接收到的消息为:消息是:blue direct队列侦听器2:接收到的消息为:消息是:blue TopicExchange\rTopicExchange与DirectExchange类似， 区别在于routingKey必须是多个单词的列表,并且以.分割。\nQueue与Exchange指定BindingKey时可以使用通配符: #:代指0个或多个单词 *:代指一个单词\n实现思路如下\n并利用@RabbitListener声明Exchange、Queue、RoutingKey 在consumer服务中，编写两个消费者方法,分别监听topic.queue1和topic.queue2 在publisher中编写测试方法，向topic.exchange发送消息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * RabbitMQ 侦听器 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/21:11 * @description: */ @Slf4j @Component public class RabbitMqListener { /** * 主题队列侦听器1 * 接收 china 的一切信息 * * @param message 消息 */ @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;topicQueue1\u0026#34;), exchange = @Exchange(value = \u0026#34;topic.exchange\u0026#34;,type = ExchangeTypes.TOPIC), key = \u0026#34;china.#\u0026#34; )) public void topicQueueListener1(String message){ log.info(\u0026#34;topic队列侦听器1:接收到的消息为:{}\u0026#34;,message); } /** * 主题队列侦听器2 * 接收一切 news 信息 * * @param message 消息 */ @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;topicQueue2\u0026#34;), exchange = @Exchange(value = \u0026#34;topic.exchange\u0026#34;,type = ExchangeTypes.TOPIC), key = \u0026#34;#.news\u0026#34; )) public void topicQueueListener2(String message){ log.info(\u0026#34;topic队列侦听器2:接收到的消息为:{}\u0026#34;,message); } } 启动项目后，确认绑定关系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * RabbitMQ发送消息测试 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/8:11 * @description: */ @SpringBootTest class SendMessageTest { @Autowired private RabbitTemplate rabbitTemplate; /** * 使用Topic交换机测试发送消息 */ @Test void sendMessageWithTopicExchangeTest(){ String exchangeName = \u0026#34;topic.exchange\u0026#34;; String[] routingKeys={\u0026#34;china.weather\u0026#34;,\u0026#34;china.news\u0026#34;,\u0026#34;Japan.weather\u0026#34;,\u0026#34;Japan.news\u0026#34;}; for (String routingKey : routingKeys) { rabbitTemplate.convertAndSend(exchangeName, routingKey, \u0026#34;消息是:\u0026#34;+routingKey); } } } 消息转换器\r说明:在SpringAMQP的发送方法中，接收消息的类型是Object,也就是说我们可以发送任意对象类型的消息，SpringAMQP会帮我们序列化为字节后发送。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration public class FanoutExchangeConfig { /** * 对象队列 * * @return {@link Queue} */ @Bean public Queue objectQueue(){ return new Queue(\u0026#34;objectQueue\u0026#34;); } } 1 2 3 4 5 6 7 8 @Slf4j @Component public class RabbitMqListener { @RabbitListener(queues = {\u0026#34;objectQueue\u0026#34;}) public void objectQueueListener(Object object){ log.info(\u0026#34;objectQueue队列侦听器:接收到的消息为:{}\u0026#34;,object); } } 这里将consumer启动之后，就会创建objectQueue队列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @SpringBootTest class SendMessageTest { @Autowired private RabbitTemplate rabbitTemplate; /** * 发送对象消息测试 */ @Test void sendObjectMessageTest() { String queueName=\u0026#34;objectQueue\u0026#34;; Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;name\u0026#34;,\u0026#34;马小跳\u0026#34;); map.put(\u0026#34;gender\u0026#34;,\u0026#34;男\u0026#34;); map.put(\u0026#34;age\u0026#34;,\u0026#34;18\u0026#34;); rabbitTemplate.convertAndSend(queueName,map); } } 消费消息的日志打印如下\n1 objectQueue队列侦听器:接收到的消息为:(Body:\u0026#39;[serialized object]\u0026#39; MessageProperties [headers={}, contentType=application/x-java-serialized-object, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=, receivedRoutingKey=objectQueue, deliveryTag=1, consumerTag=amq.ctag-6jbSNzh0393W9MP8GZ1z-w, consumerQueue=objectQueue]) 这次将consumer项目关闭，我们重新发送信息，去rabbitmq管理页面看一看消息\nrabbitmq原生只支持字节，但是spring允许我们发送对象，这是因为使用了jdk序列化，但是这种序列化有缺点\n性能较差 安全性问题，容易出现注入问题 数据长度太长了（消息体越大，传输消息的速度越慢，而且占用额外的内存空间） 如何重新设定序列化的方式？\nSpring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConverter来处理的。\n而默认实现是SimpleMessageConverter,基于JDK的ObjectOutputStream完成序列化。\n如果要修改只需要定义一个MessageConverter类型的Bean即可。推荐用JSON方式序列化\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class RabbitMqConfig { /** * 采用json的方式将消息序列化 * * @return {@link MessageConverter} */ @Bean public MessageConverter messageConverter(){ return new Jackson2JsonMessageConverter(); } } 重新发送消息，前往rabbitmq管理页面查看\n消息消费也需要配置jackson依赖、RabbitMqConfig，上面代码复制粘贴即可，这里不再重复\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * RabbitMQ 侦听器 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/21:11 * @description: */ @Slf4j @Component public class RabbitMqListener { /** * 对象队列侦听器 * * @param map 对象 */ @RabbitListener(queues = {\u0026#34;objectQueue\u0026#34;}) public void objectQueueListener(Map\u0026lt;String,Object\u0026gt; map){ log.info(\u0026#34;objectQueue队列侦听器:接收到的消息为:{}\u0026#34;,map); for (Map.Entry\u0026lt;String, Object\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;entry = \u0026#34; + entry); } } } 总结 SpringAMQP中消息的序列化和反序列化是怎么实现的?\n利用MessageConverter实现的，默认是JDK的序列化 注意发送方与接收方必须使用相同的MessageConverter ","date":"2024-04-03T00:00:00Z","image":"http://localhost:1313/p/rabbitmq/202412212126390_hu13327992905501848806.png","permalink":"http://localhost:1313/p/rabbitmq/","title":"RabbitMq"},{"content":"Elasticsearch\r基础\r以下具体内容参考自黑马程序员课程微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式微服务全技术栈课程以及大佬的掘金博客\n概念\r文档\nes的数据存储会被序列化成json的格式 es是面向文档存储数据的，文档可以理解成一条条的数据\n索引\n索引是指相同类型文档的集合，索引可以理解成表\n映射\n文档与文档的结构会有些许差异，比如有的文档有name，有的有age 索引中文档的字段约束信息类似于表结构约束 es主要用于搜索，写入操作写入MySQL，可以将MySQL的数据同步到es\n当使用分词搜索数据的时候，必须是通过分词器分析的数据才能搜索出来，否则无法搜索出数据\n标准分词器\r1 2 3 4 5 POST /_analyze { \u0026#34;analyzer\u0026#34;:\u0026#34;standard\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;我爱中国\u0026#34; } 分词结果如下\n特点是逐字一分，对中文不太友好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \u0026#34;tokens\u0026#34;: [ { \u0026#34;token\u0026#34;: \u0026#34;我\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 1, \u0026#34;type\u0026#34;: \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;爱\u0026#34;, \u0026#34;start_offset\u0026#34;: 1, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;中\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 3, \u0026#34;type\u0026#34;: \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;国\u0026#34;, \u0026#34;start_offset\u0026#34;: 3, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34;: 3 } ] } ik分词器\r1 2 3 4 5 POST /_analyze { \u0026#34;analyzer\u0026#34;:\u0026#34;ik_max_word\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;我爱中国\u0026#34; } 一般使用ik分词器和pinyin分词器对中文分词\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \u0026#34;tokens\u0026#34;: [ { \u0026#34;token\u0026#34;: \u0026#34;我\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 1, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;爱\u0026#34;, \u0026#34;start_offset\u0026#34;: 1, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;中国\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 2 } ] } pinyin分词器\r1 2 3 4 5 POST /_analyze { \u0026#34;analyzer\u0026#34;:\u0026#34;pinyin\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;我爱中国\u0026#34; } pinyin分词器可以将中文分词成拼音，一般结合ik分词器一起使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 { \u0026#34;tokens\u0026#34;: [ { \u0026#34;token\u0026#34;: \u0026#34;wo\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 0, \u0026#34;type\u0026#34;: \u0026#34;word\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;wazg\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 0, \u0026#34;type\u0026#34;: \u0026#34;word\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;ai\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 0, \u0026#34;type\u0026#34;: \u0026#34;word\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;zhong\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 0, \u0026#34;type\u0026#34;: \u0026#34;word\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;guo\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 0, \u0026#34;type\u0026#34;: \u0026#34;word\u0026#34;, \u0026#34;position\u0026#34;: 3 } ] } 配置ik分词器结合pinyin分词器\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 新建索引库并指定自定义分词器 PUT /greatom { \u0026#34;settings\u0026#34;: { \u0026#34;analysis\u0026#34;: { \u0026#34;analyzer\u0026#34;: { \u0026#34;ik_smart_pinyin\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;custom\u0026#34;, \u0026#34;tokenizer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;filter\u0026#34;: [\u0026#34;my_pinyin\u0026#34;, \u0026#34;word_delimiter\u0026#34;] }, \u0026#34;ik_max_word_pinyin\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;custom\u0026#34;, \u0026#34;tokenizer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;: [\u0026#34;my_pinyin\u0026#34;, \u0026#34;word_delimiter\u0026#34;] } }, \u0026#34;filter\u0026#34;: { \u0026#34;my_pinyin\u0026#34;: { \u0026#34;type\u0026#34; : \u0026#34;pinyin\u0026#34;, \u0026#34;keep_separate_first_letter\u0026#34; : true, \u0026#34;keep_full_pinyin\u0026#34; : true, \u0026#34;keep_original\u0026#34; : true, \u0026#34;limit_first_letter_length\u0026#34; : 16, \u0026#34;lowercase\u0026#34; : true, \u0026#34;remove_duplicated_term\u0026#34; : true } } } } } 执行结果\n1 2 3 4 5 { \u0026#34;acknowledged\u0026#34;: true, \u0026#34;shards_acknowledged\u0026#34;: true, \u0026#34;index\u0026#34;: \u0026#34;greatom\u0026#34; } ik分词器、pinyin分词器结合\n1 2 3 4 5 POST /greatom/_analyze { \u0026#34;analyzer\u0026#34;:\u0026#34;ik_smart_pinyin\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;我爱中国\u0026#34; } 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 { \u0026#34;tokens\u0026#34;: [ { \u0026#34;token\u0026#34;: \u0026#34;w\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 1, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;wo\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 1, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;我\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 1, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;start_offset\u0026#34;: 1, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;ai\u0026#34;, \u0026#34;start_offset\u0026#34;: 1, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;爱\u0026#34;, \u0026#34;start_offset\u0026#34;: 1, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;z\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;zhong\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;g\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 3 }, { \u0026#34;token\u0026#34;: \u0026#34;guo\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 3 }, { \u0026#34;token\u0026#34;: \u0026#34;中国\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 3 }, { \u0026#34;token\u0026#34;: \u0026#34;zg\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 3 } ] } ik分词器拓展词库\r配置文件在config下，为IKAnalyzer.cfg.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE properties SYSTEM \u0026#34;http://java.sun.com/dtd/properties.dtd\u0026#34;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;comment\u0026gt;IK Analyzer 扩展配置\u0026lt;/comment\u0026gt; \u0026lt;!--用户可以在这里配置自己的扩展字典 --\u0026gt; \u0026lt;entry key=\u0026#34;ext_dict\u0026#34;\u0026gt;ext.dict\u0026lt;/entry\u0026gt; \u0026lt;!--用户可以在这里配置自己的扩展停止词字典--\u0026gt; \u0026lt;entry key=\u0026#34;ext_stopwords\u0026#34;\u0026gt;ext_stopwords.dict\u0026lt;/entry\u0026gt; \u0026lt;!--用户可以在这里配置远程扩展字典 --\u0026gt; \u0026lt;!--\u0026lt;entry key=\u0026#34;remote_ext_dict\u0026#34;\u0026gt;words_location\u0026lt;/entry\u0026gt; --\u0026gt; \u0026lt;!--用户可以在这里配置远程扩展停止词字典--\u0026gt; \u0026lt;!--\u0026lt;entry key=\u0026#34;remote_ext_stopwords\u0026#34;\u0026gt;words_location\u0026lt;/entry\u0026gt; --\u0026gt; \u0026lt;/properties\u0026gt; 在config下新建ext.dict文件和ext_stopwords.dict文件\n可以利用这个功能实现一些最新的流行词或者敏感词屏蔽 需要重启生效，但是现在先不重启测试一下\n1 2 3 4 5 POST /_analyze { \u0026#34;analyzer\u0026#34;:\u0026#34;ik_max_word\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;兄弟们，坚持了，奥里给\u0026#34; } 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 { \u0026#34;tokens\u0026#34;: [ { \u0026#34;token\u0026#34;: \u0026#34;兄弟们\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 3, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;兄弟\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;们\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 3, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;坚持\u0026#34;, \u0026#34;start_offset\u0026#34;: 4, \u0026#34;end_offset\u0026#34;: 6, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 3 }, { \u0026#34;token\u0026#34;: \u0026#34;了\u0026#34;, \u0026#34;start_offset\u0026#34;: 6, \u0026#34;end_offset\u0026#34;: 7, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 4 }, { \u0026#34;token\u0026#34;: \u0026#34;奥\u0026#34;, \u0026#34;start_offset\u0026#34;: 8, \u0026#34;end_offset\u0026#34;: 9, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 5 }, { \u0026#34;token\u0026#34;: \u0026#34;里\u0026#34;, \u0026#34;start_offset\u0026#34;: 9, \u0026#34;end_offset\u0026#34;: 10, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 6 }, { \u0026#34;token\u0026#34;: \u0026#34;给\u0026#34;, \u0026#34;start_offset\u0026#34;: 10, \u0026#34;end_offset\u0026#34;: 11, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 7 } ] } 重启es服务\n执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 { \u0026#34;tokens\u0026#34;: [ { \u0026#34;token\u0026#34;: \u0026#34;兄弟们\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 3, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;兄弟\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;们\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 3, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;坚持\u0026#34;, \u0026#34;start_offset\u0026#34;: 4, \u0026#34;end_offset\u0026#34;: 6, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 3 }, { \u0026#34;token\u0026#34;: \u0026#34;奥里给\u0026#34;, \u0026#34;start_offset\u0026#34;: 8, \u0026#34;end_offset\u0026#34;: 11, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 4 } ] } 索引库操作\r常见的mapping属性 type字段类型属性\ntext 可分词的文本 keyword 精确值，比如国家、品牌、ip地址、email，只有整体才有意义 数值 long、integer、short、byte、double、float 布尔 boolean 日期 date 对象 object，如人名分为姓和名两部分 需要注意的是，es没有数组类型，但是支持某个类型多个值，比如double支持99.1或者[99.1,98.1]（这可不是数组） index是否创建索引，默认true analyzer使用哪种分词器 properties该字段的子字段 创建索引库\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 PUT /tb_user { \u0026#34;mappings\u0026#34;:{ \u0026#34;properties\u0026#34;:{ \u0026#34;name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;:{ \u0026#34;first_name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34; }, \u0026#34;last_name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34; } } }, \u0026#34;info\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;:\u0026#34;ik_smart\u0026#34; } } } } 想使用ik+pinyin分词\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 PUT /tb_user { \u0026#34;settings\u0026#34;: { \u0026#34;analysis\u0026#34;: { \u0026#34;analyzer\u0026#34;: { \u0026#34;ik_smart_pinyin\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;custom\u0026#34;, \u0026#34;tokenizer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;filter\u0026#34;: [\u0026#34;my_pinyin\u0026#34;, \u0026#34;word_delimiter\u0026#34;] }, \u0026#34;ik_max_word_pinyin\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;custom\u0026#34;, \u0026#34;tokenizer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;: [\u0026#34;my_pinyin\u0026#34;, \u0026#34;word_delimiter\u0026#34;] } }, \u0026#34;filter\u0026#34;: { \u0026#34;my_pinyin\u0026#34;: { \u0026#34;type\u0026#34; : \u0026#34;pinyin\u0026#34;, \u0026#34;keep_separate_first_letter\u0026#34; : true, \u0026#34;keep_full_pinyin\u0026#34; : true, \u0026#34;keep_original\u0026#34; : true, \u0026#34;limit_first_letter_length\u0026#34; : 16, \u0026#34;lowercase\u0026#34; : true, \u0026#34;remove_duplicated_term\u0026#34; : true } } } }, \u0026#34;mappings\u0026#34;:{ \u0026#34;properties\u0026#34;:{ \u0026#34;name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;:{ \u0026#34;first_name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34; }, \u0026#34;last_name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34; } } }, \u0026#34;info\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;:\u0026#34;ik_smart_pinyin\u0026#34; } } } } 更新索引库\r索引库一旦创建无法修改(原有的字段)，但是可以新增新的字段\n1 2 3 4 5 6 7 8 9 PUT /tb_user/_mapping { \u0026#34;properties\u0026#34;:{ \u0026#34;age\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;:false } } } 查看、删除索引库\r1 2 3 4 # 查看 GET /tb_user # 删除 DELETE /tb_user 文档操作\r新增文档\r格式如下\n1 2 3 4 5 6 7 8 9 POST /索引库/_doc/文档id { \u0026#34;字段1\u0026#34;:\u0026#34;值1\u0026#34;, \u0026#34;字段2\u0026#34;:\u0026#34;值2\u0026#34;, \u0026#34;字段3\u0026#34;:{ \u0026#34;字段4\u0026#34;:\u0026#34;值4\u0026#34;, \u0026#34;字段5\u0026#34;:\u0026#34;值5\u0026#34;, } } 1 2 3 4 5 6 7 8 POST /tb_user/_doc/1 { \u0026#34;info\u0026#34;:\u0026#34;小花的个人信息\u0026#34;, \u0026#34;name\u0026#34;:{ \u0026#34;first_name\u0026#34;:\u0026#34;小\u0026#34;, \u0026#34;last_name\u0026#34;:\u0026#34;花\u0026#34; } } 查询文档\r1 GET /tb_user/_doc/1 删除文档\r1 DELETE /tb_user/_doc/1 修改文档\r修改文档有些特殊，有两种方法\n全量修改，先删除文档，然后新增（如果指定的文档不存在，则删除操作无效，但新增不受影响 =\u0026gt; 新增） post请求变为put 1 2 3 4 5 6 7 8 PUT /tb_user/_doc/1 { \u0026#34;info\u0026#34;:\u0026#34;小花的个人信息\u0026#34;, \u0026#34;name\u0026#34;:{ \u0026#34;first_name\u0026#34;:\u0026#34;小\u0026#34;, \u0026#34;last_name\u0026#34;:\u0026#34;花\u0026#34; } } 增量修改 格式如下 1 2 3 4 5 6 POST /索引库/_update/文档id { \u0026#34;doc\u0026#34;:{ \u0026#34;字段名\u0026#34;:\u0026#34;新的值\u0026#34; } } 例如\n1 2 3 4 5 6 7 8 POST /tb_user/_update/1 { \u0026#34;doc\u0026#34;:{ \u0026#34;name\u0026#34;:{ \u0026#34;last_name\u0026#34;:\u0026#34;花花\u0026#34; } } } 练习\r详细使用方法\n推介博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create table tb_hotel ( id bigint not null comment \u0026#39;酒店id\u0026#39; primary key, name varchar(255) not null comment \u0026#39;酒店名称\u0026#39;, address varchar(255) not null comment \u0026#39;酒店地址\u0026#39;, price int(10) not null comment \u0026#39;酒店价格\u0026#39;, score int(2) not null comment \u0026#39;酒店评分\u0026#39;, brand varchar(32) not null comment \u0026#39;酒店品牌\u0026#39;, city varchar(32) not null comment \u0026#39;所在城市\u0026#39;, star_name varchar(16) null comment \u0026#39;酒店星级，1星到5星，1钻到5钻\u0026#39;, business varchar(255) null comment \u0026#39;商圈\u0026#39;, latitude varchar(32) not null comment \u0026#39;纬度\u0026#39;, longitude varchar(32) not null comment \u0026#39;经度\u0026#39;, pic varchar(255) null comment \u0026#39;酒店图片\u0026#39; ) collate = utf8mb4_general_ci row_format = COMPACT; 数据下载\n在es中，我不仅希望根据酒店名称能搜索，而且还希望可以和其他几个字段一同搜索\ncopy_to的功能，将其他几个字段全部拷贝到一个字段\n如下all同时具备了多个字段的搜索功能\n1 2 3 4 5 6 7 8 9 10 11 12 { ... \u0026#34;all\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;:\u0026#34;ik_max_word\u0026#34; }, \u0026#34;brand\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;:\u0026#34;all\u0026#34; } ... } 构建es索引库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # 酒店 PUT /hotel { \u0026#34;mappings\u0026#34;:{ \u0026#34;properties\u0026#34;:{ \u0026#34;id\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34; }, \u0026#34;name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;:\u0026#34;ik_max_word\u0026#34;, \u0026#34;copy_to\u0026#34;:\u0026#34;all\u0026#34; }, \u0026#34;address\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34; }, \u0026#34;price\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;integer\u0026#34; }, \u0026#34;score\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;integer\u0026#34; }, \u0026#34;brand\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;:\u0026#34;all\u0026#34; }, \u0026#34;city\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34; }, \u0026#34;starName\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34; }, \u0026#34;bussiness\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;:\u0026#34;all\u0026#34; }, \u0026#34;location\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;geo_point\u0026#34; }, \u0026#34;pic\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;:\u0026#34;false\u0026#34; }, \u0026#34;all\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;:\u0026#34;ik_max_word\u0026#34; } } } } 创建项目\r配置\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;3.0.2\u0026lt;/spring-boot.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--FastJson--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.71\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-elasticsearch\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import lombok.Data; import lombok.extern.slf4j.Slf4j; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; @Data @Slf4j @Configuration @ConfigurationProperties(prefix = \u0026#34;elasticsearch\u0026#34;) public class ElasticSearchConfig { /** * 协议 */ private String schema; /** * 集群地址，如果有多个用“,”隔开 */ private String address; /** * 连接超时时间 */ private int connectTimeout; /** * Socket 连接超时时间 */ private int socketTimeout; /** * 获取连接的超时时间 */ private int connectionRequestTimeout; /** * 最大连接数 */ private int maxConnectNum; /** * 最大路由连接数 */ private int maxConnectPerRoute; /** * 连接ES的用户名 */ private String username; /** * 数据查询的索引 */ private String index; /** * 密码 */ private String passwd; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 应用名称 spring.application.name=demo # 应用服务 WEB 访问端口 server.port=8080 # 查看es日志 spring.jpa.show-sql=true logging.level.tracer=TRACE elasticsearch.schema=http elasticsearch.address=localhost:9200 elasticsearch.connectTimeout=10000 elasticsearch.socketTimeout=15000 elasticsearch.connectionRequestTimeout=20000 elasticsearch.maxConnectNum=100 elasticsearch.maxConnectPerRoute=100 elasticsearch.index=\u0026#34;aha\u0026#34; # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据源名称 spring.datasource.name=defaultDataSource # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/es?serverTimezone=UTC # 数据库用户名\u0026amp;密码： spring.datasource.username=root spring.datasource.password=123456 # 配置mybatis-plus 打印sql日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # xml文件路径 mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml # 配置mybatis-plus 包路径 mybatis-plus.type-aliases-package=com.example.domain # mybatis-plus下划线转驼峰配置，默认为true mybatis-plus.configuration.map-underscore-to-camel-case=true # 配置全局默认主键类型，实体类不用加@TableId(value =\u0026#34;id\u0026#34;,type = IdType.AUTO) mybatis-plus.global-config.db-config.id-type=auto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.json.jackson.JacksonJsonpMapper; import co.elastic.clients.transport.ElasticsearchTransport; import co.elastic.clients.transport.rest_client.RestClientTransport; import org.apache.http.HttpHost; import org.elasticsearch.client.RestClient; import org.elasticsearch.client.RestClientBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.ArrayList; import java.util.List; /** * es java client */ @Configuration public class ElasticsearchClientConfig { private final ElasticSearchConfig elasticSearchConfig; public ElasticsearchClientConfig (ElasticSearchConfig elasticSearchConfig) { this.elasticSearchConfig = elasticSearchConfig; } @Bean public RestClient restClient() { // 拆分地址 List\u0026lt;HttpHost\u0026gt; hostLists = new ArrayList\u0026lt;\u0026gt;(); String[] hostArray = elasticSearchConfig.getAddress().split(\u0026#34;,\u0026#34;); for (String temp : hostArray) { String host = temp.split(\u0026#34;:\u0026#34;)[0]; String port = temp.split(\u0026#34;:\u0026#34;)[1]; hostLists.add(new HttpHost(host, Integer.parseInt(port), elasticSearchConfig.getSchema())); } // 转换成 HttpHost 数组 HttpHost[] httpHost = hostLists.toArray(new HttpHost[]{}); // 构建连接对象 RestClientBuilder builder = RestClient.builder(httpHost); // 异步连接延时配置 builder.setRequestConfigCallback(requestConfigBuilder -\u0026gt; { requestConfigBuilder.setConnectTimeout(elasticSearchConfig.getConnectTimeout()); requestConfigBuilder.setSocketTimeout(elasticSearchConfig.getSocketTimeout()); requestConfigBuilder.setConnectionRequestTimeout(elasticSearchConfig.getConnectionRequestTimeout()); return requestConfigBuilder; }); // 异步连接数配置 builder.setHttpClientConfigCallback(httpClientBuilder -\u0026gt; { httpClientBuilder.setMaxConnTotal(elasticSearchConfig.getMaxConnectNum()); httpClientBuilder.setMaxConnPerRoute(elasticSearchConfig.getMaxConnectPerRoute()); return httpClientBuilder; }); return builder.build(); } @Bean public ElasticsearchTransport elasticsearchTransport (RestClient restClient) { return new RestClientTransport( restClient, new JacksonJsonpMapper()); } @Bean public ElasticsearchClient elasticsearchClient (ElasticsearchTransport transport) { return new ElasticsearchClient(transport); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import lombok.Data; import java.io.Serializable; /** * * @TableName tb_hotel */ @TableName(value =\u0026#34;tb_hotel\u0026#34;) @Data public class Hotel implements Serializable { /** * 酒店id */ @TableId private Long id; /** * 酒店名称 */ private String name; /** * 酒店地址 */ private String address; /** * 酒店价格 */ private Integer price; /** * 酒店评分 */ private Integer score; /** * 酒店品牌 */ private String brand; /** * 所在城市 */ private String city; /** * 酒店星级，1星到5星，1钻到5钻 */ private String starName; /** * 商圈 */ private String business; /** * 纬度 */ private String latitude; /** * 经度 */ private String longitude; /** * 酒店图片 */ private String pic; @TableField(exist = false) private static final long serialVersionUID = 1L; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import com.example.domain.Hotel; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.springframework.data.annotation.Id; import org.springframework.data.elasticsearch.annotations.Document; import org.springframework.data.elasticsearch.annotations.Field; import org.springframework.data.elasticsearch.annotations.FieldType; import org.springframework.data.elasticsearch.annotations.GeoPointField; import org.springframework.data.elasticsearch.core.geo.GeoPoint; /** * @auther: 不是菜狗爱编程 * @Date: 2024/03/27/7:45 * @Description: */ @Data @AllArgsConstructor @NoArgsConstructor @Document(indexName = \u0026#34;hotel\u0026#34;,createIndex = true) public class HotelDoc { @Id @Field(type = FieldType.Keyword) private Long id; @Field(type = FieldType.Text) private String name; @Field(type = FieldType.Keyword) private String address; @Field(type = FieldType.Integer) private Integer price; @Field(type = FieldType.Integer) private Integer score; @Field(type = FieldType.Keyword) private String brand; @Field(type = FieldType.Keyword) private String city; @Field(type = FieldType.Keyword) private String starName; @Field(type = FieldType.Keyword) private String business; /** * 位置 */ @GeoPointField private GeoPoint location; @Field(type = FieldType.Keyword) private String pic; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location=new GeoPoint(Double.parseDouble(hotel.getLatitude()),Double.parseDouble(hotel.getLongitude())); this.pic = hotel.getPic(); } } 操作索引\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.mapping.Property; import co.elastic.clients.elasticsearch.indices.CreateIndexResponse; import co.elastic.clients.elasticsearch.indices.DeleteIndexResponse; import co.elastic.clients.elasticsearch.indices.GetIndexResponse; import co.elastic.clients.transport.endpoints.BooleanResponse; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; import java.util.Map; /** * 索引操作 */ @Slf4j @SpringBootTest class IndexTest { @Autowired private ElasticsearchClient elasticsearchClient; /** * 创建索引 不使用mapping */ @Test void createIndexWithoutMappingTest() throws IOException { CreateIndexResponse createIndexResponse = elasticsearchClient.indices() .create(createIndexRequest -\u0026gt; createIndexRequest.index(\u0026#34;elasticsearch-client\u0026#34;)); log.info(\u0026#34;== {} 索引创建是否成功: {}\u0026#34;, \u0026#34;elasticsearch-client\u0026#34;, createIndexResponse.acknowledged()); } /** * 创建索引 使用mapping */ @Test void createIndexWithMappingTest() throws IOException { CreateIndexResponse createIndexResponse = elasticsearchClient.indices() .create(createIndexRequest -\u0026gt; createIndexRequest.index(\u0026#34;elasticsearch-client\u0026#34;) .mappings(typeMapping -\u0026gt; typeMapping.properties(\u0026#34;name\u0026#34;, objectBuild -\u0026gt; objectBuild.text( textProperty -\u0026gt; textProperty.index(true))) .properties(\u0026#34;age\u0026#34;,objectBuild -\u0026gt; objectBuild.integer( textProperty -\u0026gt; textProperty.index(false))) ) ); log.info(\u0026#34;== {} 索引创建是否成功: {}\u0026#34;, \u0026#34;elasticsearch-client\u0026#34;, createIndexResponse.acknowledged()); } /** * 删除索引 */ @Test void deleteIndexTest() throws IOException { DeleteIndexResponse deleteIndexResponse = elasticsearchClient.indices() .delete(deleteIndexRequest -\u0026gt; deleteIndexRequest.index(\u0026#34;elasticsearch-client\u0026#34;)); log.info(\u0026#34;== {} 索引删除是否成功: {}\u0026#34;, \u0026#34;elasticsearch-client\u0026#34;, deleteIndexResponse.acknowledged()); } /** * 判断索引是否存在 */ @Test void checkIndexExistTest() throws IOException { BooleanResponse exists = elasticsearchClient.indices() .exists(existRequest -\u0026gt; existRequest.index(\u0026#34;elasticsearch-client\u0026#34;)); log.info(\u0026#34;== {} 索引是否存在: {}\u0026#34;, \u0026#34;elasticsearch-client\u0026#34;, exists.value()?\u0026#34;存在\u0026#34;:\u0026#34;不存在\u0026#34;); } /** * 查询索引详细信息 */ @Test void getIndexTest() throws IOException { GetIndexResponse getIndexResponse = elasticsearchClient.indices() .get(getIndexRequest -\u0026gt; getIndexRequest.index(\u0026#34;elasticsearch-client\u0026#34;)); Map\u0026lt;String, Property\u0026gt; properties = getIndexResponse.get(\u0026#34;elasticsearch-client\u0026#34;).mappings().properties(); for (String key : properties.keySet()) { log.info(\u0026#34;== {} 索引的详细信息为: == key: {}, Property: {}\u0026#34;, \u0026#34;elasticsearch-client\u0026#34;, key, properties.get(key)._kind()); } } } 文档操作\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch.core.*; import co.elastic.clients.elasticsearch.core.bulk.BulkOperation; import com.example.domain.Hotel; import com.example.domain.doc.HotelDoc; import com.example.service.HotelService; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; import java.util.ArrayList; import java.util.List; /** * 文档操作 */ @Slf4j @SpringBootTest class DocTest { private static final String INDEX_NAME = \u0026#34;hotel\u0026#34;; @Autowired private ElasticsearchClient elasticsearchClient; @Autowired private HotelService hotelService; /** * 添加文档 * GET /hotel/_doc/61083 */ @Test void addDocTest() throws IOException { Hotel hotel = hotelService.getById(61083); HotelDoc hotelDoc = new HotelDoc(hotel); IndexResponse index = elasticsearchClient.index( indexRequest -\u0026gt; indexRequest.index(INDEX_NAME).id(hotelDoc.getId().toString()).document(hotelDoc)); log.info(\u0026#34;== response: {}, responseStatus: {}\u0026#34;, index, index.result()); } /** * 获取文档信息 */ @Test public void getDocTest () throws IOException { GetResponse\u0026lt;HotelDoc\u0026gt; getResponse = elasticsearchClient.get(getRequest -\u0026gt; getRequest.index(INDEX_NAME).id(\u0026#34;61083\u0026#34;), HotelDoc.class ); log.info(\u0026#34;== document source: {}, response: {}\u0026#34;, getResponse.source(), getResponse); } /** * 更新文档信息 */ @Test public void updateDocTest () throws IOException { Hotel hotel = hotelService.getById(61083); HotelDoc hotelDoc = new HotelDoc(hotel); hotelDoc.setName(hotelDoc.getName()+\u0026#34;(更新后)\u0026#34;); UpdateResponse\u0026lt;HotelDoc\u0026gt; updateResponse = elasticsearchClient.update(updateRequest -\u0026gt; updateRequest.index(INDEX_NAME).id(\u0026#34;61083\u0026#34;).doc(hotelDoc), HotelDoc.class ); log.info(\u0026#34;== response: {}, responseStatus: {}\u0026#34;, updateResponse, updateResponse.result()); } /** * 删除文档信息 */ @Test public void deleteDocTest () throws IOException { DeleteResponse deleteResponse = elasticsearchClient.delete(deleteRequest -\u0026gt; deleteRequest.index(INDEX_NAME).id(\u0026#34;1\u0026#34;) ); log.info(\u0026#34;== response: {}, result:{}\u0026#34;, deleteResponse, deleteResponse.result()); } /** * 批量插入文档 * GET /hotel/_doc/36934 * GET /hotel/_doc/38609 */ @Test public void batchInsertTest () throws IOException { List\u0026lt;Hotel\u0026gt; hotels = hotelService.list(); List\u0026lt;BulkOperation\u0026gt; bulkOperationList = new ArrayList\u0026lt;\u0026gt;(); for (Hotel hotel : hotels) { HotelDoc hotelDoc = new HotelDoc(hotel); bulkOperationList.add(new BulkOperation.Builder().create(e -\u0026gt; e.document(hotelDoc).id(hotel.getId().toString())).build()); } BulkResponse bulkResponse = elasticsearchClient.bulk(bulkRequest -\u0026gt; bulkRequest.index(INDEX_NAME).operations(bulkOperationList) ); // 这边插入成功的话显示的是 false log.info(\u0026#34;== errors: {}\u0026#34;, bulkResponse.errors()); } } DSL语法\r查询所有:查询出所有数据，一般测试用。例如: match_all 全文检索(full text)查询:利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如:match_query、multi_match_query 精确查询:根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如:ids、range、term 地理(geo)查询:根据经纬度查询。例如:geo_distance、geo_bounding_box 复合(compound)查询:复合查询可以将上述各种查询条件组合起来，合并查询条件。例如:bool、function_score 查询所有\rmatch_all\r基本查询语法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 GET /indexName/_search { \u0026#34;query\u0026#34;:{ \u0026#34;查询类型\u0026#34;:{ \u0026#34;查询条件\u0026#34;:\u0026#34;条件值\u0026#34; } } } # 例如 GET /indexName/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match_all\u0026#34;:{ } } } 全文检索查询\r全文检索查询会对用户输入内容分词，常用于搜索框查询\nmatch\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET /indexName/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match\u0026#34;:{ \u0026#34;FIELD\u0026#34;:\u0026#34;TEXT\u0026#34; } } } # 例如 # 这个all字段在前文的copy_to那里 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match\u0026#34;:{ \u0026#34;all\u0026#34;:\u0026#34;上海五\u0026#34; } } } 查询结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 { \u0026#34;took\u0026#34;: 5, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 83, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 4.671594, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1557997004\u0026#34;, \u0026#34;_score\u0026#34;: 4.671594, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1557997004, \u0026#34;name\u0026#34;: \u0026#34;上海五角场凯悦酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;国定东路88号\u0026#34;, \u0026#34;price\u0026#34;: 1104, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;凯悦\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;江湾/五角场商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.300645, \u0026#34;lon\u0026#34;: 121.51918 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/3a3Zz9cDgbJEEJ1GcXzKhTh21YqK_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56977\u0026#34;, \u0026#34;_score\u0026#34;: 4.1990623, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56977, \u0026#34;name\u0026#34;: \u0026#34;上海五角场华美达大酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;黄兴路1888号\u0026#34;, \u0026#34;price\u0026#34;: 499, \u0026#34;score\u0026#34;: 40, \u0026#34;brand\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;三钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;江湾/五角场商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.292932, \u0026#34;lon\u0026#34;: 121.519759 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/26VREqAQdaGFvJdAJALVtjxcNMpL_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;39141\u0026#34;, \u0026#34;_score\u0026#34;: 3.700049, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 39141, \u0026#34;name\u0026#34;: \u0026#34;7天连锁酒店(上海五角场复旦同济大学店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;杨浦国权路315号\u0026#34;, \u0026#34;price\u0026#34;: 349, \u0026#34;score\u0026#34;: 38, \u0026#34;brand\u0026#34;: \u0026#34;7天酒店\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;江湾、五角场商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.290057, \u0026#34;lon\u0026#34;: 121.508804 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G2/M00/C7/E3/Cii-T1knFXCIJzNYAAFB8-uFNAEAAKYkQPcw1IAAUIL012_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2048671293\u0026#34;, \u0026#34;_score\u0026#34;: 3.644754, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2048671293, \u0026#34;name\u0026#34;: \u0026#34;汉庭酒店(深圳观澜五和大道店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;观湖街道五和大道327号\u0026#34;, \u0026#34;price\u0026#34;: 234, \u0026#34;score\u0026#34;: 43, \u0026#34;brand\u0026#34;: \u0026#34;汉庭\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;深圳\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;观澜\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 22.684459, \u0026#34;lon\u0026#34;: 114.07708 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2JrQi83S9qgDEkXqWpe5iyi44Uh2_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;339777429\u0026#34;, \u0026#34;_score\u0026#34;: 1.1486411, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 339777429, \u0026#34;name\u0026#34;: \u0026#34;上海嘉定喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;菊园新区嘉唐公路66号\u0026#34;, \u0026#34;price\u0026#34;: 1286, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.394595, \u0026#34;lon\u0026#34;: 121.245773 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2v2fKuo5bzhunSBC1n1E42cLTkZV_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2022598930\u0026#34;, \u0026#34;_score\u0026#34;: 1.095608, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2022598930, \u0026#34;name\u0026#34;: \u0026#34;上海宝华喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;南奉公路3111弄228号\u0026#34;, \u0026#34;price\u0026#34;: 2899, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;奉贤开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.921659, \u0026#34;lon\u0026#34;: 121.575572 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/45/BD/Cii-TF3ZaBmIStrbAASnoOyg7FoAAFpYwEoz9oABKe4992_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;46829\u0026#34;, \u0026#34;_score\u0026#34;: 1.0472558, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 46829, \u0026#34;name\u0026#34;: \u0026#34;上海浦西万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;恒丰路338号\u0026#34;, \u0026#34;price\u0026#34;: 726, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;上海火车站地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.242977, \u0026#34;lon\u0026#34;: 121.455864 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;644417\u0026#34;, \u0026#34;_score\u0026#34;: 1.0472558, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 644417, \u0026#34;name\u0026#34;: \u0026#34;上海外高桥喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;自由贸易试验区基隆路28号（二号门内）\u0026#34;, \u0026#34;price\u0026#34;: 2419, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东外高桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.350989, \u0026#34;lon\u0026#34;: 121.588751 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/1Rrtg9n7PdMEivVDhsehbJBrEre_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1463484295\u0026#34;, \u0026#34;_score\u0026#34;: 1.0472558, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1463484295, \u0026#34;name\u0026#34;: \u0026#34;上海和平豪生酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;沪南公路2653-2号\u0026#34;, \u0026#34;price\u0026#34;: 650, \u0026#34;score\u0026#34;: 41, \u0026#34;brand\u0026#34;: \u0026#34;豪生\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;周浦康桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.146478, \u0026#34;lon\u0026#34;: 121.568218 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/ZxM9gWHqj657ndRsHw4j4p3CQ5k_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1880614409\u0026#34;, \u0026#34;_score\u0026#34;: 1.0472558, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1880614409, \u0026#34;name\u0026#34;: \u0026#34;上海崇明由由喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;揽海路2888号\u0026#34;, \u0026#34;price\u0026#34;: 2198, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;崇明岛/长兴岛/横沙岛\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.462167, \u0026#34;lon\u0026#34;: 121.823103 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/21gDCGgRT3xFqCd3FxBh633j6Qsu_w200_h200_c1_t0.jpg\u0026#34; } } ] } } multi_match\rmulti_match与match查询类似，允许同时查询多个字段\n需要注意：参与搜索的字段越多，效率越低，建议使用copy_to将多个字段拷贝到一个字段中，采用match查询\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;multi_match\u0026#34;:{ \u0026#34;query\u0026#34;:\u0026#34;TEXT1\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;FIELD1\u0026#34;,\u0026#34;FIELD2\u0026#34;] } } } # 例如 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;multi_match\u0026#34;:{ \u0026#34;query\u0026#34;:\u0026#34;上海酒店\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;city\u0026#34;,\u0026#34;name\u0026#34;] } } } 查询结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 { \u0026#34;took\u0026#34;: 1, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 200, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1.1692147, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;339777429\u0026#34;, \u0026#34;_score\u0026#34;: 1.1692147, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 339777429, \u0026#34;name\u0026#34;: \u0026#34;上海嘉定喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;菊园新区嘉唐公路66号\u0026#34;, \u0026#34;price\u0026#34;: 1286, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.394595, \u0026#34;lon\u0026#34;: 121.245773 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2v2fKuo5bzhunSBC1n1E42cLTkZV_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;46829\u0026#34;, \u0026#34;_score\u0026#34;: 1.1032845, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 46829, \u0026#34;name\u0026#34;: \u0026#34;上海浦西万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;恒丰路338号\u0026#34;, \u0026#34;price\u0026#34;: 726, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;上海火车站地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.242977, \u0026#34;lon\u0026#34;: 121.455864 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;60223\u0026#34;, \u0026#34;_score\u0026#34;: 1.1032845, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 60223, \u0026#34;name\u0026#34;: \u0026#34;上海希尔顿酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;静安华山路250号\u0026#34;, \u0026#34;price\u0026#34;: 2688, \u0026#34;score\u0026#34;: 37, \u0026#34;brand\u0026#34;: \u0026#34;希尔顿\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;静安寺地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.219306, \u0026#34;lon\u0026#34;: 121.445427 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/filebroker/cdn/res/92/10/9210e74442aceceaf6e196d61fc3b6b1_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1463484295\u0026#34;, \u0026#34;_score\u0026#34;: 1.1032845, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1463484295, \u0026#34;name\u0026#34;: \u0026#34;上海和平豪生酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;沪南公路2653-2号\u0026#34;, \u0026#34;price\u0026#34;: 650, \u0026#34;score\u0026#34;: 41, \u0026#34;brand\u0026#34;: \u0026#34;豪生\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;周浦康桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.146478, \u0026#34;lon\u0026#34;: 121.568218 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/ZxM9gWHqj657ndRsHw4j4p3CQ5k_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1942992995\u0026#34;, \u0026#34;_score\u0026#34;: 1.1032845, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1942992995, \u0026#34;name\u0026#34;: \u0026#34;上海嘉定凯悦酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;裕民南路1366号\u0026#34;, \u0026#34;price\u0026#34;: 758, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;凯悦\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.352298, \u0026#34;lon\u0026#34;: 121.263314 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2D/Cii-U13edkqIfZhLAAJEW25WIF4AAGVxQIg38sAAkRz517_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1996823660\u0026#34;, \u0026#34;_score\u0026#34;: 1.1032845, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1996823660, \u0026#34;name\u0026#34;: \u0026#34;上海紫竹万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;紫星路588号3幢\u0026#34;, \u0026#34;price\u0026#34;: 642, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;交大/闵行经济开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.02118, \u0026#34;lon\u0026#34;: 121.465186 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2F/Cii-TF3edraIPzK9AAH_p8vdHKoAAGV3AJgSVEAAf-_019_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2022598930\u0026#34;, \u0026#34;_score\u0026#34;: 1.1032845, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2022598930, \u0026#34;name\u0026#34;: \u0026#34;上海宝华喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;南奉公路3111弄228号\u0026#34;, \u0026#34;price\u0026#34;: 2899, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;奉贤开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.921659, \u0026#34;lon\u0026#34;: 121.575572 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/45/BD/Cii-TF3ZaBmIStrbAASnoOyg7FoAAFpYwEoz9oABKe4992_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56201\u0026#34;, \u0026#34;_score\u0026#34;: 1.0443928, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56201, \u0026#34;name\u0026#34;: \u0026#34;上海齐鲁万怡大酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;东方路838号\u0026#34;, \u0026#34;price\u0026#34;: 873, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东陆家嘴金融贸易区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.226031, \u0026#34;lon\u0026#34;: 121.525801 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKeIJeN7AASiKHbTtx4AAGRegDSBzMABKJA111_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56227\u0026#34;, \u0026#34;_score\u0026#34;: 1.0443928, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56227, \u0026#34;name\u0026#34;: \u0026#34;上海圣淘沙万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;南桥镇南桥路1号\u0026#34;, \u0026#34;price\u0026#34;: 899, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;奉贤开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.910917, \u0026#34;lon\u0026#34;: 121.456525 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B9/Cii-U13eXSiIdJjXAARSA6FywFYAAGRnwHvy1AABFIb158_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56852\u0026#34;, \u0026#34;_score\u0026#34;: 1.0443928, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56852, \u0026#34;name\u0026#34;: \u0026#34;上海财大豪生大酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;武东路188号\u0026#34;, \u0026#34;price\u0026#34;: 592, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;豪生\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;江湾/五角场商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.304182, \u0026#34;lon\u0026#34;: 121.492936 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2jGHezLZvPZqC9cBGesbP5vAhCXi_w200_h200_c1_t0.jpg\u0026#34; } } ] } } 精确查询\r一般是查找keyword、数值、日期、boolean等类型字段，不做分词\nterm\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 GET /indexName/_search { \u0026#34;query\u0026#34;:{ \u0026#34;term\u0026#34;:{ \u0026#34;FIELD\u0026#34;:{ \u0026#34;value\u0026#34;:\u0026#34;VALUE\u0026#34; } } } } # 例如 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;term\u0026#34;:{ \u0026#34;starName\u0026#34;:{ \u0026#34;value\u0026#34;:\u0026#34;四钻\u0026#34; } } } } 查询结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 { \u0026#34;took\u0026#34;: 0, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 28, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1.9583635, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;45845\u0026#34;, \u0026#34;_score\u0026#34;: 1.9583635, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 45845, \u0026#34;name\u0026#34;: \u0026#34;上海西藏大厦万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;虹桥路100号\u0026#34;, \u0026#34;price\u0026#34;: 589, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;徐家汇地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.192714, \u0026#34;lon\u0026#34;: 121.434717 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/48GNb9GZpJDCejVAcQHYWwYyU8T_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;46829\u0026#34;, \u0026#34;_score\u0026#34;: 1.9583635, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 46829, \u0026#34;name\u0026#34;: \u0026#34;上海浦西万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;恒丰路338号\u0026#34;, \u0026#34;price\u0026#34;: 726, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;上海火车站地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.242977, \u0026#34;lon\u0026#34;: 121.455864 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;47066\u0026#34;, \u0026#34;_score\u0026#34;: 1.9583635, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 47066, \u0026#34;name\u0026#34;: \u0026#34;上海浦东东站华美达酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;施新路958号\u0026#34;, \u0026#34;price\u0026#34;: 408, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东机场核心区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.147989, \u0026#34;lon\u0026#34;: 121.759199 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2pNujAVaQbXACzkHp8bQMm6zqwhp_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56912\u0026#34;, \u0026#34;_score\u0026#34;: 1.9583635, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56912, \u0026#34;name\u0026#34;: \u0026#34;上海华凯华美达广场酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;月华路9号\u0026#34;, \u0026#34;price\u0026#34;: 747, \u0026#34;score\u0026#34;: 40, \u0026#34;brand\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;奉贤开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.814382, \u0026#34;lon\u0026#34;: 121.464521 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/45iaCNCuZavJTxwTLskhVKzwynLD_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;60522\u0026#34;, \u0026#34;_score\u0026#34;: 1.9583635, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 60522, \u0026#34;name\u0026#34;: \u0026#34;上海嘉豪淮海国际豪生酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;汾阳路1号\u0026#34;, \u0026#34;price\u0026#34;: 425, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;豪生\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;淮海路/新天地地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.215497, \u0026#34;lon\u0026#34;: 121.456297 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/38UBi4QYuaF8jN94CxQ7tb7tjtmZ_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;60916\u0026#34;, \u0026#34;_score\u0026#34;: 1.9583635, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 60916, \u0026#34;name\u0026#34;: \u0026#34;上海绿地万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;沪宜公路3101号\u0026#34;, \u0026#34;price\u0026#34;: 328, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.368523, \u0026#34;lon\u0026#34;: 121.258567 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/3VLwG9tTQQnp3M3MTeMTdx9nas9B_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;395815\u0026#34;, \u0026#34;_score\u0026#34;: 1.9583635, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 395815, \u0026#34;name\u0026#34;: \u0026#34;北京明豪华美达酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;天竺镇府前一街13号\u0026#34;, \u0026#34;price\u0026#34;: 558, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;首都机场/新国展地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 40.062832, \u0026#34;lon\u0026#34;: 116.580678 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/13/Cii-U13eP2mIKCwvAAODTZXT-fAAAGKVAA9taIAA4Nl245_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;598591\u0026#34;, \u0026#34;_score\u0026#34;: 1.9583635, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 598591, \u0026#34;name\u0026#34;: \u0026#34;上海丽昂豪生大酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;金新路99号\u0026#34;, \u0026#34;price\u0026#34;: 529, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;豪生\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东金桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.252496, \u0026#34;lon\u0026#34;: 121.600085 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2KfPPyPx9rWyVXif2CUuxv61Nryc_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;609372\u0026#34;, \u0026#34;_score\u0026#34;: 1.9583635, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 609372, \u0026#34;name\u0026#34;: \u0026#34;豪派特华美达广场酒店(深圳北站店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;民治街道梅龙路与民旺路交汇处\u0026#34;, \u0026#34;price\u0026#34;: 498, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;深圳\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;深圳北站地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 22.620501, \u0026#34;lon\u0026#34;: 114.033874 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/3G5TnUCPbjGYHAVWfvuixw8bs69t_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;629023\u0026#34;, \u0026#34;_score\u0026#34;: 1.9583635, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 629023, \u0026#34;name\u0026#34;: \u0026#34;和颐酒店(北京十里河欢乐谷店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;十八里店乡周家庄288号\u0026#34;, \u0026#34;price\u0026#34;: 390, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;和颐\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;劲松/潘家园地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 39.853354, \u0026#34;lon\u0026#34;: 116.483437 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/28hnDdqn5uzuzCKYkw2x4pYmunXM_w200_h200_c1_t0.jpg\u0026#34; } } ] } } range\r一般查询某个范围内的值\n如下查找\u0026quot;大于等于10\u0026quot;且\u0026quot;小于等于20\u0026quot;的值\ngte 大于等于 gt 大于 lte 小于等于 lt 小于\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 GET /indexName/_search { \u0026#34;query\u0026#34;:{ \u0026#34;range\u0026#34;:{ \u0026#34;FIELD\u0026#34;:{ \u0026#34;gte\u0026#34;:10, \u0026#34;lte\u0026#34;:20 } } } } # 例如 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;range\u0026#34;:{ \u0026#34;price\u0026#34;:{ \u0026#34;gte\u0026#34;:100, \u0026#34;lte\u0026#34;:200 } } } } 查询结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 { \u0026#34;took\u0026#34;: 0, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 17, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;485775\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 485775, \u0026#34;name\u0026#34;: \u0026#34;如家酒店(上海闵行华东师范大学吴泾店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;吴泾镇宝秀路977号\u0026#34;, \u0026#34;price\u0026#34;: 161, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;交大/闵行经济开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.047135, \u0026#34;lon\u0026#34;: 121.46224 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/V8pz15CkiMX5xYJRmbbp5zkKWJ8_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;517915\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 517915, \u0026#34;name\u0026#34;: \u0026#34;如家酒店·neo(深圳草埔地铁站店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;布吉路1036号\u0026#34;, \u0026#34;price\u0026#34;: 159, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;深圳\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;田贝/水贝珠宝城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 22.583191, \u0026#34;lon\u0026#34;: 114.118499 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/228vhBCQmFRFWQBYX1cgoFQb6x58_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;541619\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 541619, \u0026#34;name\u0026#34;: \u0026#34;如家酒店(上海莘庄地铁站龙之梦商业广场店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;莘庄镇莘浜路172号\u0026#34;, \u0026#34;price\u0026#34;: 149, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;莘庄工业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.105797, \u0026#34;lon\u0026#34;: 121.37755 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/3mKs3jETvJDj3dDdkRB9UyLLvPna_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;608374\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 608374, \u0026#34;name\u0026#34;: \u0026#34;如家酒店(上海浦东机场龙东大道合庆店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;东川公路5863号\u0026#34;, \u0026#34;price\u0026#34;: 160, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东机场核心区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.237662, \u0026#34;lon\u0026#34;: 121.718556 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/LUYxGGV4pzjKeN5a69K4deU8JD8_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;728180\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 728180, \u0026#34;name\u0026#34;: \u0026#34;如家酒店(深圳宝安西乡地铁站店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;西乡大道298-7号（富通城二期公交站旁）\u0026#34;, \u0026#34;price\u0026#34;: 184, \u0026#34;score\u0026#34;: 43, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;深圳\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;宝安体育中心商圈\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 22.569693, \u0026#34;lon\u0026#34;: 113.860186 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/FHdugqgUgYLPMoC4u4rdTbAPrVF_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;728415\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 728415, \u0026#34;name\u0026#34;: \u0026#34;如家酒店·neo(深圳东门步行街晒布地铁站店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;晒布路67号\u0026#34;, \u0026#34;price\u0026#34;: 152, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;深圳\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;东门商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 22.550183, \u0026#34;lon\u0026#34;: 114.120771 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/25/57/Cii-U13PFNWISSnQAAEpTtoilsQAAEVWgEvur8AASlm647_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;728604\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 728604, \u0026#34;name\u0026#34;: \u0026#34;如家酒店·neo(深圳南山地铁站南山市场店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;南新路顺富街18号化州大厦\u0026#34;, \u0026#34;price\u0026#34;: 198, \u0026#34;score\u0026#34;: 43, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;深圳\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;科技园\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 22.525561, \u0026#34;lon\u0026#34;: 113.920058 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/25/57/Cii-TF3PFLmIDGWiAAPHkaNTuOIAAEVVQBGazAAA8ep611_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2316304\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2316304, \u0026#34;name\u0026#34;: \u0026#34;如家酒店(深圳双龙地铁站店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;龙岗街道龙岗墟社区龙平东路62号\u0026#34;, \u0026#34;price\u0026#34;: 135, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;深圳\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;龙岗中心区/大运新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 22.730828, \u0026#34;lon\u0026#34;: 114.278337 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/4AzEoQ44awd1D2g95a6XDtJf3dkw_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;5873072\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 5873072, \u0026#34;name\u0026#34;: \u0026#34;速8酒店（上海火车站北广场店）\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;闸北芷江西路796号\u0026#34;, \u0026#34;price\u0026#34;: 190, \u0026#34;score\u0026#34;: 41, \u0026#34;brand\u0026#34;: \u0026#34;速8\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;上海火车站地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.255579, \u0026#34;lon\u0026#34;: 121.452903 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m2.tuniucdn.com/filebroker/cdn/res/96/6d/966d6596e6cb7b48c9cc1d7da79b57c8_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;197837109\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 197837109, \u0026#34;name\u0026#34;: \u0026#34;如家酒店·neo(深圳龙岗大道布吉地铁站店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;布吉镇深惠路龙珠商城\u0026#34;, \u0026#34;price\u0026#34;: 127, \u0026#34;score\u0026#34;: 43, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;深圳\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;布吉/深圳东站\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 22.602482, \u0026#34;lon\u0026#34;: 114.123284 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/25/58/Cii-TF3PFZOIA7jwAAKInGFN4xgAAEVbAGeP4AAAoi0485_w200_h200_c1_t0.jpg\u0026#34; } } ] } } 地理查询\rlat指纬度、lon指经度\ngeo_bounding_box\r查询geo_point值落在某个矩形范围内的所有文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 GET /indexName/_search { \u0026#34;query\u0026#34;:{ \u0026#34;geo_bounding_box\u0026#34;:{ \u0026#34;FIELD\u0026#34;:{ \u0026#34;top_left\u0026#34;:{ \u0026#34;lat\u0026#34;:31.1, \u0026#34;lon\u0026#34;:121.5 }, \u0026#34;bottom_right\u0026#34;:{ \u0026#34;lat\u0026#34;:30.9, \u0026#34;lon\u0026#34;:121.7 } } } } } # 例如 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;geo_bounding_box\u0026#34;:{ \u0026#34;location\u0026#34;:{ \u0026#34;top_left\u0026#34;:{ \u0026#34;lat\u0026#34;:31.1, \u0026#34;lon\u0026#34;:121.5 }, \u0026#34;bottom_right\u0026#34;:{ \u0026#34;lat\u0026#34;:30.9, \u0026#34;lon\u0026#34;:121.7 } } } } } 查询结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 { \u0026#34;took\u0026#34;: 7, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 2, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2022598930\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2022598930, \u0026#34;name\u0026#34;: \u0026#34;上海宝华喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;南奉公路3111弄228号\u0026#34;, \u0026#34;price\u0026#34;: 2899, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;奉贤开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.921659, \u0026#34;lon\u0026#34;: 121.575572 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/45/BD/Cii-TF3ZaBmIStrbAASnoOyg7FoAAFpYwEoz9oABKe4992_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2056298828\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2056298828, \u0026#34;name\u0026#34;: \u0026#34;上海中优城市万豪酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;沪南公路7688弄1号\u0026#34;, \u0026#34;price\u0026#34;: 1200, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;万豪\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;南汇/野生动物园\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.030053, \u0026#34;lon\u0026#34;: 121.662943 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2gBATEyysyQWmw3wZL863HGdqjaq_w200_h200_c1_t0.jpg\u0026#34; } } ] } } geo_distance\r查询到指定中心点小于某个距离值的所有文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 GET /indexName/_search { \u0026#34;query\u0026#34;:{ \u0026#34;geo_distance\u0026#34;:{ \u0026#34;distance\u0026#34;:\u0026#34;15km\u0026#34;, \u0026#34;FIELD\u0026#34;:\u0026#34;31.21,121.5\u0026#34; } } } # 例如 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;geo_distance\u0026#34;:{ \u0026#34;distance\u0026#34;:\u0026#34;15km\u0026#34;, \u0026#34;location\u0026#34;:\u0026#34;31.21,121.5\u0026#34; } } } 查询结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 { \u0026#34;took\u0026#34;: 31, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 47, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;36934\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 36934, \u0026#34;name\u0026#34;: \u0026#34;7天连锁酒店(上海宝山路地铁站店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;静安交通路40号\u0026#34;, \u0026#34;price\u0026#34;: 336, \u0026#34;score\u0026#34;: 37, \u0026#34;brand\u0026#34;: \u0026#34;7天酒店\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;四川北路商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.251433, \u0026#34;lon\u0026#34;: 121.47522 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G1/M00/3E/40/Cii9EVkyLrKIXo1vAAHgrxo_pUcAALcKQLD688AAeDH564_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;38609\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 38609, \u0026#34;name\u0026#34;: \u0026#34;速8酒店(上海赤峰路店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;广灵二路126号\u0026#34;, \u0026#34;price\u0026#34;: 249, \u0026#34;score\u0026#34;: 35, \u0026#34;brand\u0026#34;: \u0026#34;速8\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;四川北路商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.282444, \u0026#34;lon\u0026#34;: 121.479385 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G2/M00/DF/96/Cii-TFkx0ImIQZeiAAITil0LM7cAALCYwKXHQ4AAhOi377_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;38665\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 38665, \u0026#34;name\u0026#34;: \u0026#34;速8酒店上海中山北路兰田路店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;兰田路38号\u0026#34;, \u0026#34;price\u0026#34;: 226, \u0026#34;score\u0026#34;: 35, \u0026#34;brand\u0026#34;: \u0026#34;速8\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;长风公园地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.244288, \u0026#34;lon\u0026#34;: 121.422419 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G2/M00/EF/86/Cii-Tlk2mV2IMZ-_AAEucgG3dx4AALaawEjiycAAS6K083_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;38812\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 38812, \u0026#34;name\u0026#34;: \u0026#34;7天连锁酒店(上海漕溪路地铁站店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;徐汇龙华西路315弄58号\u0026#34;, \u0026#34;price\u0026#34;: 298, \u0026#34;score\u0026#34;: 37, \u0026#34;brand\u0026#34;: \u0026#34;7天酒店\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;八万人体育场地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.174377, \u0026#34;lon\u0026#34;: 121.442875 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G2/M00/E0/0E/Cii-TlkyIr2IEWNoAAHQYv7i5CkAALD-QP2iJwAAdB6245_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;39141\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 39141, \u0026#34;name\u0026#34;: \u0026#34;7天连锁酒店(上海五角场复旦同济大学店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;杨浦国权路315号\u0026#34;, \u0026#34;price\u0026#34;: 349, \u0026#34;score\u0026#34;: 38, \u0026#34;brand\u0026#34;: \u0026#34;7天酒店\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;江湾、五角场商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.290057, \u0026#34;lon\u0026#34;: 121.508804 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G2/M00/C7/E3/Cii-T1knFXCIJzNYAAFB8-uFNAEAAKYkQPcw1IAAUIL012_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;45845\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 45845, \u0026#34;name\u0026#34;: \u0026#34;上海西藏大厦万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;虹桥路100号\u0026#34;, \u0026#34;price\u0026#34;: 589, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;徐家汇地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.192714, \u0026#34;lon\u0026#34;: 121.434717 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/48GNb9GZpJDCejVAcQHYWwYyU8T_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;46829\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 46829, \u0026#34;name\u0026#34;: \u0026#34;上海浦西万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;恒丰路338号\u0026#34;, \u0026#34;price\u0026#34;: 726, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;上海火车站地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.242977, \u0026#34;lon\u0026#34;: 121.455864 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56201\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56201, \u0026#34;name\u0026#34;: \u0026#34;上海齐鲁万怡大酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;东方路838号\u0026#34;, \u0026#34;price\u0026#34;: 873, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东陆家嘴金融贸易区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.226031, \u0026#34;lon\u0026#34;: 121.525801 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKeIJeN7AASiKHbTtx4AAGRegDSBzMABKJA111_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56214\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56214, \u0026#34;name\u0026#34;: \u0026#34;上海浦东华美达大酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;新金桥路18号\u0026#34;, \u0026#34;price\u0026#34;: 830, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东金桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.244916, \u0026#34;lon\u0026#34;: 121.590752 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/3jtXiuMKZEXJAuKuAkc47yLCjUBt_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56392\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56392, \u0026#34;name\u0026#34;: \u0026#34;上海银星皇冠假日酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;番禺路400号\u0026#34;, \u0026#34;price\u0026#34;: 809, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;皇冠假日\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;徐家汇地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.202768, \u0026#34;lon\u0026#34;: 121.429524 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/37ucQ38K3UFdcRqntJ8M5dt884HR_w200_h200_c1_t0.jpg\u0026#34; } } ] } } 复合查询\r复合查询:复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑，例如: fuction score:算分函数查询，可以控制文档相关性算分,控制文档排名。\nfunction_score\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 GET /indexName/_search { \u0026#34;query\u0026#34;:{ \u0026#34;function_score\u0026#34;:{ \u0026#34;query\u0026#34;:{ \u0026#34;match\u0026#34;:{ \u0026#34;all\u0026#34;:\u0026#34;上海\u0026#34; } }, \u0026#34;functions\u0026#34;:[ { \u0026#34;filter\u0026#34;:{ \u0026#34;term\u0026#34;:{ \u0026#34;city\u0026#34;:\u0026#34;\u0026#34; } }, \u0026#34;weight\u0026#34;:10 } ], \u0026#34;boost_mode\u0026#34;:\u0026#34;sum\u0026#34; } } } # 例如 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;function_score\u0026#34;: { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;all\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;functions\u0026#34;: [ { \u0026#34;filter\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;weight\u0026#34;: 10 } ], \u0026#34;boost_mode\u0026#34;: \u0026#34;sum\u0026#34; } } } 查询结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 { \u0026#34;took\u0026#34;: 5, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 82, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 11.148642, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;339777429\u0026#34;, \u0026#34;_score\u0026#34;: 11.148642, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 339777429, \u0026#34;name\u0026#34;: \u0026#34;上海嘉定喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;菊园新区嘉唐公路66号\u0026#34;, \u0026#34;price\u0026#34;: 1286, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.394595, \u0026#34;lon\u0026#34;: 121.245773 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2v2fKuo5bzhunSBC1n1E42cLTkZV_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2022598930\u0026#34;, \u0026#34;_score\u0026#34;: 11.095608, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2022598930, \u0026#34;name\u0026#34;: \u0026#34;上海宝华喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;南奉公路3111弄228号\u0026#34;, \u0026#34;price\u0026#34;: 2899, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;奉贤开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.921659, \u0026#34;lon\u0026#34;: 121.575572 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/45/BD/Cii-TF3ZaBmIStrbAASnoOyg7FoAAFpYwEoz9oABKe4992_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;46829\u0026#34;, \u0026#34;_score\u0026#34;: 11.0472555, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 46829, \u0026#34;name\u0026#34;: \u0026#34;上海浦西万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;恒丰路338号\u0026#34;, \u0026#34;price\u0026#34;: 726, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;上海火车站地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.242977, \u0026#34;lon\u0026#34;: 121.455864 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;644417\u0026#34;, \u0026#34;_score\u0026#34;: 11.0472555, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 644417, \u0026#34;name\u0026#34;: \u0026#34;上海外高桥喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;自由贸易试验区基隆路28号（二号门内）\u0026#34;, \u0026#34;price\u0026#34;: 2419, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东外高桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.350989, \u0026#34;lon\u0026#34;: 121.588751 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/1Rrtg9n7PdMEivVDhsehbJBrEre_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1463484295\u0026#34;, \u0026#34;_score\u0026#34;: 11.0472555, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1463484295, \u0026#34;name\u0026#34;: \u0026#34;上海和平豪生酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;沪南公路2653-2号\u0026#34;, \u0026#34;price\u0026#34;: 650, \u0026#34;score\u0026#34;: 41, \u0026#34;brand\u0026#34;: \u0026#34;豪生\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;周浦康桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.146478, \u0026#34;lon\u0026#34;: 121.568218 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/ZxM9gWHqj657ndRsHw4j4p3CQ5k_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1880614409\u0026#34;, \u0026#34;_score\u0026#34;: 11.0472555, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1880614409, \u0026#34;name\u0026#34;: \u0026#34;上海崇明由由喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;揽海路2888号\u0026#34;, \u0026#34;price\u0026#34;: 2198, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;崇明岛/长兴岛/横沙岛\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.462167, \u0026#34;lon\u0026#34;: 121.823103 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/21gDCGgRT3xFqCd3FxBh633j6Qsu_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1942992995\u0026#34;, \u0026#34;_score\u0026#34;: 11.0472555, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1942992995, \u0026#34;name\u0026#34;: \u0026#34;上海嘉定凯悦酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;裕民南路1366号\u0026#34;, \u0026#34;price\u0026#34;: 758, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;凯悦\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.352298, \u0026#34;lon\u0026#34;: 121.263314 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2D/Cii-U13edkqIfZhLAAJEW25WIF4AAGVxQIg38sAAkRz517_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1996823660\u0026#34;, \u0026#34;_score\u0026#34;: 11.0472555, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1996823660, \u0026#34;name\u0026#34;: \u0026#34;上海紫竹万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;紫星路588号3幢\u0026#34;, \u0026#34;price\u0026#34;: 642, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;交大/闵行经济开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.02118, \u0026#34;lon\u0026#34;: 121.465186 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2F/Cii-TF3edraIPzK9AAH_p8vdHKoAAGV3AJgSVEAAf-_019_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56201\u0026#34;, \u0026#34;_score\u0026#34;: 11.002991, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56201, \u0026#34;name\u0026#34;: \u0026#34;上海齐鲁万怡大酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;东方路838号\u0026#34;, \u0026#34;price\u0026#34;: 873, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东陆家嘴金融贸易区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.226031, \u0026#34;lon\u0026#34;: 121.525801 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKeIJeN7AASiKHbTtx4AAGRegDSBzMABKJA111_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56227\u0026#34;, \u0026#34;_score\u0026#34;: 11.002991, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56227, \u0026#34;name\u0026#34;: \u0026#34;上海圣淘沙万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;南桥镇南桥路1号\u0026#34;, \u0026#34;price\u0026#34;: 899, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;奉贤开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.910917, \u0026#34;lon\u0026#34;: 121.456525 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B9/Cii-U13eXSiIdJjXAARSA6FywFYAAGRnwHvy1AABFIb158_w200_h200_c1_t0.jpg\u0026#34; } } ] } } bool\r布尔查询是一个或多个查询子句的组合。子查询的组合方式有:\nmust:必须匹配每个子查询，类似“与” should:选择性匹配子查询，类似“或” must_not:必须不匹配，不参与算分，类似“非” filter:必须匹配，不参与算分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;bool\u0026#34;:{ \u0026#34;must\u0026#34;:{ \u0026#34;term\u0026#34;:{ \u0026#34;city\u0026#34;:\u0026#34;上海\u0026#34; } }, \u0026#34;should\u0026#34;:{ \u0026#34;match\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;上海\u0026#34; } }, \u0026#34;must_not\u0026#34;:{ \u0026#34;range\u0026#34;:{ \u0026#34;price\u0026#34;:{ \u0026#34;gt\u0026#34;:500 } } }, \u0026#34;filter\u0026#34;:{ \u0026#34;range\u0026#34;:{ \u0026#34;price\u0026#34;:{ \u0026#34;gte\u0026#34;:100 } } } } } } 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 { \u0026#34;took\u0026#34;: 8, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 30, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1.9134885, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;60916\u0026#34;, \u0026#34;_score\u0026#34;: 1.9134885, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 60916, \u0026#34;name\u0026#34;: \u0026#34;上海绿地万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;沪宜公路3101号\u0026#34;, \u0026#34;price\u0026#34;: 328, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.368523, \u0026#34;lon\u0026#34;: 121.258567 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/3VLwG9tTQQnp3M3MTeMTdx9nas9B_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;38609\u0026#34;, \u0026#34;_score\u0026#34;: 1.861291, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 38609, \u0026#34;name\u0026#34;: \u0026#34;速8酒店(上海赤峰路店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;广灵二路126号\u0026#34;, \u0026#34;price\u0026#34;: 249, \u0026#34;score\u0026#34;: 35, \u0026#34;brand\u0026#34;: \u0026#34;速8\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;四川北路商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.282444, \u0026#34;lon\u0026#34;: 121.479385 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G2/M00/DF/96/Cii-TFkx0ImIQZeiAAITil0LM7cAALCYwKXHQ4AAhOi377_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1649956165\u0026#34;, \u0026#34;_score\u0026#34;: 1.861291, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1649956165, \u0026#34;name\u0026#34;: \u0026#34;上海南青华美达酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;华夏东路811号\u0026#34;, \u0026#34;price\u0026#34;: 299, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;迪士尼度假区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.195206, \u0026#34;lon\u0026#34;: 121.664791 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2RHmQgTpte3UVSDJ5KbqobbZGRnE_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;233036941\u0026#34;, \u0026#34;_score\u0026#34;: 1.8141286, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 233036941, \u0026#34;name\u0026#34;: \u0026#34;7天连锁酒店(上海东林寺店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;朱泾镇文商路79号\u0026#34;, \u0026#34;price\u0026#34;: 218, \u0026#34;score\u0026#34;: 37, \u0026#34;brand\u0026#34;: \u0026#34;7天酒店\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;金山枫泾古镇地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.895912, \u0026#34;lon\u0026#34;: 121.160238 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G4/M00/35/13/Cii_J1zr5PyIY3acAAFCnHJPxLUAAGX-ABvcIMAAUK0087_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;47066\u0026#34;, \u0026#34;_score\u0026#34;: 1.7713062, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 47066, \u0026#34;name\u0026#34;: \u0026#34;上海浦东东站华美达酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;施新路958号\u0026#34;, \u0026#34;price\u0026#34;: 408, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东机场核心区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.147989, \u0026#34;lon\u0026#34;: 121.759199 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2pNujAVaQbXACzkHp8bQMm6zqwhp_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;60522\u0026#34;, \u0026#34;_score\u0026#34;: 1.7713062, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 60522, \u0026#34;name\u0026#34;: \u0026#34;上海嘉豪淮海国际豪生酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;汾阳路1号\u0026#34;, \u0026#34;price\u0026#34;: 425, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;豪生\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;淮海路/新天地地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.215497, \u0026#34;lon\u0026#34;: 121.456297 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/38UBi4QYuaF8jN94CxQ7tb7tjtmZ_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;629729\u0026#34;, \u0026#34;_score\u0026#34;: 1.7713062, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 629729, \u0026#34;name\u0026#34;: \u0026#34;7天连锁酒店(上海张江高科园区店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;浦东新区蔡伦路103号\u0026#34;, \u0026#34;price\u0026#34;: 267, \u0026#34;score\u0026#34;: 36, \u0026#34;brand\u0026#34;: \u0026#34;7天酒店\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东张江地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.196154, \u0026#34;lon\u0026#34;: 121.62071 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m2.tuniucdn.com/filebroker/cdn/res/d9/61/d961508a10865b9b29c033064f31b913_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;47478\u0026#34;, \u0026#34;_score\u0026#34;: 1.732251, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 47478, \u0026#34;name\u0026#34;: \u0026#34;速8酒店(上海松江中心店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;松江荣乐东路677号\u0026#34;, \u0026#34;price\u0026#34;: 428, \u0026#34;score\u0026#34;: 35, \u0026#34;brand\u0026#34;: \u0026#34;速8\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;佘山、松江大学城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.016712, \u0026#34;lon\u0026#34;: 121.261606 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/filebroker/cdn/res/07/36/073662e1718fccefb7130a9da44ddf5c_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;5873072\u0026#34;, \u0026#34;_score\u0026#34;: 1.732251, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 5873072, \u0026#34;name\u0026#34;: \u0026#34;速8酒店（上海火车站北广场店）\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;闸北芷江西路796号\u0026#34;, \u0026#34;price\u0026#34;: 190, \u0026#34;score\u0026#34;: 41, \u0026#34;brand\u0026#34;: \u0026#34;速8\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;上海火车站地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.255579, \u0026#34;lon\u0026#34;: 121.452903 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m2.tuniucdn.com/filebroker/cdn/res/96/6d/966d6596e6cb7b48c9cc1d7da79b57c8_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;368343863\u0026#34;, \u0026#34;_score\u0026#34;: 1.732251, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 368343863, \u0026#34;name\u0026#34;: \u0026#34;如家酒店(上海金桥博兴路地铁站店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;博兴路1119号\u0026#34;, \u0026#34;price\u0026#34;: 218, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东金桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.266272, \u0026#34;lon\u0026#34;: 121.593829 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/w5ERtGJEmdgdgy5qtLPatR1xfm4_w200_h200_c1_t0.jpg\u0026#34; } } ] } } 练习\r搜索名字包含“如家”，价格不高于400,在坐标31.21,121.5周围10km范围内的酒店。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;:{ \u0026#34;match\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;如家\u0026#34; } }, \u0026#34;must_not\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;gt\u0026#34;: 400 } } }, \u0026#34;filter\u0026#34;: { \u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;10km\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;31.21,121.5\u0026#34; } } } } } 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 { \u0026#34;took\u0026#34;: 3, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 3, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1.716568, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;433576\u0026#34;, \u0026#34;_score\u0026#34;: 1.716568, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 433576, \u0026#34;name\u0026#34;: \u0026#34;如家酒店(上海南京路步行街店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;南京东路480号保安坊内\u0026#34;, \u0026#34;price\u0026#34;: 379, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;人民广场地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.236454, \u0026#34;lon\u0026#34;: 121.480948 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/BA/Cii-U13eXVaIQmdaAAWxgzdXXxEAAGRrgNIOkoABbGb143_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;434082\u0026#34;, \u0026#34;_score\u0026#34;: 1.4689932, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 434082, \u0026#34;name\u0026#34;: \u0026#34;如家酒店·neo(上海外滩城隍庙小南门地铁站店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;复兴东路260号\u0026#34;, \u0026#34;price\u0026#34;: 392, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;豫园地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.220706, \u0026#34;lon\u0026#34;: 121.498769 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-U13eXLGIdHFzAAIG-5cEwDEAAGRfQNNIV0AAgcT627_w200_h200_c1_t0.jpg\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1584362548\u0026#34;, \u0026#34;_score\u0026#34;: 1.4178693, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1584362548, \u0026#34;name\u0026#34;: \u0026#34;如家酒店(上海浦东国际旅游度假区御桥地铁站店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;御青路315-317号\u0026#34;, \u0026#34;price\u0026#34;: 339, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;周浦康桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.15719, \u0026#34;lon\u0026#34;: 121.572392 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2ybd3wqdoBtBeKcPxmyso9y1hNXa_w200_h200_c1_t0.jpg\u0026#34; } } ] } } 搜索结果处理\r排序\r默认根据相关度算分排序，可以排序字段类型有: keyword类型、数值类型、地理坐标类型(比如 距离最近的酒店)、日期类型等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 GET /indexName/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match_all\u0026#34;:{} }, \u0026#34;sort\u0026#34;:{ \u0026#34;FIELD\u0026#34;:\u0026#34;desc\u0026#34; } } # 例如 # 查询名字里有上海的酒店，按照评分降序、价格升序排列 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;score\u0026#34;: \u0026#34;desc\u0026#34; }, { \u0026#34;price\u0026#34;: \u0026#34;asc\u0026#34; } ] } 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 { \u0026#34;took\u0026#34;: 1, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 82, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: null, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2056126831\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2056126831, \u0026#34;name\u0026#34;: \u0026#34;上海虹桥金臣皇冠假日酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;申长路630弄1-3 号\u0026#34;, \u0026#34;price\u0026#34;: 2488, \u0026#34;score\u0026#34;: 48, \u0026#34;brand\u0026#34;: \u0026#34;皇冠假日\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;虹桥机场/国家会展中心\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.19036, \u0026#34;lon\u0026#34;: 121.31535 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/PvFh4Vzc84xXhm5N41F6AqdAqyJ_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 48, 2488 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1649956165\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1649956165, \u0026#34;name\u0026#34;: \u0026#34;上海南青华美达酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;华夏东路811号\u0026#34;, \u0026#34;price\u0026#34;: 299, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;迪士尼度假区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.195206, \u0026#34;lon\u0026#34;: 121.664791 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2RHmQgTpte3UVSDJ5KbqobbZGRnE_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 47, 299 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;598591\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 598591, \u0026#34;name\u0026#34;: \u0026#34;上海丽昂豪生大酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;金新路99号\u0026#34;, \u0026#34;price\u0026#34;: 529, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;豪生\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东金桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.252496, \u0026#34;lon\u0026#34;: 121.600085 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2KfPPyPx9rWyVXif2CUuxv61Nryc_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 47, 529 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56392\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56392, \u0026#34;name\u0026#34;: \u0026#34;上海银星皇冠假日酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;番禺路400号\u0026#34;, \u0026#34;price\u0026#34;: 809, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;皇冠假日\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;徐家汇地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.202768, \u0026#34;lon\u0026#34;: 121.429524 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/37ucQ38K3UFdcRqntJ8M5dt884HR_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 47, 809 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1913922369\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1913922369, \u0026#34;name\u0026#34;: \u0026#34;上海中建万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;蟠文路333号\u0026#34;, \u0026#34;price\u0026#34;: 889, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;虹桥机场/国家会展中心\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.185504, \u0026#34;lon\u0026#34;: 121.287709 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/39Afm5Bxgd784eMeFB5DrcsPnhT_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 47, 889 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;648219\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 648219, \u0026#34;name\u0026#34;: \u0026#34;上海金桥红枫万豪酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;新金桥路15号\u0026#34;, \u0026#34;price\u0026#34;: 891, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;万豪\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东金桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.244061, \u0026#34;lon\u0026#34;: 121.591153 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKuIR_a0AAUx-Xd2JLQAAGRfACSpvUABTIR560_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 47, 891 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;5870456\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 5870456, \u0026#34;name\u0026#34;: \u0026#34;上海宝华万豪酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;广中西路333号\u0026#34;, \u0026#34;price\u0026#34;: 922, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;万豪\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;大宁国际商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.279371, \u0026#34;lon\u0026#34;: 121.446327 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/BA/Cii-U13eXVqIZXDFAAUC_xbrQDAAAGRrwPRyOcABQMX057_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 47, 922 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;60398\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 60398, \u0026#34;name\u0026#34;: \u0026#34;上海复旦皇冠假日酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;邯郸路199号\u0026#34;, \u0026#34;price\u0026#34;: 924, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;皇冠假日\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;江湾/五角场商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.295382, \u0026#34;lon\u0026#34;: 121.502537 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2H1Gk8LHaBWZfYvR6NYYcGTvACmL_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 47, 924 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;47066\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 47066, \u0026#34;name\u0026#34;: \u0026#34;上海浦东东站华美达酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;施新路958号\u0026#34;, \u0026#34;price\u0026#34;: 408, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东机场核心区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.147989, \u0026#34;lon\u0026#34;: 121.759199 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2pNujAVaQbXACzkHp8bQMm6zqwhp_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 46, 408 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56852\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56852, \u0026#34;name\u0026#34;: \u0026#34;上海财大豪生大酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;武东路188号\u0026#34;, \u0026#34;price\u0026#34;: 592, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;豪生\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;江湾/五角场商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.304182, \u0026#34;lon\u0026#34;: 121.492936 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2jGHezLZvPZqC9cBGesbP5vAhCXi_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 46, 592 ] } ] } } 练习\r实现对酒店数据按照到你的位置坐标的距离升序排序\n有一些可以在线获取经纬度的网站，如网站1\n当前位置为 120.643542,31.258042\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;sort\u0026#34;: [ { \u0026#34;_geo_distance\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: \u0026#34;31.258042\u0026#34;, \u0026#34;lon\u0026#34;: \u0026#34;120.643542\u0026#34; }, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; } } ] } 查询结果，可查看sort字段距离\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 { \u0026#34;took\u0026#34;: 2, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 201, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: null, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;200215226\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 200215226, \u0026#34;name\u0026#34;: \u0026#34;上海颖奕皇冠假日酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;博园路6555号\u0026#34;, \u0026#34;price\u0026#34;: 907, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;皇冠假日\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.272533, \u0026#34;lon\u0026#34;: 121.19179 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/3Uyfi2aBRETE1K5PChiLVZCwtDLF_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 52.13395383160579 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;339777429\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 339777429, \u0026#34;name\u0026#34;: \u0026#34;上海嘉定喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;菊园新区嘉唐公路66号\u0026#34;, \u0026#34;price\u0026#34;: 1286, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.394595, \u0026#34;lon\u0026#34;: 121.245773 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2v2fKuo5bzhunSBC1n1E42cLTkZV_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 59.18378970615253 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2003479905\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2003479905, \u0026#34;name\u0026#34;: \u0026#34;上海榕港万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;新松江路1277号\u0026#34;, \u0026#34;price\u0026#34;: 798, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;佘山/松江大学城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.038198, \u0026#34;lon\u0026#34;: 121.210178 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2GM761BYH8k15qkNrJrja3cwfr2D_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 59.205785086643566 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;60916\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 60916, \u0026#34;name\u0026#34;: \u0026#34;上海绿地万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;沪宜公路3101号\u0026#34;, \u0026#34;price\u0026#34;: 328, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.368523, \u0026#34;lon\u0026#34;: 121.258567 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/3VLwG9tTQQnp3M3MTeMTdx9nas9B_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 59.703757750943225 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1942992995\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1942992995, \u0026#34;name\u0026#34;: \u0026#34;上海嘉定凯悦酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;裕民南路1366号\u0026#34;, \u0026#34;price\u0026#34;: 758, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;凯悦\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.352298, \u0026#34;lon\u0026#34;: 121.263314 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2D/Cii-U13edkqIfZhLAAJEW25WIF4AAGVxQIg38sAAkRz517_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 59.807711496975394 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1725781423\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1725781423, \u0026#34;name\u0026#34;: \u0026#34;上海三迪华美达酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;广富林路600弄7号\u0026#34;, \u0026#34;price\u0026#34;: 690, \u0026#34;score\u0026#34;: 43, \u0026#34;brand\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;佘山/松江大学城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.058023, \u0026#34;lon\u0026#34;: 121.246536 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/NoHym6tuKwVazxy33wRNTNuQWd2_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 61.53729226590151 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1913922369\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1913922369, \u0026#34;name\u0026#34;: \u0026#34;上海中建万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;蟠文路333号\u0026#34;, \u0026#34;price\u0026#34;: 889, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;虹桥机场/国家会展中心\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.185504, \u0026#34;lon\u0026#34;: 121.287709 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/39Afm5Bxgd784eMeFB5DrcsPnhT_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 61.78277329609102 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;233036941\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 233036941, \u0026#34;name\u0026#34;: \u0026#34;7天连锁酒店(上海东林寺店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;朱泾镇文商路79号\u0026#34;, \u0026#34;price\u0026#34;: 218, \u0026#34;score\u0026#34;: 37, \u0026#34;brand\u0026#34;: \u0026#34;7天酒店\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;金山枫泾古镇地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.895912, \u0026#34;lon\u0026#34;: 121.160238 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G4/M00/35/13/Cii_J1zr5PyIY3acAAFCnHJPxLUAAGX-ABvcIMAAUK0087_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 63.58330395384682 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2056126831\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2056126831, \u0026#34;name\u0026#34;: \u0026#34;上海虹桥金臣皇冠假日酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;申长路630弄1-3 号\u0026#34;, \u0026#34;price\u0026#34;: 2488, \u0026#34;score\u0026#34;: 48, \u0026#34;brand\u0026#34;: \u0026#34;皇冠假日\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;虹桥机场/国家会展中心\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.19036, \u0026#34;lon\u0026#34;: 121.31535 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/PvFh4Vzc84xXhm5N41F6AqdAqyJ_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 64.32253706416857 ] }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;47478\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 47478, \u0026#34;name\u0026#34;: \u0026#34;速8酒店(上海松江中心店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;松江荣乐东路677号\u0026#34;, \u0026#34;price\u0026#34;: 428, \u0026#34;score\u0026#34;: 35, \u0026#34;brand\u0026#34;: \u0026#34;速8\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;佘山、松江大学城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.016712, \u0026#34;lon\u0026#34;: 121.261606 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/filebroker/cdn/res/07/36/073662e1718fccefb7130a9da44ddf5c_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;sort\u0026#34;: [ 64.65591776725215 ] } ] } } 分页\relasticsearch默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。 elasticsearch中通过修改from、size参数来控制要返回的分页结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 GET /indexName/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match_all\u0026#34;:{} }, // 分页开始的位置，默认为0 \u0026#34;from\u0026#34;:990, // 期望获取的文档总数 \u0026#34;size\u0026#34;:10, \u0026#34;sort\u0026#34;:{ \u0026#34;FIELD\u0026#34;:\u0026#34;desc\u0026#34; } } 需要注意的是：如果配置es集群，此时需要查询前100条数据的情况，应该要去查找每个es分片的前100条，然后聚合这些结果，重新排序选取前100条 目前解决方案有两种\nsearch after: 分页时需要排序,原理是从上一次的排序值开始,查询下一页数据。官方推荐使用的方式。适用于手机翻页 scroll: 原理将排序数据形成快照，保存在内存。官方已经不推荐使用。 from + size:\n优点:支持随机翻页 缺点:深度分页问题，默认查询上限(from + size)是10000 场景:百度、京东、谷歌、淘宝这样的随机翻页搜索 after search: 优点:没有查询上限(单次查询的size不超过10000) 缺点:只能向后逐页查询，不支持随机翻页 场景:没有随机翻页需求的搜索，例如手机向下滚动翻页. scroll: 优点:没有查询上限(单次查询的size不超过10000) 缺点:会有额外内存消耗，并且搜索结果是非实时的 场景:海量数据的获取和迁移。从ES7.1开始不推荐,建议用aftersearch方案。 高亮\r将用户搜索的关键字突出显示\n原理是将搜索的关键字用标签标记，通过前端的css标记标签来显示高亮\n注意高亮显示的搜索不能使用match_all，因为需要对关键字高亮显示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 GET /indexName/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match\u0026#34;:{ \u0026#34;FIELD\u0026#34;:\u0026#34;TEXT\u0026#34; } }, \u0026#34;highlight\u0026#34;:{ \u0026#34;fields\u0026#34;:{ // 指定高亮的字段 \u0026#34;FIELD\u0026#34;:{ // 高亮字段的前置标签 \u0026#34;pre_tags\u0026#34;:\u0026#34;\u0026lt;em\u0026gt;\u0026#34;, // 高亮字段的后置标签 \u0026#34;post_tags\u0026#34;:\u0026#34;\u0026lt;/ems\u0026gt;\u0026#34; } } } } # 例如 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match\u0026#34;:{ \u0026#34;all\u0026#34;:\u0026#34;上海\u0026#34; } }, \u0026#34;highlight\u0026#34;:{ \u0026#34;fields\u0026#34;:{ \u0026#34;name\u0026#34;:{ // 默认情况下搜索的字段和高亮的字段需要一样 \u0026#34;require_field_match\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;pre_tags\u0026#34;:\u0026#34;\u0026lt;em\u0026gt;\u0026#34;, \u0026#34;post_tags\u0026#34;:\u0026#34;\u0026lt;/em\u0026gt;\u0026#34; } } } } 执行结果请查看highlight\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 { \u0026#34;took\u0026#34;: 3, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 82, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1.1486411, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;339777429\u0026#34;, \u0026#34;_score\u0026#34;: 1.1486411, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 339777429, \u0026#34;name\u0026#34;: \u0026#34;上海嘉定喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;菊园新区嘉唐公路66号\u0026#34;, \u0026#34;price\u0026#34;: 1286, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.394595, \u0026#34;lon\u0026#34;: 121.245773 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2v2fKuo5bzhunSBC1n1E42cLTkZV_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;highlight\u0026#34;: { \u0026#34;name\u0026#34;: [ \u0026#34;\u0026lt;em\u0026gt;上海\u0026lt;/em\u0026gt;嘉定喜来登酒店\u0026#34; ] } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2022598930\u0026#34;, \u0026#34;_score\u0026#34;: 1.095608, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2022598930, \u0026#34;name\u0026#34;: \u0026#34;上海宝华喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;南奉公路3111弄228号\u0026#34;, \u0026#34;price\u0026#34;: 2899, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;奉贤开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.921659, \u0026#34;lon\u0026#34;: 121.575572 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/45/BD/Cii-TF3ZaBmIStrbAASnoOyg7FoAAFpYwEoz9oABKe4992_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;highlight\u0026#34;: { \u0026#34;name\u0026#34;: [ \u0026#34;\u0026lt;em\u0026gt;上海\u0026lt;/em\u0026gt;宝华喜来登酒店\u0026#34; ] } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;46829\u0026#34;, \u0026#34;_score\u0026#34;: 1.0472558, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 46829, \u0026#34;name\u0026#34;: \u0026#34;上海浦西万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;恒丰路338号\u0026#34;, \u0026#34;price\u0026#34;: 726, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;上海火车站地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.242977, \u0026#34;lon\u0026#34;: 121.455864 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;highlight\u0026#34;: { \u0026#34;name\u0026#34;: [ \u0026#34;\u0026lt;em\u0026gt;上海\u0026lt;/em\u0026gt;浦西万怡酒店\u0026#34; ] } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;644417\u0026#34;, \u0026#34;_score\u0026#34;: 1.0472558, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 644417, \u0026#34;name\u0026#34;: \u0026#34;上海外高桥喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;自由贸易试验区基隆路28号（二号门内）\u0026#34;, \u0026#34;price\u0026#34;: 2419, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东外高桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.350989, \u0026#34;lon\u0026#34;: 121.588751 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/1Rrtg9n7PdMEivVDhsehbJBrEre_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;highlight\u0026#34;: { \u0026#34;name\u0026#34;: [ \u0026#34;\u0026lt;em\u0026gt;上海\u0026lt;/em\u0026gt;外高桥喜来登酒店\u0026#34; ] } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1463484295\u0026#34;, \u0026#34;_score\u0026#34;: 1.0472558, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1463484295, \u0026#34;name\u0026#34;: \u0026#34;上海和平豪生酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;沪南公路2653-2号\u0026#34;, \u0026#34;price\u0026#34;: 650, \u0026#34;score\u0026#34;: 41, \u0026#34;brand\u0026#34;: \u0026#34;豪生\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;周浦康桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.146478, \u0026#34;lon\u0026#34;: 121.568218 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/ZxM9gWHqj657ndRsHw4j4p3CQ5k_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;highlight\u0026#34;: { \u0026#34;name\u0026#34;: [ \u0026#34;\u0026lt;em\u0026gt;上海\u0026lt;/em\u0026gt;和平豪生酒店\u0026#34; ] } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1880614409\u0026#34;, \u0026#34;_score\u0026#34;: 1.0472558, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1880614409, \u0026#34;name\u0026#34;: \u0026#34;上海崇明由由喜来登酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;揽海路2888号\u0026#34;, \u0026#34;price\u0026#34;: 2198, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;崇明岛/长兴岛/横沙岛\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.462167, \u0026#34;lon\u0026#34;: 121.823103 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/21gDCGgRT3xFqCd3FxBh633j6Qsu_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;highlight\u0026#34;: { \u0026#34;name\u0026#34;: [ \u0026#34;\u0026lt;em\u0026gt;上海\u0026lt;/em\u0026gt;崇明由由喜来登酒店\u0026#34; ] } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1942992995\u0026#34;, \u0026#34;_score\u0026#34;: 1.0472558, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1942992995, \u0026#34;name\u0026#34;: \u0026#34;上海嘉定凯悦酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;裕民南路1366号\u0026#34;, \u0026#34;price\u0026#34;: 758, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;凯悦\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;嘉定新城\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.352298, \u0026#34;lon\u0026#34;: 121.263314 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2D/Cii-U13edkqIfZhLAAJEW25WIF4AAGVxQIg38sAAkRz517_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;highlight\u0026#34;: { \u0026#34;name\u0026#34;: [ \u0026#34;\u0026lt;em\u0026gt;上海\u0026lt;/em\u0026gt;嘉定凯悦酒店\u0026#34; ] } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1996823660\u0026#34;, \u0026#34;_score\u0026#34;: 1.0472558, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 1996823660, \u0026#34;name\u0026#34;: \u0026#34;上海紫竹万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;紫星路588号3幢\u0026#34;, \u0026#34;price\u0026#34;: 642, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;交大/闵行经济开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.02118, \u0026#34;lon\u0026#34;: 121.465186 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2F/Cii-TF3edraIPzK9AAH_p8vdHKoAAGV3AJgSVEAAf-_019_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;highlight\u0026#34;: { \u0026#34;name\u0026#34;: [ \u0026#34;\u0026lt;em\u0026gt;上海\u0026lt;/em\u0026gt;紫竹万怡酒店\u0026#34; ] } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56201\u0026#34;, \u0026#34;_score\u0026#34;: 1.0029912, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56201, \u0026#34;name\u0026#34;: \u0026#34;上海齐鲁万怡大酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;东方路838号\u0026#34;, \u0026#34;price\u0026#34;: 873, \u0026#34;score\u0026#34;: 44, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东陆家嘴金融贸易区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.226031, \u0026#34;lon\u0026#34;: 121.525801 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKeIJeN7AASiKHbTtx4AAGRegDSBzMABKJA111_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;highlight\u0026#34;: { \u0026#34;name\u0026#34;: [ \u0026#34;\u0026lt;em\u0026gt;上海\u0026lt;/em\u0026gt;齐鲁万怡大酒店\u0026#34; ] } }, { \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;56227\u0026#34;, \u0026#34;_score\u0026#34;: 1.0029912, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 56227, \u0026#34;name\u0026#34;: \u0026#34;上海圣淘沙万怡酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;南桥镇南桥路1号\u0026#34;, \u0026#34;price\u0026#34;: 899, \u0026#34;score\u0026#34;: 45, \u0026#34;brand\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;奉贤开发区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.910917, \u0026#34;lon\u0026#34;: 121.456525 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B9/Cii-U13eXSiIdJjXAARSA6FywFYAAGRnwHvy1AABFIb158_w200_h200_c1_t0.jpg\u0026#34; }, \u0026#34;highlight\u0026#34;: { \u0026#34;name\u0026#34;: [ \u0026#34;\u0026lt;em\u0026gt;上海\u0026lt;/em\u0026gt;圣淘沙万怡酒店\u0026#34; ] } } ] } } ElasticsearchClient查询文档\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.SortOrder; import co.elastic.clients.elasticsearch._types.query_dsl.FunctionBoostMode; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.elasticsearch.core.search.Hit; import co.elastic.clients.json.JsonData; import com.example.domain.doc.HotelDoc; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; /** * 查询语法 * * @Auther: 不是菜狗爱编程 * @Date: 2024/03/27/22:00 * @Description: */ @Slf4j @SpringBootTest class MatchTest { private static final String INDEX_NAME = \u0026#34;hotel\u0026#34;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 根据 city 使用term查询获取相应的文档， search api 才是 elasticsearch-client 的优势，可以看出使用 lambda 大大简化了代码量， * 可以与 restHighLevelClient 形成鲜明的对比，但是也有可读性较差的问题，所以 lambda 的基础要扎实 */ @Test void testRestClient() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.term(t -\u0026gt; t.field(\u0026#34;city\u0026#34;).value(v -\u0026gt; v.stringValue(\u0026#34;上海\u0026#34;)) ) ), HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * match_all */ @Test void matchAllTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.matchAll(matchAll -\u0026gt; matchAll)) , HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * match */ @Test void matchTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.match(matchQuery -\u0026gt; matchQuery.field(\u0026#34;all\u0026#34;).query(\u0026#34;上海\u0026#34;))) , HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * multi_match */ @Test void multiMatchTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.multiMatch(multiMatchQuery -\u0026gt; multiMatchQuery.fields(\u0026#34;city\u0026#34;, \u0026#34;name\u0026#34;).query(\u0026#34;上海\u0026#34;))) , HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * term */ @Test void termTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.term(t -\u0026gt; t.field(\u0026#34;city\u0026#34;).value(v -\u0026gt; v.stringValue(\u0026#34;上海\u0026#34;)) ) ), HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * range * 查找价格大于等于100，小于等于500 */ @Test void rangeTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.range(rangeQuery -\u0026gt; rangeQuery.field(\u0026#34;price\u0026#34;).gte(JsonData.of(100)).lte(JsonData.of(500))) ), HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * geo_bounding_box */ @Test void geoBoundingBoxTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.geoBoundingBox(geoBoundingBoxQuery -\u0026gt; geoBoundingBoxQuery.field(\u0026#34;location\u0026#34;) .boundingBox(geoBoundings -\u0026gt; geoBoundings.tlbr(topLeftBottomRightGeoBounds -\u0026gt; topLeftBottomRightGeoBounds // 设置左上角的纬度、经度 .topLeft(geoLocation -\u0026gt; geoLocation.latlon(latLonGeoLocation -\u0026gt; latLonGeoLocation.lat(31.1).lon(121.5))) // 设置右下角的纬度、经度 .bottomRight(geoLocation -\u0026gt; geoLocation.latlon(latLonGeoLocation -\u0026gt; latLonGeoLocation.lat(30.9).lon(121.7))) ) ) ) ), HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * geo_distance */ @Test void geoDistanceTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.geoDistance(geoDistanceQuery -\u0026gt; geoDistanceQuery.distance(\u0026#34;15km\u0026#34;) .field(\u0026#34;location\u0026#34;) .location(geoLocation -\u0026gt; geoLocation .latlon(latLonGeoLocation -\u0026gt; latLonGeoLocation .lat(31.1) .lon(121.5)))) ), HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * function_score */ @Test void functionScoreTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.functionScore(functionScoreQuery -\u0026gt; functionScoreQuery // 匹配all字段中 上海的关键字 .query(query -\u0026gt; query.match(matchQuery -\u0026gt; matchQuery.field(\u0026#34;all\u0026#34;).query(\u0026#34;上海\u0026#34;))) // 给city为上海的数据加分 .functions(functionScore -\u0026gt; functionScore.filter(termQuery -\u0026gt; termQuery.term(t -\u0026gt; t.field(\u0026#34;city\u0026#34;).value(v -\u0026gt; v.stringValue(\u0026#34;上海\u0026#34;)))) // 权重为10，加权方式为求和 .weight(10.0)).boostMode(FunctionBoostMode.Sum) ) ), HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * bool */ @Test void boolTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.bool( boolQuery -\u0026gt; boolQuery // city 必须匹配 上海 .must(query -\u0026gt; query.term(termQuery -\u0026gt; termQuery.field(\u0026#34;city\u0026#34;).value(\u0026#34;上海\u0026#34;))) // name 选择性匹配 上海 .should(shouldMatchQuery -\u0026gt; shouldMatchQuery.match(matchQuery -\u0026gt; matchQuery.field(\u0026#34;name\u0026#34;).query(\u0026#34;上海\u0026#34;))) // price 必须不大于500 .mustNot(mustNotRangeQuery -\u0026gt; mustNotRangeQuery.range(rangeQuery -\u0026gt; rangeQuery.field(\u0026#34;price\u0026#34;).gt(JsonData.of(500)))) // price 必须大于等于100 .filter(filterRangeQuery -\u0026gt; filterRangeQuery.range(rangeQuery -\u0026gt; rangeQuery.field(\u0026#34;price\u0026#34;).gte(JsonData.of(100)))) )), HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * 排序 */ @Test void sortTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.match(query -\u0026gt; query.field(\u0026#34;name\u0026#34;).query(\u0026#34;上海\u0026#34;))) .sort(sortOption -\u0026gt; sortOption.field(fieldSort -\u0026gt; fieldSort // 根据score降序 .field(\u0026#34;score\u0026#34;).order(SortOrder.Desc) // 根据price升序 .field(\u0026#34;price\u0026#34;).order(SortOrder.Asc))), HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * 分页 */ @Test void pageTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.matchAll(matchAll -\u0026gt; matchAll)) .from(10) .size(10) .sort(sortOption -\u0026gt; sortOption.field(fieldSort -\u0026gt; fieldSort // 根据score降序 .field(\u0026#34;score\u0026#34;).order(SortOrder.Desc))), HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } /** * 高亮 */ @Test void hightLightTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.match(matchQuery -\u0026gt; matchQuery.field(\u0026#34;all\u0026#34;).query(\u0026#34;上海\u0026#34;))) .highlight(highLight -\u0026gt; highLight.fields(\u0026#34;name\u0026#34;, // 默认情况下搜索的字段和高亮的字段需要一样 highLightField -\u0026gt; highLightField.requireFieldMatch(false) .preTags(\u0026#34;em\u0026#34;) .postTags(\u0026#34;em\u0026#34;))), HotelDoc.class); for (Hit\u0026lt;HotelDoc\u0026gt; hit : search.hits().hits()) { log.info(\u0026#34;== hit: source: {}, id: {}\u0026#34;, hit.source(), hit.id()); } } } 黑马旅游案例\r前端搭建，下载链接\n酒店搜索和分页\r搜索\r这是前端请求的格式 key关键字 page页码 size每页大小 sortBy排序字段，比如根据评价、价格排序\nPOST请求，路径是/hotel/list\n1 2 3 4 5 6 { \u0026#34;key\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;page\u0026#34;: 1, \u0026#34;size\u0026#34;: 5, \u0026#34;sortBy\u0026#34;: \u0026#34;default\u0026#34; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 搜索参数 * * @author: 不是菜狗爱编程 * @date: 2024/03/30/9:35 * @description: */ @Data @AllArgsConstructor @NoArgsConstructor public class SearchParams { private String key; private Integer page; private Integer size; private String sortBy; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 分页实体 * * @author: 不是菜狗爱编程 * @date: 2024/03/30/9:48 * @description: */ @Data @AllArgsConstructor @NoArgsConstructor public class PageEntity { private Long total; private List\u0026lt;HotelDoc\u0026gt; hotels; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RestController @RequestMapping(\u0026#34;hotel\u0026#34;) public class SearchController { @Autowired private HotelService hotelService; /** * 搜索 * * @param params 参数 * @return {@link PageEntity} */ @PostMapping(\u0026#34;/list\u0026#34;) public PageEntity search(@RequestBody SearchParams params){ return hotelService.search(params); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.SortOrder; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.elasticsearch.core.search.Hit; import co.elastic.clients.elasticsearch.core.search.HitsMetadata; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.example.domain.Hotel; import com.example.domain.PageEntity; import com.example.domain.SearchParams; import com.example.domain.doc.HotelDoc; import com.example.mapper.HotelMapper; import com.example.service.HotelService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.io.IOException; import java.util.ArrayList; import java.util.List; /** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */ @Service public class HotelServiceImpl extends ServiceImpl\u0026lt;HotelMapper, Hotel\u0026gt; implements HotelService { private static final String INDEX_NAME = \u0026#34;hotel\u0026#34;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 搜索 * * @param params 参数 * @return {@link PageEntity} */ @Override public PageEntity search(SearchParams params) { // 关键字 String key = params.getKey(); Integer page = params.getPage(); Integer size = params.getSize(); try { SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; { // 没有查询条件，查询全部 if (key == null || key.isEmpty()) { return q.matchAll(matchAll -\u0026gt; matchAll); } else { // 有查询条件，查询关键字 return q.match(matchQuery -\u0026gt; matchQuery.field(\u0026#34;all\u0026#34;).query(key)); } }) .from((page - 1) * size) .size(size), HotelDoc.class); return handleResponse(search); } catch (IOException e) { throw new RuntimeException(e); } } private PageEntity handleResponse(SearchResponse\u0026lt;HotelDoc\u0026gt; response){ // 解析响应 HitsMetadata\u0026lt;HotelDoc\u0026gt; hits = response.hits(); assert hits.total() != null; // 总条数 long value = hits.total().value(); List\u0026lt;Hit\u0026lt;HotelDoc\u0026gt;\u0026gt; hotels = hits.hits(); List\u0026lt;HotelDoc\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); hotels.forEach(hotelDocHit -\u0026gt; { result.add(hotelDocHit.source()); }); return new PageEntity(value,result); } } 当前接口返回的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 { \u0026#34;total\u0026#34;: 82, \u0026#34;hotels\u0026#34;: [ { \u0026#34;id\u0026#34;: 2056126831, \u0026#34;name\u0026#34;: \u0026#34;上海虹桥金臣皇冠假日酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;申长路630弄1-3 号\u0026#34;, \u0026#34;price\u0026#34;: 2488, \u0026#34;score\u0026#34;: 48, \u0026#34;brand\u0026#34;: \u0026#34;皇冠假日\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;虹桥机场/国家会展中心\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.19036, \u0026#34;lon\u0026#34;: 121.31535 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/PvFh4Vzc84xXhm5N41F6AqdAqyJ_w200_h200_c1_t0.jpg\u0026#34; }, { \u0026#34;id\u0026#34;: 56392, \u0026#34;name\u0026#34;: \u0026#34;上海银星皇冠假日酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;番禺路400号\u0026#34;, \u0026#34;price\u0026#34;: 809, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;皇冠假日\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;徐家汇地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.202768, \u0026#34;lon\u0026#34;: 121.429524 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/37ucQ38K3UFdcRqntJ8M5dt884HR_w200_h200_c1_t0.jpg\u0026#34; }, { \u0026#34;id\u0026#34;: 60398, \u0026#34;name\u0026#34;: \u0026#34;上海复旦皇冠假日酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;邯郸路199号\u0026#34;, \u0026#34;price\u0026#34;: 924, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;皇冠假日\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五星级\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;江湾/五角场商业区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.295382, \u0026#34;lon\u0026#34;: 121.502537 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2H1Gk8LHaBWZfYvR6NYYcGTvACmL_w200_h200_c1_t0.jpg\u0026#34; }, { \u0026#34;id\u0026#34;: 598591, \u0026#34;name\u0026#34;: \u0026#34;上海丽昂豪生大酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;金新路99号\u0026#34;, \u0026#34;price\u0026#34;: 529, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;豪生\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;四钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东金桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.252496, \u0026#34;lon\u0026#34;: 121.600085 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2KfPPyPx9rWyVXif2CUuxv61Nryc_w200_h200_c1_t0.jpg\u0026#34; }, { \u0026#34;id\u0026#34;: 648219, \u0026#34;name\u0026#34;: \u0026#34;上海金桥红枫万豪酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;新金桥路15号\u0026#34;, \u0026#34;price\u0026#34;: 891, \u0026#34;score\u0026#34;: 47, \u0026#34;brand\u0026#34;: \u0026#34;万豪\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;浦东金桥地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.244061, \u0026#34;lon\u0026#34;: 121.591153 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKuIR_a0AAUx-Xd2JLQAAGRfACSpvUABTIR560_w200_h200_c1_t0.jpg\u0026#34; } ] } 酒店结果过滤\r添加参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Data @AllArgsConstructor @NoArgsConstructor public class SearchParams { private String key; private Integer page; private Integer size; private String sortBy; private String city; private String brand ; private String starName ; private Integer minPrice; private Integer maxPrice; } 过滤条件包括\ncity精确匹配 brand精确匹配 starName精确匹配 price范围过滤 此时有多个条件，应该用bool查询\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.SortOrder; import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery; import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.elasticsearch.core.search.Hit; import co.elastic.clients.elasticsearch.core.search.HitsMetadata; import co.elastic.clients.json.JsonData; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.example.domain.Hotel; import com.example.domain.PageEntity; import com.example.domain.SearchParams; import com.example.domain.doc.HotelDoc; import com.example.mapper.HotelMapper; import com.example.service.HotelService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.io.IOException; import java.util.ArrayList; import java.util.List; /** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */ @Service public class HotelServiceImpl extends ServiceImpl\u0026lt;HotelMapper, Hotel\u0026gt; implements HotelService { private static final String INDEX_NAME = \u0026#34;hotel\u0026#34;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 搜索 * * @param params 参数 * @return {@link PageEntity} */ @Override public PageEntity search(SearchParams params) { // 关键字 Integer page = params.getPage(); Integer size = params.getSize(); try { BoolQuery boolQuery = buildBasicQuery(params); SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q-\u0026gt;q.bool(boolQuery)) .from((page - 1) * size) .size(size), HotelDoc.class); return handleResponse(search); } catch (IOException e) { throw new RuntimeException(e); } } private static BoolQuery buildBasicQuery(SearchParams params) { BoolQuery.Builder bool = QueryBuilders.bool(); String key = params.getKey(); String city = params.getCity(); String brand = params.getBrand(); Integer minPrice = params.getMinPrice(); Integer maxPrice = params.getMaxPrice(); // 没有查询条件，查询全部 if (key == null || key.isEmpty()) { bool.must( query-\u0026gt;query.matchAll( matchAll -\u0026gt; matchAll) ); } else { // 有查询条件，查询关键字 bool.must( query-\u0026gt;query.match( matchQuery -\u0026gt; matchQuery.field(\u0026#34;all\u0026#34;).query(key) ) ); } // 城市条件 if(city !=null\u0026amp;\u0026amp; !city.isEmpty()){ bool.filter( filterQuery-\u0026gt;filterQuery.term( termQuery-\u0026gt;termQuery.field(\u0026#34;city\u0026#34;).value(city) ) ); } // 品牌条件 if(brand !=null\u0026amp;\u0026amp; !brand.isEmpty()){ bool.filter( filterQuery-\u0026gt;filterQuery.term( termQuery-\u0026gt;termQuery.field(\u0026#34;brand\u0026#34;).value(brand) ) ); } // 价格条件 if(minPrice !=null\u0026amp;\u0026amp; maxPrice !=null){ bool.filter( filterQuery-\u0026gt;filterQuery.range( rangeQuery-\u0026gt;rangeQuery.field(\u0026#34;price\u0026#34;).gte(JsonData.of(minPrice)).lte(JsonData.of(maxPrice)) ) ); } return bool.build(); } private PageEntity handleResponse(SearchResponse\u0026lt;HotelDoc\u0026gt; response){ // 解析响应 HitsMetadata\u0026lt;HotelDoc\u0026gt; hits = response.hits(); assert hits.total() != null; // 总条数 long value = hits.total().value(); List\u0026lt;Hit\u0026lt;HotelDoc\u0026gt;\u0026gt; hotels = hits.hits(); List\u0026lt;HotelDoc\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); hotels.forEach(hotelDocHit -\u0026gt; { result.add(hotelDocHit.source()); }); return new PageEntity(value,result); } } 我周边的酒店\r根据当前定位查找附近的酒店，按照距离升序排序\n1 2 3 4 5 6 7 8 9 { \u0026#34;key\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;page\u0026#34;: 1, \u0026#34;size\u0026#34;: 5, \u0026#34;sortBy\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;速8\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;31.258042,120.643542\u0026#34; } 新增location字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Data @AllArgsConstructor @NoArgsConstructor public class SearchParams { private String key; private Integer page; private Integer size; private String sortBy; private String city; private String brand ; private String starName ; private Integer minPrice; private Integer maxPrice; private String location; } 新增distance字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 @Data @AllArgsConstructor @NoArgsConstructor @Document(indexName = \u0026#34;hotel\u0026#34;,createIndex = true) public class HotelDoc { @Id @Field(type = FieldType.Keyword) private Long id; @Field(type = FieldType.Text) private String name; @Field(type = FieldType.Keyword) private String address; @Field(type = FieldType.Integer) private Integer price; @Field(type = FieldType.Integer) private Integer score; @Field(type = FieldType.Keyword) private String brand; @Field(type = FieldType.Keyword) private String city; @Field(type = FieldType.Keyword) private String starName; @Field(type = FieldType.Keyword) private String business; /** * 位置 */ @GeoPointField private GeoPoint location; @Field(type = FieldType.Keyword) private String pic; /** * 距离 */ private Double distance; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location=new GeoPoint(Double.parseDouble(hotel.getLatitude()),Double.parseDouble(hotel.getLongitude())); this.pic = hotel.getPic(); } } handleResponse方法添加排序功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.DistanceUnit; import co.elastic.clients.elasticsearch._types.FieldValue; import co.elastic.clients.elasticsearch._types.SortOrder; import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery; import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.elasticsearch.core.search.Hit; import co.elastic.clients.elasticsearch.core.search.HitsMetadata; import co.elastic.clients.json.JsonData; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.example.domain.Hotel; import com.example.domain.PageEntity; import com.example.domain.SearchParams; import com.example.domain.doc.HotelDoc; import com.example.mapper.HotelMapper; import com.example.service.HotelService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.util.CollectionUtils; import java.io.IOException; import java.util.ArrayList; import java.util.List; /** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */ @Service public class HotelServiceImpl extends ServiceImpl\u0026lt;HotelMapper, Hotel\u0026gt; implements HotelService { private static final String INDEX_NAME = \u0026#34;hotel\u0026#34;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 搜索 * * @param params 参数 * @return {@link PageEntity} */ @Override public PageEntity search(SearchParams params) { // 关键字 Integer page = params.getPage(); Integer size = params.getSize(); String location = params.getLocation(); try { BoolQuery boolQuery = buildBasicQuery(params); SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(s -\u0026gt; s.index(INDEX_NAME) .query(q -\u0026gt; q.bool(boolQuery)) .from((page - 1) * size) .size(size) .sort(sortOption -\u0026gt; sortOption.geoDistance( geoDistanceSort -\u0026gt; geoDistanceSort.field(\u0026#34;location\u0026#34;).location( geoLocation -\u0026gt; geoLocation.latlon( latLonGeoLocation -\u0026gt; latLonGeoLocation.lat(31.258042).lon(120.643542) ) ) // 距离升序排序 .order(SortOrder.Asc) // 单位是km .unit(DistanceUnit.Kilometers) )), HotelDoc.class); return handleResponse(search); } catch (IOException e) { throw new RuntimeException(e); } } private static BoolQuery buildBasicQuery(SearchParams params) { BoolQuery.Builder bool = QueryBuilders.bool(); String key = params.getKey(); String city = params.getCity(); String brand = params.getBrand(); Integer minPrice = params.getMinPrice(); Integer maxPrice = params.getMaxPrice(); // 没有查询条件，查询全部 if (key == null || key.isEmpty()) { bool.must( query -\u0026gt; query.matchAll( matchAll -\u0026gt; matchAll) ); } else { // 有查询条件，查询关键字 bool.must( query -\u0026gt; query.match( matchQuery -\u0026gt; matchQuery.field(\u0026#34;all\u0026#34;).query(key) ) ); } // 城市条件 if (city != null \u0026amp;\u0026amp; !city.isEmpty()) { bool.filter( filterQuery -\u0026gt; filterQuery.term( termQuery -\u0026gt; termQuery.field(\u0026#34;city\u0026#34;).value(city) ) ); } // 品牌条件 if (brand != null \u0026amp;\u0026amp; !brand.isEmpty()) { bool.filter( filterQuery -\u0026gt; filterQuery.term( termQuery -\u0026gt; termQuery.field(\u0026#34;brand\u0026#34;).value(brand) ) ); } // 价格条件 if (minPrice != null \u0026amp;\u0026amp; maxPrice != null) { bool.filter( filterQuery -\u0026gt; filterQuery.range( rangeQuery -\u0026gt; rangeQuery.field(\u0026#34;price\u0026#34;).gte(JsonData.of(minPrice)).lte(JsonData.of(maxPrice)) ) ); } return bool.build(); } private PageEntity handleResponse(SearchResponse\u0026lt;HotelDoc\u0026gt; response) { // 解析响应 HitsMetadata\u0026lt;HotelDoc\u0026gt; hits = response.hits(); assert hits.total() != null; // 总条数 long value = hits.total().value(); List\u0026lt;Hit\u0026lt;HotelDoc\u0026gt;\u0026gt; hotels = hits.hits(); List\u0026lt;HotelDoc\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); hotels.forEach(hotelDocHit -\u0026gt; { HotelDoc source = hotelDocHit.source(); // 获取排序值 List\u0026lt;FieldValue\u0026gt; sort = hotelDocHit.sort(); if(!CollectionUtils.isEmpty(sort)){ Double distance = sort.get(0).doubleValue(); assert source != null; source.setDistance(distance); } result.add(source); }); return new PageEntity(value, result); } } 酒店竞价排名\r给HotelDoc类添加isAd字段，Boolean类型，表示是否是广告 挑选几个你喜欢的酒店，给它的文档数据添加isAd字段，值为true 修改search方法，添加function score功能,给isAd值为true的酒店增加权重 1 2 3 4 5 6 7 8 9 10 11 12 POST /hotel/_update/46829 { \u0026#34;doc\u0026#34;:{ \u0026#34;isAd\u0026#34;:true } } POST /hotel/_update/47066 { \u0026#34;doc\u0026#34;:{ \u0026#34;isAd\u0026#34;:true } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @Data @AllArgsConstructor @NoArgsConstructor @Document(indexName = \u0026#34;hotel\u0026#34;,createIndex = true) public class HotelDoc { @Id @Field(type = FieldType.Keyword) private Long id; @Field(type = FieldType.Text) private String name; @Field(type = FieldType.Keyword) private String address; @Field(type = FieldType.Integer) private Integer price; @Field(type = FieldType.Integer) private Integer score; @Field(type = FieldType.Keyword) private String brand; @Field(type = FieldType.Keyword) private String city; @Field(type = FieldType.Keyword) private String starName; @Field(type = FieldType.Keyword) private String business; /** * 位置 */ @GeoPointField private GeoPoint location; @Field(type = FieldType.Keyword) private String pic; /** * 距离 */ private Double distance; /** * 是广告 */ private Boolean isAd; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location=new GeoPoint(Double.parseDouble(hotel.getLatitude()),Double.parseDouble(hotel.getLongitude())); this.pic = hotel.getPic(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.DistanceUnit; import co.elastic.clients.elasticsearch._types.FieldValue; import co.elastic.clients.elasticsearch._types.SortOrder; import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery; import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreMode; import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreQuery; import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.elasticsearch.core.search.Hit; import co.elastic.clients.elasticsearch.core.search.HitsMetadata; import co.elastic.clients.json.JsonData; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.example.domain.Hotel; import com.example.domain.PageEntity; import com.example.domain.SearchParams; import com.example.domain.doc.HotelDoc; import com.example.mapper.HotelMapper; import com.example.service.HotelService; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.util.CollectionUtils; import java.io.IOException; import java.util.ArrayList; import java.util.List; /** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */ @Service public class HotelServiceImpl extends ServiceImpl\u0026lt;HotelMapper, Hotel\u0026gt; implements HotelService { private static final String INDEX_NAME = \u0026#34;hotel\u0026#34;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 搜索 * * @param params 参数 * @return {@link PageEntity} */ @Override public PageEntity search(SearchParams params) { // 关键字 Integer page = params.getPage(); Integer size = params.getSize(); String location = params.getLocation(); try { FunctionScoreQuery functionScoreQuery = buildBasicQuery(params); SearchRequest.Builder builder = new SearchRequest.Builder(); builder.index(INDEX_NAME) .query(q -\u0026gt; q.functionScore(functionScoreQuery)) .from((page - 1) * size) .size(size); // 距离排序 if (StringUtils.isNotBlank(location)) { builder.sort(s-\u0026gt;s.geoDistance( geoDistanceSort -\u0026gt; geoDistanceSort.field(\u0026#34;location\u0026#34;).location( geoLocation -\u0026gt; geoLocation.latlon( latLonGeoLocation -\u0026gt; latLonGeoLocation.lat(31.258042).lon(120.643542) ) ) // 距离升序排序 .order(SortOrder.Asc) // 单位是km .unit(DistanceUnit.Kilometers))); } SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(builder.build(), HotelDoc.class); return handleResponse(search); } catch (IOException e) { throw new RuntimeException(e); } } private static FunctionScoreQuery buildBasicQuery(SearchParams params) { BoolQuery.Builder bool = QueryBuilders.bool(); String key = params.getKey(); String city = params.getCity(); String brand = params.getBrand(); Integer minPrice = params.getMinPrice(); Integer maxPrice = params.getMaxPrice(); // 没有查询条件，查询全部 if (key == null || key.isEmpty()) { bool.must( query -\u0026gt; query.matchAll( matchAll -\u0026gt; matchAll) ); } else { // 有查询条件，查询关键字 bool.must( query -\u0026gt; query.match( matchQuery -\u0026gt; matchQuery.field(\u0026#34;all\u0026#34;).query(key) ) ); } // 城市条件 if (city != null \u0026amp;\u0026amp; !city.isEmpty()) { bool.filter( filterQuery -\u0026gt; filterQuery.term( termQuery -\u0026gt; termQuery.field(\u0026#34;city\u0026#34;).value(city) ) ); } // 品牌条件 if (brand != null \u0026amp;\u0026amp; !brand.isEmpty()) { bool.filter( filterQuery -\u0026gt; filterQuery.term( termQuery -\u0026gt; termQuery.field(\u0026#34;brand\u0026#34;).value(brand) ) ); } // 价格条件 if (minPrice != null \u0026amp;\u0026amp; maxPrice != null) { bool.filter( filterQuery -\u0026gt; filterQuery.range( rangeQuery -\u0026gt; rangeQuery.field(\u0026#34;price\u0026#34;).gte(JsonData.of(minPrice)).lte(JsonData.of(maxPrice)) ) ); } FunctionScoreQuery.Builder functionScoreBuilder = QueryBuilders.functionScore(); functionScoreBuilder.query( functionScore -\u0026gt; functionScore.functionScore( q -\u0026gt; q.query( boolQuery -\u0026gt; boolQuery.bool(bool.build()) ).functions( f -\u0026gt; f.filter( t -\u0026gt; t.term(termQuery -\u0026gt; termQuery.field(\u0026#34;isAd\u0026#34;).value(true)) ).weight(10.0) ) .scoreMode(FunctionScoreMode.Sum) ) ); return functionScoreBuilder.build(); } private PageEntity handleResponse(SearchResponse\u0026lt;HotelDoc\u0026gt; response) { // 解析响应 HitsMetadata\u0026lt;HotelDoc\u0026gt; hits = response.hits(); assert hits.total() != null; // 总条数 long value = hits.total().value(); List\u0026lt;Hit\u0026lt;HotelDoc\u0026gt;\u0026gt; hotels = hits.hits(); List\u0026lt;HotelDoc\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); hotels.forEach(hotelDocHit -\u0026gt; { HotelDoc source = hotelDocHit.source(); // 获取排序值 List\u0026lt;FieldValue\u0026gt; sort = hotelDocHit.sort(); if (!CollectionUtils.isEmpty(sort)) { Double distance = sort.get(0).doubleValue(); assert source != null; source.setDistance(distance); } result.add(source); }); return new PageEntity(value, result); } } 数据聚合\r概念介绍\r聚合可以实现对文档数据的统计、分析、运算。聚合常见的有三类:\n桶聚合(Bucket) 度量聚合(Metric) 管道聚合(Pipeline)\n桶聚合:用来对文档做分组 TermAggregation:按照文档字段值分组 Date Histogram:按照日期阶梯分组，例如一周为一组，或者一月为一组 度量聚合:用以计算一些值， 比如:最大值、最小值、平均值等 Avg Max Min Stats：同时求max、min、avg、sum等 管道聚合:其它聚合的结果为基础做聚合 参与聚合的字段类型必须是: keyword 数值 日期 布尔 桶聚合\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 # 桶聚合 GET /hotel/_search { // 设置size为0，结果中不包含文档，只包含聚合结果 \u0026#34;size\u0026#34;:0, // 定义聚合 \u0026#34;aggs\u0026#34;:{ // 自己给聚合起个名字 \u0026#34;brandAgg\u0026#34;:{ // 聚合的类型，按照品牌值聚合，所以选择term , \u0026#34;terms\u0026#34;: { // 参与聚合的字段 \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, // 希望获取的聚合结果数量 \u0026#34;size\u0026#34;: 10 } } } } # 聚合结果排序 GET /hotel/_search { \u0026#34;size\u0026#34;:0, \u0026#34;aggs\u0026#34;:{ \u0026#34;brandAgg\u0026#34;:{ \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;order\u0026#34;: { // 升序排序 \u0026#34;_count\u0026#34;: \u0026#34;asc\u0026#34; }, \u0026#34;size\u0026#34;: 10 } } } } # 限定聚合文档的范围，只对某一类文档做聚合 GET /hotel/_search { // 对价格小于等于200的文档做聚合 \u0026#34;query\u0026#34;:{ \u0026#34;range\u0026#34;:{ \u0026#34;price\u0026#34;:{ \u0026#34;lte\u0026#34;: 200 } } }, \u0026#34;size\u0026#34;:0, \u0026#34;aggs\u0026#34;:{ \u0026#34;brandAgg\u0026#34;:{ \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 10 } } } } 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 { \u0026#34;took\u0026#34;: 21, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 201, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: null, \u0026#34;hits\u0026#34;: [] }, \u0026#34;aggregations\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { \u0026#34;doc_count_error_upper_bound\u0026#34;: 0, \u0026#34;sum_other_doc_count\u0026#34;: 39, \u0026#34;buckets\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;7天酒店\u0026#34;, \u0026#34;doc_count\u0026#34;: 30 }, { \u0026#34;key\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;doc_count\u0026#34;: 30 }, { \u0026#34;key\u0026#34;: \u0026#34;皇冠假日\u0026#34;, \u0026#34;doc_count\u0026#34;: 17 }, { \u0026#34;key\u0026#34;: \u0026#34;速8\u0026#34;, \u0026#34;doc_count\u0026#34;: 15 }, { \u0026#34;key\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;doc_count\u0026#34;: 13 }, { \u0026#34;key\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;doc_count\u0026#34;: 13 }, { \u0026#34;key\u0026#34;: \u0026#34;和颐\u0026#34;, \u0026#34;doc_count\u0026#34;: 12 }, { \u0026#34;key\u0026#34;: \u0026#34;万豪\u0026#34;, \u0026#34;doc_count\u0026#34;: 11 }, { \u0026#34;key\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;doc_count\u0026#34;: 11 }, { \u0026#34;key\u0026#34;: \u0026#34;希尔顿\u0026#34;, \u0026#34;doc_count\u0026#34;: 10 } ] } } } 总结 aggs代表聚合，与query同级，此时query的作用是? 答：限定聚合的的文档范围 聚合必须的三要素:\n聚合名称 聚合类型 聚合字段 聚合可配置属性有: size:指定聚合结果数量 order:指定聚合结果排序方式 field:指定聚合字段 度量聚合\r例如，我们要求获取每个品牌的用户评分的min、max、avg等值\n根据上面概念介绍，我们需要获取多个值，单一的Avg、Min、Max查询已经无法满足需求，所以需要使用Stats查询 大概思路应该是先对品牌做桶聚合，然后再对该聚合结果继续做度量聚合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 GET /hotel/_search { \u0026#34;size\u0026#34;:0, \u0026#34;aggs\u0026#34;:{ \u0026#34;brandAgg\u0026#34;:{ \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 10 }, // brand聚合的子聚合，分组后对每组分别计算 \u0026#34;aggs\u0026#34;:{ // 聚合名称 \u0026#34;scoreAgg\u0026#34;:{ // 聚合类型，这里的stats可以计算min、max、avg等 \u0026#34;stats\u0026#34;: { // 聚合字段，这里是score \u0026#34;field\u0026#34;: \u0026#34;score\u0026#34; } } } } } } # 结果评分的平均分按照升序排序 GET /hotel/_search { \u0026#34;size\u0026#34;:0, \u0026#34;aggs\u0026#34;:{ \u0026#34;brandAgg\u0026#34;:{ \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 10, \u0026#34;order\u0026#34;: { // 按照平均分升序排序 \u0026#34;scoreAgg.avg\u0026#34;: \u0026#34;asc\u0026#34; } }, \u0026#34;aggs\u0026#34;:{ \u0026#34;scoreAgg\u0026#34;:{ \u0026#34;stats\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;score\u0026#34; } } } } } } 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 { \u0026#34;took\u0026#34;: 2, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 201, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: null, \u0026#34;hits\u0026#34;: [] }, \u0026#34;aggregations\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { \u0026#34;doc_count_error_upper_bound\u0026#34;: 0, \u0026#34;sum_other_doc_count\u0026#34;: 39, \u0026#34;buckets\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;7天酒店\u0026#34;, \u0026#34;doc_count\u0026#34;: 30, \u0026#34;scoreAgg\u0026#34;: { \u0026#34;count\u0026#34;: 30, \u0026#34;min\u0026#34;: 35, \u0026#34;max\u0026#34;: 43, \u0026#34;avg\u0026#34;: 37.86666666666667, \u0026#34;sum\u0026#34;: 1136 } }, { \u0026#34;key\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;doc_count\u0026#34;: 30, \u0026#34;scoreAgg\u0026#34;: { \u0026#34;count\u0026#34;: 30, \u0026#34;min\u0026#34;: 43, \u0026#34;max\u0026#34;: 47, \u0026#34;avg\u0026#34;: 44.833333333333336, \u0026#34;sum\u0026#34;: 1345 } }, { \u0026#34;key\u0026#34;: \u0026#34;皇冠假日\u0026#34;, \u0026#34;doc_count\u0026#34;: 17, \u0026#34;scoreAgg\u0026#34;: { \u0026#34;count\u0026#34;: 17, \u0026#34;min\u0026#34;: 44, \u0026#34;max\u0026#34;: 48, \u0026#34;avg\u0026#34;: 46, \u0026#34;sum\u0026#34;: 782 } }, { \u0026#34;key\u0026#34;: \u0026#34;速8\u0026#34;, \u0026#34;doc_count\u0026#34;: 15, \u0026#34;scoreAgg\u0026#34;: { \u0026#34;count\u0026#34;: 15, \u0026#34;min\u0026#34;: 35, \u0026#34;max\u0026#34;: 47, \u0026#34;avg\u0026#34;: 38.733333333333334, \u0026#34;sum\u0026#34;: 581 } }, { \u0026#34;key\u0026#34;: \u0026#34;万怡\u0026#34;, \u0026#34;doc_count\u0026#34;: 13, \u0026#34;scoreAgg\u0026#34;: { \u0026#34;count\u0026#34;: 13, \u0026#34;min\u0026#34;: 44, \u0026#34;max\u0026#34;: 48, \u0026#34;avg\u0026#34;: 45.69230769230769, \u0026#34;sum\u0026#34;: 594 } }, { \u0026#34;key\u0026#34;: \u0026#34;华美达\u0026#34;, \u0026#34;doc_count\u0026#34;: 13, \u0026#34;scoreAgg\u0026#34;: { \u0026#34;count\u0026#34;: 13, \u0026#34;min\u0026#34;: 40, \u0026#34;max\u0026#34;: 47, \u0026#34;avg\u0026#34;: 44, \u0026#34;sum\u0026#34;: 572 } }, { \u0026#34;key\u0026#34;: \u0026#34;和颐\u0026#34;, \u0026#34;doc_count\u0026#34;: 12, \u0026#34;scoreAgg\u0026#34;: { \u0026#34;count\u0026#34;: 12, \u0026#34;min\u0026#34;: 44, \u0026#34;max\u0026#34;: 47, \u0026#34;avg\u0026#34;: 46.083333333333336, \u0026#34;sum\u0026#34;: 553 } }, { \u0026#34;key\u0026#34;: \u0026#34;万豪\u0026#34;, \u0026#34;doc_count\u0026#34;: 11, \u0026#34;scoreAgg\u0026#34;: { \u0026#34;count\u0026#34;: 11, \u0026#34;min\u0026#34;: 43, \u0026#34;max\u0026#34;: 47, \u0026#34;avg\u0026#34;: 45.81818181818182, \u0026#34;sum\u0026#34;: 504 } }, { \u0026#34;key\u0026#34;: \u0026#34;喜来登\u0026#34;, \u0026#34;doc_count\u0026#34;: 11, \u0026#34;scoreAgg\u0026#34;: { \u0026#34;count\u0026#34;: 11, \u0026#34;min\u0026#34;: 44, \u0026#34;max\u0026#34;: 48, \u0026#34;avg\u0026#34;: 46, \u0026#34;sum\u0026#34;: 506 } }, { \u0026#34;key\u0026#34;: \u0026#34;希尔顿\u0026#34;, \u0026#34;doc_count\u0026#34;: 10, \u0026#34;scoreAgg\u0026#34;: { \u0026#34;count\u0026#34;: 10, \u0026#34;min\u0026#34;: 37, \u0026#34;max\u0026#34;: 48, \u0026#34;avg\u0026#34;: 45.4, \u0026#34;sum\u0026#34;: 454 } } ] } } } RestApi实现聚合\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.SortOrder; import co.elastic.clients.elasticsearch._types.aggregations.Aggregate; import co.elastic.clients.elasticsearch._types.aggregations.StringTermsBucket; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.json.JsonData; import co.elastic.clients.util.NamedValue; import com.example.domain.doc.HotelDoc; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; import java.util.List; import java.util.Map; /** * 聚合测试 * * @author: 不是菜狗爱编程 * @date: 2024/03/31/16:32 * @description: */ @SpringBootTest class AggregationTest { private static final String INDEX_NAME = \u0026#34;hotel\u0026#34;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 桶聚合 * * @throws IOException io异常 */ @Test void bucketTest() throws IOException { SearchRequest.Builder searchRequestBuilder = new SearchRequest.Builder(); searchRequestBuilder.index(INDEX_NAME) .size(0) .aggregations(\u0026#34;brandAgg\u0026#34;,agg-\u0026gt;agg.terms( termsAggregation-\u0026gt;termsAggregation.field(\u0026#34;brand\u0026#34;).size(10) )); SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(searchRequestBuilder.build(), HotelDoc.class); Map\u0026lt;String, Aggregate\u0026gt; map = search.aggregations(); for (Map.Entry\u0026lt;String, Aggregate\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;entry.getValue() = \u0026#34; + entry.getValue()); } System.out.println(\u0026#34;============================\u0026#34;); // 或者根据聚合名称来获取聚合结果 Aggregate brandAgg = search.aggregations().get(\u0026#34;brandAgg\u0026#34;); List\u0026lt;StringTermsBucket\u0026gt; array = brandAgg.sterms().buckets().array(); for (StringTermsBucket stringTermsBucket : array) { System.out.printf(\u0026#34;酒店品牌:%s 数量%d\\n\u0026#34;,stringTermsBucket.key().stringValue(),stringTermsBucket.docCount()); } } /** * 桶聚合排序 * * @throws IOException io异常 */ @Test void bucketWithSortTest() throws IOException { SearchRequest.Builder searchRequestBuilder = new SearchRequest.Builder(); searchRequestBuilder.index(INDEX_NAME) .size(0) .aggregations(\u0026#34;brandAgg\u0026#34;,agg-\u0026gt;agg.terms( termsAggregation-\u0026gt;termsAggregation.field(\u0026#34;brand\u0026#34;) .order(NamedValue.of(\u0026#34;_count\u0026#34;, SortOrder.Asc)) .size(10) )); SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(searchRequestBuilder.build(), HotelDoc.class); Map\u0026lt;String, Aggregate\u0026gt; map = search.aggregations(); for (Map.Entry\u0026lt;String, Aggregate\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;entry.getValue() = \u0026#34; + entry.getValue()); } } /** * 限定聚合文档的范围 * * @throws IOException io异常 */ @Test void bucketWithQualifiedDocument() throws IOException { SearchRequest.Builder searchRequestBuilder = new SearchRequest.Builder(); searchRequestBuilder.index(INDEX_NAME) .query(query-\u0026gt;query.range( rangeQuery-\u0026gt;rangeQuery.field(\u0026#34;price\u0026#34;).lte(JsonData.of(200)) )) .size(0) .aggregations(\u0026#34;brandAgg\u0026#34;,agg-\u0026gt;agg.terms( termsAggregation-\u0026gt;termsAggregation.field(\u0026#34;brand\u0026#34;) .size(10) )); SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(searchRequestBuilder.build(), HotelDoc.class); Map\u0026lt;String, Aggregate\u0026gt; map = search.aggregations(); for (Map.Entry\u0026lt;String, Aggregate\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;entry.getValue() = \u0026#34; + entry.getValue()); } } } 黑马旅游实现品牌、城市、星级的聚合\r基本实现\r搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的 实现service中的filters方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface HotelService extends IService\u0026lt;Hotel\u0026gt; { /** * 搜索 * * @param params 参数 * @return {@link PageEntity} */ PageEntity search(SearchParams params); /** * 实现品牌、城市、星级的聚合 * * @return {@link Map}\u0026lt;{@link String}, {@link List}\u0026lt;{@link String}\u0026gt;\u0026gt; */ Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; filters(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.DistanceUnit; import co.elastic.clients.elasticsearch._types.FieldValue; import co.elastic.clients.elasticsearch._types.SortOrder; import co.elastic.clients.elasticsearch._types.aggregations.Aggregate; import co.elastic.clients.elasticsearch._types.aggregations.Aggregation; import co.elastic.clients.elasticsearch._types.aggregations.AggregationBuilders; import co.elastic.clients.elasticsearch._types.aggregations.StringTermsBucket; import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery; import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreMode; import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreQuery; import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.elasticsearch.core.search.Hit; import co.elastic.clients.elasticsearch.core.search.HitsMetadata; import co.elastic.clients.json.JsonData; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.example.domain.Hotel; import com.example.domain.PageEntity; import com.example.domain.SearchParams; import com.example.domain.doc.HotelDoc; import com.example.mapper.HotelMapper; import com.example.service.HotelService; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.util.CollectionUtils; import java.io.IOException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */ @Service public class HotelServiceImpl extends ServiceImpl\u0026lt;HotelMapper, Hotel\u0026gt; implements HotelService { private static final String INDEX_NAME = \u0026#34;hotel\u0026#34;; /** * 品牌聚合名称 */ private static final String BRAND_AGGREGATION=\u0026#34;brandAgg\u0026#34;; /** * 城市聚合名称 */ private static final String CITY_AGGREGATION=\u0026#34;cityAgg\u0026#34;; /** * 星级聚合名称 */ private static final String STAR_AGGREGATION=\u0026#34;starAgg\u0026#34;; @Autowired private ElasticsearchClient elasticsearchClient; @Override public Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; filters() { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); try { SearchRequest.Builder searchRequestBuilder = new SearchRequest.Builder(); searchRequestBuilder.index(INDEX_NAME) .size(0) .aggregations(buildAggregation()); SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(searchRequestBuilder.build(), HotelDoc.class); // 根据聚合名称来获取聚合结果 Map\u0026lt;String, Aggregate\u0026gt; aggregations = search.aggregations(); List\u0026lt;String\u0026gt; brandList=getAggByName(aggregations,BRAND_AGGREGATION); List\u0026lt;String\u0026gt; cityList=getAggByName(aggregations,CITY_AGGREGATION); List\u0026lt;String\u0026gt; starList=getAggByName(aggregations,STAR_AGGREGATION); result.put(\u0026#34;brand\u0026#34;,brandList); result.put(\u0026#34;city\u0026#34;,cityList); result.put(\u0026#34;star\u0026#34;,starList); } catch (IOException e) { throw new RuntimeException(e); } return result; } /** * 按名称获取聚合结果 * * @param aggregations 聚合 * @param aggregationName 聚合名称 * @return {@link List}\u0026lt;{@link String}\u0026gt; */ private List\u0026lt;String\u0026gt; getAggByName(Map\u0026lt;String, Aggregate\u0026gt; aggregations, String aggregationName) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Aggregate brandAgg = aggregations.get(aggregationName); List\u0026lt;StringTermsBucket\u0026gt; array = brandAgg.sterms().buckets().array(); for (StringTermsBucket stringTermsBucket : array) { list.add(stringTermsBucket.key().stringValue()); } return list; } public Map\u0026lt;String, Aggregation\u0026gt; buildAggregation(){ Map\u0026lt;String, Aggregation\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 品牌聚合 Aggregation brandAgg = AggregationBuilders.terms(termsAggregation -\u0026gt; termsAggregation.field(\u0026#34;brand\u0026#34;).size(10)); // 城市聚合 Aggregation cityAgg = AggregationBuilders.terms(termsAggregation -\u0026gt; termsAggregation.field(\u0026#34;city\u0026#34;).size(10)); // 星级聚合 Aggregation starAgg = AggregationBuilders.terms(termsAggregation -\u0026gt; termsAggregation.field(\u0026#34;starName\u0026#34;).size(10)); map.put(BRAND_AGGREGATION,brandAgg); map.put(CITY_AGGREGATION,cityAgg); map.put(STAR_AGGREGATION,starAgg); return map; } } 测试\n1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class HotelServiceImplTest { @Autowired private HotelService hotelService; @Test void filters() { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; filters = hotelService.filters(); for (Map.Entry\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; entry : filters.entrySet()) { System.out.println(entry.getKey() + \u0026#34;= \u0026#34; + entry.getValue()); } } } 日志打印如下\n1 2 3 4 5 6 7 8 9 10 2024-03-31T17:46:47.091+08:00 TRACE 17560 --- [ main] tracer : curl -iX POST \u0026#39;http://localhost:9200/hotel/_search?typed_keys=true\u0026#39; -d \u0026#39;{\u0026#34;aggregations\u0026#34;:{\u0026#34;starAgg\u0026#34;:{\u0026#34;terms\u0026#34;:{\u0026#34;field\u0026#34;:\u0026#34;starName\u0026#34;,\u0026#34;size\u0026#34;:10}},\u0026#34;brandAgg\u0026#34;:{\u0026#34;terms\u0026#34;:{\u0026#34;field\u0026#34;:\u0026#34;brand\u0026#34;,\u0026#34;size\u0026#34;:10}},\u0026#34;cityAgg\u0026#34;:{\u0026#34;terms\u0026#34;:{\u0026#34;field\u0026#34;:\u0026#34;city\u0026#34;,\u0026#34;size\u0026#34;:10}}},\u0026#34;size\u0026#34;:0}\u0026#39; # HTTP/1.1 200 OK # X-elastic-product: Elasticsearch # content-type: application/vnd.elasticsearch+json;compatible-with=8 # content-length: 1072 # # {\u0026#34;took\u0026#34;:0,\u0026#34;timed_out\u0026#34;:false,\u0026#34;_shards\u0026#34;:{\u0026#34;total\u0026#34;:1,\u0026#34;successful\u0026#34;:1,\u0026#34;skipped\u0026#34;:0,\u0026#34;failed\u0026#34;:0},\u0026#34;hits\u0026#34;:{\u0026#34;total\u0026#34;:{\u0026#34;value\u0026#34;:201,\u0026#34;relation\u0026#34;:\u0026#34;eq\u0026#34;},\u0026#34;max_score\u0026#34;:null,\u0026#34;hits\u0026#34;:[]},\u0026#34;aggregations\u0026#34;:{\u0026#34;sterms#starAgg\u0026#34;:{\u0026#34;doc_count_error_upper_bound\u0026#34;:0,\u0026#34;sum_other_doc_count\u0026#34;:0,\u0026#34;buckets\u0026#34;:[{\u0026#34;key\u0026#34;:\u0026#34;二钻\u0026#34;,\u0026#34;doc_count\u0026#34;:84},{\u0026#34;key\u0026#34;:\u0026#34;五钻\u0026#34;,\u0026#34;doc_count\u0026#34;:49},{\u0026#34;key\u0026#34;:\u0026#34;四钻\u0026#34;,\u0026#34;doc_count\u0026#34;:28},{\u0026#34;key\u0026#34;:\u0026#34;五星级\u0026#34;,\u0026#34;doc_count\u0026#34;:20},{\u0026#34;key\u0026#34;:\u0026#34;三钻\u0026#34;,\u0026#34;doc_count\u0026#34;:13},{\u0026#34;key\u0026#34;:\u0026#34;四星级\u0026#34;,\u0026#34;doc_count\u0026#34;:7}]},\u0026#34;sterms#cityAgg\u0026#34;:{\u0026#34;doc_count_error_upper_bound\u0026#34;:0,\u0026#34;sum_other_doc_count\u0026#34;:0,\u0026#34;buckets\u0026#34;:[{\u0026#34;key\u0026#34;:\u0026#34;上海\u0026#34;,\u0026#34;doc_count\u0026#34;:83},{\u0026#34;key\u0026#34;:\u0026#34;北京\u0026#34;,\u0026#34;doc_count\u0026#34;:62},{\u0026#34;key\u0026#34;:\u0026#34;深圳\u0026#34;,\u0026#34;doc_count\u0026#34;:56}]},\u0026#34;sterms#brandAgg\u0026#34;:{\u0026#34;doc_count_error_upper_bound\u0026#34;:0,\u0026#34;sum_other_doc_count\u0026#34;:39,\u0026#34;buckets\u0026#34;:[{\u0026#34;key\u0026#34;:\u0026#34;7天酒店\u0026#34;,\u0026#34;doc_count\u0026#34;:30},{\u0026#34;key\u0026#34;:\u0026#34;如家\u0026#34;,\u0026#34;doc_count\u0026#34;:30},{\u0026#34;key\u0026#34;:\u0026#34;皇冠假日\u0026#34;,\u0026#34;doc_count\u0026#34;:17},{\u0026#34;key\u0026#34;:\u0026#34;速8\u0026#34;,\u0026#34;doc_count\u0026#34;:15},{\u0026#34;key\u0026#34;:\u0026#34;万怡\u0026#34;,\u0026#34;doc_count\u0026#34;:13},{\u0026#34;key\u0026#34;:\u0026#34;华美达\u0026#34;,\u0026#34;doc_count\u0026#34;:13},{\u0026#34;key\u0026#34;:\u0026#34;和颐\u0026#34;,\u0026#34;doc_count\u0026#34;:12},{\u0026#34;key\u0026#34;:\u0026#34;万豪\u0026#34;,\u0026#34;doc_count\u0026#34;:11},{\u0026#34;key\u0026#34;:\u0026#34;喜来登\u0026#34;,\u0026#34;doc_count\u0026#34;:11},{\u0026#34;key\u0026#34;:\u0026#34;希尔顿\u0026#34;,\u0026#34;doc_count\u0026#34;:10}]}}} star= [二钻, 五钻, 四钻, 五星级, 三钻, 四星级] city= [上海, 北京, 深圳] brand= [7天酒店, 如家, 皇冠假日, 速8, 万怡, 华美达, 和颐, 万豪, 喜来登, 希尔顿] 添加过滤条件\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * @author: 不是菜狗爱编程 * @date: 2024/03/30/9:47 * @description: */ @RestController @RequestMapping(\u0026#34;hotel\u0026#34;) public class SearchController { @Autowired private HotelService hotelService; @PostMapping(\u0026#34;/filters\u0026#34;) public Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; filters(@RequestBody SearchParams params){ return hotelService.filters(params); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.DistanceUnit; import co.elastic.clients.elasticsearch._types.FieldValue; import co.elastic.clients.elasticsearch._types.SortOrder; import co.elastic.clients.elasticsearch._types.aggregations.Aggregate; import co.elastic.clients.elasticsearch._types.aggregations.Aggregation; import co.elastic.clients.elasticsearch._types.aggregations.AggregationBuilders; import co.elastic.clients.elasticsearch._types.aggregations.StringTermsBucket; import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery; import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreMode; import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreQuery; import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.elasticsearch.core.search.Hit; import co.elastic.clients.elasticsearch.core.search.HitsMetadata; import co.elastic.clients.json.JsonData; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.example.domain.Hotel; import com.example.domain.PageEntity; import com.example.domain.SearchParams; import com.example.domain.doc.HotelDoc; import com.example.mapper.HotelMapper; import com.example.service.HotelService; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.util.CollectionUtils; import java.io.IOException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */ @Service public class HotelServiceImpl extends ServiceImpl\u0026lt;HotelMapper, Hotel\u0026gt; implements HotelService { private static final String INDEX_NAME = \u0026#34;hotel\u0026#34;; /** * 品牌聚合名称 */ private static final String BRAND_AGGREGATION=\u0026#34;brandAgg\u0026#34;; /** * 城市聚合名称 */ private static final String CITY_AGGREGATION=\u0026#34;cityAgg\u0026#34;; /** * 星级聚合名称 */ private static final String STAR_AGGREGATION=\u0026#34;starAgg\u0026#34;; @Autowired private ElasticsearchClient elasticsearchClient; @Override public Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; filters(SearchParams params) { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); try { FunctionScoreQuery functionScoreQuery = buildBasicQuery(params); SearchRequest.Builder searchRequestBuilder = new SearchRequest.Builder(); searchRequestBuilder.index(INDEX_NAME) // 添加过滤条件 .query(q -\u0026gt; q.functionScore(functionScoreQuery)) .size(0) .aggregations(buildAggregation()); SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(searchRequestBuilder.build(), HotelDoc.class); // 根据聚合名称来获取聚合结果 Map\u0026lt;String, Aggregate\u0026gt; aggregations = search.aggregations(); List\u0026lt;String\u0026gt; brandList=getAggByName(aggregations,BRAND_AGGREGATION); List\u0026lt;String\u0026gt; cityList=getAggByName(aggregations,CITY_AGGREGATION); List\u0026lt;String\u0026gt; starList=getAggByName(aggregations,STAR_AGGREGATION); result.put(\u0026#34;brand\u0026#34;,brandList); result.put(\u0026#34;city\u0026#34;,cityList); result.put(\u0026#34;star\u0026#34;,starList); } catch (IOException e) { throw new RuntimeException(e); } return result; } /** * 按名称获取聚合结果 * * @param aggregations 聚合 * @param aggregationName 聚合名称 * @return {@link List}\u0026lt;{@link String}\u0026gt; */ private List\u0026lt;String\u0026gt; getAggByName(Map\u0026lt;String, Aggregate\u0026gt; aggregations, String aggregationName) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Aggregate brandAgg = aggregations.get(aggregationName); List\u0026lt;StringTermsBucket\u0026gt; array = brandAgg.sterms().buckets().array(); for (StringTermsBucket stringTermsBucket : array) { list.add(stringTermsBucket.key().stringValue()); } return list; } public Map\u0026lt;String, Aggregation\u0026gt; buildAggregation(){ Map\u0026lt;String, Aggregation\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 品牌聚合 Aggregation brandAgg = AggregationBuilders.terms(termsAggregation -\u0026gt; termsAggregation.field(\u0026#34;brand\u0026#34;).size(10)); // 城市聚合 Aggregation cityAgg = AggregationBuilders.terms(termsAggregation -\u0026gt; termsAggregation.field(\u0026#34;city\u0026#34;).size(10)); // 星级聚合 Aggregation starAgg = AggregationBuilders.terms(termsAggregation -\u0026gt; termsAggregation.field(\u0026#34;starName\u0026#34;).size(10)); map.put(BRAND_AGGREGATION,brandAgg); map.put(CITY_AGGREGATION,cityAgg); map.put(STAR_AGGREGATION,starAgg); return map; } private static FunctionScoreQuery buildBasicQuery(SearchParams params) { BoolQuery.Builder bool = QueryBuilders.bool(); String key = params.getKey(); String city = params.getCity(); String brand = params.getBrand(); Integer minPrice = params.getMinPrice(); Integer maxPrice = params.getMaxPrice(); // 没有查询条件，查询全部 if (key == null || key.isEmpty()) { bool.must( query -\u0026gt; query.matchAll( matchAll -\u0026gt; matchAll) ); } else { // 有查询条件，查询关键字 bool.must( query -\u0026gt; query.match( matchQuery -\u0026gt; matchQuery.field(\u0026#34;all\u0026#34;).query(key) ) ); } // 城市条件 if (city != null \u0026amp;\u0026amp; !city.isEmpty()) { bool.filter( filterQuery -\u0026gt; filterQuery.term( termQuery -\u0026gt; termQuery.field(\u0026#34;city\u0026#34;).value(city) ) ); } // 品牌条件 if (brand != null \u0026amp;\u0026amp; !brand.isEmpty()) { bool.filter( filterQuery -\u0026gt; filterQuery.term( termQuery -\u0026gt; termQuery.field(\u0026#34;brand\u0026#34;).value(brand) ) ); } // 价格条件 if (minPrice != null \u0026amp;\u0026amp; maxPrice != null) { bool.filter( filterQuery -\u0026gt; filterQuery.range( rangeQuery -\u0026gt; rangeQuery.field(\u0026#34;price\u0026#34;).gte(JsonData.of(minPrice)).lte(JsonData.of(maxPrice)) ) ); } FunctionScoreQuery.Builder functionScoreBuilder = QueryBuilders.functionScore(); functionScoreBuilder.query( functionScore -\u0026gt; functionScore.functionScore( q -\u0026gt; q.query( boolQuery -\u0026gt; boolQuery.bool(bool.build()) ).functions( f -\u0026gt; f.filter( t -\u0026gt; t.term(termQuery -\u0026gt; termQuery.field(\u0026#34;isAd\u0026#34;).value(true)) ).weight(10.0) ) .scoreMode(FunctionScoreMode.Sum) ) ); return functionScoreBuilder.build(); } } 自动补全\r自定义分词器\relasticsearch中分词器(analyzer) 的组成包含三部分:\ncharacter filters:在tokenizer之 前对文本进行处理。例如删除字符、替换字符 tokenizer:将文本按照-定的规则切割成词条(term) 。例如keyword,就是不分词;还有ik_smart tokenizer filter:将tokenizer输 出的词条做进一步 处理。例如大小写转换、同义词处理、拼音处理等 我们可以在创建索引库时，通过settings来配置自定义的analyzer(分词器) 这个分词器只对当前索引库有效 这里没有 character filters，这里并不需要对特殊字符进行处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 PUT /test { \u0026#34;settings\u0026#34;:{ \u0026#34;analysis\u0026#34;:{ // 自定义分词器 \u0026#34;analyzer\u0026#34;:{ // 分词器名称 \u0026#34;my_analyzer\u0026#34;:{ \u0026#34;tokenizer\u0026#34;:\u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;:\u0026#34;pinyin\u0026#34; } } } } } 这里的pinyin分词器其实还有些问题，会一个字一个字地转成拼音，而且把中文删除，需要进行进一步的定制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 PUT /test { \u0026#34;settings\u0026#34;:{ \u0026#34;analysis\u0026#34;:{ // 自定义分词器 \u0026#34;analyzer\u0026#34;:{ // 分词器名称 \u0026#34;my_analyzer\u0026#34;:{ \u0026#34;tokenizer\u0026#34;:\u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;:\u0026#34;py\u0026#34; } }, // 自定义tokenizer filter \u0026#34;filter\u0026#34;:{ // 过滤器名称 \u0026#34;py\u0026#34;:{ // 过滤器类型，这里是pinyin \u0026#34;type\u0026#34; : \u0026#34;pinyin\u0026#34;, \u0026#34;keep_full_pinyin\u0026#34; : false, \u0026#34;keep_joined_full_pinyin\u0026#34; : true, // 是否要保留中文 \u0026#34;keep_original\u0026#34; : true, \u0026#34;limit_first_letter_length\u0026#34; : 16, \u0026#34;remove_duplicated_term\u0026#34; : true, \u0026#34;none_chinese_pinyin_tokenize\u0026#34; : false } } } } } # 例如 PUT /test { \u0026#34;settings\u0026#34;:{ \u0026#34;analysis\u0026#34;:{ // 自定义分词器 \u0026#34;analyzer\u0026#34;:{ // 分词器名称 \u0026#34;my_analyzer\u0026#34;:{ \u0026#34;tokenizer\u0026#34;:\u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;:\u0026#34;py\u0026#34; } }, // 自定义tokenizer filter \u0026#34;filter\u0026#34;:{ // 过滤器名称 \u0026#34;py\u0026#34;:{ // 过滤器类型，这里是pinyin \u0026#34;type\u0026#34; : \u0026#34;pinyin\u0026#34;, \u0026#34;keep_full_pinyin\u0026#34; : false, \u0026#34;keep_joined_full_pinyin\u0026#34; : true, // 是否要保留中文 \u0026#34;keep_original\u0026#34; : true, \u0026#34;limit_first_letter_length\u0026#34; : 16, \u0026#34;remove_duplicated_term\u0026#34; : true, \u0026#34;none_chinese_pinyin_tokenize\u0026#34; : false } } } }, \u0026#34;mappings\u0026#34;:{ \u0026#34;properties\u0026#34;:{ \u0026#34;name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;:\u0026#34;my_analyzer\u0026#34; } } } } 测试方法1\n1 2 3 4 5 POST /test/_analyze { \u0026#34;text\u0026#34;:[\u0026#34;建设祖国\u0026#34;], \u0026#34;analyzer\u0026#34;:\u0026#34;my_analyzer\u0026#34; } 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 { \u0026#34;tokens\u0026#34;: [ { \u0026#34;token\u0026#34;: \u0026#34;今天天气\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;jintiantianqi\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;jttq\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;今天\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;jintian\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;jt\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;天天\u0026#34;, \u0026#34;start_offset\u0026#34;: 1, \u0026#34;end_offset\u0026#34;: 3, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;tiantian\u0026#34;, \u0026#34;start_offset\u0026#34;: 1, \u0026#34;end_offset\u0026#34;: 3, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;tt\u0026#34;, \u0026#34;start_offset\u0026#34;: 1, \u0026#34;end_offset\u0026#34;: 3, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;天气\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 3 }, { \u0026#34;token\u0026#34;: \u0026#34;tianqi\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 3 }, { \u0026#34;token\u0026#34;: \u0026#34;tq\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 3 } ] } 测试方法2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 插入两条测试数据 POST /test/_doc/1 { \u0026#34;name\u0026#34;:\u0026#34;狮子\u0026#34; } POST /test/_doc/2 { \u0026#34;name\u0026#34;:\u0026#34;虱子\u0026#34; } # 查看插入数据 GET /test/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match_all\u0026#34;: {} } } GET /test/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;:\u0026#34;狮子很猛\u0026#34; } } } 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 { \u0026#34;took\u0026#34;: 8, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 2, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 0.33425623, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;_score\u0026#34;: 0.33425623, \u0026#34;_source\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;狮子\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;_score\u0026#34;: 0.3085442, \u0026#34;_source\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;虱子\u0026#34; } } ] } } 问题\r可以看到这里搜的是狮子，但是结果把虱子也搜到了 拼音分词器适合在创建倒排索引的时候使用，但不能在搜索的时候使用。 用户更希望 输入中文的时候，用中文进行分词搜索，而输入拼音的时候，用拼音来搜索，排除掉输入中文，使用拼音来搜，这样会搜索到同音字 因此字段在创建倒排索引时应该用my_analyzer分词器;字段在搜索时应该使用ik_smart分词器 为什么这么说呢？可以根据上图多揣摩揣摩 在插入文档狮子和虱子的时候，倒排索引中就出现了这四个词条，狮子、shizi、sz、虱子\n在搜索的时候，使用ik分词器，输入中文则会对应的中文词条，输入英文则会搜索到对应的英文词条\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 PUT /test { \u0026#34;settings\u0026#34;:{ \u0026#34;analysis\u0026#34;:{ \u0026#34;analyzer\u0026#34;:{ \u0026#34;my_analyzer\u0026#34;:{ \u0026#34;tokenizer\u0026#34;:\u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;:\u0026#34;py\u0026#34; } }, \u0026#34;filter\u0026#34;:{ \u0026#34;py\u0026#34;:{ \u0026#34;type\u0026#34; : \u0026#34;pinyin\u0026#34;, \u0026#34;keep_full_pinyin\u0026#34; : false, \u0026#34;keep_joined_full_pinyin\u0026#34; : true, \u0026#34;keep_original\u0026#34; : true, \u0026#34;limit_first_letter_length\u0026#34; : 16, \u0026#34;remove_duplicated_term\u0026#34; : true, \u0026#34;none_chinese_pinyin_tokenize\u0026#34; : false } } } }, \u0026#34;mappings\u0026#34;:{ \u0026#34;properties\u0026#34;:{ \u0026#34;name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;:\u0026#34;my_analyzer\u0026#34;, // 指定ik_smart分词器 \u0026#34;search_analyzer\u0026#34;:\u0026#34;ik_smart\u0026#34; } } } } 继续上述测试方法，结果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { \u0026#34;took\u0026#34;: 0, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 1, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 0.9530773, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;_score\u0026#34;: 0.9530773, \u0026#34;_source\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;狮子\u0026#34; } } ] } } completion suggester查询\relasticsearch提供了Completion Suggester查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 PUT /test2 { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;completion\u0026#34; } } } } // 示例数据 POST /test2/_doc { \u0026#34;title\u0026#34;:[\u0026#34;Sony\u0026#34;,\u0026#34;WH-1000XM3\u0026#34;] } POST /test2/_doc { \u0026#34;title\u0026#34;:[\u0026#34;SK-II\u0026#34;,\u0026#34;PITERA\u0026#34;] } POST /test2/_doc { \u0026#34;title\u0026#34;:[\u0026#34;Nintendo\u0026#34;,\u0026#34;Switch\u0026#34;] } 查询语法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET /test2/_search { \u0026#34;suggest\u0026#34;:{ // 自定义自动补全的名称 \u0026#34;title_suggest\u0026#34;:{ // 关键字 \u0026#34;text\u0026#34;:\u0026#34;s\u0026#34;, \u0026#34;completion\u0026#34;:{ // 补全查询的字段 \u0026#34;field\u0026#34;:\u0026#34;title\u0026#34;, // 跳过重复 \u0026#34;skip_duplicates\u0026#34;:true, // 获取前10条结果 \u0026#34;size\u0026#34;:10 } } } } 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \u0026#34;took\u0026#34;: 878, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 0, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: null, \u0026#34;hits\u0026#34;: [] }, \u0026#34;suggest\u0026#34;: { \u0026#34;title_suggest\u0026#34;: [ { \u0026#34;text\u0026#34;: \u0026#34;s\u0026#34;, \u0026#34;offset\u0026#34;: 0, \u0026#34;length\u0026#34;: 1, \u0026#34;options\u0026#34;: [ { \u0026#34;text\u0026#34;: \u0026#34;SK-II\u0026#34;, \u0026#34;_index\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;0_HglI4BYJfEHegm4Kw4\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;title\u0026#34;: [ \u0026#34;SK-II\u0026#34;, \u0026#34;PITERA\u0026#34; ] } }, { \u0026#34;text\u0026#34;: \u0026#34;Sony\u0026#34;, \u0026#34;_index\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;0vHglI4BYJfEHegm2qwt\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;title\u0026#34;: [ \u0026#34;Sony\u0026#34;, \u0026#34;WH-1000XM3\u0026#34; ] } }, { \u0026#34;text\u0026#34;: \u0026#34;Switch\u0026#34;, \u0026#34;_index\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1PHglI4BYJfEHegm5qyP\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;title\u0026#34;: [ \u0026#34;Nintendo\u0026#34;, \u0026#34;Switch\u0026#34; ] } } ] } ] } } hotel索引库的自动补全、拼音搜索功能\r实现思路如下\n修改hotel索引库结构，设置自定义拼音分词器 修改索引库的name、all字段，使用自定义分词器 索引库添加一个新字段suggestion,类型为completion类型，使用自定义的分词器 给HotelDoc类添加suggestion字段,内容包含brand、business 重新导入数据到hotel库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 酒店数据索引库 PUT /hotel { \u0026#34;settings\u0026#34;: { \u0026#34;analysis\u0026#34;: { \u0026#34;analyzer\u0026#34;: { \u0026#34;text_anlyzer\u0026#34;: { \u0026#34;tokenizer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;: \u0026#34;py\u0026#34; }, // 参与自动补全的词条本来是固定的，无需进行分词 \u0026#34;completion_analyzer\u0026#34;: { \u0026#34;tokenizer\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;filter\u0026#34;: \u0026#34;py\u0026#34; } }, \u0026#34;filter\u0026#34;: { \u0026#34;py\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;pinyin\u0026#34;, \u0026#34;keep_full_pinyin\u0026#34;: false, \u0026#34;keep_joined_full_pinyin\u0026#34;: true, \u0026#34;keep_original\u0026#34;: true, \u0026#34;limit_first_letter_length\u0026#34;: 16, \u0026#34;remove_duplicated_term\u0026#34;: true, \u0026#34;none_chinese_pinyin_tokenize\u0026#34;: false } } } }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;id\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;name\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;text_anlyzer\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;address\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;price\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;score\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;brand\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;city\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;starName\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;business\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;location\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;geo_point\u0026#34; }, \u0026#34;pic\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;all\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, // 创建索引时，使用拼音 \u0026#34;analyzer\u0026#34;: \u0026#34;text_anlyzer\u0026#34;, // 搜索时使用ik_smart，而不需要拼音 \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;suggestion\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;completion\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;completion_analyzer\u0026#34; } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @Data @AllArgsConstructor @NoArgsConstructor @Document(indexName = \u0026#34;hotel\u0026#34;,createIndex = true) public class HotelDoc { @Id @Field(type = FieldType.Keyword) private Long id; @Field(type = FieldType.Text) private String name; @Field(type = FieldType.Keyword) private String address; @Field(type = FieldType.Integer) private Integer price; @Field(type = FieldType.Integer) private Integer score; @Field(type = FieldType.Keyword) private String brand; @Field(type = FieldType.Keyword) private String city; @Field(type = FieldType.Keyword) private String starName; @Field(type = FieldType.Keyword) private String business; /** * 位置 */ @GeoPointField private GeoPoint location; @Field(type = FieldType.Keyword) private String pic; /** * 距离 */ private Double distance; /** * 是广告 */ private Boolean isAd; /** * 自动补全 */ @Field(type = FieldType.Keyword) private List\u0026lt;String\u0026gt; suggestion; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location=new GeoPoint(Double.parseDouble(hotel.getLatitude()),Double.parseDouble(hotel.getLongitude())); this.pic = hotel.getPic(); // 判断是否有多个值 if(this.business.contains(\u0026#34;/\u0026#34;)){ // 商圈是否被\u0026#34;/\u0026#34;分割 String[] arr = this.business.split(\u0026#34;/\u0026#34;); // 添加元素 this.suggestion=new ArrayList\u0026lt;\u0026gt;(); Collections.addAll(this.suggestion,arr); }else { this.suggestion= Arrays.asList(this.brand,this.business); } } } 导入数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 批量插入文档 * GET /hotel/_doc/36934 * GET /hotel/_doc/38609 */ @Test public void batchInsertTest () throws IOException { List\u0026lt;Hotel\u0026gt; hotels = hotelService.list(); List\u0026lt;BulkOperation\u0026gt; bulkOperationList = new ArrayList\u0026lt;\u0026gt;(); for (Hotel hotel : hotels) { HotelDoc hotelDoc = new HotelDoc(hotel); bulkOperationList.add(new BulkOperation.Builder().create(e -\u0026gt; e.document(hotelDoc).id(hotel.getId().toString())).build()); } BulkResponse bulkResponse = elasticsearchClient.bulk(bulkRequest -\u0026gt; bulkRequest.index(INDEX_NAME).operations(bulkOperationList) ); // 这边插入成功的话显示的是 false log.info(\u0026#34;== errors: {}\u0026#34;, bulkResponse.errors()); } 在kibana中测试一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 GET /hotel/_search { \u0026#34;suggest\u0026#34;:{ \u0026#34;suggestions\u0026#34;:{ \u0026#34;text\u0026#34;:\u0026#34;sd\u0026#34;, \u0026#34;completion\u0026#34;:{ \u0026#34;field\u0026#34;:\u0026#34;suggestion\u0026#34;, \u0026#34;skip_duplicates\u0026#34;:true, \u0026#34;size\u0026#34;:10 } } } } 查询结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 { \u0026#34;took\u0026#34;: 1, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 0, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: null, \u0026#34;hits\u0026#34;: [] }, \u0026#34;suggest\u0026#34;: { \u0026#34;suggestions\u0026#34;: [ { \u0026#34;text\u0026#34;: \u0026#34;sd\u0026#34;, \u0026#34;offset\u0026#34;: 0, \u0026#34;length\u0026#34;: 2, \u0026#34;options\u0026#34;: [ { \u0026#34;text\u0026#34;: \u0026#34;上地产业园/西三旗\u0026#34;, \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2359697\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 2359697, \u0026#34;name\u0026#34;: \u0026#34;如家酒店(北京上地安宁庄东路店)\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;清河小营安宁庄东路18号20号楼\u0026#34;, \u0026#34;price\u0026#34;: 420, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;二钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;上地产业园/西三旗\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 40.041322, \u0026#34;lon\u0026#34;: 116.333316 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/2wj2f8mo9WZQCmzm51cwkZ9zvyp8_w200_h200_c1_t0.jpg\u0026#34;, \u0026#34;suggestion\u0026#34;: [ \u0026#34;如家\u0026#34;, \u0026#34;上地产业园/西三旗\u0026#34; ] } }, { \u0026#34;text\u0026#34;: \u0026#34;首都机场/新国展地区\u0026#34;, \u0026#34;_index\u0026#34;: \u0026#34;hotel\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;395702\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;id\u0026#34;: 395702, \u0026#34;name\u0026#34;: \u0026#34;北京首都机场希尔顿酒店\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;首都机场3号航站楼三经路1号\u0026#34;, \u0026#34;price\u0026#34;: 222, \u0026#34;score\u0026#34;: 46, \u0026#34;brand\u0026#34;: \u0026#34;希尔顿\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;starName\u0026#34;: \u0026#34;五钻\u0026#34;, \u0026#34;business\u0026#34;: \u0026#34;首都机场/新国展地区\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 40.048969, \u0026#34;lon\u0026#34;: 116.619566 }, \u0026#34;pic\u0026#34;: \u0026#34;https://m.tuniucdn.com/fb2/t1/G6/M00/52/10/Cii-U13ePtuIMRSjAAFZ58NGQrMAAGKMgADZ1QAAVn_167_w200_h200_c1_t0.jpg\u0026#34;, \u0026#34;suggestion\u0026#34;: [ \u0026#34;希尔顿\u0026#34;, \u0026#34;首都机场/新国展地区\u0026#34; ] } } ] } ] } } RestApi实现\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.elasticsearch.core.search.CompletionSuggest; import co.elastic.clients.elasticsearch.core.search.CompletionSuggestOption; import co.elastic.clients.elasticsearch.core.search.Suggestion; import com.example.domain.doc.HotelDoc; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; import java.util.List; /** * 自动补全测试 * * @author: 不是菜狗爱编程 * @date: 2024/04/01/7:13 * @description: */ @SpringBootTest class CompletionTest { private static final String INDEX_NAME = \u0026#34;hotel\u0026#34;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 自动补全测试 */ @Test void completionTest() throws IOException { SearchRequest.Builder searchBuilder = new SearchRequest.Builder(); // 设置自动补全名称 searchBuilder.index(INDEX_NAME).suggest(suggester -\u0026gt; suggester.suggesters(\u0026#34;suggestions\u0026#34;, // 搜索关键字 suggesters -\u0026gt; suggesters.text(\u0026#34;sh\u0026#34;).completion( // 补全字段 completionSuggester -\u0026gt; completionSuggester.field(\u0026#34;suggestion\u0026#34;) // 跳过重复项 .skipDuplicates(true) // 条数 .size(10) ) )); SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(searchBuilder.build(), HotelDoc.class); // 根据自动补全名称来获取 List\u0026lt;Suggestion\u0026lt;HotelDoc\u0026gt;\u0026gt; suggestions = search.suggest().get(\u0026#34;suggestions\u0026#34;); for (Suggestion\u0026lt;HotelDoc\u0026gt; suggestion : suggestions) { CompletionSuggest\u0026lt;HotelDoc\u0026gt; completion = suggestion.completion(); for (CompletionSuggestOption\u0026lt;HotelDoc\u0026gt; option : completion.options()) { String text = option.text(); System.out.println(\u0026#34;text = \u0026#34; + text); } } } } 黑马旅游实现输入框自动补全\r请求url为/hotel/suggestion?key=xxx\n1 2 3 4 5 6 7 8 9 10 @RestController @RequestMapping(\u0026#34;hotel\u0026#34;) public class SearchController { @Autowired private HotelService hotelService; @GetMapping(\u0026#34;/suggestion\u0026#34;) public List\u0026lt;String\u0026gt; suggestion(@RequestParam(\u0026#34;key\u0026#34;) String prefix){ return hotelService.getSuggestions(prefix); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 package com.example.service.impl; import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.DistanceUnit; import co.elastic.clients.elasticsearch._types.FieldValue; import co.elastic.clients.elasticsearch._types.SortOrder; import co.elastic.clients.elasticsearch._types.aggregations.Aggregate; import co.elastic.clients.elasticsearch._types.aggregations.Aggregation; import co.elastic.clients.elasticsearch._types.aggregations.AggregationBuilders; import co.elastic.clients.elasticsearch._types.aggregations.StringTermsBucket; import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery; import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreMode; import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreQuery; import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.elasticsearch.core.search.*; import co.elastic.clients.json.JsonData; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.example.domain.Hotel; import com.example.domain.PageEntity; import com.example.domain.SearchParams; import com.example.domain.doc.HotelDoc; import com.example.mapper.HotelMapper; import com.example.service.HotelService; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.util.CollectionUtils; import java.io.IOException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */ @Service public class HotelServiceImpl extends ServiceImpl\u0026lt;HotelMapper, Hotel\u0026gt; implements HotelService { private static final String INDEX_NAME = \u0026#34;hotel\u0026#34;; @Autowired private ElasticsearchClient elasticsearchClient; @Override public List\u0026lt;String\u0026gt; getSuggestions(String prefix) { try { // 返回自动补全结果 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); SearchRequest.Builder searchBuilder = new SearchRequest.Builder(); // 设置自动补全名称 searchBuilder.index(INDEX_NAME).suggest(suggester -\u0026gt; suggester.suggesters(\u0026#34;suggestions\u0026#34;, // 搜索关键字 suggesters -\u0026gt; suggesters.text(prefix).completion( // 补全字段 completionSuggester -\u0026gt; completionSuggester.field(\u0026#34;suggestion\u0026#34;) // 跳过重复项 .skipDuplicates(true) // 条数 .size(10) ) )); SearchResponse\u0026lt;HotelDoc\u0026gt; search = elasticsearchClient.search(searchBuilder.build(), HotelDoc.class); // 根据自动补全名称来获取 List\u0026lt;Suggestion\u0026lt;HotelDoc\u0026gt;\u0026gt; suggestions = search.suggest().get(\u0026#34;suggestions\u0026#34;); for (Suggestion\u0026lt;HotelDoc\u0026gt; suggestion : suggestions) { CompletionSuggest\u0026lt;HotelDoc\u0026gt; completion = suggestion.completion(); for (CompletionSuggestOption\u0026lt;HotelDoc\u0026gt; option : completion.options()) { String text = option.text(); list.add(text); } } return list; } catch (IOException e) { throw new RuntimeException(e); } } } 数据同步\r方案选择\relasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变,这个就是elasticsearch与mysql之间的数据同步。\n同步调用 存在问题：业务耦合对性能有影响\n异步通知 消除耦合，提升了性能\n监听binlog 对mysql的压力增加了 总结 方式一:同步调用 优点:实现简单,粗暴 缺点:业务耦合度高 方式二:异步通知 优点:低耦合,实现难度一般 缺点:依赖mq的可靠性 方式三:监听binlog 优点:完全解除服务间耦合 缺点:开启binlog增加数据库负担、实现复杂度高\nMQ实现数据同步\r集群\r","date":"2024-04-01T00:00:00Z","image":"http://localhost:1313/p/elasticsearct%E5%A4%8D%E4%B9%A0/202412212115512_hu9086345817820291088.png","permalink":"http://localhost:1313/p/elasticsearct%E5%A4%8D%E4%B9%A0/","title":"Elasticsearct复习"},{"content":"全新Activiti7工作流讲解\r一、Activiti7概述\r官网地址：https://www.activiti.org/ Activiti由Alfresco软件开发，目前最高版本Activiti 7。是BPMN的一个基于java的软件实现，不过Activiti 不仅仅包括BPMN，还有DMN决策表和CMMN Case管理引擎，并且有自己的用户管理、微服务API等一系列功能，是一个服务平台。 二、Activiti7的入门案例\r官方手册：http://jeecg.com/activiti5.21/\n1.创建SpringBoot项目\r现在开发中或者我们自己学习写案例都是通过SpringBoot脚手架工具来快速构建项目的。那么我们也就直接通过创建SpringBoot项目来给大家讲解相关的案例。创建一个普通的SpringBoot项目。指定版本为2.4.2即可 然后添加对应的依赖：Activiti7的依赖和MySQL的依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;2.4.2\u0026lt;/spring-boot.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.23\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.activiti\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activiti-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;7.0.0.GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;com.boge.act.PrepareDemo2Application\u0026lt;/mainClass\u0026gt; \u0026lt;skip\u0026gt;true\u0026lt;/skip\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;repackage\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;repackage\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 相关的Activiti依赖加载进来了 到这儿基本环境就OK了\n2.获取ProcessEngine\r2.1 默认的方式\r在工作流引擎框架中，ProcessEngine是一个非常核心的对象，我们需要首先解决这个对象的获取。获取方式很多。先来看最简单的一个基于activiti.cfg.xml的XML文件的配置方式。\n1 2 3 4 5 @Test public void test1(){ ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); System.out.println(processEngine); } 通过getDefaultProcessEngine方法加载会默认的从classpath路径下加载activiti.cfg.xml配置文件。我们添加该文件。内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;processEngineConfiguration\u0026#34; class=\u0026#34;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/activiti7\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;jdbcDriver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;jdbcUsername\u0026#34; value=\u0026#34;root\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;jdbcPassword\u0026#34; value=\u0026#34;123456\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;databaseSchemaUpdate\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;asyncExecutorActivate\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;mailServerHost\u0026#34; value=\u0026#34;mail.my-corp.com\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;mailServerPort\u0026#34; value=\u0026#34;5025\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 然后我们就可以启动，但是出现了如下错误： 出现这种情况只需要在mysql的连接字符串中添加上nullCatalogMeansCurrent=true，设置为只查当前连接的schema库即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;processEngineConfiguration\u0026#34; class=\u0026#34;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/activiti7?nullCatalogMeansCurrent=true\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;jdbcDriver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;jdbcUsername\u0026#34; value=\u0026#34;root\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;jdbcPassword\u0026#34; value=\u0026#34;123456\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;databaseSchemaUpdate\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;asyncExecutorActivate\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;mailServerHost\u0026#34; value=\u0026#34;mail.my-corp.com\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;mailServerPort\u0026#34; value=\u0026#34;5025\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 然后执行程序正确。搞定。同时在数据库中创建了相关的表结构 2.2 编程方式获取\r上面的配置文件的方式中的配置文件其实是一个Spring的配置文件，但是这并不意味着Activiti只能用于Spring环境。我们也可以通过编程的方式来使用配置文件，从而来构建ProcessEngineConfiguration对象，具体的实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 @Test public void test2(){ ProcessEngine engine = ProcessEngineConfiguration .createStandaloneInMemProcessEngineConfiguration() .setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/activiti7?nullCatalogMeansCurrent=true\u0026#34;) .setJdbcDriver(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;) .setJdbcPassword(\u0026#34;123456\u0026#34;) .setJdbcUsername(\u0026#34;root\u0026#34;) .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE) .buildProcessEngine(); System.out.println(engine); } 上面讲解中的相关属性说明： databaseSchemaUpdate：用于设置流程引擎启动关闭时使用的数据库表结构控制策略\nfalse (默认): 当引擎启动时，检查数据库表结构的版本是否匹配库文件版本。版本不匹配时抛出异常。 true: 构建引擎时，检查并在需要时更新表结构。表结构不存在则会创建。 create-drop: 引擎创建时创建表结构，并在引擎关闭时删除表结构。 2.3 表结构介绍\r在Activiti7中。我们启动服务会自动维护Activiti7需要使用到的相关的表结构。在这块我们需要有个大概的了解。首先是支持的数据库有：\nActiviti数据库类型 示例JDBC URL 备注 h2 jdbc:h2:tcp://localhost/activiti 默认配置的数据库 mysql jdbc:mysql://localhost:3306/activiti?autoReconnect=true 已使用mysql-connector-java数据库驱动测试 oracle jdbc:oracle:thin:@localhost:1521:xe postgres jdbc:postgresql://localhost:5432/activiti db2 jdbc:db2://localhost:50000/activiti mssql jdbc:sqlserver://localhost:1433;databaseName=activiti (jdbc.driver=com.microsoft.sqlserver.jdbc.SQLServerDriver) OR jdbc:jtds:sqlserver://localhost:1433/activiti (jdbc.driver=net.sourceforge.jtds.jdbc.Driver) 已使用Microsoft JDBC Driver 4.0 (sqljdb Activiti的所有数据库表都以**ACT_**开头。第二部分是说明表用途的两字符标示符。服务API的命名也大略符合这个规则。 ACT_RE_*: RE代表repository。带有这个前缀的表包含“静态”信息，例如流程定义与流程资源（图片、规则等）。 ACT_RU_*: RU代表runtime。这些表存储运行时信息，例如流程实例（process instance）、用户任务（user task）、变量（variable）、作业（job）等。Activiti只在流程实例运行中保存运行时数据，并在流程实例结束时删除记录。这样保证运行时表小和快。 ACT_ID_*: ID代表identity。这些表包含身份信息，例如用户、组等。 ACT_HI_*: HI代表history。这些表存储历史数据，例如已完成的流程实例、变量、任务等。 ACT_GE_*: 通用数据。用于不同场景下 注意：MySQL数据库最好使用5.7及以上的版本 3.在线流程设计器\r接下来我们通过官方提供的流程设计器来实现一个简单流程的设计。然后完成相关的部署和流程整体操作。 官网下载地址：https://www.activiti.org/get-started 下载下来后解压缩 进入到wars中。提供的有Activiti-app.war 把这war包拷贝到Tomcat服务器中即可。注意Tomcat的版本不要高于8.5，然后Tomcat服务。访问 http://localhost:8080/activiti-app 即可。登录的账号密码是 admin test 点击create process 弹出窗口。录入相关的流程定义信息 绘制好流程图后。保存并下载对应的xml文件 得到的流程图的xml内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;definitions xmlns=\u0026#34;http://www.omg.org/spec/BPMN/20100524/MODEL\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; xmlns:activiti=\u0026#34;http://activiti.org/bpmn\u0026#34; xmlns:bpmndi=\u0026#34;http://www.omg.org/spec/BPMN/20100524/DI\u0026#34; xmlns:omgdc=\u0026#34;http://www.omg.org/spec/DD/20100524/DC\u0026#34; xmlns:omgdi=\u0026#34;http://www.omg.org/spec/DD/20100524/DI\u0026#34; typeLanguage=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; expressionLanguage=\u0026#34;http://www.w3.org/1999/XPath\u0026#34; targetNamespace=\u0026#34;http://www.activiti.org/processdef\u0026#34;\u0026gt; \u0026lt;process id=\u0026#34;test1\u0026#34; name=\u0026#34;test1\u0026#34; isExecutable=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;documentation\u0026gt;test1\u0026lt;/documentation\u0026gt; \u0026lt;startEvent id=\u0026#34;startEvent1\u0026#34;\u0026gt;\u0026lt;/startEvent\u0026gt; \u0026lt;userTask id=\u0026#34;sid-470631FF-51BA-4954-96BB-346B99CA0A2C\u0026#34; name=\u0026#34;人事审批\u0026#34; activiti:assignee=\u0026#34;zhangsan\u0026#34;\u0026gt; \u0026lt;extensionElements\u0026gt; \u0026lt;modeler:initiator-can-complete xmlns:modeler=\u0026#34;http://activiti.com/modeler\u0026#34;\u0026gt;\u0026lt;![CDATA[false]]\u0026gt;\u0026lt;/modeler:initiator-can-complete\u0026gt; \u0026lt;/extensionElements\u0026gt; \u0026lt;/userTask\u0026gt; \u0026lt;sequenceFlow id=\u0026#34;sid-B53369E8-E698-4F53-AE40-97E7654BFA78\u0026#34; sourceRef=\u0026#34;startEvent1\u0026#34; targetRef=\u0026#34;sid-470631FF-51BA-4954-96BB-346B99CA0A2C\u0026#34;\u0026gt;\u0026lt;/sequenceFlow\u0026gt; \u0026lt;userTask id=\u0026#34;sid-34454522-B109-41C9-8519-59D29B621099\u0026#34; name=\u0026#34;经理审批\u0026#34; activiti:assignee=\u0026#34;lisi\u0026#34;\u0026gt; \u0026lt;extensionElements\u0026gt; \u0026lt;modeler:initiator-can-complete xmlns:modeler=\u0026#34;http://activiti.com/modeler\u0026#34;\u0026gt;\u0026lt;![CDATA[false]]\u0026gt;\u0026lt;/modeler:initiator-can-complete\u0026gt; \u0026lt;/extensionElements\u0026gt; \u0026lt;/userTask\u0026gt; \u0026lt;sequenceFlow id=\u0026#34;sid-5AE88ADE-9FD3-48F2-81EF-528DA0C068CB\u0026#34; sourceRef=\u0026#34;sid-470631FF-51BA-4954-96BB-346B99CA0A2C\u0026#34; targetRef=\u0026#34;sid-34454522-B109-41C9-8519-59D29B621099\u0026#34;\u0026gt;\u0026lt;/sequenceFlow\u0026gt; \u0026lt;endEvent id=\u0026#34;sid-EA0332FA-59B0-45C0-9D24-47C78051D52C\u0026#34;\u0026gt;\u0026lt;/endEvent\u0026gt; \u0026lt;sequenceFlow id=\u0026#34;sid-F6C0657A-C92F-4DEA-AAB1-93750FFBD7E5\u0026#34; sourceRef=\u0026#34;sid-34454522-B109-41C9-8519-59D29B621099\u0026#34; targetRef=\u0026#34;sid-EA0332FA-59B0-45C0-9D24-47C78051D52C\u0026#34;\u0026gt;\u0026lt;/sequenceFlow\u0026gt; \u0026lt;/process\u0026gt; \u0026lt;bpmndi:BPMNDiagram id=\u0026#34;BPMNDiagram_test1\u0026#34;\u0026gt; \u0026lt;bpmndi:BPMNPlane bpmnElement=\u0026#34;test1\u0026#34; id=\u0026#34;BPMNPlane_test1\u0026#34;\u0026gt; \u0026lt;bpmndi:BPMNShape bpmnElement=\u0026#34;startEvent1\u0026#34; id=\u0026#34;BPMNShape_startEvent1\u0026#34;\u0026gt; \u0026lt;omgdc:Bounds height=\u0026#34;30.0\u0026#34; width=\u0026#34;30.0\u0026#34; x=\u0026#34;100.0\u0026#34; y=\u0026#34;163.0\u0026#34;\u0026gt;\u0026lt;/omgdc:Bounds\u0026gt; \u0026lt;/bpmndi:BPMNShape\u0026gt; \u0026lt;bpmndi:BPMNShape bpmnElement=\u0026#34;sid-470631FF-51BA-4954-96BB-346B99CA0A2C\u0026#34; id=\u0026#34;BPMNShape_sid-470631FF-51BA-4954-96BB-346B99CA0A2C\u0026#34;\u0026gt; \u0026lt;omgdc:Bounds height=\u0026#34;80.0\u0026#34; width=\u0026#34;100.0\u0026#34; x=\u0026#34;175.0\u0026#34; y=\u0026#34;138.0\u0026#34;\u0026gt;\u0026lt;/omgdc:Bounds\u0026gt; \u0026lt;/bpmndi:BPMNShape\u0026gt; \u0026lt;bpmndi:BPMNShape bpmnElement=\u0026#34;sid-34454522-B109-41C9-8519-59D29B621099\u0026#34; id=\u0026#34;BPMNShape_sid-34454522-B109-41C9-8519-59D29B621099\u0026#34;\u0026gt; \u0026lt;omgdc:Bounds height=\u0026#34;80.0\u0026#34; width=\u0026#34;100.0\u0026#34; x=\u0026#34;320.0\u0026#34; y=\u0026#34;138.0\u0026#34;\u0026gt;\u0026lt;/omgdc:Bounds\u0026gt; \u0026lt;/bpmndi:BPMNShape\u0026gt; \u0026lt;bpmndi:BPMNShape bpmnElement=\u0026#34;sid-EA0332FA-59B0-45C0-9D24-47C78051D52C\u0026#34; id=\u0026#34;BPMNShape_sid-EA0332FA-59B0-45C0-9D24-47C78051D52C\u0026#34;\u0026gt; \u0026lt;omgdc:Bounds height=\u0026#34;28.0\u0026#34; width=\u0026#34;28.0\u0026#34; x=\u0026#34;465.0\u0026#34; y=\u0026#34;164.0\u0026#34;\u0026gt;\u0026lt;/omgdc:Bounds\u0026gt; \u0026lt;/bpmndi:BPMNShape\u0026gt; \u0026lt;bpmndi:BPMNEdge bpmnElement=\u0026#34;sid-5AE88ADE-9FD3-48F2-81EF-528DA0C068CB\u0026#34; id=\u0026#34;BPMNEdge_sid-5AE88ADE-9FD3-48F2-81EF-528DA0C068CB\u0026#34;\u0026gt; \u0026lt;omgdi:waypoint x=\u0026#34;275.0\u0026#34; y=\u0026#34;178.0\u0026#34;\u0026gt;\u0026lt;/omgdi:waypoint\u0026gt; \u0026lt;omgdi:waypoint x=\u0026#34;320.0\u0026#34; y=\u0026#34;178.0\u0026#34;\u0026gt;\u0026lt;/omgdi:waypoint\u0026gt; \u0026lt;/bpmndi:BPMNEdge\u0026gt; \u0026lt;bpmndi:BPMNEdge bpmnElement=\u0026#34;sid-F6C0657A-C92F-4DEA-AAB1-93750FFBD7E5\u0026#34; id=\u0026#34;BPMNEdge_sid-F6C0657A-C92F-4DEA-AAB1-93750FFBD7E5\u0026#34;\u0026gt; \u0026lt;omgdi:waypoint x=\u0026#34;420.0\u0026#34; y=\u0026#34;178.0\u0026#34;\u0026gt;\u0026lt;/omgdi:waypoint\u0026gt; \u0026lt;omgdi:waypoint x=\u0026#34;465.0\u0026#34; y=\u0026#34;178.0\u0026#34;\u0026gt;\u0026lt;/omgdi:waypoint\u0026gt; \u0026lt;/bpmndi:BPMNEdge\u0026gt; \u0026lt;bpmndi:BPMNEdge bpmnElement=\u0026#34;sid-B53369E8-E698-4F53-AE40-97E7654BFA78\u0026#34; id=\u0026#34;BPMNEdge_sid-B53369E8-E698-4F53-AE40-97E7654BFA78\u0026#34;\u0026gt; \u0026lt;omgdi:waypoint x=\u0026#34;130.0\u0026#34; y=\u0026#34;178.0\u0026#34;\u0026gt;\u0026lt;/omgdi:waypoint\u0026gt; \u0026lt;omgdi:waypoint x=\u0026#34;175.0\u0026#34; y=\u0026#34;178.0\u0026#34;\u0026gt;\u0026lt;/omgdi:waypoint\u0026gt; \u0026lt;/bpmndi:BPMNEdge\u0026gt; \u0026lt;/bpmndi:BPMNPlane\u0026gt; \u0026lt;/bpmndi:BPMNDiagram\u0026gt; \u0026lt;/definitions\u0026gt; 然后我们就可以做流程的部署操作了\n4.流程操作\r4.1 流程部署\r设计好了流程图我们就可以通过如下的代码完成流程的部署。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 流程部署操作 */ @Test public void test3(){ // 1.获取ProcessEngine对象 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); // 2.完成流程的部署操作 需要通过RepositoryService来完成 RepositoryService repositoryService = processEngine.getRepositoryService(); // 3.完成部署操作 Deployment deploy = repositoryService.createDeployment() .addClasspathResource(\u0026#34;flow/test1.bpmn20.xml\u0026#34;) .name(\u0026#34;第一个流程\u0026#34;) .deploy(); System.out.println(deploy.getId()); System.out.println(deploy.getName()); } 流程部署的行为会涉及到数据库中的这两张表 然后我们可以通过Activiti提供的相关的API来获取流程部署和流程定义的相关信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * 查询当前部署的流程有哪些 */ @Test public void test4(){ ProcessEngine engine = ProcessEngines.getDefaultProcessEngine(); RepositoryService repositoryService = engine.getRepositoryService(); // 查询有哪些部署的流程--》查询相关的流程定义信息 // repositoryService.createDeploymentQuery() 查询流程部署的相关信息 // repositoryService.createProcessDefinitionQuery() 查询部署的流程的相关的定义 List\u0026lt;Deployment\u0026gt; list = repositoryService.createDeploymentQuery().list(); // 查询所有的部署信息 for (Deployment deployment : list) { System.out.println(deployment.getId()); System.out.println(deployment.getName()); } List\u0026lt;ProcessDefinition\u0026gt; list1 = repositoryService.createProcessDefinitionQuery().list(); for (ProcessDefinition processDefinition : list1) { System.out.println(processDefinition.getId()); System.out.println(processDefinition.getName()); System.out.println(processDefinition.getDescription()); } } 4.2 发起流程\r部署流程成功后。我们就可以发起一个流程。发起流程需要通过RuntimeService来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 发起一个流程 */ @Test public void test5(){ ProcessEngine engine = ProcessEngines.getDefaultProcessEngine(); // 发起流程 需要通过 runtimeService来实现 RuntimeService runtimeService = engine.getRuntimeService(); // 通过流程定义ID来启动流程 返回的是流程实例对象 ProcessInstance processInstance = runtimeService .startProcessInstanceById(\u0026#34;test1:1:3\u0026#34;); System.out.println(\u0026#34;processInstance.getId() = \u0026#34; + processInstance.getId()); System.out.println(\u0026#34;processInstance.getDeploymentId() = \u0026#34; + processInstance.getDeploymentId()); System.out.println(\u0026#34;processInstance.getDescription() = \u0026#34; + processInstance.getDescription()); } 发起流程成功后。在对应的act_ru_task中就有一条对应的待办记录。 对应的流程状态如下： 4.3 查询流程\r用户登录后要查看待办的任务信息。我们需要通过TaskService来实现查询操作。具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 待办查询 */ @Test public void test6(){ ProcessEngine engine = ProcessEngines.getDefaultProcessEngine(); // 待办查询 执行中的任务处理通过 TaskService来实现 TaskService taskService = engine.getTaskService(); // Task 对象对应的其实就是 act_ru_task 这张表的记录 List\u0026lt;Task\u0026gt; list = taskService.createTaskQuery().taskAssignee(\u0026#34;lisi\u0026#34;).list(); if(list != null \u0026amp;\u0026amp; !list.isEmpty()){ for (Task task : list) { System.out.println(\u0026#34;task.getId() = \u0026#34; + task.getId()); System.out.println(\u0026#34;task.getName() = \u0026#34; + task.getName()); System.out.println(\u0026#34;task.getAssignee() = \u0026#34; + task.getAssignee()); } }else{ System.out.println(\u0026#34;当前没有待办任务\u0026#34;); } } 4.4 审批流程\r当前登录用户查看到相关的待办信息后。可以做流程的审批处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 任务审批 */ @Test public void test7(){ ProcessEngine engine = ProcessEngines.getDefaultProcessEngine(); // 做任务申请 也需要通过 TaskService 来实现 TaskService taskService = engine.getTaskService(); // 根据当前登录用户查询出对应的待办信息 List\u0026lt;Task\u0026gt; list = taskService.createTaskQuery().taskAssignee(\u0026#34;lisi\u0026#34;).list(); if(list != null \u0026amp;\u0026amp; list.size() \u0026gt; 0){ for (Task task : list) { // 做对应的任务审批处理 taskService.complete(task.getId()); } } // 完成任务 // taskService.complete(\u0026#34;2505\u0026#34;); } 5.涉及表结构\r上面一个审批涉及到的表结构的介绍\n表名 说明 act_re_deployment 部署流程的记录表：一次部署行为会产生一张表 act_re_procdef 流程定义表：一张流程图对应的表 act_hi_procinst 流程实例表：发起一个流程。就会创建对应的一张表 act_ru_task 流程待办表：当前需要审批的记录表，节点审批后就会被删除 act_hi_actinst 历史记录：流程审批节点的记录信息 三、表达式\r值表达式\r${}\n方法表达式\r方法表达式Method expression:调用一个方法， 可以带或不带参数。当调不带参数的方法时，要确保在方法名后添加空括号(以避免与值表达式混淆)。传递的参数可以是字面值,也可以是表达式，它们会被自动解析。例如:\n1 2 3 4 ${printer.print()} ${myBean.getAssignee()} ${myBean.addNewOrder(\u0026#39;orderName\u0026#39;)} ${myBean.doSomething(myVar,execution)} 监听器\r","date":"2024-03-01T00:00:00Z","image":"http://localhost:1313/p/activiti7/202412212108679_hu2780851740685485858.png","permalink":"http://localhost:1313/p/activiti7/","title":"Activiti7"},{"content":"Mockito\r基础\r当我们mock了某个对象后，调用该方法的时候是并不会去执行实际方法的逻辑的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class User { private String name = \u0026#34;小张\u0026#34;; private String gender = \u0026#34;男\u0026#34;; private Integer age = 15; } //================================= class MockitoTest { /** * 函数是否已执行 */ @Test void functionHasExecutedTest() { // 模拟user对象 User mockUser = mock(User.class); mockUser.setName(\u0026#34;呵呵呵\u0026#34;); mockUser.setGender(\u0026#34;女\u0026#34;); mockUser.setAge(11); System.out.println(\u0026#34;mockUser.getName() = \u0026#34; + mockUser.getName()); System.out.println(\u0026#34;mockUser.getGender() = \u0026#34; + mockUser.getGender()); System.out.println(\u0026#34;mockUser.getAge() = \u0026#34; + mockUser.getAge()); } } 查看覆盖率发现对应的get、set方法没有被调用过\n这也就是调用mock对象方法时，不会执行实际逻辑的意思\n验证方法被调用的次数\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import org.junit.jupiter.api.Test; import java.util.List; import static org.mockito.Mockito.*; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { /** * 函数是否已执行 */ @Test void functionHasExecutedTest(){ // 模拟创建List对象 List mockList = mock(List.class); // add(\u0026#34;星期一\u0026#34;)方法 mockList.add(\u0026#34;星期一\u0026#34;); // 校验add(\u0026#34;星期一\u0026#34;)方法的执行次数是否是1 // times(1)表示该方法执行了一次 verify(mockList,times(1)).add(\u0026#34;星期一\u0026#34;); } } 在Mocktio 4.10.0中还可以使用List mockList = mock();来mock对象，无需传入对应class\n模拟方法返回值\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.junit.jupiter.api.Test; import com.example.entity.User; import static org.mockito.Mockito.mock; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { /** * 函数是否已执行 */ @Test void functionHasExecutedTest() { // 真实user对象 User user = new User(); // 打印为小张 System.out.println(\u0026#34;user.getName() = \u0026#34; + user.getName()); // 模拟user对象 User mockUser = mock(User.class); // 打印为null，因为还没mock方法的返回值 System.out.println(\u0026#34;mockUser.getName() = \u0026#34; + mockUser.getName()); } } mock方法的返回值\nwhen(object.functionName()).thenReturn(result)来mock方法的返回值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.junit.jupiter.api.Test; import com.example.entity.User; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { /** * 函数是否已执行 */ @Test void functionHasExecutedTest() { // 真实user对象 User user = new User(); // 打印为小张 System.out.println(\u0026#34;user.getName() = \u0026#34; + user.getName()); // 模拟user对象 User mockUser = mock(User.class); // mock方法的返回值 when(mockUser.getName()).thenReturn(\u0026#34;小明\u0026#34;); // 打印为小明 System.out.println(\u0026#34;mockUser.getName() = \u0026#34; + mockUser.getName()); } } 当调用mockUser.getName()方法时，会返回小明 因为我们mock了该方法的返回值，所以并不会去走实际逻辑，而是直接返回我们mock的返回值小明\n模拟异常\rmock异常\nwhen(object.functionName()).thenThrow(throwable);来mock异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.example.entity.User; import org.junit.jupiter.api.Test; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { /** * 函数是否已执行 */ @Test void functionHasExecutedTest() { // 模拟user对象 User mockUser = mock(User.class); when(mockUser.getAge()).thenThrow(new RuntimeException(\u0026#34;年龄保密\u0026#34;)); System.out.println(\u0026#34;mockUser.getAge() = \u0026#34; + mockUser.getAge()); } } 使用doThrow来mock方法体的异常\ndoThrow(throwable).when(mockObject).functionName();\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.example.entity.User; import org.junit.jupiter.api.Test; import static org.mockito.Mockito.doThrow; import static org.mockito.Mockito.mock; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { /** * 函数是否已执行 */ @Test void functionHasExecutedTest() { // 模拟user对象 User mockUser = mock(User.class); doThrow(new RuntimeException(\u0026#34;年龄保密\u0026#34;)).when(mockUser).getAge(); System.out.println(\u0026#34;mockUser.getAge() = \u0026#34; + mockUser.getAge()); } } Mocktio可以配合Junit来使用更加优雅\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import com.example.entity.User; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.mockito.Mockito.doThrow; import static org.mockito.Mockito.mock; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { /** * 函数是否已执行 */ @Test void functionHasExecutedTest() { // 模拟user对象 User mockUser = mock(User.class); doThrow(new RuntimeException(\u0026#34;年龄保密\u0026#34;)).when(mockUser).getAge(); // 断言异常类型 RuntimeException runtimeException = assertThrows(RuntimeException.class, () -\u0026gt; { // 发生异常的代码块 System.out.println(\u0026#34;mockUser.getAge() = \u0026#34; + mockUser.getAge()); }); // 断言异常信息 assertEquals(\u0026#34;年龄保密\u0026#34;,runtimeException.getMessage()); } } 更多细节\r1 2 3 4 5 class MockitoTest { int generateInt(int num){ return num; } } 希望generateInt方法传入任意值，都返回1\nanyInt()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.mockito.ArgumentMatchers.anyInt; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { /** * 函数是否已执行 */ @Test void functionHasExecutedTest() { MockitoTest mockitoTest=mock(MockitoTest.class); when(mockitoTest.generateInt(anyInt())).thenReturn(1); assertEquals(mockitoTest.generateInt(2),1); } int generateInt(int num){ return num; } } atLeast(xxx)、atMost(xxx)mock方法调用的最小、最大次数\nverify(mockitoObject,atLeast(num)).functionName();\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import org.junit.jupiter.api.Test; import static org.mockito.ArgumentMatchers.anyInt; import static org.mockito.Mockito.*; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { /** * 函数是否已执行 */ @Test void functionHasExecutedTest() { MockitoTest mockitoTest=mock(MockitoTest.class); // 调用三次该方法 mockitoTest.generateInt(1); mockitoTest.generateInt(2); mockitoTest.generateInt(3); verify(mockitoTest,atLeast(3)).generateInt(anyInt()); } int generateInt(int num){ return num; } } when(mockitoTest.generateInt(anyInt())).thenReturn(2).thenReturn(1)支持链式调用\n表示第一次调用generateInt返回2，第二次调用返回1\n配合Junit断言使用，断言不一致则抛出AssertionFailedError异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.mockito.ArgumentMatchers.anyInt; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { /** * 函数是否已执行 */ @Test void functionHasExecutedTest() { MockitoTest mockitoTest = mock(MockitoTest.class); when(mockitoTest.generateInt(anyInt())) // 第一次调用返回2 .thenReturn(2) // 第二次调用返回1 .thenReturn(1); assertEquals(2,mockitoTest.generateInt(1)); assertEquals(1,mockitoTest.generateInt(2)); } int generateInt(int num) { return num; } } 验证执行顺序\n将需要排序的对象传入inOrder()方法中\n案例中add()方法和verify()的顺序不能反，一定要先执行模拟方法add，然后再verify 校验顺序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import org.junit.jupiter.api.Test; import org.mockito.InOrder; import java.util.List; import static org.mockito.Mockito.inOrder; import static org.mockito.Mockito.mock; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { /** * 函数是否已执行 */ @Test void functionHasExecutedTest() { List mockitoList1 = mock(List.class); List mockitoList2 = mock(List.class); mockitoList1.add(1); mockitoList2.add(1); mockitoList1.add(2); InOrder inOrder = inOrder(mockitoList1, mockitoList2); inOrder.verify(mockitoList1).add(1); inOrder.verify(mockitoList2).add(1); inOrder.verify(mockitoList1).add(2); } } 顺序不一致，则会抛出以下异常信息\n1 2 3 4 5 6 7 8 org.mockito.exceptions.verification.VerificationInOrderFailure: Verification in order failure Wanted but not invoked: list.add(1); -\u0026gt; at com.example.MockitoTest.functionHasExecutedTest(MockitoTest.java:30) Wanted anywhere AFTER following interaction: list.add(2); -\u0026gt; at com.example.MockitoTest.functionHasExecutedTest(MockitoTest.java:26) 注解\r@Mock\r@Mock代替Mockito.mock()方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import org.junit.jupiter.api.Test; import org.mockito.Mock; import org.springframework.boot.test.context.SpringBootTest; import java.util.List; import static org.mockito.Mockito.when; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ @SpringBootTest class MockitoTest { @Mock List\u0026lt;Integer\u0026gt; mockitoList; /** * 函数是否已执行 */ @Test void mockitoTest() { when(mockitoList.get(0)).thenReturn(1); System.out.println(\u0026#34;mockitoList.get(0) = \u0026#34; + mockitoList.get(0)); } } 注意@SpringBootTest\n或者使用如下写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import java.util.List; import static org.mockito.Mockito.when; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { private AutoCloseable closeable; @Mock List\u0026lt;Integer\u0026gt; mockitoList; @BeforeEach void init() { closeable = MockitoAnnotations.openMocks(this); } @AfterEach void destroy() { try { closeable.close(); } catch (Exception e) { throw new RuntimeException(e); } } /** * 函数是否已执行 */ @Test void mockitoTest() { when(mockitoList.get(0)).thenReturn(1); System.out.println(\u0026#34;mockitoList.get(0) = \u0026#34; + mockitoList.get(0)); } } @Spy\r@Spy用于返回一个真实的对象，@Mock返回的是一个模拟的假对象\n除非使用when(xxx).thenReturn(xxx)为其设置返回值，否则将会执行真实的业务逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import com.example.entity.User; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.mockito.MockitoAnnotations; import org.mockito.Spy; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { private AutoCloseable closeable; @Spy User mockUser; @BeforeEach void init() { closeable = MockitoAnnotations.openMocks(this); } @AfterEach void destroy() { try { closeable.close(); } catch (Exception e) { throw new RuntimeException(e); } } /** * 函数是否已执行 */ @Test void mockitoTest() { System.out.println(\u0026#34;mockUser.getName() = \u0026#34; + mockUser.getName()); } } 可以看到这里执行了getName方法的真实逻辑\n@Captor\r捕获方法的参数，进行进一步的校验\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.mockito.ArgumentCaptor; import org.mockito.Captor; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import java.util.Map; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { private AutoCloseable closeable; @Mock Map\u0026lt;Integer,String\u0026gt; mockMap; @Captor ArgumentCaptor\u0026lt;Integer\u0026gt; key; @Captor ArgumentCaptor\u0026lt;String\u0026gt; value; @BeforeEach void init() { closeable = MockitoAnnotations.openMocks(this); } @AfterEach void destroy() { try { closeable.close(); } catch (Exception e) { throw new RuntimeException(e); } } /** * 函数是否已执行 */ @Test void mockitoTest() { mockMap.put(1,\u0026#34;星期一\u0026#34;); verify(mockMap,times(1)).put(key.capture(),value.capture()); assertEquals(1,key.getValue()); assertEquals(\u0026#34;星期一\u0026#34;,value.getValue()); } } @InjectMocks\r@InjectMocks注解可以注入指定的Bean，但是和@Autowired有些区别\n1 2 3 4 5 6 7 8 9 @Component public class UserMapper { public User selectUserByName(String name){ User user = new User(); user.setName(name); System.out.println(\u0026#34;mapper真实逻辑已执行\u0026#34;); return user; } } 1 2 3 4 5 6 7 8 9 @Service public class UserService { @Autowired private UserMapper userMapper; public User getUserByName(String name){ System.out.println(\u0026#34;service真实逻辑已执行\u0026#34;); return userMapper.selectUserByName(name); } } 这样注入UserService在执行时会报错NullPointerException\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import com.example.entity.User; import com.example.service.UserService; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.mockito.InjectMocks; import org.mockito.MockitoAnnotations; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { private AutoCloseable closeable; @InjectMocks UserService userService; @BeforeEach void init() { closeable = MockitoAnnotations.openMocks(this); } @AfterEach void destroy() { try { closeable.close(); } catch (Exception e) { throw new RuntimeException(e); } } /** * 函数是否已执行 */ @Test void mockitoTest() { User userByName = userService.getUserByName(\u0026#34;李四\u0026#34;); System.out.println(\u0026#34;userByName = \u0026#34; + userByName); } } 因为此时只注入了UserService，而UserMapper并没有被注入\n请看如下两种写法\n使用@Spy来mockUserMapper\n使用@Mock来mockUserMapper\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import com.example.entity.User; import com.example.mapper.UserMapper; import com.example.service.UserService; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.mockito.InjectMocks; import org.mockito.MockitoAnnotations; import org.mockito.Spy; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { private AutoCloseable closeable; @InjectMocks UserService userService; @Spy UserMapper userMapper; @BeforeEach void init() { closeable = MockitoAnnotations.openMocks(this); } @AfterEach void destroy() { try { closeable.close(); } catch (Exception e) { throw new RuntimeException(e); } } /** * 函数是否已执行 */ @Test void mockitoTest() { User userByName = userService.getUserByName(\u0026#34;李四\u0026#34;); System.out.println(\u0026#34;userByName = \u0026#34; + userByName); } } 以上代码会执行UserMapper的getUserByName方法的真实逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import com.example.entity.User; import com.example.mapper.UserMapper; import com.example.service.UserService; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import static org.mockito.Mockito.when; /** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */ class MockitoTest { private AutoCloseable closeable; @InjectMocks UserService userService; @Mock UserMapper userMapper; @BeforeEach void init() { closeable = MockitoAnnotations.openMocks(this); } @AfterEach void destroy() { try { closeable.close(); } catch (Exception e) { throw new RuntimeException(e); } } /** * 函数是否已执行 */ @Test void mockitoTest() { User mockUser = new User(); mockUser.setName(\u0026#34;张三\u0026#34;); // mock方法返回值 when(userMapper.selectUserByName(\u0026#34;李四\u0026#34;)).thenReturn(mockUser); User userByName = userService.getUserByName(\u0026#34;李四\u0026#34;); System.out.println(\u0026#34;userByName = \u0026#34; + userByName); } } 而以上代码并不会去执行真实逻辑\n而是返回mock的返回值张三\n","date":"2024-03-01T00:00:00Z","image":"http://localhost:1313/p/mockito/202412212122932_hu15592126295959117144.png","permalink":"http://localhost:1313/p/mockito/","title":"Mockito"},{"content":"Nginx\r参考博客 前端正常显示，但是请求404 比如http://192.168.56.10/api/user/list报404，后端请求http://192.168.56.10:8080/user/list正常显示 出现问题的nginx配置如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; server { listen 80; server_name localhost; location ^~/api/{ proxy_pass http://192.168.56.10:8080/; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } include /etc/nginx/conf.d/*.conf;表示使用的是conf.d下的default.conf文件 将/etc/nginx/nginx.conf文件改成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } 将/etc/nginx/conf.d/default.conf文件改成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 server { listen 80; listen [::]:80; server_name localhost; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } location ^~/api/{ proxy_pass http://192.168.56.10:8080/; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache\u0026#39;s document root # concurs with nginx\u0026#39;s one # #location ~ /\\.ht { # deny all; #} } 主要是在/etc/nginx/conf.d/default.conf文件里添加这一段代码\n1 2 3 location ^~/api/{ proxy_pass http://192.168.56.10:8080/; } 扩展\n1 2 3 location ^~/api/{ proxy_pass http://192.168.56.10:8080; } http://192.168.56.10/api/user/list结果为http://192.168.56.10:8080/api/user/list\n1 2 3 location ^~/api/{ proxy_pass http://192.168.56.10:8080/; } http://192.168.56.10/api/user/list结果为http://192.168.56.10:8080/user/list\n1 2 3 location ^~/api/{ proxy_pass http://192.168.56.10:8080/test; } http://192.168.56.10/api/user/list结果为http://192.168.56.10:8080/test/user/list\n","date":"2024-03-01T00:00:00Z","image":"http://localhost:1313/p/nginx%E6%8A%A5%E9%94%99/202412212222986_hu7299803662963343624.png","permalink":"http://localhost:1313/p/nginx%E6%8A%A5%E9%94%99/","title":"Nginx报错"},{"content":"配置全局组件\r这里封装一个全局组件Global.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;global-component\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; 全局组件 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; #global-component{ border: 1px solid black; margin: 10px 10px; line-height: 25px; width: 80px; height: 25px; } \u0026lt;/style\u0026gt; 在main.ts引入注册，类似element注册\n1 2 3 4 5 6 7 // main.ts // 如果您正在使用CDN引入，请删除下面一行。 import * as ElementPlusIconsVue from \u0026#39;@element-plus/icons-vue\u0026#39; const app = createApp(App) for (const [key, component] of Object.entries(ElementPlusIconsVue)) { app.component(key, component) } 1 2 3 4 5 6 import {createApp} from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import Global from \u0026#34;@/view/Global.vue\u0026#34;; const app = createApp(App) app.component(\u0026#39;Global\u0026#39;,Global) app.mount(\u0026#39;#app\u0026#39;) 在其他vue页面 立即使用即可 无需引入\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;Global/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; 批量注册全局组件\r可以参考element ui 其实就是遍历一下然后通过 app.component 注册 配置局部组件\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;wraps\u0026#34;\u0026gt; \u0026lt;layout-menu :flag=\u0026#34;flag\u0026#34; @on-click=\u0026#34;getMenu\u0026#34; @on-toogle=\u0026#34;getMenuItem\u0026#34; :data=\u0026#34;menuList\u0026#34; class=\u0026#34;wraps-left\u0026#34;\u0026gt;\u0026lt;/layout-menu\u0026gt; \u0026lt;div class=\u0026#34;wraps-right\u0026#34;\u0026gt; \u0026lt;layout-header\u0026gt; \u0026lt;/layout-header\u0026gt; \u0026lt;layout-main class=\u0026#34;wraps-right-main\u0026#34;\u0026gt;\u0026lt;/layout-main\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { reactive,ref } from \u0026#34;vue\u0026#34;; import layoutHeader from \u0026#34;./Header.vue\u0026#34;; import layoutMenu from \u0026#34;./Menu.vue\u0026#34;; import layoutMain from \u0026#34;./Content.vue\u0026#34;; 就是在一个组件内（A） 通过import 去引入别的组件(B) 称之为局部组件 应为B组件只能在A组件内使用 所以是局部组件 如果C组件想用B组件 就需要C组件也手动import 引入 B 组件\n配置递归组件\r原理跟我们写js递归是一样的 自己调用自己 通过一个条件来结束递归 否则导致内存泄漏 案例递归树 在父组件配置数据结构 数组对象格式 传给子组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;template\u0026gt; \u0026lt;TreeCom :data=\u0026#34;data\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive} from \u0026#34;vue\u0026#34;; import TreeCom from \u0026#34;@/view/TreeCom.vue\u0026#34;; type TreeProps = { name: string, icon?: string, children?: TreeProps[] | [] } const data = reactive\u0026lt;TreeProps[]\u0026gt;([ { name: \u0026#34;no.1\u0026#34;, children: [ { name: \u0026#34;no.1-1\u0026#34;, children: [ { name: \u0026#34;no.1-1-1\u0026#34;, }, ], }, ], }, { name: \u0026#34;no.2\u0026#34;, children: [ { name: \u0026#34;no.2-1\u0026#34;, }, ], }, { name: \u0026#34;no.3\u0026#34;, }, ]) \u0026lt;/script\u0026gt; 子组件接收值 第一个script\n1 2 3 4 5 6 7 8 type TreeProps = { name: string, icon?: string, children?: TreeProps[] | [] } let props=defineProps\u0026lt;{ data:TreeProps[] }\u0026gt;(); 子组件增加一个script 定义组件名称为了 递归用\r给我们的组件定义名称有好几种方式\r1.在增加一个script 通过 export 添加name\r1 2 3 4 5 \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name:\u0026#34;TreeItem\u0026#34; } \u0026lt;/script\u0026gt; 2.直接使用文件名当组件名\r3.使用插件 unplugin-vue-macros/README-zh-CN.md at 722a80795a6c7558debf7c62fd5f57de70e0d0bf · sxzz/unplugin-vue-macros · GitHub unplugin-vue-define-options\n1 2 3 4 5 import DefineOptions from \u0026#39;unplugin-vue-define-options/vite\u0026#39; import Vue from \u0026#39;@vitejs/plugin-vue\u0026#39; export default defineConfig({ plugins: [Vue(), DefineOptions()], }) ts支持\n1 \u0026#34;types\u0026#34;: [\u0026#34;unplugin-vue-define-options/macros-global\u0026#34;], template TreeItem 其实就是当前组件 通过import 把自身又引入了一遍 如果他没有children 了就结束\n1 2 3 4 5 6 7 \u0026lt;div style=\u0026#34;margin-left:10px;\u0026#34; class=\u0026#34;tree\u0026#34;\u0026gt; \u0026lt;div :key=\u0026#34;index\u0026#34; v-for=\u0026#34;(item,index) in data\u0026#34;\u0026gt; \u0026lt;div @click=\u0026#39;clickItem(item)\u0026#39;\u0026gt;{{item.name}} \u0026lt;/div\u0026gt; \u0026lt;TreeItem @on-click=\u0026#39;clickItem\u0026#39; v-if=\u0026#39;item?.children?.length\u0026#39; :data=\u0026#34;item.children\u0026#34;\u0026gt;\u0026lt;/TreeItem\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div v-for=\u0026#34;(item,index) in data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34;\u0026gt;\u0026lt;span\u0026gt;{{item.name}}\u0026lt;/span\u0026gt; \u0026lt;TreeCom v-if=\u0026#34;item?.children?.length\u0026#34; :data=\u0026#34;item.children\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; type TreeProps = { name: string, icon?: string, children?: TreeProps[] | [] } let props=defineProps\u0026lt;{ data:TreeProps[] }\u0026gt;(); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; div{ margin-left: 10px; } \u0026lt;/style\u0026gt; ","date":"2024-02-16T00:00:00Z","image":"http://localhost:1313/p/10.%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/10.%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6/","title":"10.全局组件、局部组件、递归组件"},{"content":"Junit测试\r这里使用junit5进行演示\n正常的情况\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /** * @Author: 不是菜鸡爱编程 * @Date: 2023/11/29/21:30 * @Description: */ public class Calculate { /** * 加 * * @param i 我 * @param j j * @return int */ public static int add(int i,int j){ return i+j; } /** * 减 * * @param i 我 * @param j j * @return int */ public static int sub(int i,int j){ return i-j; } /** * 乘 * * @param i 我 * @param j j * @return int */ public static int multi(int i,int j){ return i*j; } /** * 除 * * @param i 我 * @param j j * @return int */ public static int div(int i,int j){ return i/j; } } 有以上类，我们需要进行测试\n在idea中按住Ctrl+Shift+T 勾选方法 会生成以下模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class CalculateTest { @Test void add() { } @Test void sub() { } @Test void multi() { } @Test void div() { } } 我们将使用断言Assert来完成测试 我们将预期值与实际值进行比较 可以看到100%测试覆盖率 注释掉一个测试方法后，导致测试覆盖率不足100%，因为有部分代码未被测试到 修改预期值后导致测试方法不通过\n异常的情况\r在Calculate中添加一个方法throwException\n1 2 3 4 5 6 public class Calculate { // ... public static void throwException(){ throw new IllegalStateException(); } } 可能抛出异常的方法该如何测试？ 测试方法1 设置一个标志位\n捕获到异常后，更改标志位\n断言标志位为True\n1 2 3 4 5 6 7 8 9 10 @Test void throwException() { boolean flag=false; try { Calculate.throwException(); } catch (IllegalStateException e) { flag=true; } assertTrue(flag); } 测试方法2\n后面是lambda表达式\n1 2 3 4 @Test void throwException() { assertThrows(IllegalStateException.class, Calculate::throwException); } junit4可使用如下写法\n1 2 3 4 5 @Test(expected=IndexOutOfBoundsException.class) public void testIndexOutOfBoundsException() { ArrayList emptyList = new ArrayList(); Object o = emptyList.get(0); } ","date":"2024-02-16T00:00:00Z","image":"http://localhost:1313/p/junit/202412212121680_hu6671927515246374568.png","permalink":"http://localhost:1313/p/junit/","title":"Junit"},{"content":"测试环境概述 服务器端 操作系统：Windows Server 2008 企业版 64位 Oracle软件：Oracle 11g 64位 客户端 操作系统： Windows 7 64位 图形界面工具：PL/SQL Developer14.0.5 64位 Oracle客户端：Oracle Win64_11gR2_client\n第一步：下载服务端Oracle 11g安装包。\n下载地址： 链接 提取码：qwer\n官方网站下载地址： 链接1 链接2 链接2\n注意：下载OTN上的这些软件，你需要一个OTN免费帐号，不过如果通过迅雷进行下载，就不用登陆OTN了。 也可自行在官方网站内下载其他Oracle客户端或图形界面工具版本： https://www.oracle.com/database/technologies/instant-client/downloads.html\n第二步：Oracle 11g服务端安装 1、解压已经下载的文件，将两个压缩文件包同时解压到同一个目录下，点击“确定”。如下图所示： 2、打开安装包路径，找到【setup.exe】双击安装。如下图所示：\n3、安装前请确保电脑或服务器已经安装好microsoft .net framework\n3.5。如不知如何进行安装，可参考（点击后边文字即刻跳转）：如何在内网环境下离线安装.NET Framework3.5。双击安装等待。弹出安装窗口，配置安全更新，如图所示，点“下一步”，提示未提供邮件地址，点“是”跳过。\n4、安装选项配置，如图所示，点击“下一步”\n5、系统类配置，可根据自己需求进行选择。这里选择“桌面类”安装。\n6、典型安装配置，可按实际情况修改安装路径，输入管理口令后点“下一点”。\n因为是学习环境，所以口令输入比较简单，会提示密码复杂度校验提醒，安装会有如下提示，点“是”跳过即可。\n7、先决条件检查，物理环境检查无问题，进度条100%，安装自动跳转到下个安装界面。\n8、概要配置界面预览，如下图所示，点“完成”开始安装产品，等待，大概20分钟左右。\n安装过程中弹出“创建克隆数据库正在进行”，继续等待即可。\n弹框，可查看“口令管理”，建议点点看看就可以了，不必要纠结，点击口令管理下的“确定”。\n9、数据库创建完成，如图所示，点击“关闭”。\n到此Oracle就安装完成了。\n","date":"2024-02-16T00:00:00Z","image":"http://localhost:1313/p/oracle%E9%85%8D%E7%BD%AE/202412211404987_hu10051977929522698601.png","permalink":"http://localhost:1313/p/oracle%E9%85%8D%E7%BD%AE/","title":"Oracle"},{"content":"Flowable\r一般数据对应表 act_ge_bytearray 通用的流程定义和流程资源 act_ge_property 系统相关属性 流程历史记录表 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- act_hi_actinst 历史的流程实例 act_hi_attachment 历史的流程附件 act_hi_comment 历史的说明性信息 act_hi_detail 历史的流程运行中的细节信息 act_hi_entitylink 任务参与者数据表 act_hi_identitylink 历史的流程运行过程中用户关系 act_hi_procinst 历史的流程实例 act_hi_taskinst 历史的任务实例 act_hi_tsk_log 每一次执行可能会带上的数据 act_hi_varinst 历史的流程运行中的变量信息 用户用户组表 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; act_id_bytearray 二进制数据表 act_id_group 用户组信息表 act_id_info 用户信息详情表 act_id_membership 人与组关系表 act_id_priv 权限表 act_id_priv_mapping 用户或组权限关系表 act_id_property 属性表 act_id_token 系统登录日志表 act_id_user 用户表 流程定义表 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- act_re_deployment 部署单元信息 act_re_model 模型信息 act_re_procdef 已部署的流程定义 运行实例表 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; act_ru_actinst 流程实例每一个活动对应的状态表 act_ru_deadletter_job 作业失败表，失败次数\u0026gt;重试次数 act_ru_entitylink 实例的父子关系表 act_ru_event_subscr 运行时事件 act_ru_execution 运行时流程执行实例 act_ru_external_job 使用作业表来实现异步逻辑、计时器或历史处理 act_ru_history_job 历史作业表 act_ru_identitylink 用户或组的数据及其与流程实例相关的角色表 act_ru_job 运行时作业表 act_ru_suspended_job 运行时挂起的定时作业表 act_ru_task 正在运行的实例的每个未完成用户任务的条目 act_ru_timer_job 运行时定时器表 act_ru_variable 实例相关的变量 其他表 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; act_evt_log 事件日志表 act_procdef_info 流程定义信息 ","date":"2024-02-15T00:00:00Z","image":"http://localhost:1313/p/git/202412212118817_hu4777519752544750320.png","permalink":"http://localhost:1313/p/git/","title":"Flowable"},{"content":"tar包\r1 tar -zxvf XXX.tar.gz nacos\r1 2 3 cd /usr/local/nacos/bin # 启动命令 sudo sh startup.sh -m standalone zookeeper\r启动失败，可参考博客\n博客1、博客2、博客3\n1 2 3 4 5 6 7 8 9 10 11 12 cd /usr/local/zookeeper/bin # 启动zookeeper ./zkServer.sh start # 停止zookeeper ./zkServer.sh stop # 查看状态 ./zkServer.sh status # 连接zookeeper ./zkCli.sh -server 192.168.56.10:2181 # 查看 ls / ls /dubbo ","date":"2024-02-15T00:00:00Z","image":"http://localhost:1313/p/shell/202412212157770_hu11912074021454797946.png","permalink":"http://localhost:1313/p/shell/","title":"Shell"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;header-div\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;scss\u0026#34; scoped\u0026gt; $breakPoints: ( \u0026#39;phone\u0026#39;:( 320px, 480px ), \u0026#39;pad\u0026#39;:( 481px, 768px ), \u0026#39;notebook\u0026#39;:( 769px, 1024px ), \u0026#39;desktop\u0026#39;:( 1025px, 1200px ), \u0026#39;tv\u0026#39;:( 1201px ), ); // 混合 @mixin respond-to($breakName) { $bp: map-get($breakPoints, $breakName); @if type-of($bp)== \u0026#39;list\u0026#39; { $min: nth($bp, 1); $max: nth($bp, 2); @media (min-width: $min) and (max-width: $max) { @content; } } @else { @media (min-width: $bp) { @content; } } } .header-div { width: 100%; @include respond-to(\u0026#39;phone\u0026#39;) { background-color: red; height: 40px; } @include respond-to(\u0026#39;pad\u0026#39;) { height: 60px; } @include respond-to(\u0026#39;notebook\u0026#39;) { background-color: green; height: 80px; } } \u0026lt;/style\u0026gt; ","date":"2024-02-15T00:00:00Z","image":"http://localhost:1313/p/%E5%AA%92%E4%BB%8B%E6%9F%A5%E8%AF%A2/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/%E5%AA%92%E4%BB%8B%E6%9F%A5%E8%AF%A2/","title":"媒介查询"},{"content":"TSX\r安装、配置\n1 npm install @vitejs/plugin-vue-jsx -D vite.config.ts\n1 2 3 4 import vueJsx from \u0026#39;@vitejs/plugin-vue-jsx\u0026#39; plugins: [ vueJsx() ] 写法1\r1 2 3 4 5 export default function (){ return ( \u0026lt;div\u0026gt;测试tsx\u0026lt;/div\u0026gt; ) } 1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;Test/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#39;ts\u0026#39;\u0026gt; import Test from \u0026#34;@/view/Test.tsx\u0026#34;; \u0026lt;/script\u0026gt; 写法2\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 import {defineComponent} from \u0026#34;vue\u0026#34;; export default defineComponent({ data(){ let age=23 return{ age } }, render(){ return( \u0026lt;div\u0026gt;age:{this.age}\u0026lt;/div\u0026gt; ) } }) methods\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import {defineComponent} from \u0026#34;vue\u0026#34;; export default defineComponent({ data(){ let age=23 return{ age } }, methods:{ test(){ console.log(\u0026#39;测试方法运行\u0026#39;); } }, render(){ return( \u0026lt;div onClick={()=\u0026gt;this.test()}\u0026gt;age:{this.age}\u0026lt;/div\u0026gt; ) } }) 写法3\r1 2 3 4 5 6 7 8 9 10 11 12 import {defineComponent} from \u0026#34;vue\u0026#34;; export default defineComponent({ setup(){ let age=23; let test=()=\u0026gt;{ console.log(\u0026#39;测试方法已运行\u0026#39;); } return ()=\u0026gt;( \u0026lt;div onClick={test}\u0026gt;age:{age}\u0026lt;/div\u0026gt; ) } }) v-show\r支持\n1 2 3 4 5 6 7 8 9 import {defineComponent} from \u0026#34;vue\u0026#34;; export default defineComponent({ setup(){ let flag:boolean=false; return ()=\u0026gt;( \u0026lt;div v-show={flag}\u0026gt;hhh\u0026lt;/div\u0026gt; ) } }) ref\n在html标签中，需要使用.value来获取\n1 2 3 4 5 6 7 8 9 import {defineComponent, ref} from \u0026#34;vue\u0026#34;; export default defineComponent({ setup(){ let flag=ref\u0026lt;boolean\u0026gt;(false); return ()=\u0026gt;( \u0026lt;div v-show={flag.value}\u0026gt;hhh\u0026lt;/div\u0026gt; ) } }) v-if\r不支持\n三元表达式写法\n1 2 3 4 5 6 7 8 9 import {defineComponent, ref} from \u0026#34;vue\u0026#34;; export default defineComponent({ setup(){ let flag=ref\u0026lt;boolean\u0026gt;(false); return ()=\u0026gt;( \u0026lt;div\u0026gt;{flag.value?\u0026#39;显示\u0026#39;:\u0026#39;隐藏\u0026#39;}\u0026lt;/div\u0026gt; ) } }) v-for\r不支持\n数组.map遍历写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import {defineComponent} from \u0026#34;vue\u0026#34;; export default defineComponent({ setup(){ let data=[ { name:\u0026#39;aaa\u0026#39;, age:12 }, { name:\u0026#39;bbb\u0026#39;, age:22 } ] return ()=\u0026gt;( \u0026lt;div\u0026gt;{data.map(item=\u0026gt;{ return \u0026lt;div\u0026gt;name:{item.name}--age:{item.age}\u0026lt;/div\u0026gt; })}\u0026lt;/div\u0026gt; ) } }) v-bind\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import {defineComponent} from \u0026#34;vue\u0026#34;; export default defineComponent({ setup() { let data = [ { name: \u0026#39;aaa\u0026#39;, age: 12 }, { name: \u0026#39;bbb\u0026#39;, age: 22 } ] return () =\u0026gt; ( \u0026lt;div\u0026gt;{data.map(item =\u0026gt; { return \u0026lt;div name={item.name}\u0026gt;{item.name}\u0026lt;/div\u0026gt; })}\u0026lt;/div\u0026gt; ) } }) props/emit\rTest.tsx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import {defineComponent} from \u0026#34;vue\u0026#34;; interface Props { name?: string } export default defineComponent({ props: { name: String }, emits: [\u0026#39;on-click\u0026#39;], setup(props: Props, {emit}) { let emitFun = (content: string) =\u0026gt; { console.log(\u0026#39;触发了emit\u0026#39;); emit(\u0026#39;on-click\u0026#39;, content) }; return () =\u0026gt; ( \u0026lt;\u0026gt; \u0026lt;p\u0026gt;{props.name}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; emitFun(\u0026#39;测试内容\u0026#39;)}\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } }) Home.vue\n1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;Test name=\u0026#34;马小跳\u0026#34; @on-click=\u0026#34;getEmit\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#39;ts\u0026#39;\u0026gt; import Test from \u0026#34;@/view/Test.tsx\u0026#34;; let getEmit=(item:string)=\u0026gt;{ console.log(\u0026#39;item:\u0026#39;,item); } \u0026lt;/script\u0026gt; 插槽\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import {defineComponent} from \u0026#34;vue\u0026#34;; export default defineComponent({ setup() { const A = (_, {slots}) =\u0026gt; ( \u0026lt;\u0026gt; \u0026lt;div\u0026gt;{slots.default ? slots.default() : \u0026#39;默认值\u0026#39;}\u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; ) const slot = { default: () =\u0026gt; (\u0026lt;div\u0026gt;default slots\u0026lt;/div\u0026gt;) } return () =\u0026gt; ( \u0026lt;\u0026gt; \u0026lt;A v-slots={slot}/\u0026gt; \u0026lt;/\u0026gt; ) } }) ","date":"2023-07-27T00:00:00Z","image":"http://localhost:1313/p/20.tsx/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/20.tsx/","title":"20.TSX"},{"content":"兄弟组件传参和Bus\rHome\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;A @on-click=\u0026#34;getFlag\u0026#34;/\u0026gt; \u0026lt;B :flag=\u0026#34;flag\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#39;ts\u0026#39;\u0026gt; import {provide, reactive, readonly, ref} from \u0026#39;vue\u0026#39; import A from \u0026#39;./A.vue\u0026#39; import B from \u0026#39;./B.vue\u0026#39; const flag=ref\u0026lt;boolean\u0026gt;(false) const getFlag=(props:boolean)=\u0026gt;{ flag.value=props } \u0026lt;/script\u0026gt; A\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;emitB\u0026#34;\u0026gt;传递flag\u0026lt;/button\u0026gt;当前flag值为{{flag}} \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {inject, reactive, ref} from \u0026#39;vue\u0026#39;; import type {Ref} from \u0026#34;vue\u0026#34;; let flag=ref\u0026lt;boolean\u0026gt;(true) const emit=defineEmits([\u0026#39;on-click\u0026#39;]) const emitB=()=\u0026gt;{ flag.value=!flag.value emit(\u0026#39;on-click\u0026#39;,flag.value) } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; button{ width: 80px; height: 30px; } \u0026lt;/style\u0026gt; B\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;B接收到值了:{{flag}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {inject, reactive, ref} from \u0026#39;vue\u0026#39;; import type {Ref} from \u0026#34;vue\u0026#34;; type Props={ flag:boolean } defineProps\u0026lt;Props\u0026gt;(); \u0026lt;/script\u0026gt; Event Bus\r安装mitt库\n1 npm install mitt -S 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import {createApp} from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import mitt from \u0026#34;mitt\u0026#34;; const Mit = mitt() //TypeScript注册 // 由于必须要拓展ComponentCustomProperties类型才能获得类型提示 declare module \u0026#34;vue\u0026#34; { export interface ComponentCustomProperties { $Bus: typeof Mit } } const app = createApp(App) //Vue3挂载全局API app.config.globalProperties.$Bus = Mit 使用方法通过emit派发， on 方法添加事件，off 方法移除，clear 清空所有 A组件派发（emit）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;我是A\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;emit1\u0026#34;\u0026gt;emit1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;emit2\u0026#34;\u0026gt;emit2\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#39;ts\u0026#39;\u0026gt; import { getCurrentInstance } from \u0026#39;vue\u0026#39; const instance = getCurrentInstance(); const emit1 = () =\u0026gt; { instance?.proxy?.$Bus.emit(\u0026#39;on-num\u0026#39;, 100) } const emit2 = () =\u0026gt; { instance?.proxy?.$Bus.emit(\u0026#39;*****\u0026#39;, 500) } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; B组件监听（on）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;我是B\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#39;ts\u0026#39;\u0026gt; import { getCurrentInstance } from \u0026#39;vue\u0026#39; const instance = getCurrentInstance() instance?.proxy?.$Bus.on(\u0026#39;on-num\u0026#39;, (num) =\u0026gt; { console.log(num,\u0026#39;===========\u0026gt;B\u0026#39;) }) \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 监听所有事件（ on(\u0026quot;*\u0026quot;) ）\n1 2 3 instance?.proxy?.$Bus.on(\u0026#39;*\u0026#39;,(type,num)=\u0026gt;{ console.log(type,num,\u0026#39;===========\u0026gt;B\u0026#39;) }) 移除监听事件（off）\n1 2 3 4 5 const Fn = (num: any) =\u0026gt; { console.log(num, \u0026#39;===========\u0026gt;B\u0026#39;) } instance?.proxy?.$Bus.on(\u0026#39;on-num\u0026#39;,Fn)//listen instance?.proxy?.$Bus.off(\u0026#39;on-num\u0026#39;,Fn)//unListen 清空所有监听（clear）\n1 instance?.proxy?.$Bus.all.clear() ","date":"2023-07-26T00:00:00Z","image":"http://localhost:1313/p/19.%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82%E5%92%8Cbus/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/19.%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82%E5%92%8Cbus/","title":"19.兄弟组件传参和Bus"},{"content":"watchEffect高级侦听器\r原博客 执行传入的函数，同时响应式追踪其依赖，当依赖改变时重新运行该函数\n1 2 3 4 5 import {ref, watchEffect} from \u0026#39;vue\u0026#39;; let message = ref\u0026lt;number\u0026gt;(0) watchEffect(() =\u0026gt; { console.log(\u0026#39;message\u0026#39;, message.value); }) 清除副作用\n在触发监听之前会调用一个函数来处理逻辑，如防抖\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { watchEffect, ref } from \u0026#39;vue\u0026#39; let message = ref\u0026lt;number\u0026gt;(0) watchEffect((beforeTest) =\u0026gt; { beforeTest(()=\u0026gt;{ console.log(\u0026#39;测试前\u0026#39;); }) console.log(\u0026#39;message\u0026#39;, message.value); }) \u0026lt;/script\u0026gt; 停止跟踪\nwatchEffect 返回一个函数 调用之后将停止更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ message }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;message++\u0026#34;\u0026gt;测试\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;stopWatch\u0026#34;\u0026gt;停止监听\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { watchEffect, ref } from \u0026#39;vue\u0026#39; let message = ref\u0026lt;number\u0026gt;(0) let stopWatch=watchEffect((beforeTest) =\u0026gt; { beforeTest(()=\u0026gt;{ console.log(\u0026#39;测试前\u0026#39;); }) console.log(\u0026#39;message\u0026#39;, message.value); }) \u0026lt;/script\u0026gt; 刷新时机\npre sync post 更新时机 组件更新前执行 同步执行 组件更新后执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ message }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;message++\u0026#34;\u0026gt;测试\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;stopWatch\u0026#34;\u0026gt;停止监听\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {watchEffect, ref} from \u0026#39;vue\u0026#39; let message = ref\u0026lt;number\u0026gt;(0) let stopWatch = watchEffect((beforeTest) =\u0026gt; { beforeTest(() =\u0026gt; { console.log(\u0026#39;测试前\u0026#39;); }) console.log(\u0026#39;message\u0026#39;, message.value); }, { flush: \u0026#39;post\u0026#39;, onTrigger() { console.log(\u0026#39;更新前\u0026#39;); } }) \u0026lt;/script\u0026gt; ","date":"2023-07-17T00:00:00Z","image":"http://localhost:1313/p/07.watcheffect%E9%AB%98%E7%BA%A7%E4%BE%A6%E5%90%AC%E5%99%A8/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/07.watcheffect%E9%AB%98%E7%BA%A7%E4%BE%A6%E5%90%AC%E5%99%A8/","title":"07.watchEffect高级侦听器"},{"content":"sass学习\rsass官方文档\nless官方文档\n原博客 bem架构 BEM实际上是block、element、modifier的缩写，分别为块层、元素层、修饰符层 BEM 命名约定的模式是：\n1 2 3 4 5 .block {} .block__element {} .block--modifier {} 嵌套规则\rSass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器\n1 2 3 4 5 6 7 8 #main p { color: #00ff00; width: 97%; .redbox { background-color: #ff0000; color: #000000; } } 父选择器 \u0026amp;\r1 2 3 4 5 6 a { font-weight: bold; text-decoration: none; \u0026amp;:hover { text-decoration: underline; } body.firefox \u0026amp; { font-weight: normal; } } 变量 $\r1 2 3 4 $width: 5em; #main { width: $width; } 插值语句 #{}\r1 2 3 4 5 $name: foo; $attr: border; p.#{$name} { #{$attr}-color: blue; } @at-root\r1 2 3 4 5 6 7 8 @media print { .page { width: 8in; @at-root (without: media) { color: red; } } } 编译后\n1 2 3 4 5 6 7 8 @media print { .page { width: 8in; } } .page { color: red; } 定义混合指令 @mixin\r混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义：\n1 2 3 4 5 6 7 8 @mixin large-text { font: { family: Arial; size: 20px; weight: bold; } color: #ff0000; } 引用混合样式 @include\r1 2 3 4 5 6 7 8 9 10 11 12 13 @mixin large-text { font: { family: Arial; size: 20px; weight: bold; } color: #ff0000; } .page-title { @include large-text; padding: 4px; margin-top: 10px; } 编译后\n1 2 3 4 5 6 7 8 .page-title { font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; } 练习:实现layout布局\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 $block-sel: \u0026#34;-\u0026#34; !default; $element-sel: \u0026#34;__\u0026#34; !default; $modifier-sel: \u0026#34;--\u0026#34; !default; $namespace:\u0026#39;xm\u0026#39; !default; @mixin bfc { height: 100%; overflow: hidden; } //混入 @mixin b($block) { $B: $namespace + $block-sel + $block; //变量 .#{$B}{ //插值语法#{} @content; //内容替换 } } @mixin flex { display: flex; } @mixin e($element) { $selector:\u0026amp;; @at-root { #{$selector + $element-sel + $element} { @content; } } } @mixin m($modifier) { $selector:\u0026amp;; @at-root { #{$selector + $modifier-sel + $modifier} { @content; } } } 全局扩充sass\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], css: { preprocessorOptions: { scss: { additionalData: \u0026#34;@import \u0026#39;./src/bem.scss\u0026#39;;\u0026#34; } } } }) Vue 组件用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;xm-wraps\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Menu\u0026gt;\u0026lt;/Menu\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;xm-wraps__right\u0026#34;\u0026gt; \u0026lt;Header\u0026gt;\u0026lt;/Header\u0026gt; \u0026lt;Content\u0026gt;\u0026lt;/Content\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; import { ref, reactive } from \u0026#34;vue\u0026#34; import Menu from \u0026#39;./Menu/index.vue\u0026#39; import Content from \u0026#39;./Content/index.vue\u0026#39; import Header from \u0026#39;./Header/index.vue\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;scss\u0026#34; scoped\u0026gt; @include b(\u0026#39;wraps\u0026#39;){ @include bfc; @include flex; @include e(right){ flex:1; display: flex; flex-direction: column; } } \u0026lt;/style\u0026gt; ","date":"2023-07-17T00:00:00Z","image":"http://localhost:1313/p/08.sass%E5%AD%A6%E4%B9%A0/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/08.sass%E5%AD%A6%E4%B9%A0/","title":"08.sass学习"},{"content":"父子组件传参\r父传子\r父组件通过v-bind绑定一个数据，然后子组件通过defineProps接受传过来的值 父组件\n1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;children title=\u0026#34;标题1\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Children from \u0026#39;@/view/Children.vue\u0026#39; \u0026lt;/script\u0026gt; 子组件\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;template\u0026gt; 这里是children，父组件传递的title为\u0026lt;span\u0026gt;{{title}}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, ref} from \u0026#39;vue\u0026#39;; defineProps({ title:{ type:String, default:\u0026#39;默认标题\u0026#39; } }) \u0026lt;/script\u0026gt; 如果使用typescript，则可以采用如下写法\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; 这里是children，父组件传递的title为\u0026lt;span\u0026gt;{{title}}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, ref} from \u0026#39;vue\u0026#39;; const props=defineProps\u0026lt;{ title:string }\u0026gt;() console.log(\u0026#39;父组件传递的title为:\u0026#39;,props.title); \u0026lt;/script\u0026gt; 若需要设置默认值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; 这里是children，父组件传递的title为\u0026lt;span\u0026gt;{{title}}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, ref} from \u0026#39;vue\u0026#39;; type Props={ title:string arr:number[] } withDefaults(defineProps\u0026lt;Props\u0026gt;(),{ title:\u0026#39;默认标题\u0026#39;, arr:()=\u0026gt;[1,2,3,4,5,6] }) \u0026lt;/script\u0026gt; 子传父\r子组件\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;send\u0026#34;\u0026gt;sendToFather\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, ref} from \u0026#39;vue\u0026#39;; const emit=defineEmits([\u0026#39;on-click\u0026#39;]) const send=()=\u0026gt;{ emit(\u0026#39;on-click\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;) } \u0026lt;/script\u0026gt; 父组件\n1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;children @on-click=\u0026#34;getProps\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Children from \u0026#39;@/view/Children.vue\u0026#39; let getProps=(...name:string[])=\u0026gt;{ console.log(name); } \u0026lt;/script\u0026gt; ts写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;send\u0026#34;\u0026gt;sendToFather\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, ref} from \u0026#39;vue\u0026#39;; interface Props { (e: \u0026#39;on-click\u0026#39;, ...name: string[]): void } const emit = defineEmits\u0026lt;Props\u0026gt;() const send = () =\u0026gt; { emit(\u0026#39;on-click\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;) } \u0026lt;/script\u0026gt; 给父组件传递方法 子组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; 这是子组件 \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, ref} from \u0026#39;vue\u0026#39;; let time=ref\u0026lt;string\u0026gt;(\u0026#39;2023/7/17 22:00\u0026#39;) const open=()=\u0026gt;{ console.log(\u0026#39;这是open方法,当前时间为:\u0026#39;,time.value) } defineExpose({ name:\u0026#39;马小跳\u0026#39;, open }) \u0026lt;/script\u0026gt; 父组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;children ref=\u0026#34;childProps\u0026#34;/\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Children from \u0026#39;@/view/Children.vue\u0026#39; import {ref} from \u0026#34;vue\u0026#34;; const childProps=ref(null); let test=()=\u0026gt;{ console.log(\u0026#39;name:\u0026#39;,childProps.value.name); childProps.value.open() } \u0026lt;/script\u0026gt; ","date":"2023-07-17T00:00:00Z","image":"http://localhost:1313/p/09.%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/09.%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/","title":"09.父子组件传参"},{"content":"计算属性\rcomputed\n购物车案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 \u0026lt;template\u0026gt; \u0026lt;a-input v-model:value=\u0026#34;searchContent\u0026#34; type=\u0026#34;text\u0026#34; style=\u0026#34;width: 500px\u0026#34; placeholder=\u0026#34;请输入关键词搜索\u0026#34;/\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th v-for=\u0026#34;title in dataList.title\u0026#34;\u0026gt;{{ title }}\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr v-for=\u0026#34;(item,index) in searchDataList\u0026#34;\u0026gt; \u0026lt;td align=\u0026#34;center\u0026#34;\u0026gt;{{ item.key }}\u0026lt;/td\u0026gt; \u0026lt;td align=\u0026#34;center\u0026#34;\u0026gt;{{ item.name }}\u0026lt;/td\u0026gt; \u0026lt;td align=\u0026#34;center\u0026#34;\u0026gt;{{ item.money }}\u0026lt;/td\u0026gt; \u0026lt;td align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;a-button type=\u0026#34;default\u0026#34; @click=\u0026#34;item.num\u0026gt;1?item.num--:item.num\u0026#34;\u0026gt;-\u0026lt;/a-button\u0026gt; {{ item.num }} \u0026lt;a-button type=\u0026#34;default\u0026#34; @click=\u0026#34;item.num\u0026lt;99?item.num++:item.num\u0026#34;\u0026gt;+\u0026lt;/a-button\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td align=\u0026#34;center\u0026#34;\u0026gt;{{ item.money * item.num }}￥\u0026lt;/td\u0026gt; \u0026lt;td align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;a-button danger type=\u0026#34;default\u0026#34; @click=\u0026#34;deleteItem(index)\u0026#34;\u0026gt;删除\u0026lt;/a-button\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td colspan=\u0026#34;5\u0026#34; align=\u0026#34;right\u0026#34;\u0026gt;总价:{{ total }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, ref, computed} from \u0026#39;vue\u0026#39;; interface Data { key: string, name: string, money: number, num: number, } const searchContent = ref\u0026lt;string\u0026gt;(\u0026#39;\u0026#39;); const dataList = reactive({ title: [ \u0026#39;编号\u0026#39;, \u0026#39;商品\u0026#39;, \u0026#39;单价\u0026#39;, \u0026#39;数量\u0026#39;, \u0026#39;金额\u0026#39;, \u0026#39;操作\u0026#39; ], arr: [ { key: \u0026#39;1\u0026#39;, name: \u0026#39;昂贵的辣条\u0026#39;, money: 100, num: 1, }, { key: \u0026#39;2\u0026#39;, name: \u0026#39;便宜的面包\u0026#39;, money: 50, num: 1, }, { key: \u0026#39;3\u0026#39;, name: \u0026#39;稀有的牛奶\u0026#39;, money: 200, num: 1, }, ] }); let data = dataList.arr; let total = computed(() =\u0026gt; { return data.reduce((pre: number, now: Data) =\u0026gt; { return pre + now.num * now.money }, 0) }); let deleteItem = (index: number) =\u0026gt; { data.splice(index, 1) } const searchDataList = computed(() =\u0026gt; { return data.filter((item: Data) =\u0026gt; { return item.name.includes(searchContent.value); }); }); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; th { width: 100px; } \u0026lt;/style\u0026gt; reduce函数接受两个值，一个是之前的值，一个是改变后的值\n第一次没有之前的值，所以赋值为0 小满zs-\u0026gt;购物车案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input placeholder=\u0026#34;请输入名称\u0026#34; v-model=\u0026#34;keyWord\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;table style=\u0026#34;margin-top:10px;\u0026#34; width=\u0026#34;500\u0026#34; cellspacing=\u0026#34;0\u0026#34; cellpadding=\u0026#34;0\u0026#34; border\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;物品\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;单价\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;数量\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;总价\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;(item, index) in searchData\u0026#34;\u0026gt; \u0026lt;td align=\u0026#34;center\u0026#34;\u0026gt;{{ item.name }}\u0026lt;/td\u0026gt; \u0026lt;td align=\u0026#34;center\u0026#34;\u0026gt;{{ item.price }}\u0026lt;/td\u0026gt; \u0026lt;td align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;item.num \u0026gt; 1 ? item.num-- : null\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;input v-model=\u0026#34;item.num\u0026#34; type=\u0026#34;number\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;item.num \u0026lt; 99 ? item.num++ : null\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td align=\u0026#34;center\u0026#34;\u0026gt;{{ item.price * item.num }}\u0026lt;/td\u0026gt; \u0026lt;td align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;del(index)\u0026#34;\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td colspan=\u0026#34;5\u0026#34; align=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;span\u0026gt;总价：{{ total }}\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#39;ts\u0026#39;\u0026gt; import { reactive, ref,computed } from \u0026#39;vue\u0026#39; let keyWord = ref\u0026lt;string\u0026gt;(\u0026#39;\u0026#39;) interface Data { name: string, price: number, num: number } const data = reactive\u0026lt;Data[]\u0026gt;([ { name: \u0026#34;小满的绿帽子\u0026#34;, price: 100, num: 1, }, { name: \u0026#34;小满的红衣服\u0026#34;, price: 200, num: 1, }, { name: \u0026#34;小满的黑袜子\u0026#34;, price: 300, num: 1, } ]) let searchData = computed(()=\u0026gt;{ return data.filter(item =\u0026gt; item.name.includes(keyWord.value)) }) let total = computed(() =\u0026gt; { return data.reduce((prev: number, next: Data) =\u0026gt; { return prev + next.num * next.price }, 0) }) const del = (index: number) =\u0026gt; { data.splice(index, 1) } \u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#39;less\u0026#39;\u0026gt;\u0026lt;/style\u0026gt; ","date":"2023-07-16T00:00:00Z","image":"http://localhost:1313/p/05.%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/05.%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/","title":"05.计算属性"},{"content":"阿里云OSS上传图片遇到403这个错误（谷粒商城）\r1 upload.js?c0e8:599 POST http://gulimall-twh.oss-cn-shanghai.aliyuncs.com/ 403 (Forbidden) 挺纳闷的，跟着视频一起做的，没有漏掉授权类的步骤 上网查基本都是授权的问题，还有一个同志是电脑时间的问题，说是需要电脑时间必须和北京时间同步，不能有错误 但是以上都不是我报错的原因，我看了一下请求 这里accessKeyId是一个undefined 但是确确实实可以获取到accessKeyId 开始查看前端代码（upload组件是课件里直接发的），我猜想是upload组件这里出问题了 果不其然！！！ 将accessid改为accessId即可 由于阿里云的文档改了一点，视频里是accessid，所以视频里没报错 估计是阿里云文档里后来把accessid改成accessId了\n","date":"2023-07-16T00:00:00Z","image":"http://localhost:1313/p/%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%94%99%E8%AF%AF/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%94%99%E8%AF%AF/","title":"阿里云oss图片上传错误"},{"content":"01.Ref全家桶\rRef\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;message1:{{ message1 }}\u0026lt;/p\u0026gt; \u0026lt;a-button @click=\u0026#34;refTest\u0026#34;\u0026gt;Ref测试\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {customRef, defineComponent, isRef, reactive, ref, shallowRef, triggerRef} from \u0026#39;vue\u0026#39;; import {notification} from \u0026#34;ant-design-vue\u0026#34;; export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { let message1 = ref\u0026lt;string\u0026gt;(\u0026#34;信息\u0026#34;) /** * 测试ref * 接受一个内部值并返回一个响应式且可变的 ref 对象 */ let refTest = () =\u0026gt; { message1.value += \u0026#34;=\u0026#34; notification[\u0026#39;success\u0026#39;]({ message: \u0026#39;测试ref\u0026#39;, description: \u0026#39;测试成功\u0026#39;, }); } return { message1, refTest, } } }) \u0026lt;/script\u0026gt; isRef\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;message1:{{ message1 }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;message2:{{ message2 }}\u0026lt;/p\u0026gt; \u0026lt;a-button @click=\u0026#34;isRefTest\u0026#34;\u0026gt;isRef测试\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {customRef, defineComponent, isRef, onMounted, reactive, ref, shallowRef, triggerRef} from \u0026#39;vue\u0026#39;; import {notification} from \u0026#34;ant-design-vue\u0026#34;; export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { let message1 = ref\u0026lt;string\u0026gt;(\u0026#34;信息\u0026#34;) let message2 = \u0026#34;信息\u0026#34; /** * 测试isRef * 判断是不是一个ref对象 */ let isRefTest = () =\u0026gt; { notification[\u0026#39;success\u0026#39;]({ message: \u0026#39;测试isRef\u0026#39;, description: \u0026#39;message1\u0026#39; + (isRef(message1) ? \u0026#39;是\u0026#39; : \u0026#39;不是\u0026#39;) + \u0026#39;ref//\u0026#39; + \u0026#39;message2\u0026#39; + (isRef(message2) ? \u0026#39;是\u0026#39; : \u0026#39;不是\u0026#39;) + \u0026#39;ref\u0026#39;, }); } return { message1, message2, isRefTest } } }) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; shallowRef\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;message3:{{ message3 }}\u0026lt;/p\u0026gt; \u0026lt;a-button @click=\u0026#34;shallowRefTest(true)\u0026#34;\u0026gt;shallowRef测试\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {customRef, defineComponent, isRef, onMounted, reactive, ref, shallowRef, triggerRef} from \u0026#39;vue\u0026#39;; import {notification} from \u0026#34;ant-design-vue\u0026#34;; export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { let message3 = shallowRef({ name: \u0026#39;马小跳\u0026#39; }) /** * 测试shallowRef */ let shallowRefTest = (flag: boolean) =\u0026gt; { // 有以下两种方法 // 只有直接直接针对value来进行修改才会触发响应式 if (!flag) { // 不会变成响应式的情况 message3.value.name = \u0026#39;aaa\u0026#39;; notification[\u0026#39;error\u0026#39;]({ message: \u0026#39;测试shallowRef\u0026#39;, description: \u0026#39;没有响应式变化\u0026#39; }); } else { // 会变成响应式的情况 message3.value = {name: \u0026#39;aaa\u0026#39;}; notification[\u0026#39;success\u0026#39;]({ message: \u0026#39;测试shallowRef\u0026#39;, description: \u0026#39;发生响应式变化\u0026#39; }); } } return { message3, shallowRefTest } } }) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; triggerRef\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;message3:{{ message3 }}\u0026lt;/p\u0026gt; \u0026lt;a-button @click=\u0026#34;triggerRefTest\u0026#34;\u0026gt;triggerRef测试\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {customRef, defineComponent, isRef, onMounted, reactive, ref, shallowRef, triggerRef} from \u0026#39;vue\u0026#39;; import {notification} from \u0026#34;ant-design-vue\u0026#34;; export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { let message3 = shallowRef({ name: \u0026#39;马小跳\u0026#39; }) /** * 强制更新页面DOM */ let triggerRefTest = () =\u0026gt; { message3.value.name = \u0026#39;bbb\u0026#39;; triggerRef(message3); notification[\u0026#39;success\u0026#39;]({ message: \u0026#39;测试triggerRef\u0026#39;, description: \u0026#39;已经强制更新页面DOM\u0026#39; }); } return { message3, triggerRefTest } } }) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; customRef\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;message4:{{ message4 }}\u0026lt;/p\u0026gt; \u0026lt;a-button @click=\u0026#34;customRefTest\u0026#34;\u0026gt;customRef测试\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {customRef, defineComponent, isRef, onMounted, reactive, ref, shallowRef, triggerRef} from \u0026#39;vue\u0026#39;; import {notification} from \u0026#34;ant-design-vue\u0026#34;; export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { let message4=myCustomRef(\u0026#39;哈哈哈\u0026#39;); /** * 自定义ref * customRef 是个工厂函数要求我们返回一个对象 并且实现 get 和 set * 适合去做防抖之类的 */ function myCustomRef(value) { let timer: any; return customRef((track, trigger) =\u0026gt; { return { get() { track(); return value; }, set(newVal) { // 制作防抖 clearTimeout(timer) timer = setTimeout(() =\u0026gt; { console.log(\u0026#39;触发了set\u0026#39;) value = newVal timer = null; notification[\u0026#39;success\u0026#39;]({ message: \u0026#39;测试customRef\u0026#39;, description: \u0026#39;已经调用customRefTest方法\u0026#39; }); trigger(); }, 500) } } }) } let customRefTest=()=\u0026gt;{ message4.value+=\u0026#39;==\u0026#39; } return { message4, customRefTest } } }) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 标签中的ref属性\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;div ref=\u0026#34;dom\u0026#34;\u0026gt;aaa\u0026lt;/div\u0026gt; \u0026lt;a-button @click=\u0026#34;buttonTest\u0026#34;\u0026gt;ref属性测试\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {customRef, defineComponent, isRef, onMounted, reactive, ref, shallowRef, triggerRef} from \u0026#39;vue\u0026#39;; import {notification} from \u0026#34;ant-design-vue\u0026#34;; export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { const dom=ref\u0026lt;HTMLDivElement\u0026gt;() /** * 获取到元素节点 * 要求:ref的值相同 * 如:ref=\u0026#34;dom\u0026#34;、const dom=ref\u0026lt;\u0026gt;(); */ let buttonTest=()=\u0026gt;{ console.log(\u0026#34;dom:\u0026#34;,dom.value); } return { // 需要return出来才能获取到节点 dom, buttonTest } } }) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; ","date":"2023-07-13T00:00:00Z","image":"http://localhost:1313/p/01.ref%E5%85%A8%E5%AE%B6%E6%A1%B6/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/01.ref%E5%85%A8%E5%AE%B6%E6%A1%B6/","title":"01.Ref全家桶"},{"content":"02.Reactive全家桶\rreactive\rreactive(\u0026rsquo;\u0026rsquo;)不支持string类型\n查看源码可知，只支持引用类型，object、map、set\n而ref都支持 reactive在赋值时无需使用.value\n而ref需要\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{user.name}}--{{user.gender}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test1\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref} from \u0026#39;vue\u0026#39;; import {Button} from \u0026#34;ant-design-vue\u0026#34;; let user=reactive({ name:\u0026#39;马小跳\u0026#39;, gender:\u0026#39;男\u0026#39; }); let test1=()=\u0026gt;{ user.name=\u0026#39;洛洛\u0026#39;; console.log(user); } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 阻止默认事件\n@click.prevent\n1 2 3 \u0026lt;form\u0026gt; \u0026lt;button @click.prevent=\u0026#34;test1\u0026#34;\u0026gt;test2\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; reactive是经过proxy代理的对象，直接赋值会失去响应式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-for=\u0026#34;user in users\u0026#34;\u0026gt;{{user}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test1\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref} from \u0026#39;vue\u0026#39;; let users=reactive\u0026lt;string[]\u0026gt;([]); let test1=()=\u0026gt;{ // 假设res为获取到的数据 let res=[\u0026#39;小满\u0026#39;,\u0026#39;辣辣\u0026#39;,\u0026#39;路西\u0026#39;]; // 失去响应式 users=res; console.log(users); } \u0026lt;/script\u0026gt; 正确方法如下 方法1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-for=\u0026#34;user in users\u0026#34;\u0026gt;{{user}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test1\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref} from \u0026#39;vue\u0026#39;; let users=reactive\u0026lt;string[]\u0026gt;([]); let test1=()=\u0026gt;{ // 假设res为获取到的数据 let res=[\u0026#39;小满\u0026#39;,\u0026#39;辣辣\u0026#39;,\u0026#39;路西\u0026#39;]; // 正确方法1 // 结构后赋值 users.push(...res); console.log(users); } \u0026lt;/script\u0026gt; 方法2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-for=\u0026#34;user in users.arr\u0026#34;\u0026gt;{{user}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test1\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref} from \u0026#39;vue\u0026#39;; let users=reactive\u0026lt;{arr:string[]}\u0026gt;({arr:[]}); let test1=()=\u0026gt;{ // 假设res为获取到的数据 let res=[\u0026#39;小满\u0026#39;,\u0026#39;辣辣\u0026#39;,\u0026#39;路西\u0026#39;]; // 正确方法2 users.arr=res; console.log(users); } \u0026lt;/script\u0026gt; readonly\r无法修改readonly修饰的值，报错Attempt to assign to const or readonly variable 但是会受reactive影响\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test1\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, readonly, ref} from \u0026#39;vue\u0026#39;; import {message} from \u0026#34;ant-design-vue\u0026#34;; let user=reactive({name:\u0026#39;小荷\u0026#39;}); const readUser=readonly(user); let test1=()=\u0026gt;{ user.name=\u0026#39;小满\u0026#39;; message.success(readUser.name) } \u0026lt;/script\u0026gt; shallowReactive\r与shallowRef类似\n只能对浅层的数据 如果是深层的数据只会改变值 不会改变视图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; {{ user.name.firstName }}{{ user.name.lastName }}--{{user.gender}} \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test1\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, readonly, ref, shallowReactive} from \u0026#39;vue\u0026#39;; import {message} from \u0026#34;ant-design-vue\u0026#34;; let user = shallowReactive({ name: { firstName: \u0026#39;赵\u0026#39;, lastName: \u0026#39;子龙\u0026#39; }, gender: \u0026#39;男\u0026#39; }); let test1 = () =\u0026gt; { user.name.firstName = \u0026#39;貂\u0026#39; user.name.lastName = \u0026#39;蝉\u0026#39; user.gender = \u0026#39;女\u0026#39; } \u0026lt;/script\u0026gt; 不是说好不改变视图的吗？\n和shallowRef一样，shallowReactive也会受reactive影响\n当gender属性改变时，触发了强制更新\n所以如下代码即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; {{ user.name.firstName }}{{ user.name.lastName }}--{{user.gender}} \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test1\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, readonly, ref, shallowReactive} from \u0026#39;vue\u0026#39;; import {message} from \u0026#34;ant-design-vue\u0026#34;; let user = shallowReactive({ name: { firstName: \u0026#39;赵\u0026#39;, lastName: \u0026#39;子龙\u0026#39; }, gender: \u0026#39;男\u0026#39; }); let test1 = () =\u0026gt; { user.name.firstName = \u0026#39;貂\u0026#39; user.name.lastName = \u0026#39;蝉\u0026#39; // user.gender = \u0026#39;女\u0026#39; } \u0026lt;/script\u0026gt; ","date":"2023-07-13T00:00:00Z","image":"http://localhost:1313/p/02.reactive%E5%85%A8%E5%AE%B6%E6%A1%B6/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/02.reactive%E5%85%A8%E5%AE%B6%E6%A1%B6/","title":"02.Reactive全家桶"},{"content":"03.to全家桶\rtoRef\r修改响应式对象的值\n对于非响应式数据，只会改变数据，视图依然不会发生变化\ntoRef(A,B)\nA=\u0026gt;对象\nB=\u0026gt;key值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive,toRef, toRefs, toRaw} from \u0026#39;vue\u0026#39;; let user=reactive({ name:\u0026#39;马小跳\u0026#39;, gender:\u0026#39;男\u0026#39;, like:\u0026#39;篮球\u0026#39; }) let refName=toRef(user,\u0026#39;name\u0026#39;); let test1=()=\u0026gt;{ console.log(refName); console.log(refName.value); // 对值进行修改 refName.value=\u0026#39;洛洛\u0026#39;; } \u0026lt;/script\u0026gt;\t应用场景 有某函数需要接受指定参数，可使用toRef解构出对象的属性给指定函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; {{user.name}} \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive,toRef, toRefs, toRaw} from \u0026#39;vue\u0026#39;; import {message} from \u0026#34;ant-design-vue\u0026#34;; let user=reactive({ name:\u0026#39;马小跳\u0026#39;, gender:\u0026#39;男\u0026#39;, like:\u0026#39;篮球\u0026#39; }) let test1=()=\u0026gt;{ let refName=toRef(user,\u0026#39;name\u0026#39;); sendMessage(refName.value); } let sendMessage=(name:string)=\u0026gt;{ message.success(\u0026#39;你好,\u0026#39;+name); } \u0026lt;/script\u0026gt; toRefs\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;template\u0026gt; {{user.name}} \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive,toRef, toRaw} from \u0026#39;vue\u0026#39;; import {message} from \u0026#34;ant-design-vue\u0026#34;; let user=reactive({ name:\u0026#39;马小跳\u0026#39;, gender:\u0026#39;男\u0026#39;, like:\u0026#39;篮球\u0026#39; }) // 类似实现原理 const toRefs=\u0026lt;T extends object\u0026gt;(object:T)=\u0026gt;{ const map:any={}; for (let key in object) { map[key]=toRef(object,key) } return map; } let test1=()=\u0026gt;{ let {name,gender}=toRefs(user); console.log(name.value); console.log(gender.value); } \u0026lt;/script\u0026gt; 否则失去响应式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; {{ user.name }} \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, toRef, toRefs, toRaw} from \u0026#39;vue\u0026#39;; let user = reactive({ name: \u0026#39;马小跳\u0026#39;, gender: \u0026#39;男\u0026#39;, like: \u0026#39;篮球\u0026#39; }) let test1 = () =\u0026gt; { // let {name,gender}=toRefs(user); // 会失去响应式 let {name, gender} = user; console.log(name); console.log(gender); } \u0026lt;/script\u0026gt; toRaw\r获取代理前的对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; {{ user.name }} \u0026lt;a-button danger @click=\u0026#34;test1\u0026#34;\u0026gt;test\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, toRef, toRefs, toRaw} from \u0026#39;vue\u0026#39;; let user = reactive({ name: \u0026#39;马小跳\u0026#39;, gender: \u0026#39;男\u0026#39;, like: \u0026#39;篮球\u0026#39; }) let test1 = () =\u0026gt; { console.log(user); console.log(toRaw(user)); } \u0026lt;/script\u0026gt; ","date":"2023-07-13T00:00:00Z","image":"http://localhost:1313/p/03.to%E5%85%A8%E5%AE%B6%E6%A1%B6/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/03.to%E5%85%A8%E5%AE%B6%E6%A1%B6/","title":"03.to全家桶"},{"content":"","date":"2023-07-13T00:00:00Z","image":"http://localhost:1313/p/04.%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/04.%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","title":"04.响应式原理"},{"content":"监听器\rwatch第一个参数监听源\nwatch第二个参数回调函数cb（newVal,oldVal）\nwatch第三个参数一个options配置项是一个对象(immediate是否立即调用一次、deep:true 是否开启深度监听)\n原博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;a-button danger @click=\u0026#34;change\u0026#34;\u0026gt;测试\u0026lt;/a-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {reactive, ref, computed, watch} from \u0026#39;vue\u0026#39;; import {message} from \u0026#34;ant-design-vue\u0026#34;; let keywords = ref\u0026lt;number\u0026gt;(0) watch(keywords, (newVal, oldVal) =\u0026gt; { message.success(\u0026#39;新的值:\u0026#39; + newVal+\u0026#39; 旧的值:\u0026#39;+oldVal); }, { deep: true }) let change = () =\u0026gt; { keywords.value += 1; } \u0026lt;/script\u0026gt; ","date":"2023-07-13T00:00:00Z","image":"http://localhost:1313/p/06.%E7%9B%91%E5%90%AC%E5%99%A8/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/06.%E7%9B%91%E5%90%AC%E5%99%A8/","title":"06.监听器"},{"content":"依赖注入Provide、Inject\rHome.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;div v-for=\u0026#34;item in colorList\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;color\u0026#34; v-model=\u0026#34;colorVal\u0026#34; :value=\u0026#34;item.value\u0026#34;\u0026gt;{{item.showName}} \u0026lt;/div\u0026gt; \u0026lt;A/\u0026gt; \u0026lt;B/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#39;ts\u0026#39;\u0026gt; import {provide, reactive, ref} from \u0026#39;vue\u0026#39; import A from \u0026#39;./A.vue\u0026#39; import B from \u0026#39;./B.vue\u0026#39; type Color={ value:string, showName:string } let colorList=reactive\u0026lt;Array\u0026lt;Color\u0026gt;\u0026gt;([{ value:\u0026#39;yellow\u0026#39;, showName:\u0026#39;黄色\u0026#39; },{ value:\u0026#39;red\u0026#39;, showName:\u0026#39;红色\u0026#39; },{ value:\u0026#39;purple\u0026#39;, showName:\u0026#39;紫色\u0026#39; }]) let colorVal=ref\u0026lt;string\u0026gt;(\u0026#39;\u0026#39;) provide(\u0026#39;color\u0026#39;,colorVal); \u0026lt;/script\u0026gt; A.vue\n在css中也可以使用v-bind来绑定参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;这是A组件\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;attA\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {inject, reactive, ref} from \u0026#39;vue\u0026#39;; import type {Ref} from \u0026#34;vue\u0026#34;; let color=inject\u0026lt;Ref\u0026lt;string\u0026gt;\u0026gt;(\u0026#39;color\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; #attA{ width: 30px; height: 30px; background: v-bind(color); } \u0026lt;/style\u0026gt; B.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;这是B组件\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;attB\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {inject, reactive, ref} from \u0026#39;vue\u0026#39;; import type {Ref} from \u0026#34;vue\u0026#34;; let color=inject\u0026lt;Ref\u0026lt;string\u0026gt;\u0026gt;(\u0026#39;color\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; #attB{ width: 30px; height: 30px; background: v-bind(color); } \u0026lt;/style\u0026gt; 注意，此时的参数可以在子组件中修改\n此时会导致父组件以及其他子组件的该参数都会发生改变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;这是A组件\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;changeColor\u0026#34;\u0026gt;修改颜色\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;attA\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {inject, reactive, ref} from \u0026#39;vue\u0026#39;; import type {Ref} from \u0026#34;vue\u0026#34;; let color=inject\u0026lt;Ref\u0026lt;string\u0026gt;\u0026gt;(\u0026#39;color\u0026#39;); let changeColor=()=\u0026gt;{ color.value=\u0026#39;black\u0026#39; } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; #attA{ width: 30px; height: 30px; background: v-bind(color); } \u0026lt;/style\u0026gt; 若不希望子组件进行修改，可设置为readonly\n1 2 let colorVal=ref\u0026lt;string\u0026gt;(\u0026#39;\u0026#39;) provide(\u0026#39;color\u0026#39;,readonly(colorVal)); 子组件无法使用xxx.?value来进行修改，可采用以下两种方法 1.默认值\n1 let color=inject\u0026lt;Ref\u0026lt;string\u0026gt;\u0026gt;(\u0026#39;color\u0026#39;,ref(\u0026#39;red\u0026#39;)); 2.非空断言\n1 color!.value=\u0026#39;xxx\u0026#39; ","date":"2023-07-13T00:00:00Z","image":"http://localhost:1313/p/18.%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5provideinject/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/18.%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5provideinject/","title":"18.依赖注入Provide、Inject"},{"content":"遭遇问题\r404\rhttp://localhost:8080/activiti-app访问报404 在activiti官网上下的文件，官网链接，网盘链接 看了一下tomcat，是因为activiti-app.war没有被解压 怀疑是war包有问题，又去github下载了（实际可能不是），链接 后来没办法，试过直接用zip解压，但是启动tomcat时候报错了，即便删掉重新启动还是会报错 最后清了一下tomcat缓存就成功了 以下是清理Tomcat的步骤：\n1 2 3 4 5 6 7 8 9 10 1. 停止Tomcat服务器：在命令行中输入“shutdown.bat”（Windows）或“shutdown.sh”（Linux）。 2. 删除Tomcat工作目录：在Tomcat安装目录下找到“work”文件夹并删除。 3. 删除Tomcat日志文件：在Tomcat安装目录下找到“logs”文件夹并删除其中的日志文件。 4. 删除Tomcat临时文件：在Tomcat安装目录下找到“temp”文件夹并删除其中的临时文件。 5. 清理Tomcat缓存：在Tomcat安装目录下找到“catalina”文件夹并删除其中的缓存文件。 6. 清理Tomcat应用程序：在Tomcat安装目录下找到“webapps”文件夹并删除其中的应用程序。 7. 清理Tomcat配置文件：在Tomcat安装目录下找到“conf”文件夹并删除其中的配置文件。 8. 清理Tomcat插件：在Tomcat安装目录下找到“lib”文件夹并删除其中的插件。 9. 重新启动Tomcat服务器：在命令行中输入“startup.bat”（Windows）或“startup.sh”（Linux）。 注意：在清理Tomcat之前，请备份重要的文件和配置。 配置MySQL\r查看博客\n启动依然还有报错，需要将mysql连接包复制到lib文件夹下\n不确定对mysql连接包的版本有没有要求，我刚开始用的是8.0.30版本，依然存在报错，改为8.0.17后即可，记得删除原本5.xx版本的jar包 再次启动，报错如下\n1 2 3 4 5 6 ### Error querying database. Cause: java.sql.SQLSyntaxErrorException: Table \u0026#39;activit.ACT_GE_PROPERTY\u0026#39; doesn\u0026#39;t exist ### The error may exist in org/activiti/db/mapping/entity/Property.xml ### The error may involve org.activiti.engine.impl.persistence.entity.PropertyEntityImpl.selectProperty-Inline ### The error occurred while setting parameters ### SQL: select * from ACT_GE_PROPERTY where NAME_ = ? ### Cause: java.sql.SQLSyntaxErrorException: Table \u0026#39;activit.ACT_GE_PROPERTY\u0026#39; doesn\u0026#39;t exist 修改配置文件\n添加nullCatalogMeansCurrent=true即可 datasource.url=jdbc:mysql://127.0.0.1:3306/activiti6ui?nullCatalogMeansCurrent=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\u0026amp;allowPublicKeyRetrieval=true junit报错\r导入activiti依赖后，junit报错\n1 java.lang.IllegalStateException: Failed to load ApplicationContext 更换junit依赖即可\n1 2 3 4 5 6 7 8 9 10 package com.example.demo; import org.junit.Test; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest public class ActivitiDemoApplicationTests { @Test public void contextLoads() { System.out.println(\u0026#34;aaa\u0026#34;); } } 注意\nactiviti和mybatis版本问题，可能会导致版本冲突\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activiti-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;activiti-demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;activiti-demo\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;2.3.12.RELEASE\u0026lt;/spring-boot.version\u0026gt; \u0026lt;mybatis-plus.version\u0026gt;3.5.2\u0026lt;/mybatis-plus.version\u0026gt; \u0026lt;activiti.version\u0026gt;7.0.0.GA\u0026lt;/activiti.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- web --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- test --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis-plus --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- activiti --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.activiti\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activiti-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${activiti.version}\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;com.example.demo.ActivitiDemoApplication\u0026lt;/mainClass\u0026gt; \u0026lt;skip\u0026gt;true\u0026lt;/skip\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;repackage\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;repackage\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 获取ProcessEngine对象报错\rjdk从8更换为11即可 流程部署后查询不到\r那是因为没有部署成功 这两个xml文件，图标都不一样，是文件的命名有问题 将文件名改为xxx.bpmn20即可\n","date":"2023-07-10T00:00:00Z","image":"http://localhost:1313/p/activiti%E6%8A%A5%E9%94%99/202412212108679_hu2780851740685485858.png","permalink":"http://localhost:1313/p/activiti%E6%8A%A5%E9%94%99/","title":"Activiti报错"},{"content":"搭建Gitee图床\r我个人常用的markdown应用有typora、vscode和息流三款\ntypora收费，网络上有不少破解教程 vscode可以安装插件来写markdown文档，需要知道markdown的语法格式 息流使用起来相对更加简单，有免费空间限制，如果只是编写文档也足够了 在使用typora编写文档时，图片存储是个问题，虽然可以调整为相对路径存储，但是还需要保存好对应的本地图片，不然不知道图片被删掉了的话\u0026hellip; 相对路径存储\n这个时候可以搭建一个图床，需要先下载名为【PicGo】的工具 github下载地址 https://github.com/Molunerfinn/PicGo 123网盘下载地址 https://www.123pan.com/s/tMU0Vv-31zUd.html 安装好PicGo默认即可，之后需要创建一个Gitee仓库\n新建仓库\n创建私有仓库\n个人主页\n个人设置\n私人令牌\n生成新令牌\n提交信息\n复制令牌\n这里很重要了，最好是保存一下生成的这串令牌，后续无法再查看到了 接下来开始配置PicGo\n安装插件\n安装一下【gitee】插件\n配置Gitee信息\n上方的repo填写如下图片的地址\n仓库地址\ntoken则填写生成的【私人令牌】 接下来别忘了开源仓库\n进入私有仓库\n找到仓库后进入\n管理\n设置仓库\n添加readme文件\n再次进入管理\n开源Gitee仓库\n最后配置一下Typora的文件上传\n配置Typora\n为了避免上传的图片重名，可以打开PicGo的【时间戳重命名】配置\n配置时间戳\ntypora上传图片结果\n最后提一嘴，我使用过阿里云OSS和Github的图床，阿里云OSS倒是没什么问题，可能会有少许收费，Github懂得都懂，连接不太好毕竟是在国外，可能会造成图片传不上去，或者传上去了显示不出来\n","date":"2023-07-09T00:00:00Z","image":"http://localhost:1313/p/%E6%90%AD%E5%BB%BAgitee%E5%9B%BE%E5%BA%8A/202412211443704_hu3779382978942361160.png","permalink":"http://localhost:1313/p/%E6%90%AD%E5%BB%BAgitee%E5%9B%BE%E5%BA%8A/","title":"搭建Gitee图床"},{"content":"elasticsearch学习\r索引库操作\r下载sql文件，执行sql\r执行sql，创建表\rsql文件\n进入kibana\r进入kibana\r在 Elasticsearch 中，创建文档、索引和 mapping 的顺序如下：\n创建索引：在 Elasticsearch 中，索引是存储文档的容器。要创建索引，可以使用 PUT 请求，指定索引名称和一些可选的设置。\n创建 mapping：mapping 定义了索引中的字段和它们的数据类型。要创建 mapping，可以使用 PUT 请求，指定索引名称和 mapping 定义。\n创建文档：文档是索引中的数据单元。要创建文档，可以使用 POST 请求，指定索引名称、文档 ID 和文档内容。\n需要注意的是，如果在创建文档时指定的索引不存在，Elasticsearch 会自动创建该索引，并使用默认的 mapping。因此，为了确保索引中的字段和数据类型符合预期，最好在创建索引之前先定义好 mapping。 酒店定义如下，但是注意一个问题\rname、brand、business等字段都要参与搜索，也就是说用户输入的关键词可能是多个关键字（查询条件不是一个值，而是多个值）\n可以使用copy_to属性，将当前字段拷贝到指定字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 酒店的mapping映射（不完美） PUT /hotel { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;price\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;score\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;brand\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;city\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;starName\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;business\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34; }, \u0026#34;location\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;geo_point\u0026#34; }, \u0026#34;pic\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;:false } } } } 更改后的mapping如下\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # 酒店的mapping映射 PUT /hotel { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;copy_to\u0026#34;:\u0026#34;all\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;price\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;score\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;brand\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;:\u0026#34;all\u0026#34; }, \u0026#34;city\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;starName\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;business\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;:\u0026#34;all\u0026#34; }, \u0026#34;location\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;geo_point\u0026#34; }, \u0026#34;pic\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;:false }, \u0026#34;all\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34; } } } } 创建项目\r可以看到我这里的版本是8.6.2\rpom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;demo\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;2.3.12.RELEASE\u0026lt;/spring-boot.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--elasticsearch--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-elasticsearch\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis plus--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--fastjson--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.58\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--web--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--test--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;com.example.demo.DemoApplication\u0026lt;/mainClass\u0026gt; \u0026lt;skip\u0026gt;true\u0026lt;/skip\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;repackage\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;repackage\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 编写测试类\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import lombok.extern.slf4j.Slf4j; import org.apache.http.HttpHost; import org.elasticsearch.client.RestClient; import org.elasticsearch.client.RestHighLevelClient; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j class HotelDocumentTest { private RestHighLevelClient client; @BeforeEach void initClient(){ this.client=new RestHighLevelClient(RestClient.builder( HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;) // 若是集群，可指定多个地址如下 //HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;), //HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;) )); } @AfterEach void destroyClient(){ try { this.client.close(); } catch (IOException e) { log.error(\u0026#34;关闭资源出错,{}\u0026#34;,e.getMessage()); throw new RuntimeException(e); } } @Test void contextLoads() { System.out.println(client); } } 存放静态常量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class HotelContants { public static final String MAPPING_TEMPLATE=\u0026#34;{\\n\u0026#34; + \u0026#34; \\\u0026#34;mappings\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;properties\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;id\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;name\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;text\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;analyzer\\\u0026#34;: \\\u0026#34;ik_max_word\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;:\\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;address\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;index\\\u0026#34;: false\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;price\\\u0026#34;:{\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;integer\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;score\\\u0026#34;:{\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;integer\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;brand\\\u0026#34;:{\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;:\\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;city\\\u0026#34;:{\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;starName\\\u0026#34;:{\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;business\\\u0026#34;:{\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;:\\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;:\\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;location\\\u0026#34;:{\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;:\\\u0026#34;geo_point\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;pic\\\u0026#34;:{\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;:\\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;index\\\u0026#34;:false\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;all\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;text\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;analyzer\\\u0026#34;: \\\u0026#34;ik_max_word\\\u0026#34;\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34;}\u0026#34;; } 编写测试方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import com.example.demo.constants.HotelContants; import lombok.extern.slf4j.Slf4j; import org.apache.http.HttpHost; import org.elasticsearch.client.RequestOptions; import org.elasticsearch.client.RestClient; import org.elasticsearch.client.RestHighLevelClient; import org.elasticsearch.client.indices.CreateIndexRequest; import org.elasticsearch.common.xcontent.XContentType; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j class HotelDocumentTest { private RestHighLevelClient client; @BeforeEach void initClient(){ this.client=new RestHighLevelClient(RestClient.builder( HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;) // 若是集群，可指定多个地址如下 //HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;), //HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;) )); } @AfterEach void destroyClient(){ try { this.client.close(); } catch (IOException e) { log.error(\u0026#34;关闭资源出错,{}\u0026#34;,e.getMessage()); throw new RuntimeException(e); } } /** * 创建索引库 */ @Test void createHotelIndexTest(){ // 1.创建Request对象 CreateIndexRequest request = new CreateIndexRequest(\u0026#34;hotel\u0026#34;); // 2.请求参数，MAPPING_TEMPLATE是静态常量字符串，内容是创建索引库的DSL语句 request.source(HotelContants.MAPPING_TEMPLATE, XContentType.JSON); // 3.发起请求 try { client.indices().create(request, RequestOptions.DEFAULT); } catch (IOException e) { throw new RuntimeException(e); } } } 运行成功，前往kibana查询索引库\n1 GET /hotel 删除索引库、判断索引库是否存在\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 import com.example.demo.constants.HotelContants; import lombok.extern.slf4j.Slf4j; import org.apache.http.HttpHost; import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest; import org.elasticsearch.client.RequestOptions; import org.elasticsearch.client.RestClient; import org.elasticsearch.client.RestHighLevelClient; import org.elasticsearch.client.indices.CreateIndexRequest; import org.elasticsearch.client.indices.GetIndexRequest; import org.elasticsearch.common.xcontent.XContentType; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j class HotelDocumentTest { private RestHighLevelClient client; @BeforeEach void initClient() { this.client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;) // 若是集群，可指定多个地址如下 //HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;), //HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;) )); } @AfterEach void destroyClient() { try { this.client.close(); } catch (IOException e) { log.error(\u0026#34;关闭资源出错,{}\u0026#34;, e.getMessage()); throw new RuntimeException(e); } } /** * 创建索引库 */ @Test void createHotelIndexTest() { // 1.创建Request对象 CreateIndexRequest request = new CreateIndexRequest(\u0026#34;hotel\u0026#34;); // 2.请求参数，MAPPING_TEMPLATE是静态常量字符串，内容是创建索引库的DSL语句 request.source(HotelContants.MAPPING_TEMPLATE, XContentType.JSON); // 3.发起请求 try { client.indices().create(request, RequestOptions.DEFAULT); } catch (IOException e) { throw new RuntimeException(e); } } /** * 删除索引库 */ @Test void deleteHotelIndexTest() { // 1.创建Request对象 DeleteIndexRequest request = new DeleteIndexRequest(\u0026#34;hotel\u0026#34;); // 2.发起请求 try { client.indices().delete(request, RequestOptions.DEFAULT); } catch (IOException e) { throw new RuntimeException(e); } } /** * 判断索引库是否存在 */ @Test void existsHotelIndexTest() { // 1.创建Request对象 GetIndexRequest request = new GetIndexRequest(\u0026#34;hotel\u0026#34;); // 2.发起请求 boolean exists = false; try { exists = client.indices().exists(request, RequestOptions.DEFAULT); } catch (IOException e) { throw new RuntimeException(e); } System.out.println(\u0026#34;索引库\u0026#34;+(exists?\u0026#34;存在\u0026#34;:\u0026#34;不存在\u0026#34;)); } } 索引库总结\r索引库操作的基本步骤\n初始化RestHighLevelClient 创建XXXIndexRequest（XXX是create、get、delete） 准备DSL（create时需要语句） 发送请求，调用RestHighLevelClient对象的indices().xxx()方法（xxx是create、exists、delete） 文档操作\r插入数据\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import com.alibaba.fastjson.JSON; import com.example.demo.domain.Hotel; import com.example.demo.domain.HotelDoc; import com.example.demo.service.HotelService; import lombok.extern.slf4j.Slf4j; import org.apache.http.HttpHost; import org.elasticsearch.action.index.IndexRequest; import org.elasticsearch.client.RequestOptions; import org.elasticsearch.client.RestClient; import org.elasticsearch.client.RestHighLevelClient; import org.elasticsearch.common.xcontent.XContentType; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelIndexTest { @Autowired private HotelService hotelService; private RestHighLevelClient client; @BeforeEach void initClient() { this.client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;) // 若是集群，可指定多个地址如下 //HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;), //HttpHost.create(\u0026#34;http://localhost:9200\u0026#34;) )); } @AfterEach void destroyClient() { try { this.client.close(); } catch (IOException e) { log.error(\u0026#34;关闭资源出错,{}\u0026#34;, e.getMessage()); throw new RuntimeException(e); } } @Test void addIndexTest() { // hotel对象与索引库不符，经纬度是分开的两个字段，索引库则是一个字段 // 所以新建一个HotelDoc类与索引库对应 Hotel hotel = hotelService.getById(61083L); HotelDoc hotelDoc = new HotelDoc(hotel); // 1.准备request对象 IndexRequest request = new IndexRequest(\u0026#34;hotel\u0026#34;).id(hotel.getId().toString()); // 2.准备json文档 request.source(JSON.toJSONString(hotelDoc), XContentType.JSON); // 3.发送请求 try { client.index(request, RequestOptions.DEFAULT); } catch (IOException e) { throw new RuntimeException(e); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class HotelDoc { private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \u0026#34;,\u0026#34; + hotel.getLongitude(); this.pic = hotel.getPic(); } } 这里运行报错了，不过不影响，插入数据已经成功\rkibana使用GET /hotel/_doc/61083查询\n参考博客 查看日志打印，发现 es版本\u0026gt;8 推介查看博客\n添加依赖和配置\r1 2 3 4 5 6 7 8 9 10 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;co.elastic.clients\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;elasticsearch-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jakarta.json\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.json-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 spring: es: address: localhost port: 9200 scheme: http username: elastic password: 123456 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.json.jackson.JacksonJsonpMapper; import co.elastic.clients.transport.ElasticsearchTransport; import co.elastic.clients.transport.rest_client.RestClientTransport; import org.apache.http.HttpHost; import org.apache.http.auth.AuthScope; import org.apache.http.auth.UsernamePasswordCredentials; import org.apache.http.client.CredentialsProvider; import org.apache.http.impl.client.BasicCredentialsProvider; import org.apache.http.impl.nio.client.HttpAsyncClientBuilder; import org.elasticsearch.client.RestClient; import org.elasticsearch.client.RestClientBuilder; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class ElasticSearchConfig { @Value(\u0026#34;${spring.es.address}\u0026#34;) String address; @Value(\u0026#34;${spring.es.port}\u0026#34;) Integer port; @Value(\u0026#34;${spring.es.scheme}\u0026#34;) String scheme; @Value(\u0026#34;${spring.es.username}\u0026#34;) String username; @Value(\u0026#34;${spring.es.password}\u0026#34;) String password; @Bean public ElasticsearchClient esRestClientWithCred(){ final CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); // 配置连接ES的用户名和密码，如果没有用户名和密码可以不加这一行 credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(username, password)); RestClientBuilder restClientBuilder = RestClient.builder(new HttpHost(address, port, scheme)) .setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() { @Override public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpAsyncClientBuilder) { return httpAsyncClientBuilder.setDefaultCredentialsProvider(credentialsProvider); } }); RestClient restClient = restClientBuilder.build(); ElasticsearchTransport transport = new RestClientTransport( restClient, new JacksonJsonpMapper()); return new ElasticsearchClient(transport); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch.core.GetResponse; import co.elastic.clients.elasticsearch.core.IndexRequest; import com.alibaba.fastjson.JSON; import com.example.demo.domain.Hotel; import com.example.demo.domain.HotelDoc; import com.example.demo.service.HotelService; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelIndexElasticTest { @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void addIndexTest() { // 创建要插入的实体 // hotel对象与索引库不符，经纬度是分开的两个字段，索引库则是一个字段 // 所以新建一个HotelDoc类与索引库对应 Hotel hotel = hotelService.getById(61083); HotelDoc hotelDoc = new HotelDoc(hotel); // 方法一 IndexRequest\u0026lt;Object\u0026gt; indexRequest = new IndexRequest.Builder\u0026lt;\u0026gt;() // 博客中并未添加这句话，需要自己指定id，否则 GET /hotel/_doc/61083 在kibana中无法查询到相关数据 .id(hotel.getId().toString()) .index(\u0026#34;hotel\u0026#34;) .document(hotelDoc) .build(); try { client.index(indexRequest); } catch (IOException e) { throw new RuntimeException(e); } } } 在上述代码中遇到过一个问题\r正常运行结束，但是在kibana中无法查询到数据\n是因为没有手动指定id，具体查看上述代码注释\n采用lambda表达式的写法\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch.core.GetResponse; import co.elastic.clients.elasticsearch.core.IndexRequest; import com.alibaba.fastjson.JSON; import com.example.demo.domain.Hotel; import com.example.demo.domain.HotelDoc; import com.example.demo.service.HotelService; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelIndexElasticTest { @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void addIndexTest2() { // 创建要插入的实体 // hotel对象与索引库不符，经纬度是分开的两个字段，索引库则是一个字段 // 所以新建一个HotelDoc类与索引库对应 Hotel hotel = hotelService.getById(61083); HotelDoc hotelDoc = new HotelDoc(hotel); // 方法二 try { client.index(item -\u0026gt; item .id(hotel.getId().toString()) .index(\u0026#34;hotel\u0026#34;) .document(hotelDoc)); } catch (IOException e) { throw new RuntimeException(e); } } } 查询数据\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch.core.GetResponse; import co.elastic.clients.elasticsearch.core.IndexRequest; import com.alibaba.fastjson.JSON; import com.example.demo.domain.Hotel; import com.example.demo.domain.HotelDoc; import com.example.demo.service.HotelService; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelIndexElasticTest { @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; /** * 获取索引 */ @Test void getIndexTest(){ String id = \u0026#34;61083\u0026#34;; GetResponse\u0026lt;HotelDoc\u0026gt; response = null; try { response = client.get(g -\u0026gt; g .index(\u0026#34;hotel\u0026#34;) .id(id), HotelDoc.class ); } catch (IOException e) { throw new RuntimeException(e); } if (response.found()) { HotelDoc hotelDoc = response.source(); log.info(\u0026#34;返回结果 \u0026#34; + JSON.toJSONString(hotelDoc)); } else { log.info(\u0026#34;数据不存在\u0026#34;); } } } 修改数据\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch.core.GetResponse; import co.elastic.clients.elasticsearch.core.IndexRequest; import com.alibaba.fastjson.JSON; import com.example.demo.domain.Hotel; import com.example.demo.domain.HotelDoc; import com.example.demo.service.HotelService; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelIndexElasticTest { @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void updateIndexTest() { Hotel hotel = hotelService.getById(61083); HotelDoc hotelDoc = new HotelDoc(hotel); // 将城市从“上海”变为“不在上海” hotelDoc.setCity(\u0026#34;不在上海\u0026#34;); try { client.update(item -\u0026gt; item .index(\u0026#34;hotel\u0026#34;) .doc(hotelDoc) .id(hotel.getId().toString()), HotelDoc.class ); } catch (IOException e) { throw new RuntimeException(e); } } } 删除数据\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch.core.GetResponse; import co.elastic.clients.elasticsearch.core.IndexRequest; import com.alibaba.fastjson.JSON; import com.example.demo.domain.Hotel; import com.example.demo.domain.HotelDoc; import com.example.demo.service.HotelService; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelIndexElasticTest { @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; /** * 删除索引测试 */ @Test void deleteIndexTest() { Hotel hotel = hotelService.getById(61083); try { client.delete(item -\u0026gt; item .id(hotel.getId().toString()) .index(\u0026#34;hotel\u0026#34;)); } catch (IOException e) { throw new RuntimeException(e); } } } 批量导入数据\r利用JavaRestClient批量导入酒店数据到ES\r需求:批量查询酒店数据，然后批量导入索引库中\n思路:\n利用mybatis-plus查询酒店数据 将查询到的酒店数据(Hotel) 转换为文档类型数据( HotelDoc ) 利用JavaRestClient中 的Bulk批处理，实现批量新增文档 黑马程序员里的写法如上图所示\r但是由于我在windows安装的elasticsearch的版本问题，所以采用如下写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch.core.BulkRequest; import co.elastic.clients.elasticsearch.core.GetResponse; import co.elastic.clients.elasticsearch.core.IndexRequest; import co.elastic.clients.elasticsearch.core.bulk.BulkOperation; import co.elastic.clients.elasticsearch.core.bulk.IndexOperation; import com.alibaba.fastjson.JSON; import com.example.demo.domain.Hotel; import com.example.demo.domain.HotelDoc; import com.example.demo.service.HotelService; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; import java.util.ArrayList; import java.util.List; @Slf4j @SpringBootTest class HotelIndexElasticTest { @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; /** * 批量导入数据测试 */ @Test void bulkIndexListTest() { // 1.创建Bulk请求 BulkRequest bulkRequest = null; List\u0026lt;BulkOperation\u0026gt; bulkOperations = new ArrayList\u0026lt;\u0026gt;(); for (Hotel hotel : hotelService.list()) { HotelDoc hotelDoc = new HotelDoc(hotel); IndexOperation\u0026lt;Object\u0026gt; build = new IndexOperation.Builder\u0026lt;\u0026gt;() .id(hotelDoc.getId().toString()) .index(\u0026#34;hotel\u0026#34;) .document(hotelDoc).build(); bulkOperations.add(build._toBulkOperation()); } // 2.添加要批量提交的请求 bulkRequest = new BulkRequest.Builder() .index(\u0026#34;hotel\u0026#34;) .operations(bulkOperations) .build(); System.out.printf(\u0026#34;一共插入了%s条数据%n\u0026#34;,bulkRequest.operations().size()); // 3.发起bulk请求 try { client.bulk(bulkRequest); } catch (IOException e) { throw new RuntimeException(e); } } } 批量查询\r1 GET /hotel/_search 文档总结\r文档操作的基本步骤\n初始化RestHighLevelClient 创建XXXRequest。（XXX是Index、Get、Update、Delete） 准备参数（Index和Update时需要） 发送请求，调用RestHighLevelClient对象的xxx()方法（xxx是index、get、update、delete） 解析结果（get时需要） DSL查询及案例\rDSL查询语法\r基本语法\r1 2 3 4 5 6 7 # 查询所有 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match_all\u0026#34;: {} } } 全文检索查询\r1 2 3 4 5 6 7 8 9 # match查询 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match\u0026#34;:{ \u0026#34;all\u0026#34;:\u0026#34;外滩\u0026#34; } } } 如下查询与上面的查询效果一样，但是由于检索多个字段，效率更低\r推介使用上面的查询（copy_to）\n1 2 3 4 5 6 7 8 9 10 # multi_match查询 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;外滩如家\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;brand\u0026#34;,\u0026#34;name\u0026#34;,\u0026#34;business\u0026#34;] } } } 精确查询\r精确匹配不会对输入的内容进行分词，必须完全一致\r假如:输入的是上海杭州，则查询结果为0\n1 2 3 4 5 6 7 8 9 10 11 # term查询 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;term\u0026#34;:{ \u0026#34;city\u0026#34;:{ \u0026#34;value\u0026#34;:\u0026#34;上海\u0026#34; } } } } 价格大于等于100，小于等于300\rgt为大于，gte为大于等于；lte和lt同理\n1 2 3 4 5 6 7 8 9 10 11 12 # range查询 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;range\u0026#34;:{ \u0026#34;price\u0026#34;: { \u0026#34;gte\u0026#34;: 100, \u0026#34;lte\u0026#34;: 300 } } } } 地理查询\r查询在一个矩形范围内的地点\rtop_left(左上角)和bottom_right(右下角)分别确定一个点，两个点水平作两条直线得到的矩形范围 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # geo_bounding_box查询 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;geo_bounding_box\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;top_left\u0026#34;: { \u0026#34;lat\u0026#34;: 31.1, \u0026#34;lon\u0026#34;: 121.5 }, \u0026#34;bottom_right\u0026#34;: { \u0026#34;lat\u0026#34;: 30.9, \u0026#34;lon\u0026#34;: 121.7 } } } } } 查询距离一个点一定范围内的数据\r```sql\r# geo_distance查询\rGET /hotel/_search\r{\r\"query\":{\r\"geo_distance\": {\r\"distance\": \"15km\",\r\"location\": {\r\"lat\": 31.21,\r\"lon\": 121.5\r}\r}\r}\r}\r```\r\u003e 也可以使用下面这种写法\r```sql\r# geo_distance查询\rGET /hotel/_search\r{\r\"query\":{\r\"geo_distance\": {\r\"distance\": \"15km\",\r\"location\": \"31.21,121.5\"\r}\r}\r}\r```\r#### Function score query\r![image-20230525224121984](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202307132142645.png)\r\u003e # 案例\r\u003e\r\u003e 让“如家”这个品牌的酒店排名靠前一些\r```sql\r# 让“如家”这个品牌的酒店排名靠前一些\r# function score查询\rGET /hotel/_search\r{\r\"query\":{\r\"function_score\": {\r\"query\": {\r\"match\": {\r\"all\": \"如家\"\r}\r},\r\"functions\": [\r{\r\"filter\":{\r\"term\":{\r\"brand\":\"如家\"\r}\r},\r\"weight\": 10\r}\r],\r\"boost_mode\": \"sum\"\r}\r}\r}\r```\r#### 复合查询Boolean Query\r\u003e布尔查询是-个或多个查询子句的组合。子查询的组合方式有:\r\u003e1. must:必须匹配每个子查询，类似“与”\r\u003e2. should:选择性匹配子查询，类似“或\"\r\u003e3. must_ not:必须不匹配，`不参与算分`，类似“非”\r\u003e4. filter:必须匹配，`不参与算分`\r```sql\r# city在上海、brand是“皇冠假日”和“华美达”中的一个、price不能小于等于500、score大于等于45\rGET /hotel/_search\r{\r\"query\":{\r\"bool\": {\r\"must\": [\r{\r\"term\": {\r\"city\": {\r\"value\": \"上海\"\r}\r}\r}\r],\r\"should\": [\r{\r\"term\": {\r\"brand\": {\r\"value\": \"皇冠假日\"\r}\r}\r},\r{\r\"term\": {\r\"brand\": {\r\"value\": \"华美达\"\r}\r}\r}\r],\r\"must_not\": [\r{\r\"range\": {\r\"price\": {\r\"lte\": 500\r}\r}\r},\r{\r\"range\": {\r\"score\": {\r\"gte\": 45\r}\r}\r}\r]\r}\r}\r}\r```\r\u003e # 案例练习\r\u003e\r\u003e 需求：搜索名字包含`如家`，价格不高于400，在坐标31.21、121.5周围10km范围内的酒店\r```sql\r# 搜索名字包含`如家`，价格不高于400，在坐标31.21、121.5周围10km范围内的酒店\rGET /hotel/_search\r{\r\"query\":{\r\"bool\": {\r\"must\": [\r{\r\"match\": {\r\"name\": \"如家\"\r}\r}\r],\r\"must_not\": [\r{\r\"range\": {\r\"price\": {\r\"gt\": 400\r}\r}\r}\r],\r\"filter\": [\r{\r\"geo_distance\": {\r\"distance\": \"10km\",\r\"location\": {\r\"lat\": 31.21,\r\"lon\": 121.5\r}\r}\r}\r]\r}\r}\r}\r```\r### 搜索结果处理\r#### 排序\r```sql\r# 排序，排序字段和排序方式 asc、desc\rGET /hotel/_search\r{\r\"query\":{\r\"match_all\": {}\r},\r\"sort\":{\r\"price\":\"asc\"\r}\r}\r```\r\u003e # 地理位置排序\r```sql\r# 排序，排序字段和排序方式 asc、desc\rGET /hotel/_search\r{\r\"query\":{\r\"match_all\": {}\r},\r\"sort\":{\r\"_geo_distance\":{\r\"location\":{\r\"lat\": 31.21,\r\"lon\": 121.5\r},\r\"order\":\"asc\",\r\"unit\":\"km\"\r}\r}\r}\r```\r\u003e 也可以采用如下写法\r```sql\r# 排序，排序字段和排序方式 asc、desc\rGET /hotel/_search\r{\r\"query\":{\r\"match_all\": {}\r},\r\"sort\":{\r\"_geo_distance\":{\r\"location\":\"31.21,121.5\",\r\"order\":\"asc\",\r\"unit\":\"km\"\r}\r}\r}\r```\r\u003e # 案例：对酒店数据按照用户评价降序排序，评价相同的按照价格升序排序\r```sql\r# 对酒店数据按照用户评价降序排序，评价相同的按照价格升序排序\rGET /hotel/_search\r{\r\"query\":{\r\"match_all\": {}\r},\r\"sort\":[\r{\r\"score\":\"desc\"\r},\r{\r\"price\":\"asc\"\r}\r]\r}\r```\r\u003e # 案例：实现对酒店数据按照位置坐标的距离升序排序\r```sql\r# 实现对酒店数据按照位置坐标的距离升序排序\rGET /hotel/_search\r{\r\"query\":{\r\"match_all\": {}\r},\r\"sort\":{\r\"_geo_distance\":{\r\"location\":\"31.21,121.5\",\r\"order\":\"asc\",\r\"unit\":\"km\"\r}\r}\r}\r# 或者采用如下地理位置写法\r# 实现对酒店数据按照位置坐标的距离升序排序\rGET /hotel/_search\r{\r\"query\":{\r\"match_all\": {}\r},\r\"sort\":{\r\"_geo_distance\":{\r\"location\":{\r\"lat\":31.21,\r\"lon\":121.5\r},\r\"order\":\"asc\",\r\"unit\":\"km\"\r}\r}\r}\r```\r#### 分页\r\u003eelasticsearch默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。\r\u003e\r\u003eelasticsearch中通过修改`from`、`size`参 数来控制要返回的分页结果\r```sql\r# 分页查询\rGET /hotel/_search\r{\r\"query\":{\r\"match_all\": {}\r},\r\"sort\":[\r{\r\"price\":\"asc\"\r}\r],\r\"from\":0,\r\"size\":5\r}\r```\r\u003e ## `深度分页问题`\r\u003e\r\u003e ES是分布式的，所以会面临深度分页问题。例如按price排序后，获取from = 990，size =10的数据:\r\u003e #### 如果希望查找前1000条数据，`正确`的做法是取每个片上的前1000条数据，然后将这些数据重新排序\r\u003e\r\u003e 1. 首先在每个数据分片.上都排序并查询前1000条文档。\r\u003e 2. 然后将所有节点的结果聚合，在内存中重新排序选出前1000条文档\r\u003e 3. 最后从这1000条中，选取从990开始的10条文档\r\u003e\r\u003e `注意`：如果搜索页数过深，或者结果集(from + size)越大，对内存和CPU的消耗也越高。因此ES设定结果集查询的.上限是10000\r\u003e\r\u003e 针对深度分页，ES提供了两种`解决方案`,官方文档:\r\u003e\r\u003e search after:分页时需要排序，原理是从上一-次的排序值开始，查询下一页数据。官方推荐使用的方式。\r\u003e\r\u003e scroll:原理将排序数据形成快照，保存在内存。官方已经不推荐使用。\r`from + size`:\r优点:支持随机翻页\r缺点:深度分页问题，默认查询上限(from + size)是10000\r场景:百度、京东、谷歌、淘宝这样的`随机翻页搜索`\r`after search`:\r优点:没有查询上限(单次查询的size不超过10000 )\r缺点:只能向后逐页查询，不支持随机翻页\r场景:没有随机翻页需求的搜索，例如`手机向下滚动翻页`\r`scroll`:\r优点:没有查询.上限(单次查询的size不超过10000)\r缺点:会有额外内存消耗，并且搜索结果是非实时的\r场景:海量数据的获取和迁移。从ES7.1开始不推荐，建议用aftersearch方案\r#### 高亮\r```sql\r# 高亮查询\rGET /hotel/_search\r{\r\"query\":{\r\"match\": {\r\"all\": \"如家\"\r}\r},\r\"highlight\":{\r// 指定要高亮的字段\r\"fields\": {\r\"all\": {\r// 用来标记高亮字段的前置标签\r\"pre_tags\": \"\",\r// 用来标记高亮字段的后置标签\r\"post_tags\": \"\"\r}\r}\r}\r}\r```\r\u003e ### 注意这里不能使用`match_all`，因为需要指定搜索的关键字\r\u003e\r\u003e 同时，默认情况下 ES搜索字段必须与高亮字段一致，上述案例中都是`all`，请看下面案例\r```sql\r# 高亮查询\rGET /hotel/_search\r{\r\"query\":{\r\"match\": {\r\"all\": \"如家\"\r}\r},\r\"highlight\":{\r// 指定要高亮的字段\r\"fields\": {\r\"name\": {\r// 搜索字段和高亮字段可以不匹配\r\"require_field_match\": \"false\", // 用来标记高亮字段的前置标签\r\"pre_tags\": \"\",\r// 用来标记高亮字段的后置标签\r\"post_tags\": \"\"\r}\r}\r}\r}\r```\r### RestClient查询\r#### match_all\r```java\rimport co.elastic.clients.elasticsearch.ElasticsearchClient;\rimport co.elastic.clients.elasticsearch.core.SearchRequest;\rimport co.elastic.clients.elasticsearch.core.SearchResponse;\rimport com.example.demo.domain.HotelDoc;\rimport com.example.demo.service.HotelService;\rimport lombok.extern.slf4j.Slf4j;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport java.io.IOException;\r@Slf4j\r@SpringBootTest\rclass HotelSearchTest {\r@Autowired\rprivate HotelService hotelService;\r@Autowired\rElasticsearchClient client;\r@Test\rvoid matchAllTest() throws IOException {\rSearchRequest request = new SearchRequest.Builder()\r.index(\"hotel\")\r.query(q -\u003e q.matchAll(matchAllQuery -\u003e matchAllQuery))\r.build();\rSearchResponse matchSearch = client.search(request, HotelDoc.class);\rlog.info(\"共搜索到:{}条数据\", (matchSearch.hits().total() == null ? 0 : matchSearch.hits().total().value()));\rmatchSearch.hits().hits().forEach(item -\u003e {\rSystem.out.println(item.source());\r});\r}\r}\r```\r#### match\r```java\rimport co.elastic.clients.elasticsearch.ElasticsearchClient;\rimport co.elastic.clients.elasticsearch.core.SearchRequest;\rimport co.elastic.clients.elasticsearch.core.SearchResponse;\rimport com.example.demo.domain.HotelDoc;\rimport com.example.demo.service.HotelService;\rimport lombok.extern.slf4j.Slf4j;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport java.io.IOException;\r@Slf4j\r@SpringBootTest\rclass HotelSearchTest {\r@Autowired\rprivate HotelService hotelService;\r@Autowired\rElasticsearchClient client;\r@Test\rvoid matchTest() throws IOException {\rSearchRequest request = new SearchRequest.Builder()\r.index(\"hotel\")\r.query(query-\u003equery.match(\rmatchQuery-\u003ematchQuery.field(\"brand\").query(\"如家\")\r))\r.build();\rSearchResponse matchSearch = client.search(request, HotelDoc.class);\rmatchSearch.hits().hits().forEach(item -\u003e {\rSystem.out.println(item.source());\r});\r}\r}\r```\r#### term\r```java\rimport co.elastic.clients.elasticsearch.ElasticsearchClient;\rimport co.elastic.clients.elasticsearch.core.SearchRequest;\rimport co.elastic.clients.elasticsearch.core.SearchResponse;\rimport com.example.demo.domain.HotelDoc;\rimport com.example.demo.service.HotelService;\rimport lombok.extern.slf4j.Slf4j;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport java.io.IOException;\r@Slf4j\r@SpringBootTest\rclass HotelSearchTest {\r@Autowired\rprivate HotelService hotelService;\r@Autowired\rElasticsearchClient client;\r@Test\rvoid termQueryTest() throws IOException {\rSearchRequest request = new SearchRequest.Builder()\r.index(\u0026quot;hotel\u0026quot;)\r.query(query -\u0026gt; query.term(\rtermQuery -\u0026gt; termQuery.field(\u0026quot;city\u0026quot;).value(\u0026quot;北京\u0026quot;)\r))\r.build();\rSearchResponse\u0026lt;HotelDoc\u0026gt; matchSearch = client.search(request, HotelDoc.class);\rmatchSearch.hits().hits().forEach(item -\u0026gt; {\rSystem.out.println(item.source());\r});\r}\r}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #### range ```java import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import com.example.demo.domain.HotelDoc; import com.example.demo.service.HotelService; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelSearchTest { @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void termQueryTest() throws IOException { SearchRequest request = new SearchRequest.Builder() .index(\u0026#34;hotel\u0026#34;) .query(query -\u0026gt; query.range( rangeQuery-\u0026gt;rangeQuery .field(\u0026#34;price\u0026#34;) .gte(JsonData.of(100)).lte(JsonData.of(300)) )) .build(); SearchResponse\u0026lt;HotelDoc\u0026gt; matchSearch = client.search(request, HotelDoc.class); matchSearch.hits().hits().forEach(item -\u0026gt; { System.out.println(item.source()); }); } } bool\r搜索名字包含如家，价格不高于400，在坐标31.21、121.5周围10km范围内的酒店（案例在之前boolean query部分出现过）\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 搜索名字包含`如家`，价格不高于400，在坐标31.21、121.5周围10km范围内的酒店 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: [ { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;如家\u0026#34; } } ], \u0026#34;must_not\u0026#34;: [ { \u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;gt\u0026#34;: 400 } } } ], \u0026#34;filter\u0026#34;: [ { \u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;10km\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.21, \u0026#34;lon\u0026#34;: 121.5 } } } ] } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import com.example.demo.domain.HotelDoc; import com.example.demo.service.HotelService; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelSearchTest { @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void boolQueryTest() throws IOException { SearchRequest request = new SearchRequest.Builder() .index(\u0026#34;hotel\u0026#34;) .query(query -\u0026gt; query.bool( boolQuery -\u0026gt; boolQuery .must(mustQuery -\u0026gt; mustQuery .match(matchQuery -\u0026gt; matchQuery .field(\u0026#34;name\u0026#34;).query(\u0026#34;如家\u0026#34;)) ) .mustNot(mustNotQuery -\u0026gt; mustNotQuery .range(rangeQuery -\u0026gt; rangeQuery .field(\u0026#34;price\u0026#34;) .gt(JsonData.of(400)) ) ) .filter(filterQuery -\u0026gt; filterQuery .geoDistance(geoDistanceQuery -\u0026gt; geoDistanceQuery .distance(\u0026#34;10km\u0026#34;) .field(\u0026#34;location\u0026#34;) .location(geoLocation -\u0026gt; geoLocation .latlon(new LatLonGeoLocation.Builder() .lat(31.21) .lon(121.5) .build() ) ) ) ) )) .build(); SearchResponse\u0026lt;HotelDoc\u0026gt; matchSearch = client.search(request, HotelDoc.class); matchSearch.hits().hits().forEach(item -\u0026gt; { System.out.println(item.source()); }); }\t} 也可以使用下面的写法\r注意：QueryBuilders的包别导错了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.LatLonGeoLocation; import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery; import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.json.JsonData; import com.example.demo.domain.HotelDoc; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelSearchTest { @Autowired ElasticsearchClient client; @Test void boolQueryTest() throws IOException { BoolQuery build = new BoolQuery.Builder() .must(QueryBuilders.term().field(\u0026#34;name\u0026#34;).value(\u0026#34;如家\u0026#34;).build()._toQuery()) .mustNot(QueryBuilders.range().field(\u0026#34;price\u0026#34;).gt(JsonData.of(400)).build()._toQuery()) .filter(QueryBuilders.geoDistance().field(\u0026#34;location\u0026#34;) .distance(\u0026#34;10km\u0026#34;) .location(item -\u0026gt; item.latlon(new LatLonGeoLocation.Builder().lat(31.21).lon(121.5).build())) .build()._toQuery()) .build(); SearchRequest request = new SearchRequest.Builder() .index(\u0026#34;hotel\u0026#34;) .query(build._toQuery()) .build(); SearchResponse\u0026lt;HotelDoc\u0026gt; matchSearch = client.search(request, HotelDoc.class); matchSearch.hits().hits().forEach(item -\u0026gt; { System.out.println(item.source()); }); } } fuzzy\n模糊查询（fuzzy query）是一种搜索技术，它允许在搜索时使用模糊匹配，以便在搜索结果中包含与搜索词项相似但不完全匹配的项。模糊查询通常用于处理拼写错误、同义词、缩写词、音近字等情况。在实现模糊查询时，常用的算法包括编辑距离算法、n-gram算法、Soundex算法等。在搜索引擎、数据库、信息检索等领域中，模糊查询是一种常见的技术手段。\n1 2 3 4 5 6 7 8 9 10 11 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;fuzzy\u0026#34;: { \u0026#34;brand\u0026#34;: { \u0026#34;fuzziness\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;儒家\u0026#34; } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.LatLonGeoLocation; import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery; import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.json.JsonData; import com.example.demo.domain.HotelDoc; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelSearchTest { @Autowired ElasticsearchClient client; @Test void fuzzyQueryTest() throws IOException { SearchResponse\u0026lt;HotelDoc\u0026gt; request = client.search(searchRequest -\u0026gt; searchRequest .index(\u0026#34;hotel\u0026#34;) .query(query -\u0026gt; query .fuzzy(fuzzyQuery -\u0026gt; fuzzyQuery .field(\u0026#34;brand\u0026#34;) .fuzziness(\u0026#34;auto\u0026#34;) .value(\u0026#34;儒家\u0026#34;) ) ), HotelDoc.class); log.info(\u0026#34;共搜索到:{}条数据\u0026#34;, (request.hits().total() == null ? 0 : request.hits().total().value())); request.hits().hits().forEach(item -\u0026gt; { System.out.println(item.source()); }); } } 排序和分页\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.LatLonGeoLocation; import co.elastic.clients.elasticsearch._types.SortOrder; import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery; import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.json.JsonData; import com.example.demo.domain.HotelDoc; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelSearchTest { @Autowired ElasticsearchClient client; /** * 分页、排序测试 */ @Test void pageAndSortTest() throws IOException { // 页码、每页信息条数 int page = 1, size = 10; SearchRequest request = new SearchRequest.Builder() .index(\u0026#34;hotel\u0026#34;) .query(builder -\u0026gt; builder.match(matchAllQuery -\u0026gt; matchAllQuery.field(\u0026#34;brand\u0026#34;).query(\u0026#34;如家\u0026#34;))) .from((page - 1) * size) .size(size) .sort(sortOptions -\u0026gt; sortOptions.field(fieldSort -\u0026gt; fieldSort.field(\u0026#34;price\u0026#34;).order(SortOrder.Asc))) .build(); SearchResponse\u0026lt;HotelDoc\u0026gt; search = client.search(request, HotelDoc.class); log.info(\u0026#34;共搜索到:{}条数据\u0026#34;, (search.hits().total() == null ? 0 : search.hits().total().value())); search.hits().hits().forEach(item -\u0026gt; { System.out.println(item.source()); }); } } 高亮\r总体来说不算太难，对应sql语句使用idea的提示基本就可以凑出来\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 GET /hotel/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match\u0026#34;: { \u0026#34;all\u0026#34;: \u0026#34;如家\u0026#34; } }, \u0026#34;highlight\u0026#34;:{ \u0026#34;fields\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;require_field_match\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;pre_tags\u0026#34;:\u0026#34;\u0026lt;em\u0026gt;\u0026#34;, \u0026#34;post_tags\u0026#34;: \u0026#34;\u0026lt;/em\u0026gt;\u0026#34; } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import co.elastic.clients.elasticsearch.ElasticsearchClient; import co.elastic.clients.elasticsearch._types.LatLonGeoLocation; import co.elastic.clients.elasticsearch._types.SortOrder; import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery; import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders; import co.elastic.clients.elasticsearch.core.SearchRequest; import co.elastic.clients.elasticsearch.core.SearchResponse; import co.elastic.clients.json.JsonData; import com.example.demo.domain.HotelDoc; import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.io.IOException; @Slf4j @SpringBootTest class HotelSearchTest { @Autowired ElasticsearchClient client; /** * 高亮测试 */ @Test void highLightTest() throws IOException { SearchRequest request = new SearchRequest.Builder() .index(\u0026#34;hotel\u0026#34;) .query(query-\u0026gt;query.match(matchQuery-\u0026gt;matchQuery.field(\u0026#34;all\u0026#34;).query(\u0026#34;如家\u0026#34;))) .highlight(highLight-\u0026gt;highLight.fields(\u0026#34;name\u0026#34;,builder -\u0026gt; builder.preTags(\u0026#34;\u0026lt;em\u0026gt;\u0026#34;).postTags(\u0026#34;\u0026lt;/em\u0026gt;\u0026#34;)).requireFieldMatch(false)) .build(); SearchResponse\u0026lt;HotelDoc\u0026gt; search = client.search(request, HotelDoc.class); log.info(\u0026#34;共搜索到:{}条数据\u0026#34;, (search.hits().total() == null ? 0 : search.hits().total().value())); search.hits().hits().forEach(item -\u0026gt; { item.highlight().values().forEach(System.out::println); }); } } ","date":"2023-05-30T00:00:00Z","image":"http://localhost:1313/p/elasticsearct%E5%AD%A6%E4%B9%A0/202412212115512_hu9086345817820291088.png","permalink":"http://localhost:1313/p/elasticsearct%E5%AD%A6%E4%B9%A0/","title":"Elasticsearct学习"},{"content":"map与实体转换\r以下工具类请查看此博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class MapAndEntityConverter { /** * 利用反射将map集合封装成bean对象 * * @param map * @param clazz * @return {@link T} * @throws Exception 异常 */ public static \u0026lt;T\u0026gt; T mapToBean(Map\u0026lt;String, Object\u0026gt; map, Class\u0026lt;?\u0026gt; clazz) throws Exception { Object obj = clazz.newInstance(); if (map != null \u0026amp;\u0026amp; !map.isEmpty() \u0026amp;\u0026amp; map.size() \u0026gt; 0) { // map.entrySet():获取到Map集合中所有的键值对对象的集合(Set集合) for (Map.Entry\u0026lt;String, Object\u0026gt; entry : map.entrySet()) { // 属性名 String propertyName = entry.getKey(); // 属性值 Object value = entry.getValue(); String setMethodName = \u0026#34;set\u0026#34; + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1); //获取和map的key匹配的属性名称 Field field = getClassField(clazz, propertyName); if (field == null) { continue; } Class\u0026lt;?\u0026gt; fieldTypeClass = field.getType(); value = convertValType(value, fieldTypeClass); try { clazz.getMethod(setMethodName, field.getType()).invoke(obj, value); } catch (NoSuchMethodException e) { e.printStackTrace(); } } } return (T) obj; } /** * 根据给定对象类匹配对象中的特定字段 * * @param clazz clazz * @param fieldName 字段名 * @return {@link Field} */ private static Field getClassField(Class\u0026lt;?\u0026gt; clazz, String fieldName) { if (Object.class.getName().equals(clazz.getName())) { return null; } Field[] declaredFields = clazz.getDeclaredFields(); for (Field field : declaredFields) { if (field.getName().equals(fieldName)) { return field; } } //如果该类还有父类，将父类对象中的字段也取出 Class\u0026lt;?\u0026gt; superClass = clazz.getSuperclass(); //递归获取 if (superClass != null) { return getClassField(superClass, fieldName); } return null; } /** * 将map的value值转为实体类中字段类型匹配的方法 * * @param value * @param fieldTypeClass * @return {@link Object} */ private static Object convertValType(Object value, Class\u0026lt;?\u0026gt; fieldTypeClass) { Object retVal = null; if (Long.class.getName().equals(fieldTypeClass.getName()) || long.class.getName().equals(fieldTypeClass.getName())) { retVal = Long.parseLong(value.toString()); } else if (Integer.class.getName().equals(fieldTypeClass.getName()) || int.class.getName().equals(fieldTypeClass.getName())) { retVal = Integer.parseInt(value.toString()); } else if (Float.class.getName().equals(fieldTypeClass.getName()) || float.class.getName().equals(fieldTypeClass.getName())) { retVal = Float.parseFloat(value.toString()); } else if (Double.class.getName().equals(fieldTypeClass.getName()) || double.class.getName().equals(fieldTypeClass.getName())) { retVal = Double.parseDouble(value.toString()); } else { retVal = value; } return retVal; } /** * 对象转map * * @param obj obj * @return {@link Map}\u0026lt;{@link String}, {@link Object}\u0026gt; */ public static Map\u0026lt;String, Object\u0026gt; objToMap(Object obj) { Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;String, Object\u0026gt;(); // 获取f对象对应类中的所有属性域 Field[] fields = obj.getClass().getDeclaredFields(); for (int i = 0, len = fields.length; i \u0026lt; len; i++) { String varName = fields[i].getName(); // 将key置为小写，默认为对象的属性 varName = varName.toLowerCase(); try { // 获取原来的访问控制权限 boolean accessFlag = fields[i].isAccessible(); // 修改访问控制权限 fields[i].setAccessible(true); // 获取在对象f中属性fields[i]对应的对象中的变量 Object o = fields[i].get(obj); if (o != null) { map.put(varName, o.toString()); } // 恢复访问控制权限 fields[i].setAccessible(accessFlag); } catch (IllegalArgumentException | IllegalAccessException ex) { ex.printStackTrace(); } } return map; } } 编写测试类\n1 2 3 4 5 6 7 8 9 10 11 import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class UserToMap { private Long id; private String name; private String gender; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import java.util.HashMap; import java.util.Map; @Slf4j @SpringBootTest class DemoApplicationTests { @Test void contextLoads() { } /** * 实体转map测试 */ @Test void entityToMapTest() { UserToMap userToMap = new UserToMap(1L, \u0026#34;马小跳\u0026#34;, \u0026#34;男\u0026#34;); Map\u0026lt;String, Object\u0026gt; stringObjectMap = MapAndEntityConverter.objToMap(userToMap); System.out.println(stringObjectMap); } /** * map转实体测试 */ @Test void mapToEntityTest() { Map\u0026lt;String, Object\u0026gt; stringObjectMap = new HashMap\u0026lt;\u0026gt;(); stringObjectMap.put(\u0026#34;id\u0026#34;, 1L); stringObjectMap.put(\u0026#34;name\u0026#34;, \u0026#34;马小跳\u0026#34;); stringObjectMap.put(\u0026#34;gender\u0026#34;, \u0026#34;男\u0026#34;); UserToMap user = null; try { user = MapAndEntityConverter.mapToBean(stringObjectMap, UserToMap.class); } catch (Exception e) { log.error(\u0026#34;map转实体失败\u0026#34;); throw new RuntimeException(e); } System.out.println(user); } } 注意\r有个需要注意lombok生成的class文件的get、set方法\r有可能会导致转换出错（博客楼主提供的工具类并未出错）\n视频查看\n视频中使用Jackson的ObjectMapper类实现map转entity\nentity有一个字段是lDate，而ObjectMapper的规定需要生成的get、set方法为getlDate、setlDate\n但是lombok @Data注解生成的get、set方法为getLDate、setLDate\n导致lDate转换后的值为空，同样的情况还出现在BeanUtils\n解决方法就是手写（idea自动生成）get、set方法 楼主这里采用的set方法和lombok一致\n1 String setMethodName = \u0026#34;set\u0026#34; + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1); 有个需要注意的地方是entity转map，结果如下\n1 {uname=马小跳, gender=男, id=1} 而entity属性名为uName\n","date":"2023-05-28T00:00:00Z","image":"http://localhost:1313/p/map%E4%B8%8E%E5%AE%9E%E4%BD%93%E8%BD%AC%E6%8D%A2/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/map%E4%B8%8E%E5%AE%9E%E4%BD%93%E8%BD%AC%E6%8D%A2/","title":"Map与实体转换"},{"content":"PO、VO、DAO、BO、DTO、POJO\r《阿里巴巴Java开发规范》关于领域模型的部分介绍如下 分层领域模型规约:\nDO(Data Object):此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 DTO(Data Transfer Object):数据传输对象，Service 或 Manager 向外传输的对象。 BO(Business Object):业务对象，由 Service 层输出的封装业务逻辑的对象。 AO(ApplicationObject):应用对象，在Web层与Service层之间抽象的复用对象模型， 极为贴近展示层，复用度不高。 VO(View Object):显示层对象，通常是 Web 向模板渲染引擎层传输的对象。 Query:数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。 领域模型命名规约： 数据对象：xxxDO，xxx即为数据表名 数据传输对象：xxxDTO，xxx为业务领域相关的名称。 展示对象：xxxVO，xxx一般为网页名称。 POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。 一、PO :(persistant object )，持久对象 可以看成是与数据库中的表相映射的java对象。使用Hibernate来生成PO是不错的选择。 二、VO :(value object) ，值对象 通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要。 PO只能用在数据层，VO用在商业逻辑层和表示层。各层操作属于该层自己的数据对象，这样就可以降低各层之间的耦合，便于以后系统的维护和扩展。 三、DAO :(Data Access Objects) ，数据访问对象接口 DAO是Data Access Object数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间。 J2EE开发人员使用数据访问对象（DAO）设计模式把底层的数据访问逻辑和高层的商务逻辑分开.实现DAO模式能够更加专注于编写数据访问代码。 DAO模式是标准的J2EE设计模式之一.开发人员使用这个模式把底层的数据访问操作和上层的商务逻辑分开.一个典型的DAO实现有下列几个组件：\n一个DAO工厂类； 一个DAO接口； 一个实现DAO接口的具体类； 数据传递对象（有些时候叫做值对象）。 具体的DAO类包含了从特定的数据源访问数据的逻辑。 四、BO :(Business Object)，业务对象层 表示应用程序领域内“事物”的所有实体类。这些实体类驻留在服务器上，并利用服务类来协助完成它们的职责。 五、DTO Data Transfer Object数据传输对象 主要用于远程调用等需要大量传输对象的地方。比如我们一张表有100个字段，那么对应的PO就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO 六、POJO :(Plain Old Java Objects)，简单的Java对象 实际就是普通JavaBeans,使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接.其中有一些属性及其getter、setter方法的类,有时可以作为value object或dto(Data Transform Object)来使用。 当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。\n","date":"2023-05-28T00:00:00Z","image":"http://localhost:1313/p/povodaobodtopojo/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/povodaobodtopojo/","title":"PO、VO、DAO、BO、DTO、POJO"},{"content":"Apifox使用\r当请求跑通之后，可以保存为接口，生成api文档\r新建接口\r数据模型\r此时可以定义成功后的响应，也可以引用一下其他的数据模型 新建BaseResponse接口 引用数据模型 同理可以把data也引用对应的实体类数据模型（user、book、order\u0026hellip;） 自动生成测试数据\r","date":"2023-05-25T00:00:00Z","image":"http://localhost:1313/p/apifox%E4%BD%BF%E7%94%A8/main-interface-dark_hu2826266290548158972.webp","permalink":"http://localhost:1313/p/apifox%E4%BD%BF%E7%94%A8/","title":"Apifox"},{"content":"Clion配置\r准备工作\r仅用作学习记录，可点击下方【参考博客】的链接前往原博客，支持原创\n参考博客\nmingw-w64 如果下载速度太慢，可点击此处下载\n配置环境\r在环境变量的path中添加mingw64下bin的路径\n1 D:\\mingw64\\bin cmd输入gcc -v，若显示如下，表示成功\n配置Clion\r","date":"2023-05-25T00:00:00Z","image":"http://localhost:1313/p/clion%E9%85%8D%E7%BD%AE/clion_ide_overview_hu11639118281139101265.png","permalink":"http://localhost:1313/p/clion%E9%85%8D%E7%BD%AE/","title":"Clion"},{"content":"vue3 \u0026amp; typescript学习\r学习文档\n我这个已经安装过Element-plus了\n初识语法\r类型注解\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;{{user.name}}\u0026lt;/h3\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Message\u0026#34; circle @click=\u0026#34;testGreeter\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive} from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { // 1.类型注解 const greeter = (person: string) =\u0026gt; { return \u0026#39;Hello,\u0026#39; + person } const user = reactive({ name: \u0026#34;张三\u0026#34;, age: 25 }); function testGreeter() { user.name = greeter(user.name); } return { testGreeter, user } } }) \u0026lt;/script\u0026gt; 接口\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-input v-model=\u0026#34;input\u0026#34; placeholder=\u0026#34;Please input\u0026#34;/\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Message\u0026#34; circle @click=\u0026#34;testGreeter\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref} from \u0026#39;vue\u0026#39;; // 2.接口 interface UserInfo { firstName: string; lastName: string; } export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { const greeter = (user: UserInfo) =\u0026gt; { return \u0026#39;Hello,\u0026#39; + user.firstName + \u0026#39;_\u0026#39; + user.lastName } const user = reactive({ firstName: \u0026#34;南宫\u0026#34;, lastName: \u0026#34;问天\u0026#34; }); let input = ref(); function testGreeter() { input.value = greeter(user); } return { testGreeter, input } } }) \u0026lt;/script\u0026gt; 类\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-input v-model=\u0026#34;input\u0026#34; placeholder=\u0026#34;Please input\u0026#34;/\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Message\u0026#34; circle @click=\u0026#34;testGreeter\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref} from \u0026#39;vue\u0026#39;; // 3.类 class User { fullName: string; firstName: string; lastName: string; constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; this.fullName = firstName + \u0026#39;_\u0026#39; + lastName; } } interface UserInfo { firstName: string; lastName: string; } export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { const greeter = (user: UserInfo) =\u0026gt; { return \u0026#39;Hello,\u0026#39; + user.firstName + \u0026#39;_\u0026#39; + user.lastName } const obj = new User(\u0026#39;南宫\u0026#39;, \u0026#39;问天\u0026#39;); const user = reactive(obj); let input = ref(); function testGreeter() { input.value = greeter(user); } return { testGreeter, input } } }) \u0026lt;/script\u0026gt; 常用语法\r查看原文档\n基础类型\r布尔值\r1 2 3 let isDone: boolean = false; isDone = true; // isDone = 2 // error 数字\r1 2 3 4 let a1: number = 10 // 十进制 let a2: number = 0b1010 // 二进制 let a3: number = 0o12 // 八进制 let a4: number = 0xa // 十六进制 字符串\r1 2 3 4 5 let name:string = \u0026#39;tom\u0026#39; name = \u0026#39;jack\u0026#39; // name = 12 // error let age:number = 12 const info = `My name is ${name}, I am ${age} years old!` undefined \u0026amp; null\r1 2 let u: undefined = undefined let n: null = null 数组\r1 let list1: number[] = [1, 2, 3] 数组泛型\n1 let list2: Array\u0026lt;number\u0026gt; = [1, 2, 3] 元组 tuple\r元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。\n1 2 3 let t1: [string, number] t1 = [\u0026#39;hello\u0026#39;, 10] // OK t1 = [10, \u0026#39;hello\u0026#39;] // Error 枚举\renum 类型是对 JavaScript 标准数据类型的一个补充。 使用枚举类型可以为一组数值赋予友好的名字。\n1 2 3 4 5 6 7 8 9 10 enum Color { Red, Green, Blue } // 枚举数值默认从0开始依次递增 // 根据特定的名称得到对应的枚举数值 let myColor: Color = Color.Green // 0 console.log(myColor, Color.Red, Color.Blue) // 输出:1 0 2 默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号：\n1 2 enum Color {Red = 1, Green, Blue} let c: Color = Color.Green 或者，全部都采用手动赋值：\n1 2 enum Color {Red = 1, Green = 2, Blue = 4} let c: Color = Color.Green 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：\n1 2 3 enum Color {Red = 1, Green, Blue} let colorName: string = Color[2] console.log(colorName) // \u0026#39;Green\u0026#39; 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量：\n1 2 3 let notSure: any = 4 notSure = \u0026#39;maybe a string\u0026#39; notSure = false // 也可以是个 boolean 在对现有代码进行改写的时候，any 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，any 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n1 2 let list: any[] = [1, true, \u0026#39;free\u0026#39;] list[1] = 100 void\r某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：\n1 2 3 4 5 6 7 /* 表示没有任何类型, 一般用来说明函数的返回值不能是undefined和null之外的值 */ function fn(): void { console.log(\u0026#39;fn()\u0026#39;) // return undefined // return null // return 1 // error } 声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null：\n1 let unusable: void = undefined object\robject 表示非原始类型，也就是除 number，string，boolean之外的类型。 使用 object 类型，就可以更好的表示像 Object.create 这样的 API。例如：\n1 2 3 4 5 6 7 8 9 function fn2(obj:object):object { console.log(\u0026#39;fn2()\u0026#39;, obj) return {} // return undefined // return null } console.log(fn2(new String(\u0026#39;abc\u0026#39;))) // console.log(fn2(\u0026#39;abc\u0026#39;) // error console.log(fn2(String)) 联合类型\r联合类型（Union Types）表示取值可以为多种类型中的一种 需求1: 定义一个一个函数得到一个数字或字符串值的字符串形式值\n1 2 3 function toString2(x: number | string) : string { return x.toString() } 需求2: 定义一个一个函数得到一个数字或字符串值的长度\n1 2 3 4 5 6 7 8 function getLength(x: number | string) { // return x.length // error if (x.length) { // error return x.length } else { return x.toString().length } } 类型断言\r通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 其一是“尖括号”语法, 另一个为 as 语法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* 类型断言(Type Assertion): 可以用来手动指定一个值的类型 语法: 方式一: \u0026lt;类型\u0026gt;值 方式二: 值 as 类型 tsx中只能用这种方式 */ /* 需求: 定义一个函数得到一个字符串或者数值数据的长度 */ function getLength(x: number | string) { if ((\u0026lt;string\u0026gt;x).length) { return (x as string).length } else { return x.toString().length } } console.log(getLength(\u0026#39;abcd\u0026#39;), getLength(1234)) 类型推断\r类型推断: TS会在没有明确的指定类型的时候推测出一个类型 有下面2种情况: 1. 定义变量时赋值了, 推断为对应的类型. 2. 定义变量时没有赋值, 推断为any类型\n1 2 3 4 5 6 7 /* 定义变量时赋值了, 推断为对应的类型 */ let b9 = 123 // number // b9 = \u0026#39;abc\u0026#39; // error /* 定义变量时没有赋值, 推断为any类型 */ let b10 // any类型 b10 = 123 b10 = \u0026#39;abc\u0026#39; 接口\r简单用法\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;次数:{{num}}\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;el-button @click=\u0026#34;test\u0026#34;\u0026gt;点击\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref} from \u0026#39;vue\u0026#39;; interface UserForm{ // 只读属性 readonly name:string, age:number } interface Alarm{ alert(): any; } interface Light { lightOn(): void; lightOff(): void; } class Car implements Alarm { alert() { console.log(\u0026#39;Car alert\u0026#39;); } } export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { let num=ref\u0026lt;number\u0026gt;(0); const test=()=\u0026gt;{ num.value++; const car=new Car() car.alert(); } return { test, num } } }) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 类实现接口\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 类类型: 实现接口 1. 一个类可以实现多个接口 2. 一个接口可以继承多个接口 */ interface Alarm { alert(): any; } interface Light { lightOn(): void; lightOff(): void; } class Car implements Alarm { alert() { console.log(\u0026#39;Car alert\u0026#39;); } } 一个类实现多个接口\r1 2 3 4 5 6 7 8 9 10 11 class Car2 implements Alarm, Light { alert() { console.log(\u0026#39;Car alert\u0026#39;); } lightOn() { console.log(\u0026#39;Car light on\u0026#39;); } lightOff() { console.log(\u0026#39;Car light off\u0026#39;); } } 接口继承接口\r1 2 interface LightableAlarm extends Alarm, Light { } 类\r修饰符\r当成员被标记成 private 时，它就不能在声明它的类的外部访问 protected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* 访问修饰符: 用来描述类内部的属性/方法的可访问性 public: 默认值, 公开的外部也可以访问 private: 只能类内部可以访问 protected: 类内部和子类可以访问 */ class Animal { public name: string public constructor (name: string) { this.name = name } public run (distance: number=0) { console.log(`${this.name} run ${distance}m`) } } class Person extends Animal { private age: number = 18 protected sex: string = \u0026#39;男\u0026#39; run (distance: number=5) { console.log(\u0026#39;Person jumping...\u0026#39;) super.run(distance) } } class Student extends Person { run (distance: number=6) { console.log(\u0026#39;Student jumping...\u0026#39;) console.log(this.sex) // 子类能看到父类中受保护的成员 // console.log(this.age) // 子类看不到父类中私有的成员 super.run(distance) } } console.log(new Person(\u0026#39;abc\u0026#39;).name) // 公开的可见 // console.log(new Person(\u0026#39;abc\u0026#39;).sex) // 受保护的不可见 // console.log(new Person(\u0026#39;abc\u0026#39;).age) // 私有的不可见 静态属性\r1 2 3 4 5 6 7 8 9 10 /* 静态属性, 是类对象的属性 非静态属性, 是类的实例对象的属性 */ class Person { name1: string = \u0026#39;A\u0026#39; static name2: string = \u0026#39;B\u0026#39; } console.log(Person.name2) console.log(new Person().name1) 抽象类\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 抽象类 不能创建实例对象, 只有实现类才能创建实例 可以包含未实现的抽象方法 */ abstract class Animal { abstract cry () run () { console.log(\u0026#39;run()\u0026#39;) } } class Dog extends Animal { cry () { console.log(\u0026#39; Dog cry()\u0026#39;) } } const dog = new Dog() dog.cry() dog.run() 函数\r函数类型\r1 2 3 4 5 6 function add(x: number, y: number): number { return x + y } let myAdd = function(x: number, y: number): number { return x + y } 可选参数和默认参数\rJavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能。 比如，我们想让 lastName 是可选的\n1 2 3 4 5 6 7 8 9 10 function buildName(firstName: string=\u0026#39;A\u0026#39;, lastName?: string): string { if (lastName) { return firstName + \u0026#39;-\u0026#39; + lastName } else { return firstName } } console.log(buildName(\u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;)) console.log(buildName(\u0026#39;C\u0026#39;)) console.log(buildName()) 函数重载\rtypeof判断参数的类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 函数重载: 函数名相同, 而形参不同的多个函数 需求: 我们有一个add函数，它可以接收2个string类型的参数进行拼接，也可以接收2个number类型的参数进行相加 */ // 重载函数声明 function add (x: string, y: string): string function add (x: number, y: number): number // 定义函数实现 function add(x: string | number, y: string | number): string | number { // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 x + y if (typeof x === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; typeof y === \u0026#39;string\u0026#39;) { return x + y } else if (typeof x === \u0026#39;number\u0026#39; \u0026amp;\u0026amp; typeof y === \u0026#39;number\u0026#39;) { return x + y } } console.log(add(1, 2)) console.log(add(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)) // console.log(add(1, \u0026#39;a\u0026#39;)) // error 泛型\r基本使用\n1 2 3 4 5 6 7 8 9 10 function createArray(value: any, count: number): any[] { const arr: any[] = [] for (let index = 0; index \u0026lt; count; index++) { arr.push(value) } return arr } const arr1 = createArray(11, 3) const arr2 = createArray(\u0026#39;aa\u0026#39;, 3) console.log(arr1[0].toFixed(), arr2[0].split(\u0026#39;\u0026#39;)) 函数泛型\r1 2 3 4 5 6 7 8 9 10 11 12 13 function createArray2 \u0026lt;T\u0026gt; (value: T, count: number) { const arr: Array\u0026lt;T\u0026gt; = [] for (let index = 0; index \u0026lt; count; index++) { arr.push(value) } return arr } const arr3 = createArray2\u0026lt;number\u0026gt;(11, 3) console.log(arr3[0].toFixed()) // console.log(arr3[0].split(\u0026#39;\u0026#39;)) // error const arr4 = createArray2\u0026lt;string\u0026gt;(\u0026#39;aa\u0026#39;, 3) console.log(arr4[0].split(\u0026#39;\u0026#39;)) // console.log(arr4[0].toFixed()) // error 多个泛型参数的函数\r1 2 3 4 5 function swap \u0026lt;K, V\u0026gt; (a: K, b: V): [K, V] { return [a, b] } const result = swap\u0026lt;string, number\u0026gt;(\u0026#39;abc\u0026#39;, 123) console.log(result[0].length, result[1].toFixed()) 泛型接口\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 interface IbaseCRUD \u0026lt;T\u0026gt; { data: T[] add: (t: T) =\u0026gt; void getById: (id: number) =\u0026gt; T } class User { id?: number; //id主键自增 name: string; //姓名 age: number; //年龄 constructor (name, age) { this.name = name this.age = age } } class UserCRUD implements IbaseCRUD \u0026lt;User\u0026gt; { data: User[] = [] add(user: User): void { user = {...user, id: Date.now()} this.data.push(user) console.log(\u0026#39;保存user\u0026#39;, user.id) } getById(id: number): User { return this.data.find(item =\u0026gt; item.id===id) } } const userCRUD = new UserCRUD() userCRUD.add(new User(\u0026#39;tom\u0026#39;, 12)) userCRUD.add(new User(\u0026#39;tom2\u0026#39;, 13)) console.log(userCRUD.data) 泛型类\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class GenericNumber\u0026lt;T\u0026gt; { zeroValue: T add: (x: T, y: T) =\u0026gt; T } let myGenericNumber = new GenericNumber\u0026lt;number\u0026gt;() myGenericNumber.zeroValue = 0 myGenericNumber.add = function(x, y) { return x + y } let myGenericString = new GenericNumber\u0026lt;string\u0026gt;() myGenericString.zeroValue = \u0026#39;abc\u0026#39; myGenericString.add = function(x, y) { return x + y } console.log(myGenericString.add(myGenericString.zeroValue, \u0026#39;test\u0026#39;)) console.log(myGenericNumber.add(myGenericNumber.zeroValue, 12)) 泛型约束\r如果我们直接对一个泛型参数取 length 属性, 会报错, 因为这个泛型根本就不知道它有这个属性\n1 2 3 4 // 没有泛型约束 function fn \u0026lt;T\u0026gt;(x: T): void { // console.log(x.length) // error } 我们可以使用泛型约束来实现\n1 2 3 4 5 6 7 interface Lengthwise { length: number; } // 指定泛型约束 function fn2 \u0026lt;T extends Lengthwise\u0026gt;(x: T): void { console.log(x.length) } 我们需要传入符合约束类型的值，必须包含必须 length 属性：\n1 2 fn2(\u0026#39;abc\u0026#39;) // fn2(123) // error number没有length属性 vuex\r1 npm install vuex --save-dev store/index.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { createStore } from \u0026#39;vuex\u0026#39; export default createStore({ state: { }, getters: { }, mutations: { }, actions: { }, modules: { } }) main.ts\n1 2 3 4 import App from \u0026#39;./App.vue\u0026#39; const app = createApp(App) app.use(store) app.mount(\u0026#39;#app\u0026#39;) 在vue3中，vuex提供了一个useStore方法来获取全局的store 没有什么比直接看官网更清楚了\n访问 State 和 Getter\r为了访问 state 和 getter，需要创建 computed 引用以保留响应性，这与在选项式 API 中创建计算属性等效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import {createStore} from \u0026#39;vuex\u0026#39; export default createStore({ state: { count:0, }, getters: { double(state){ return state.count; } }, mutations: { }, actions: { }, modules: { }, plugins:[ ] }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Message\u0026#34; circle @click=\u0026#34;testGreeter\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref, computed} from \u0026#39;vue\u0026#39;; import {useStore} from \u0026#34;vuex\u0026#34;; export default defineComponent({ setup() { const store = useStore(); let count = computed(() =\u0026gt; { return store.state.count; }) let double = computed(() =\u0026gt; { return store.getters.double; }) function testGreeter() { console.log(\u0026#34;count的值:\u0026#34;,count.value); console.log(\u0026#34;double的值:\u0026#34;,double.value); } return { testGreeter, } } }) \u0026lt;/script\u0026gt; 官网采用以下写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref, computed} from \u0026#39;vue\u0026#39;; import {useStore} from \u0026#34;vuex\u0026#34;; export default defineComponent({ setup() { const store = useStore(); return { count: computed(() =\u0026gt; store.state.count), double: computed(() =\u0026gt; store.getters.double) } } }) \u0026lt;/script\u0026gt; 访问 Mutation 和 Action\r要使用 mutation 和 action 时，只需要在 setup 钩子函数中调用 commit 和 dispatch 函数\n参考博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import {createStore} from \u0026#39;vuex\u0026#39; import createPersistedstate from \u0026#39;vuex-persistedstate\u0026#39; import user from \u0026#39;./modules/user\u0026#39; export default createStore({ state: { count:0, }, getters: { }, mutations: { sum (state, num) { state.count += num } }, actions: { }, modules: { }, plugins:[ ] }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Message\u0026#34; circle @click=\u0026#34;testVuex(10)\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref, computed} from \u0026#39;vue\u0026#39;; import {useStore} from \u0026#34;vuex\u0026#34;; export default defineComponent({ setup() { const store = useStore(); const testVuex=(num)=\u0026gt;{ // 使用 store.commit(\u0026#39;mution中函数名\u0026#39;, \u0026#39;需要传递的参数\u0026#39; ) 在commit里添加参数的方式进行传递 store.commit(\u0026#39;sum\u0026#39;, num) console.log(store.state.count); } return { testVuex, } } }) \u0026lt;/script\u0026gt; 也可以采用以下方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import {createStore} from \u0026#39;vuex\u0026#39; import createPersistedstate from \u0026#39;vuex-persistedstate\u0026#39; import user from \u0026#39;./modules/user\u0026#39; export default createStore({ state: { count:0, }, getters: { }, mutations: { sum (state, payload) { state.count += payload.num } }, actions: { }, modules: { }, plugins:[ ] }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Message\u0026#34; circle @click=\u0026#34;testVuex(10)\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref, computed} from \u0026#39;vue\u0026#39;; import {useStore} from \u0026#34;vuex\u0026#34;; export default defineComponent({ setup() { const store = useStore(); const testVuex=(num)=\u0026gt;{ // 前面提到了 mution 主要包含 type 和 回调函数 两部分, 和通过commit payload的方式进行参数传递（提交）,下面我们可以用这种方式进行 mution 的提交 store.commit({ type: \u0026#39;sum\u0026#39;, // 类型就是mution中定义的方法名称 num }) console.log(store.state.count); } return { testVuex, } } }) \u0026lt;/script\u0026gt; actions\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import {createStore} from \u0026#39;vuex\u0026#39; import createPersistedstate from \u0026#39;vuex-persistedstate\u0026#39; import user from \u0026#39;./modules/user\u0026#39; export default createStore({ state: { count:0, }, getters: { }, mutations: { sum (state, num) { state.count += num } }, actions: { // context 上下文对象，可以理解为store sum_actions (context, num) { setTimeout(() =\u0026gt; { context.commit(\u0026#39;sum\u0026#39;, num) // 通过context去触发mutions中的sum }, 1000) } }, modules: { }, plugins:[ ] }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Message\u0026#34; circle @click=\u0026#34;testVuex(10)\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref, computed} from \u0026#39;vue\u0026#39;; import {useStore} from \u0026#34;vuex\u0026#34;; export default defineComponent({ setup() { const store = useStore(); const testVuex=(num)=\u0026gt;{ store.dispatch(\u0026#39;sum_actions\u0026#39;, num) console.log(store.state.count); } return { testVuex, } } }) \u0026lt;/script\u0026gt; 通过 promise 实现异步操作完成，通知组件异步执行成功或是失败。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import {createStore} from \u0026#39;vuex\u0026#39; import createPersistedstate from \u0026#39;vuex-persistedstate\u0026#39; import user from \u0026#39;./modules/user\u0026#39; export default createStore({ state: { count: 0, }, getters: { }, mutations: { sum(state, num) { state.count += num } }, actions: { sum_actions(context, payload) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { // 通过 context 上下文对象拿到 count if (context.state.count \u0026lt; 30) { context.commit(\u0026#39;sum\u0026#39;, payload.num) resolve(\u0026#39;异步操作执行成功\u0026#39;) } else { reject(new Error(\u0026#39;异步操作执行错误\u0026#39;)) } }, 1000) }) } }, modules: {}, plugins: [ ] }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Message\u0026#34; circle @click=\u0026#34;testVuex(10)\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref, computed} from \u0026#39;vue\u0026#39;; import {useStore} from \u0026#34;vuex\u0026#34;; export default defineComponent({ setup() { const store = useStore(); const testVuex=(num)=\u0026gt;{ store.dispatch(\u0026#39;sum_actions\u0026#39;, { num }).then((res) =\u0026gt; { console.log(\u0026#34;success:\u0026#34;,res) }).catch((err) =\u0026gt; { console.log(err) }) } return { testVuex, } } }) \u0026lt;/script\u0026gt; getters\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import {createStore} from \u0026#39;vuex\u0026#39; import createPersistedstate from \u0026#39;vuex-persistedstate\u0026#39; import user from \u0026#39;./modules/user\u0026#39; export default createStore({ state: { users: [{ name: \u0026#34;小美\u0026#34;, age: 12 }, { name: \u0026#34;小红\u0026#34;, age: 22 }, { name: \u0026#34;小明\u0026#34;, age: 23 }] }, getters: { filterUsersByAge(state) { return state.users.filter(item =\u0026gt; item.age \u0026gt;= 20) } }, mutations: {}, actions: {}, modules: {}, plugins: [ ] }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Message\u0026#34; circle @click=\u0026#34;testVuex(10)\u0026#34;/\u0026gt; \u0026lt;br\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;{{ store.getters.filterUsersByAge }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in store.getters.filterUsersByAge\u0026#34;\u0026gt;{{ item }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref, computed} from \u0026#39;vue\u0026#39;; import {useStore} from \u0026#34;vuex\u0026#34;; export default defineComponent({ setup() { const store = useStore(); const testVuex = (num) =\u0026gt; { } return { testVuex, store } } }) \u0026lt;/script\u0026gt; modules\nuser.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 export default { namespaced: true, // 为每个模块添加一个前缀名，保证模块命明不冲突 // state中存放的就是全局共享的数据 // sessionStorage.getItem(\u0026#39;userState\u0026#39;)?JSON.parse(sessionStorage.getItem(\u0026#39;userState\u0026#39;)) state: null != window.sessionStorage.getItem(\u0026#39;state\u0026#39;) ? JSON.parse(sessionStorage.getItem(\u0026#39;state\u0026#39;)) : { user: { name: \u0026#34;\u0026#34;, age: null, gender: \u0026#34;\u0026#34; } }, // 取值的方法，计算属性 getters: { getUser(state) { return state.user; } }, // 可以修改state值的方法，同步阻塞 mutations: { // 传入user对象，更新全局的user updateUser(state, user) { state.user = user; } }, // 异步调用mutations方法 actions: { asyncUpdateUser(context, user) { context.commit(\u0026#39;updateUser\u0026#39;, user); } } } ","date":"2023-04-30T00:00:00Z","image":"http://localhost:1313/p/vue3-typescript/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/vue3-typescript/","title":"Vue3+Typescript"},{"content":"vue3快速上手\r1 vue create vue3-demo ElementPlus\r1 npm install element-plus --save 完整引入\n1 2 3 4 5 6 7 8 // main.ts import { createApp } from \u0026#39;vue\u0026#39; import ElementPlus from \u0026#39;element-plus\u0026#39; import \u0026#39;element-plus/dist/index.css\u0026#39; import App from \u0026#39;./App.vue\u0026#39; const app = createApp(App) app.use(ElementPlus) app.mount(\u0026#39;#app\u0026#39;) 安装图标\n1 npm install @element-plus/icons-vue 图标注册\n1 2 3 4 5 6 7 // main.ts // 如果您正在使用CDN引入，请删除下面一行。 import * as ElementPlusIconsVue from \u0026#39;@element-plus/icons-vue\u0026#39; const app = createApp(App) for (const [key, component] of Object.entries(ElementPlusIconsVue)) { app.component(key, component) } 综合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // main.ts import {createApp} from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; import ElementPlus from \u0026#39;element-plus\u0026#39; import \u0026#39;element-plus/dist/index.css\u0026#39; import * as ElementPlusIconsVue from \u0026#39;@element-plus/icons-vue\u0026#39; const app = createApp(App) app.use(store) app.use(router) app.use(ElementPlus) for (const [key, component] of Object.entries(ElementPlusIconsVue)) { app.component(key, component) } app.mount(\u0026#39;#app\u0026#39;) axios\r安装axios\n以下内容参考【程序员青戈】的博客\n1 npm install axios -s utils/request.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import axios from \u0026#39;axios\u0026#39; const request = axios.create({ baseURL: \u0026#39;/api\u0026#39;, // 注意！！ 这里是全局统一加上了 \u0026#39;/api\u0026#39; 前缀，也就是说所有接口都会加上\u0026#39;/api\u0026#39;前缀在，页面里面写接口的时候就不要加 \u0026#39;/api\u0026#39;了，否则会出现2个\u0026#39;/api\u0026#39;，类似 \u0026#39;/api/api/user\u0026#39;这样的报错，切记！！！ timeout: 5000 }) // request 拦截器 // 可以自请求发送前对请求做一些处理 // 比如统一加token，对请求参数统一加密 request.interceptors.request.use(config =\u0026gt; { config.headers[\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/json;charset=utf-8\u0026#39;; // config.headers[\u0026#39;token\u0026#39;] = user.token; // 设置请求头 return config }, error =\u0026gt; { return Promise.reject(error) }); // response 拦截器 // 可以在接口响应后统一处理结果 request.interceptors.response.use( response =\u0026gt; { let res = response.data; // 如果是返回的文件 if (response.config.responseType === \u0026#39;blob\u0026#39;) { return res } // 兼容服务端返回的字符串数据 if (typeof res === \u0026#39;string\u0026#39;) { res = res ? JSON.parse(res) : res } return res; }, error =\u0026gt; { console.log(\u0026#39;err\u0026#39; + error) // for debug return Promise.reject(error) } ) export default request vue.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 跨域配置 module.exports = { devServer: { //记住，别写错了devServer//设置本地默认端口 选填 port: 10020, proxy: { //设置代理，必须填 \u0026#39;/api\u0026#39;: { //设置拦截器 拦截器格式 斜杠+拦截器名字，名字可以自己定 target: \u0026#39;http://localhost:10010\u0026#39;, //代理的目标地址 changeOrigin: true, //是否设置同源，输入是的 pathRewrite: { //路径重写 \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; //选择忽略拦截器里面的内容 } } } } } vuex\r安装vuex（已安装，main.ts配置参考element plus处）\n1 npm install vuex --save-dev 安装持久化插件\n1 npm i vuex-persistedstate 关闭严格模式\ntsconfig.json里将\u0026quot;strict\u0026quot;: false设置为\u0026quot;strict\u0026quot;: true sotore/modules/userts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 export default { namespaced: true, // 为每个模块添加一个前缀名，保证模块命明不冲突 // state中存放的就是全局共享的数据 // sessionStorage.getItem(\u0026#39;userState\u0026#39;)?JSON.parse(sessionStorage.getItem(\u0026#39;userState\u0026#39;)) state: null != window.sessionStorage.getItem(\u0026#39;state\u0026#39;) ? JSON.parse(sessionStorage.getItem(\u0026#39;state\u0026#39;)) : { user: { name: \u0026#34;\u0026#34;, age: null, gender: \u0026#34;\u0026#34; } }, // 取值的方法，计算属性 getters: { getUser(state) { return state.user; } }, // 可以修改state值的方法，同步阻塞 mutations: { // 传入user对象，更新全局的user updateUser(state, user) { state.user = user; } }, // 异步调用mutations方法 actions: { asyncUpdateUser(context, user) { context.commit(\u0026#39;updateUser\u0026#39;, user); } } } store/indexts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import {createStore} from \u0026#39;vuex\u0026#39; import createPersistedState from \u0026#39;vuex-persistedstate\u0026#39; import user from \u0026#39;./modules/user\u0026#39; export default createStore({ state: { }, getters: { }, mutations: {}, actions: {}, modules: { user }, plugins: [ // 配置vuex插件 // 使用模块提供的方法 createPersistedState({ // 默认存储在localStorage 现改为sessionStorage storage: window.sessionStorage, // 本地存储数据的键名 // 配置存储持久化的key键名 key: \u0026#39;user\u0026#39;, // 指定需要存储的模块，如果是模块下具体的数据需要加上模块名称，如user.token // paths数组可以选择配置持久化的模块，不写代表所有 // paths: [\u0026#39;user\u0026#39;, \u0026#39;cart\u0026#39;] }) ] }) 测试页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;el-button icon=\u0026#34;Search\u0026#34; circle @click=\u0026#34;testVuex\u0026#34; /\u0026gt; \u0026lt;br\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34; @click=\u0026#34;clearDataFromVuex\u0026#34;\u0026gt;删除vuex内的数据\u0026lt;/el-button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;h3\u0026gt;name:{{ store.state.user.user.name }}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;age:{{ store.state.user.user.age }}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;gender:{{ store.state.user.user.gender }}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref, computed} from \u0026#39;vue\u0026#39;; import {useStore} from \u0026#34;vuex\u0026#34;; export default defineComponent({ name: \u0026#39;HelloWorld\u0026#39;, props: { msg: String, }, setup() { const store = useStore(); const testVuex = () =\u0026gt; { // 使用这种方式可以改变值，但是无法实现数据的持久化 // store.state.user.user.name=\u0026#39;假面骑士decade\u0026#39; // store.state.user.user.age=22 // store.state.user.user.gender=\u0026#39;男\u0026#39; // 下面两种方法可以实现vuex的数据持久化 // store.commit(\u0026#39;user/updateUser\u0026#39;,{ // name: \u0026#34;Decade\u0026#34;, // age: 22, // gender: \u0026#34;男\u0026#34; // }); store.dispatch(\u0026#39;user/asyncUpdateUser\u0026#39;, { name: \u0026#34;假面骑士\u0026#34;, age: 18, gender: \u0026#34;女\u0026#34; }); } const clearDataFromVuex=()=\u0026gt;{ store.dispatch(\u0026#39;user/asyncUpdateUser\u0026#39;, {}); }; return { testVuex, clearDataFromVuex, store } } }); \u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#34;less\u0026#34;\u0026gt; \u0026lt;/style\u0026gt; 简单集成ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;el-button icon=\u0026#34;Search\u0026#34; circle @click=\u0026#34;testVuex\u0026#34;/\u0026gt; \u0026lt;br\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34; @click=\u0026#34;clearDataFromVuex\u0026#34;\u0026gt;删除vuex内的数据\u0026lt;/el-button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;h3\u0026gt;name:{{ store.state.user.user.name }}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;age:{{ store.state.user.user.age }}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;gender:{{ store.state.user.user.gender }}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref, computed} from \u0026#39;vue\u0026#39;; import {useStore} from \u0026#34;vuex\u0026#34;; interface userForm { name: string, age: number, gender: string } export default defineComponent({ name: \u0026#39;HelloWorld\u0026#39;, props: { msg: String, }, setup() { const store = useStore(); const testVuex = (user: userForm) =\u0026gt; { user = { name: \u0026#34;Decade\u0026#34;, age: 22, gender: \u0026#34;男\u0026#34; }; store.commit(\u0026#39;user/updateUser\u0026#39;, user); } const clearDataFromVuex = () =\u0026gt; { store.dispatch(\u0026#39;user/asyncUpdateUser\u0026#39;, {}); }; return { testVuex, clearDataFromVuex, store } } }); \u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#34;less\u0026#34;\u0026gt; \u0026lt;/style\u0026gt; cookie\r1 npm install vue-cookies --save main.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import {createApp} from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; import ElementPlus from \u0026#39;element-plus\u0026#39; import \u0026#39;element-plus/dist/index.css\u0026#39; import * as ElementPlusIconsVue from \u0026#39;@element-plus/icons-vue\u0026#39; import \u0026#39;@/assets/css/global.css\u0026#39; import VueCookies from \u0026#39;vue-cookies\u0026#39; const app = createApp(App) app.use(store) app.use(router) app.use(ElementPlus) for (const [key, component] of Object.entries(ElementPlusIconsVue)) { app.component(key, component) } // @ts-ignore app.config.globalProperties.$cookies = VueCookies; app.mount(\u0026#39;#app\u0026#39;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;cookie-test\u0026#34;\u0026gt; \u0026lt;el-button @click=\u0026#34;cookieInTest\u0026#34;\u0026gt;点击存入cookie\u0026lt;/el-button\u0026gt; \u0026lt;el-button @click=\u0026#34;cookieDeleteTest\u0026#34;\u0026gt;点击删除cookie\u0026lt;/el-button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;cookieForm:{{cookieForm}}\u0026lt;/span\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;mydata:{{myData}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, getCurrentInstance, ref,onMounted} from \u0026#39;vue\u0026#39;; import VueCookies from \u0026#39;vue-cookies\u0026#39; export default defineComponent({ name: \u0026#39;\u0026#39;, setup(){ let cookieForm=ref(); let internalInstance = getCurrentInstance(); let cookies = internalInstance.appContext.config.globalProperties.$cookies const cookieInTest=()=\u0026gt;{ // 存入，可加时间限制(秒) // cookies.set(\u0026#39;test\u0026#39;, \u0026#39;Hello world!\u0026#39;,5); // cookies.set(\u0026#39;test\u0026#39;, \u0026#39;Hello world!\u0026#39;,5000); // 获取 // cookieForm.value=cookies.get(\u0026#39;test\u0026#39;); // 将数据保存到cookie中 cookies.set(\u0026#39;myData\u0026#39;, \u0026#39;测试数据\u0026#39;, \u0026#39;30d\u0026#39;) myData.value=cookies.get(\u0026#39;myData\u0026#39;); console.log(\u0026#34;set--mydata,\u0026#34;,myData.value); } const cookieDeleteTest=()=\u0026gt;{ // cookies.remove(\u0026#39;test\u0026#39;); // 获取 // cookieForm.value=cookies.get(\u0026#39;test\u0026#39;); cookies.remove(\u0026#39;myData\u0026#39;); myData.value=cookies.get(\u0026#39;myData\u0026#39;); } const createdData=()=\u0026gt;{ // cookieForm = cookies.get(\u0026#39;myData\u0026#39;) } const myData = ref(\u0026#39;\u0026#39;) onMounted(() =\u0026gt; { // 从cookie中读取数据 myData.value = cookies.get(\u0026#39;myData\u0026#39;) console.log(\u0026#34;mydata,\u0026#34;,myData.value); }) return { cookieForm, cookieInTest, cookieDeleteTest, myData } } }) \u0026lt;/script\u0026gt; 工具类\rutil/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import Vue from \u0026#39;vue\u0026#39; import {Router as router} from \u0026#34;vue-router\u0026#34;; /** * 获取uuid * @returns {string} uuid */ export function getUUID() { return \u0026#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\u0026#39;.replace(/[xy]/g, c =\u0026gt; { return (c === \u0026#39;x\u0026#39; ? (Math.random() * 16 | 0) : (\u0026#39;r\u0026amp;0x3\u0026#39; | \u0026#39;0x8\u0026#39;)).toString(16) }) } /** * 是否有权限 * @param {*} key */ export function isAuth (key) { return JSON.parse(sessionStorage.getItem(\u0026#39;permissions\u0026#39;) || \u0026#39;[]\u0026#39;).indexOf(key) !== -1 || false } /** * 树形数据转换 * @param {*} data * @param {*} id * @param {*} pid */ export function treeDataTranslate (data, id = \u0026#39;id\u0026#39;, pid = \u0026#39;parentId\u0026#39;) { const res = []; const temp = {}; for (let i = 0; i \u0026lt; data.length; i++) { temp[data[i][id]] = data[i] } for (let k = 0; k \u0026lt; data.length; k++) { if (temp[data[k][pid]] \u0026amp;\u0026amp; data[k][id] !== data[k][pid]) { if (!temp[data[k][pid]][\u0026#39;children\u0026#39;]) { temp[data[k][pid]][\u0026#39;children\u0026#39;] = [] } if (!temp[data[k][pid]][\u0026#39;_level\u0026#39;]) { temp[data[k][pid]][\u0026#39;_level\u0026#39;] = 1 } data[k][\u0026#39;_level\u0026#39;] = temp[data[k][pid]]._level + 1 temp[data[k][pid]][\u0026#39;children\u0026#39;].push(data[k]) } else { res.push(data[k]) } } return res } /** * 清除登录信息 */ export function clearLoginInfo () { // Vue.cookie.delete(\u0026#39;token\u0026#39;) // store.commit(\u0026#39;resetStore\u0026#39;) // router.options.isAddDynamicMenuRoutes = false } qs\r1 npm install qs --save qs的使用\rparse\r将url的参数转化为object对象\n1 2 const str = \u0026#34;name=%E9%A9%AC%E5%B0%8F%E8%B7%B3\u0026amp;age=12\u0026amp;address=%E5%BC%82%E6%AC%A1%E5%85%83\u0026#39;\u0026#34; console.log(qs.parse(str)) // Object {name: \u0026#34;马小跳\u0026#34;,age: \u0026#34;12\u0026#34;,address: \u0026#34;异次元\u0026#34;} stringfy\r将对象转为url参数格式\n1 2 3 4 5 6 console.log(qs.stringify({ name:\u0026#39;马小跳\u0026#39;, age:12, address:\u0026#39;异次元\u0026#39; })) // logs name=%E9%A9%AC%E5%B0%8F%E8%B7%B3\u0026amp;age=12\u0026amp;address=%E5%BC%82%E6%AC%A1%E5%85%83 echarts\recharts官网 数据可视化\n1 npm install echarts --save main.ts内引入\n1 2 3 4 // 全局引入相关包 import * as echarts from \u0026#34;echarts\u0026#34;; // 开启echarts app.config.globalProperties.$echarts = echarts; 组件内使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;myChart\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, toRefs, reactive, onMounted} from \u0026#39;vue\u0026#39; import * as echarts from \u0026#39;echarts\u0026#39; export default defineComponent({ name: \u0026#39;EchartsTest\u0026#39;, setup() { const state = reactive({ option: { title: { text: \u0026#39;Referer of a Website\u0026#39;, subtext: \u0026#39;Fake Data\u0026#39;, left: \u0026#39;center\u0026#39; }, tooltip: { trigger: \u0026#39;item\u0026#39; }, legend: { orient: \u0026#39;vertical\u0026#39;, left: \u0026#39;left\u0026#39; }, grid: { top: \u0026#39;4%\u0026#39;, left: \u0026#39;2%\u0026#39;, right: \u0026#39;4%\u0026#39;, bottom: \u0026#39;0%\u0026#39;, containLabel: true, }, series: [ { name: \u0026#39;Access From\u0026#39;, type: \u0026#39;pie\u0026#39;, radius: \u0026#39;50%\u0026#39;, data: [ { value: 1048, name: \u0026#39;Search Engine\u0026#39; }, { value: 735, name: \u0026#39;Direct\u0026#39; }, { value: 580, name: \u0026#39;Email\u0026#39; }, { value: 484, name: \u0026#39;Union Ads\u0026#39; }, { value: 300, name: \u0026#39;Video Ads\u0026#39; } ], emphasis: { itemStyle: { shadowBlur: 10, shadowOffsetX: 0, shadowColor: \u0026#39;rgba(0, 0, 0, 0.5)\u0026#39; } } } ] }, }) const initEcharts = () =\u0026gt; { let myChart = echarts.init(document.getElementById(\u0026#39;myChart\u0026#39;)) // 绘制图表 myChart.setOption(state.option) } onMounted(() =\u0026gt; { initEcharts() }) return { ...toRefs(state), } }, }) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; #myChart{ width: 700px; height: 700px; } \u0026lt;/style\u0026gt; 其他\r常用依赖\r博客\n常用库\r博客\n","date":"2023-04-30T00:00:00Z","image":"http://localhost:1313/p/vue3%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/vue3%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/","title":"Vue3常用配置"},{"content":"JavaScript\r弹窗\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;练习\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/js/jquery-3.0.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/vue2.7.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;myAlert()\u0026#34; class=\u0026#34;large-btn btn\u0026#34;\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // 警告框 function myAlert(){ alert(\u0026#34;警告\u0026#34;); } // 确认框 function myConfirm(){ var flag=confirm(\u0026#34;是否确认？\u0026#34;); console.log(\u0026#34;您选择是:\u0026#34;,flag===true?\u0026#39;确认\u0026#39;:\u0026#39;取消\u0026#39;); } // 提示框 function myPrompt(){ prompt(\u0026#34;标题\u0026#34;,\u0026#34;默认的内容是XXX(不写则为空)\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 事件\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;练习\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/js/jquery-3.0.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/vue2.7.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .my-div{ width:100px; height: 100px; background-color: red; border: 1px solid black; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;my-div\u0026#34; onclick=\u0026#34;myClick()\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; onfocus=\u0026#34;myFocus()\u0026#34; placeholder=\u0026#34;获取焦点\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; onblur=\u0026#34;myBlur()\u0026#34; placeholder=\u0026#34;失去焦点\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;my-div\u0026#34; onmouseover=\u0026#34;myMouseover()\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; onkeyup=\u0026#34;myKeyup()\u0026#34; placeholder=\u0026#34;键盘弹起\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;script\u0026gt; // 鼠标点击 function myClick(){ console.log(\u0026#34;鼠标点击\u0026#34;); } // 获取焦点 function myFocus(){ console.log(\u0026#34;获取焦点\u0026#34;); } // 失去焦点 function myBlur(){ console.log(\u0026#34;失去焦点\u0026#34;); } // 鼠标移入 function myMouseover(){ console.log(\u0026#34;鼠标移入\u0026#34;); } // 键盘弹起 function myKeyup(){ console.log(\u0026#34;键盘弹起\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 时钟\rsetInterval \u0026amp; setTimeout\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;练习\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/js/jquery-3.0.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/vue2.7.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // var 日期对象=new Date(参数) // 参数格式 MM DD,YYYY,hh:mm:ss window.onload = function () { this.showTime(); }; function showTime() { // 每隔1秒执行一次 setInterval(function () { time = this.getTime(); document.getElementById(\u0026#39;app\u0026#39;).innerText = time }, 1000); // 定时1秒后执行 // setTimeout(function () { // console.log(\u0026#39;aaa\u0026#39;); // }) } function getTime() { var today = new Date(); console.log(today.getDay()); console.log(today.getMonth() + 1); console.log(today.getFullYear() + \u0026#39;年:\u0026#39; + (today.getMonth() + 1) + \u0026#39;月\u0026#39; + today.getDate() + \u0026#39;日\u0026#39; + today.getHours() + \u0026#39;:\u0026#39; + today.getMinutes() + \u0026#39;:\u0026#39; + today.getSeconds()); return today.getFullYear() + \u0026#39;年:\u0026#39; + (today.getMonth() + 1) + \u0026#39;月\u0026#39; + today.getDate() + \u0026#39;日\u0026#39; + today.getHours() + \u0026#39;:\u0026#39; + today.getMinutes() + \u0026#39;:\u0026#39; + today.getSeconds(); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 显示与隐藏\rdisplay 不保留隐藏的属性\nvisibility 只是隐藏，原本的标签还在\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;练习\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/js/jquery-3.0.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/vue2.7.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; div { display: none; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; onclick=\u0026#34;dpcq()\u0026#34;\u0026gt;斗破苍穹\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026lt;a href=\u0026#34;#\u0026#34; onclick=\u0026#34;wdqk()\u0026#34;\u0026gt;武动乾坤\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;button\u0026gt;点击1\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;button onclick=\u0026#34;showButton1()\u0026#34;\u0026gt;点击2\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // document.URL 返回当前文档URL // document.referrer 载入本页面文档的地址 // 由于代码写在body上方，此时还未加载a标签，所以应该将script写在body下方 var num = document.getElementsByTagName(\u0026#39;a\u0026#39;); for (var i = 0; i \u0026lt; num.length; i++) { console.log(num[i]); } console.log(\u0026#39;aaa\u0026#39;); // 显示斗破苍穹 function dpcq() { document.getElementsByTagName(\u0026#39;div\u0026#39;)[0].style.display = \u0026#39;block\u0026#39;; document.getElementsByTagName(\u0026#39;div\u0026#39;)[1].style.display = \u0026#39;none\u0026#39;; } // 显示武动乾坤 function wdqk() { document.getElementsByTagName(\u0026#39;div\u0026#39;)[1].style.display = \u0026#39;block\u0026#39;; document.getElementsByTagName(\u0026#39;div\u0026#39;)[0].style.display = \u0026#39;none\u0026#39;; } function showButton1() { var button1 = document.getElementsByTagName(\u0026#39;button\u0026#39;)[0]; button1.style.visibility = \u0026#39;hidden\u0026#39; button1.style.display = \u0026#39;none\u0026#39; // display 和 visibility 的区别 // display 不保留隐藏的属性 // visibility 只是隐藏，原本的标签还在 } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 全选\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; // document获取对象的其他方法 // querySelector() 返回页面中第一个匹配规则的元素 // querySelectorAll() 返回页面中匹配规则的全部元素 window.onload = function () { var list = document.querySelectorAll(\u0026#34;.one\u0026#34;) for (let i = 0; i \u0026lt; list.length; i++) { list[i].onclick = function () { var flag = true; for (let j = 0; j \u0026lt; list.length; j++) { // 等同于 // if(lest[j].checked==false) if (!list[j].checked) { flag = false; } document.querySelector(\u0026#34;input\u0026#34;).checked = flag; } } } } function chooseAll() { // 打印全选的选中状态 // console.log(document.querySelector(\u0026#34;input\u0026#34;).checked); var checkList = document.querySelectorAll(\u0026#34;.one\u0026#34;) for (let i = 0; i \u0026lt; checkList.length; i++) { checkList[i].checked = document.querySelector(\u0026#34;input\u0026#34;).checked; } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;all\u0026#34; onclick=\u0026#34;chooseAll()\u0026#34;\u0026gt;全选\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; class=\u0026#34;one\u0026#34; value=\u0026#34;eat\u0026#34;\u0026gt;吃饭\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; class=\u0026#34;one\u0026#34; value=\u0026#34;game\u0026#34;\u0026gt;游戏\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; class=\u0026#34;one\u0026#34; value=\u0026#34;learn\u0026#34;\u0026gt;学习\u0026lt;br\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CSS交互\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #app { width: 50px; height: 50px; background-color: red; } .one { width: 50px; height: 50px; background-color: red; } .two { width: 50px; height: 50px; background-color: green; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; window.onload = function () { // 方法一： // var allDiv = document.querySelector(\u0026#34;#app\u0026#34;); // allDiv.onmouseover = function () { // allDiv.style.backgroundColor = \u0026#39;green\u0026#39;; // }; // allDiv.onmouseout = function () { // allDiv.style.backgroundColor = \u0026#39;red\u0026#39;; // }; // 方法二： // var allDiv = document.querySelector(\u0026#34;#app\u0026#34;); // allDiv.onmouseover = function () { // allDiv.id = \u0026#39;\u0026#39;; // // 去掉div id则可以显示 two的样式 // // 因为id的优先级大于class // allDiv.className = \u0026#39;two\u0026#39;; // }; // allDiv.onmouseout = function () { // allDiv.className = \u0026#39;one\u0026#39;; // }; }; function test() { // background-color 改为 backgroundColor，驼峰命名 document.getElementById(\u0026#34;app\u0026#34;).style.backgroundColor = \u0026#39;grey\u0026#39;; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;test()\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34; class=\u0026#34;two\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 获取文本框的值\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;练习\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/js/jquery-3.0.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/vue2.7.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;button onclick=\u0026#34;getInputData()\u0026#34;\u0026gt;获取\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function getInputData(){ console.log(\u0026#34;值:\u0026#34;,document.getElementsByTagName(\u0026#34;input\u0026#34;)[0].value); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 省市级联\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; window.onload=function () { var pro=document.getElementById(\u0026#34;province\u0026#34;); var city=document.getElementById(\u0026#34;city\u0026#34;); pro.onchange=function () { city.innerHTML=\u0026#34;\u0026#34;; var arr=new Array(2); arr[0]=[\u0026#39;武汉\u0026#39;,\u0026#39;荆州\u0026#39;,\u0026#34;aaa\u0026#34;]; arr[1]=[\u0026#39;长沙\u0026#39;,\u0026#39;啊啊\u0026#39;]; var index=pro.selectedIndex-1; for(let i=0;i\u0026lt;arr.length;i++){ city.add(new Option(arr[index][i],arr[index][i]),null) } } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;select id=\u0026#34;province\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;0\u0026#34; hidden\u0026gt;--请选择--\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;湖北\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;湖南\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;city\u0026#34;\u0026gt;\u0026lt;/select\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 正则表达式校验\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;练习\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/js/jquery-3.0.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/vue2.7.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;tip\u0026#34; style=\u0026#34;color: red\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;script\u0026gt; // 正则表达式语法 // 普通方式 // var reg=/表达式/附加参数 // 如：var reg=/white/g; // 构造函数 // var reg=new RegExp(\u0026#34;表达式\u0026#34;,\u0026#34;附加参数\u0026#34;); // 简单模式 // var reg=/china8/; // 复合模式 // var reg=/^\\w+$/; // RegExp 对象的方法 // exec 检索字符中是正则表达式的匹配，返回找到的值 // test 检索字符中指定的值，返回true or false // RegExp 对象的属性 // global RegExp对象是否具有标志g，全文查找 // ignoreCase RegExp对象是否具有标志i，忽略大小写 // multiline RegExp对象是否具有标志m，多行查找 window.onload = function () { var user = document.getElementById(\u0026#34;username\u0026#34;); user.onblur = function () { var reg = /^\\d{3}\\S{1}@\\S{2}.com$/ if (!reg.test(user.value)) { document.getElementById(\u0026#34;tip\u0026#34;).innerText = \u0026#39;格式输入错误\u0026#39; } else { document.getElementById(\u0026#34;tip\u0026#34;).innerText = \u0026#39;\u0026#39; } } } \u0026lt;/script\u0026gt; ","date":"2023-04-19T00:00:00Z","image":"http://localhost:1313/p/javascript/202412212151372_hu8426718956455247112.png","permalink":"http://localhost:1313/p/javascript/","title":"JavaScript"},{"content":"JQuery\r初识语法\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;练习\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/js/jquery-3.0.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/vue2.7.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .one { width: 300px; height: 300px; background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(document).ready(function () { console.log(\u0026#34;aaa\u0026#34;); }); // 以上写法可简写成如下写法 $(function () { console.log(\u0026#34;bbb\u0026#34;); }); $(function () { // 支持链式编程，如下 // $(\u0026#34;.one\u0026#34;).mouseover(function () { // $(\u0026#34;.one\u0026#34;).css(\u0026#34;backgroundColor\u0026#34;, \u0026#34;green\u0026#34;).next().css() // }); $(\u0026#34;#app\u0026#34;).addClass(\u0026#34;one\u0026#34;); $(\u0026#34;.one\u0026#34;).mouseover(function () { $(\u0026#34;.one\u0026#34;).css(\u0026#34;backgroundColor\u0026#34;, \u0026#34;green\u0026#34;) }); $(\u0026#34;.one\u0026#34;).mouseout(function () { $(\u0026#34;.one\u0026#34;).css(\u0026#34;backgroundColor\u0026#34;, \u0026#34;red\u0026#34;) }); }); // jquery对象转DOM对象 // var $app = $(\u0026#34;#app\u0026#34;); //jquery对象 // var app = $app[0]; // DOM对象 // var $app = $(\u0026#34;#app\u0026#34;); //jquery对象 // var app = $app.get(0); // DOM对象 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 类CSS选择器\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;练习\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/js/jquery-3.0.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/vue2.7.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;h2 class=\u0026#34;top\u0026#34; name=\u0026#34;qaq\u0026#34;\u0026gt;啊啊啊\u0026lt;/h2\u0026gt; \u0026lt;span\u0026gt;呵呵\u0026lt;/span\u0026gt; \u0026lt;div id=\u0026#34;aaa\u0026#34;\u0026gt; \u0026lt;p\u0026gt;哈哈\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt;呵呵\u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;aa\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt;bb\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;哈哈\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt;cc\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;哈哈\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(function () { // 并集选择器 $(\u0026#34;h2,span\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;red\u0026#34;); // 交集选择器 // 选择class为top的h2标签 $(\u0026#34;h2.top\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;green\u0026#34;); // 全局选择器 // $(\u0026#39;*\u0026#39;).css(...) // 后代选择器 // $(\u0026#34;#aaa p\u0026#34;) // 子选择器 // $(\u0026#34;#aaa\u0026gt;p) // 相邻选择器 // 这里选择的是id为aaa内的p标签，p标签后紧邻着的div $(\u0026#34;#aaa\u0026gt;p+div\u0026#34;).css(\u0026#39;color\u0026#39;, \u0026#39;red\u0026#39;); // 同辈选择器 // 这里选择的是id为aaa内的div标签,div标签之后的所有的同辈的p标签 // 请注意！！！ // 选择的是div之后的p标签，所以第一个p标签并不会被选中 // $(\u0026#34;#aaa\u0026gt;div~p\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); // 属性选择器 // 选择的是页面上具有class属性的标签 $(\u0026#34;[class]\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); // 选择的是页面上具有class属性的h2标签 $(\u0026#34;h2[class]\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); // 选择的是页面上class属性为top的h2标签 $(\u0026#34;h2[class=\u0026#39;top\u0026#39;]\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); // 选择的是页面上class属性以op结尾的h2标签 $(\u0026#34;h2[class$=\u0026#39;op\u0026#39;]\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); // 选择的是页面上class属性以t开头的h2标签 $(\u0026#34;h2[class^=\u0026#39;t\u0026#39;]\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); // 选择的是页面上class属性包含t的h2标签 $(\u0026#34;h2[class*=\u0026#39;t\u0026#39;]\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); // 多属性条件选择 // 选择的是页面上包含class属性，且name属性以q开头 以q结尾的标签 $(\u0026#34;h2[class][name^=\u0026#39;q\u0026#39;][name$=\u0026#39;q\u0026#39;]\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 过滤选择器\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;练习\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/js/jquery-3.0.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/vue2.7.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;div1\u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;span\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt;div2\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;div3\u0026lt;/div\u0026gt; \u0026lt;p hidden\u0026gt;aaa\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; $(function () { // 基本过滤选择器 // 选择第一个div $(\u0026#34;div:first\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;red\u0026#34;); // 选择最后一个div $(\u0026#34;div:last\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); // 选择第偶数个div(从0开始) $(\u0026#34;div:even\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;red\u0026#34;); // 选择第奇数个div(从0开始) $(\u0026#34;div:odd\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;red\u0026#34;); // // 选择索引为1(从0开始) $(\u0026#34;div:eq(1)\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;red\u0026#34;); // 选择索引大于1(从0开始) $(\u0026#34;div:gt(1)\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;red\u0026#34;); // 选择索引小于1(从0开始) $(\u0026#34;div:lt(1)\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); // 选择class不为one的li元素 $(\u0026#34;li:not(.one)\u0026#34;) // 选择所有的标题元素 $(\u0026#34;:header\u0026#34;) // 选择获取焦点的元素 $(\u0026#34;:focus\u0026#34;) // 可见性过滤选择器 // 选择隐藏的p标签，使其显示 $(\u0026#34;p:hidden\u0026#34;).show(); // 选择显示的p标签，使其隐藏 $(\u0026#34;p:visible\u0026#34;).hide(); // 表单对象过滤选择器 // 内容过滤选择器、子元素过滤选择器 }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 事件\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #app{ width: 300px; height: 300px; background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;../js/jquery/jquery-1.11.1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(function () { // 鼠标事件 $(\u0026#34;div[id=\u0026#39;app\u0026#39;]\u0026#34;).mouseover(function () { $(\u0026#34;div[id=\u0026#39;app\u0026#39;]\u0026#34;).css(\u0026#39;backgroundColor\u0026#39;,\u0026#34;blue\u0026#34;); }); $(\u0026#34;div[id=\u0026#39;app\u0026#39;]\u0026#34;).mouseout(function () { $(\u0026#34;div[id=\u0026#39;app\u0026#39;]\u0026#34;).css(\u0026#39;backgroundColor\u0026#39;,\u0026#34;red\u0026#34;); }) }) $(document).keyup(function (event) { // console.log(event.keyCode); if(event.keyCode==13){ console.log(\u0026#34;提交成功!\u0026#34;); } }) \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JQuery动画\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #app { width: 300px; height: 300px; background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;../js/jquery/jquery-1.11.1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(function () { $(\u0026#34;div[id=\u0026#39;app\u0026#39;]\u0026#34;).hover( function () { $(\u0026#34;div[id=\u0026#39;app\u0026#39;]\u0026#34;).css(\u0026#34;backgroundColor\u0026#34;, \u0026#34;green\u0026#34;); }, function () { $(\u0026#34;div[id=\u0026#39;app\u0026#39;]\u0026#34;).css(\u0026#34;backgroundColor\u0026#34;, \u0026#34;red\u0026#34;); } ); }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var i=0; $(\u0026#34;button:first\u0026#34;).click(function () { i++; if(i%2==1){ // $(\u0026#34;div#app\u0026#34;).hide(\u0026#34;show\u0026#34;); // 1000毫秒 // $(\u0026#34;div#app\u0026#34;).hide(1000); // $(\u0026#34;div#app\u0026#34;).fadeOut(\u0026#34;show\u0026#34;); $(\u0026#34;div#app\u0026#34;).slideUp(\u0026#34;show\u0026#34;); }else{ // $(\u0026#34;div#app\u0026#34;).show(\u0026#34;show\u0026#34;); // $(\u0026#34;div#app\u0026#34;).fadeIn(\u0026#34;show\u0026#34;); $(\u0026#34;div#app\u0026#34;).slideDown(\u0026#34;show\u0026#34;); } // 淡入、淡出效果 // fadeIn、fadeOut // 改变元素的高度 // slideUp、slideDown }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 样式及内容操作\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;../js/jquery/jquery-1.11.1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;cli\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;随便输入\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(\u0026#34;button[id=\u0026#39;cli\u0026#39;]\u0026#34;).click(function () { // $(\u0026#34;div[id=\u0026#39;app\u0026#39;]\u0026#34;).css(\u0026#34;backgroundColor\u0026#34;,\u0026#34;red\u0026#34;) // 同时设置多个样式 $(\u0026#34;div[id=\u0026#39;app\u0026#39;]\u0026#34;).css({ \u0026#34;width\u0026#34;:\u0026#34;300px\u0026#34;, \u0026#34;height\u0026#34;:\u0026#34;300px\u0026#34;, \u0026#34;backgroundColor\u0026#34;:\u0026#34;red\u0026#34; }) // 追加样式 // addClass(\u0026#34;classname1 classname2\u0026#34;) // 移除样式 // removeClass(\u0026#34;style1 style2\u0026#34;) }) $(\u0026#34;input[type=\u0026#39;text\u0026#39;]\u0026#34;).bind({ \u0026#34;blur\u0026#34;:function () { // 获取值 // console.log(\u0026#34;失去焦点了\u0026#34;,$(\u0026#34;input[type=\u0026#39;text\u0026#39;]\u0026#34;).val()); // 设置值 // val()为空时，获取值；val(\u0026#34;xxx\u0026#34;)时，设置值 $(\u0026#34;input[type=\u0026#39;text\u0026#39;]\u0026#34;).val(\u0026#34;aaa\u0026#34;) }, \u0026#34;focus\u0026#34;:function () { // 获取值 console.log(\u0026#34;获取焦点了\u0026#34;,$(\u0026#34;input[type=\u0026#39;text\u0026#39;]\u0026#34;).val()); } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 节点操作\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;../js/jquery/jquery-1.11.1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; li{ color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 前者添加到后者 // $(\u0026#34;\u0026lt;li\u0026gt;啊哈哈哈\u0026lt;/li\u0026gt;\u0026#34;).appendTo(\u0026#34;#app\u0026#34;); // 向前者中添加后者 // $(\u0026#34;#app\u0026#34;).append(\u0026#34;\u0026lt;li\u0026gt;啊哈哈哈\u0026lt;/li\u0026gt;\u0026#34;); // 将后者添加到前者之前 // $(\u0026#34;#app\u0026#34;).prepend(\u0026#34;\u0026lt;li\u0026gt;啊哈哈哈\u0026lt;/li\u0026gt;\u0026#34;); // 将前者添加到后者之前 // $(\u0026#34;\u0026lt;li\u0026gt;啊哈哈哈\u0026lt;/li\u0026gt;\u0026#34;).prependTo(\u0026#34;#app\u0026#34;); // 前者后面添加后者，同辈节点 // $(\u0026#34;#app\u0026#34;).after(\u0026#34;\u0026lt;li\u0026gt;啊哈哈哈\u0026lt;/li\u0026gt;\u0026#34;); // 前者添加后者后面，同辈节点 // $(\u0026#34;\u0026lt;li\u0026gt;啊哈哈哈\u0026lt;/li\u0026gt;\u0026#34;).insertAfter(\u0026#34;#app\u0026#34;); // 前者前面添加后者，同辈节点 // $(\u0026#34;#app\u0026#34;).before(\u0026#34;\u0026lt;li\u0026gt;啊哈哈哈\u0026lt;/li\u0026gt;\u0026#34;); // 后者前面添加前者，同辈节点 // $(\u0026#34;\u0026lt;li\u0026gt;啊哈哈哈\u0026lt;/li\u0026gt;\u0026#34;).insertBefore(\u0026#34;#app\u0026#34;); // replace()和replaceAll()用于替换某个节点 // 新节点替换旧节点 // $(\u0026#34;旧节点\u0026#34;).replaceWith(\u0026#34;新节点\u0026#34;); // $(\u0026#34;新节点\u0026#34;).replaceAll(\u0026#34;旧节点\u0026#34;); // clone()用于复制某个节点 // true 表示需要copy事件处理 // $(\u0026#34;span\u0026#34;).clone(true).appendTo(\u0026#34;div\u0026#34;); // 删除节点 // remove() 删除某个节点，自身删除自身 // detach() 删除整个节点，保留元素事件、附加数据 // empty() 清空节点内容，清空子节点 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 属性操作\u0026amp;节点遍历\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;../js/jquery/jquery-1.11.1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34; name=\u0026#34;哈哈\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;span\u0026gt;aaa\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34;\u0026gt;男 \u0026lt;script\u0026gt; $(function () { // 获取name属性的值 console.log($(\u0026#34;#app\u0026#34;).attr(\u0026#34;name\u0026#34;)); // 设置值 $(\u0026#34;#app\u0026#34;).attr({style:\u0026#34;width: 300px;height:300px;background-color:red\u0026#34;}) $(\u0026#34;img\u0026#34;).attr({width:\u0026#39;300px\u0026#39;,height:\u0026#34;300px\u0026#34;}) // prop 和 attr的区别 // 第一个input标签 // 显示 undefined // console.log($(\u0026#34;input[type=\u0026#39;radio\u0026#39;]\u0026#34;).attr(\u0026#34;checked\u0026#34;)); // 显示 false // console.log($(\u0026#34;input[type=\u0026#39;radio\u0026#39;]\u0026#34;).prop(\u0026#34;checked\u0026#34;)); // $(\u0026#34;input[type=\u0026#39;radio\u0026#39;]\u0026#34;).attr(\u0026#34;checked\u0026#34;,\u0026#34;checked\u0026#34;); // $(\u0026#34;input[type=\u0026#39;radio\u0026#39;]\u0026#34;).prop(\u0026#34;checked\u0026#34;,\u0026#34;true\u0026#34;); // 获取父级元素 // console.log($(\u0026#34;span[id=\u0026#39;test\u0026#39;]\u0026#34;).parent()); // 获取所有父级及祖级元素 // console.log($(\u0026#34;span[id=\u0026#39;test\u0026#39;]\u0026#34;).parents()); // 获取元素的所有子元素，但不包含孙子元素（子元素的子元素） // console.log($(\u0026#34;#app\u0026#34;).children()); // 用于获取该标签之后的元素 // next() // 用于获取该标签之前的元素 // prev() // 用于获取该标签之前、与后的所有同辈元素元素 // sublings() // css() // 设置或返回元素的宽度 // weight // 设置或返回元素的高度 // height $(function () { // $(\u0026#34;div\u0026#34;).each(function (i, domEle) { // // 索引 //// console.log(i); // console.log($(domEle).text()); // }) }) $.each((\u0026#34;div\u0026#34;),function (i, domEle) { console.log($(domEle).text()); }) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2023-04-19T00:00:00Z","image":"http://localhost:1313/p/jquery/202412212153256_hu8427917866387828145.png","permalink":"http://localhost:1313/p/jquery/","title":"JQuery"},{"content":" 推介查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/jquery/3.0.0/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } body { width: 100%; height: 100vh; /* flex布局 */ display: flex; /* justify-content \u0026amp; align-items */ /* 延横轴方向居中对齐 */ /*justify-content: center;*/ /* 靠右对齐 */ /*justify-content: flex-end;*/ /* 左右两端对齐，相等间距 */ /*justify-content: space-between;*/ /* 项目中间的间距为左右两端的2倍 */ /*justify-content: space-around;*/ /* 项目之间间距与项目容器之间间距相等 */ /*justify-content: space-evenly;*/ /* 默认，沿着交叉轴布局方向分布 */ /*justify-content: flex-start;*/ /* 交叉轴居中排列,此处需要将父元素设置一定高度才起作用 */ /*align-items: center;*/ /* 交叉轴底部对齐 */ /*align-items: flex-end;*/ /* 项目水平垂直居中 */ /*justify-content: center;*/ /*align-items: center;*/ /* flex-direction \u0026amp; flex-wrap*/ /* 默认为row */ /*flex-direction: row-reverse;*/ /* 按列分布 */ /*flex-direction: column;*/ /*flex-direction: column-reverse;*/ /* flex-wrap默认为nowrap，项目会强行等分容器，且不换行 */ /* 根据自身宽度进行排列 */ flex-wrap: wrap; } /* 项目属性: order \u0026amp; flex \u0026amp; align-self */ /*order 排列顺序*/ /*flex-grow 项目在有剩余空间时，是否放大*/ /*取值:默认0 1 auto, flex属性是flex- grow, flex-shrink与flex- basis三个属性的简写，*/ /*用于定义项目放大，缩小与宽度。该属性有两个快捷键值，分别是auto(1 1 auto)等分放大缩小，与none(0 0 auto)不放大，但等分缩小，*/ .test-div { width: 200px; height: 200px; background-color: #00FFFF; border: 1px solid black; text-align: center; line-height: 200px; } .test-div:first-child { background-color: red; /*order: 1;*/ /*align-self: center;*/ /*align-self: flex-end;*/ } .test-div:nth-child(2) { background-color: gray; /*order: 0;*/ } .test-div:nth-child(3) { background-color: greenyellow; /*order: 2;*/ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;test-div\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;test-div\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;test-div\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2023-04-16T00:00:00Z","image":"http://localhost:1313/p/flex%E5%B8%83%E5%B1%80/202412212158979_hu2930731717379496667.png","permalink":"http://localhost:1313/p/flex%E5%B8%83%E5%B1%80/","title":"Flex布局"},{"content":"Vue3学习\r要求，点击按钮，改变数据 vue2的写法也可以实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;count:{{count}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Home\u0026#39;, props: { msg: String, }, data(){ return{ count:0 } }, methods:{ test(){ this.count++; } } }); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; button{ width: 80px; height: 30px; } \u0026lt;/style\u0026gt; 接下来看vue3的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;count:{{count}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Home\u0026#39;, props: { msg: String, }, setup(){ // 变量 let count=0; // 方法 function test(){ count++; console.log(\u0026#34;测试:\u0026#34;,count); } return{ count:count, test } } }); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; button{ width: 80px; height: 30px; } \u0026lt;/style\u0026gt; 然而此时的页面并没有变化，为什么？\n因为此时的数据并不是响应式数据 ref\r正确写法 ref一般用来定义一个基本类型的响应式数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;count:{{count}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, ref} from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Home\u0026#39;, props: { msg: String, }, setup(){ // ref一般用来定义一个基本类型的响应式数据，若需要将一个对象变成响应式数据该用谁呢？（答:reactive） let count=ref(0); // 方法 function test(){ // count是一个ref对象，所以不能直接count++ // 而上面并没有写{{count.value}}来进行渲染，而是{{count}} count.value++; console.log(\u0026#34;测试:\u0026#34;,count); } return{ count:count, test } } }); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; button{ width: 80px; height: 30px; } \u0026lt;/style\u0026gt; reactive\r要求，显示用户的相关信息，点击按钮后更新用户信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p\u0026gt;姓名:{{user.name}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;年龄:{{user.age}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;座驾:{{user.cars}}\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;父亲姓名:{{user.father.name}}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;父亲年龄:{{user.father.age}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;母亲姓名:{{user.mather.name}}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;母亲年龄:{{user.father.age}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref} from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Home\u0026#39;, props: { msg: String, }, /* 作用:定义多个数据的响应式 const proxy=reactive(obj):接收一个普通对象然后返回该普通对象的响应式代理器对象 响应式转换是“深层的”:会影响对象内部所有嵌套的属性 内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据都是响应式的 */ setup() { // 把数据编程响应式的数据 // 返回的是一个proxy代理对象，被代理的对象是传入的对象 // testObj是代理对象，而obj是目标对象 // obj={} // const testObj=reactive(obj); // obj.name=\u0026#39;aaa\u0026#39; // 直接使用目标对象的方式来更新属性的值，是无法改变的，只能使用代理对象来进行修改 // 正确使用方式如下: // testObj.name=\u0026#39;aaa\u0026#39; let user = reactive({ name: \u0026#34;王明\u0026#34;, age: 20, cars: [\u0026#39;风火轮\u0026#39;, \u0026#39;哮天犬\u0026#39;, \u0026#39;筋斗云\u0026#39;], father: { name: \u0026#34;王海\u0026#34;, age: 45 }, mather: { name: \u0026#34;李花花\u0026#34;, age: 43 } }); // 方法 const test=()=\u0026gt;{ user.name+=\u0026#39;-\u0026#39;; user.age++; user.cars=[\u0026#39;葫芦\u0026#39;,\u0026#39;飞剑\u0026#39;] } return { user: user, test } } }); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; button { width: 80px; height: 30px; } \u0026lt;/style\u0026gt; 新需求，\nuser-\u0026gt;代理对象 obj -\u0026gt;目标对象\nuser对象或者obj对象添加一个新的属性，哪种方式会影响界面的更新？ user对象或者obj对象移除一个已存在的属性，哪种方式会影响界面的更新？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p\u0026gt;姓名:{{user.name}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;年龄:{{user.age}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;性别:{{user.gender}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;座驾:{{user.cars}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref} from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Home\u0026#39;, props: { msg: String, }, setup() { // 为了在使用【obj.gender=\u0026#39;男\u0026#39;;】时不出现错误信息才采用这种写法 // let obj:any={ let obj:any={ name: \u0026#34;王明\u0026#34;, age: 20, cars: [\u0026#39;风火轮\u0026#39;, \u0026#39;哮天犬\u0026#39;, \u0026#39;筋斗云\u0026#39;] }; let user = reactive(obj); // 方法 const test=()=\u0026gt;{ // 这种方式页面并没有更新渲染，但是obj中的属性已被添加 // obj.gender=\u0026#39;男\u0026#39;; // 为了不出现错误提示，可【let obj:any={】或者【let user = reactive\u0026lt;any\u0026gt;(obj);】 // 这种方式可以更新界面，而且属性也被添加到obj对象了 user.gender=\u0026#39;男\u0026#39; // 界面没有更新，但是obj中的属性已被删除 // delete obj.age; // 页面更新渲染,obj中属性已被删除 delete user.age; console.log(user); } return { user: user, test } } }); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; button { width: 80px; height: 30px; } \u0026lt;/style\u0026gt; 总结：如果操作代理对象,目标对象中的数据也会随之变化，同时如果想要在操作数据的时候，界面也要跟着重新更新渲染，那么需要操作代理对象\nvue2与vue3响应式的对比\rvue2\n核心: 对象:通过defineProperty对对象的已有属性值的读取和修改进行劫持(监视/拦截) 数组:通过重写数组更新数组一系列更新元素的方法来实现元素修改的劫持 问题 对象直接新添加的属性或删除已有属性,界面不会自动更新 直接通过下标替换元素或更新length,界面不会自动更新arr[1]= {} vue3\n核心: 通过Proxy(代理):拦截对data任意属性的任意(13种)操作,包括属性值的读写,属性的添加，属性的删除等.. 通过Reflect(反射):动态对被代理对象的相应属性进行特定的操作 响应式数据\r响应式数据原理:\n直接在vue项目中新建一个html页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;响应式的原理\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 目标对象 const user = { name: \u0026#39;佐助\u0026#39;, age: 20, wife: { name: \u0026#39;小樱\u0026#39;, age: 19 } } // 代理对象 const proxyUser = new Proxy(user, { // 获取目标对象的某个属性值 get(target, prop) { console.log(\u0026#34;get方法被调用了\u0026#34;); return Reflect.get(target, prop); }, // 修改目标对象的属性值 \u0026amp; 为目标对象添加新的属性 set(target, prop, newValue) { console.log(\u0026#34;set方法被调用了\u0026#34;); return Reflect.set(target, prop, newValue); }, // 删除目标对象上的某个属性 deleteProperty(target, prop) { console.log(\u0026#34;deleteProperty方法被调用了\u0026#34;); return Reflect.deleteProperty(target, prop); } }); // 通过代理对象获取目标对象的信息 console.log(proxyUser.name); // 通过代理对象更新目标对象上的属性值 proxyUser.name = \u0026#39;鸣人\u0026#39;; console.log(user); // 通过代理对象向目标对象中添加一个新的属性 proxyUser.gender=\u0026#39;男\u0026#39;; // 通过代理对象删除目标对象中的属性 delete proxyUser.name; console.log(user); // 更新目标对象中的某个属性的对象的值 proxyUser.wife.name=\u0026#39;雏田\u0026#39;; console.log(user); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 响应式数据的测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p\u0026gt;姓名:{{user.name}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;年龄:{{user.age}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;性别:{{user.gender}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;座驾:{{user.cars}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, reactive, ref} from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Home\u0026#39;, props: { msg: String, }, setup() { // 为了在使用【obj.gender=\u0026#39;男\u0026#39;;】时不出现错误信息才采用这种写法 // let obj:any={ let obj:any={ name: \u0026#34;王明\u0026#34;, age: 20, cars: [\u0026#39;风火轮\u0026#39;, \u0026#39;哮天犬\u0026#39;, \u0026#39;筋斗云\u0026#39;] }; let user = reactive(obj); // 方法 const test=()=\u0026gt;{ user.cars[0]=\u0026#39;炼丹炉\u0026#39;; // 数组中添加新元素 user.cars[3]=\u0026#39;葫芦\u0026#39;; } return { user: user, test } } }); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; button { width: 80px; height: 30px; } \u0026lt;/style\u0026gt; setup细节\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;子级组件\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;msg:{{msg}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent} from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Child\u0026#39;, props:[\u0026#39;msg\u0026#39;], // setup细节问题: // 1.setup在beforeCreate之前就会执行 setup(){ console.log(\u0026#34;setup执行了\u0026#34;); // setup中一般都是返回一个对象，对象中的属性和方法可以都在html模板中使用 return{ } }, // 数据初始化的生命周期的回调 beforeCreate() { console.log(\u0026#34;beforeCreate执行了\u0026#34;); } }); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; ","date":"2023-04-16T00:00:00Z","image":"http://localhost:1313/p/vue3%E5%AD%A6%E4%B9%A0/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/vue3%E5%AD%A6%E4%B9%A0/","title":"Vue3学习"},{"content":"thymeleaf学习\r依赖\r1 2 3 4 5 6 7 8 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; thymeleaf默认模板\r1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ch\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;默认的标题\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;默认的描述\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;默认的关键字\u0026#34;\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; thymeleaf配置\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 server: # 应用服务 WEB 访问端口 port: 10010 spring: # 应用名称 application: name: thymeleaf-demo # 配置thymeleaf thymeleaf: cache: false mode: HTML5 encoding: UTF-8 prefix: classpath:/templates/ #名称的后缀 suffix: .html servlet: content-type: text/html datasource: # 数据库驱动： driver-class-name: com.mysql.cj.jdbc.Driver # 数据源名称 name: defaultDataSource # 数据库连接地址 url: jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8 # 数据库用户名\u0026amp;密码： username: root password: 123456 mybatis-plus: # 指定Mybatis的Mapper文件 mapper-locations: classpath:mapper/*xml # 指定Mybatis的实体目录 type-aliases-package: com.example.plus.domain # 日志打印 configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 逻辑删除列配置 global-config: db-config: # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-field: delFlag # 逻辑已删除值(默认为 1) logic-delete-value: 1 # 逻辑未删除值(默认为 0) logic-not-delete-value: 0 logging: pattern: dateformat: MM-ddHH:mm:ss:SSS 注意\r本项目采用thymeleaf+mybatis plus+mysql+springboot，项目结构如下 其中templates用来存放html，templates下的component内用于存放页面中可复用的组件 static下存放静态文件，如js、css、img\u0026hellip; thymeleaf:. └─src └─main ├─java │ └─com │ └─example │ ├─controller │ ├─domain │ ├─mapper │ └─service │ └─impl └─resources ├─mapper ├─static │ ├─css │ ├─js │ └─json └─templates └─component\n示例1\r语法:${}获取数据，||拼接(当然可也用单引号+双引号拼接)\n访问localhost:10010/test可观察到页面标题的变化\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ch\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title th:text=\u0026#34;|拼接+${title}|\u0026#34;\u0026gt;默认的标题\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;默认的描述\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;默认的关键字\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Hello World! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 @GetMapping(\u0026#34;/test\u0026#34;) public ModelAndView indexTest(){ ModelAndView modelAndView=new ModelAndView(); modelAndView.addObject(\u0026#34;title\u0026#34;,\u0026#34;传递的标题\u0026#34;); modelAndView.setViewName(\u0026#34;index\u0026#34;); return modelAndView; } 语法\r1 2 3 4 5 6 7 8 9 @GetMapping(\u0026#34;/basic-train\u0026#34;) public ModelAndView basicTest(){ ModelAndView modelAndView=new ModelAndView(); modelAndView.addObject(\u0026#34;userList\u0026#34;,userService.list()); modelAndView.addObject(\u0026#34;user\u0026#34;,userService.getById(2)); modelAndView.addObject(\u0026#34;title\u0026#34;,\u0026#34;basic页面\u0026#34;); modelAndView.setViewName(\u0026#34;basic\u0026#34;); return modelAndView; } 链接变表达式：可引入外部文件，如js、css等 1 2 3 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; th:href=\u0026#34;@{css/test.css}\u0026#34;\u0026gt; \u0026lt;script th:src=\u0026#34;@{js/jquery-3.0.0.min.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;a th:href=\u0026#34;@{index.html}\u0026#34;\u0026gt;超链接\u0026lt;/a\u0026gt; th:text 这里有个细节请注意:mysql表中的字段为nick_name，这里的属性和java实体类对应，所以是nickName\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- th:text --\u0026gt; \u0026lt;span th:text=\u0026#34;${user.id}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;span th:text=\u0026#34;${user.username}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;span th:text=\u0026#34;${user.password}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;span th:text=\u0026#34;${user.nickName}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;!-- 换一种方式 --\u0026gt; \u0026lt;div th:object=\u0026#34;${user}\u0026#34;\u0026gt; \u0026lt;span th:text=\u0026#34;*{id}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;span th:text=\u0026#34;*{username}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;span th:text=\u0026#34;*{password}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;span th:text=\u0026#34;*{nickName}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/div\u0026gt; th:if 1 2 \u0026lt;!-- th:if --\u0026gt; \u0026lt;div th:if=\u0026#34;${user.id}==1\u0026#34;\u0026gt;id为1\u0026lt;/div\u0026gt; th:each 循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- th:each --\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;账号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;密码\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;昵称\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr th:each=\u0026#34;item,index : ${userList}\u0026#34;\u0026gt; \u0026lt;td th:text=\u0026#34;${item.id}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${item.username}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${item.password}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${item.nickName}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; th:classappend 添加class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;账号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;密码\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;昵称\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr th:each=\u0026#34;item,index : ${userList}\u0026#34;\u0026gt; \u0026lt;!-- 追加class --\u0026gt; \u0026lt;!-- 如果是最后一个，则添加test为class --\u0026gt; \u0026lt;td th:text=\u0026#34;${item.id}\u0026#34; th:classappend=\u0026#34;${index.last}?test\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${item.username}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${item.password}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${item.nickName}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; th:switch 1 2 3 4 5 6 7 8 \u0026lt;!-- th:switch --\u0026gt; \u0026lt;div th:switch=\u0026#34;${user.username}\u0026#34;\u0026gt; \u0026lt;p th:case=\u0026#34;admin\u0026#34;\u0026gt;用户是admin\u0026lt;/p\u0026gt; \u0026lt;p th:case=\u0026#34;aaaaa\u0026#34;\u0026gt;用户是aaaaa\u0026lt;/p\u0026gt; \u0026lt;p th:case=\u0026#34;asdas\u0026#34;\u0026gt;用户是asdas\u0026lt;/p\u0026gt; \u0026lt;!-- 若都不是其他case，则显示默认值 --\u0026gt; \u0026lt;p th:case=\u0026#34;*\u0026#34;\u0026gt;默认值\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 如何动态获取th:text里的内容？\u0026ndash;th:inline 1 2 3 4 5 6 7 \u0026lt;!-- 需要动态渲染的javascript --\u0026gt; \u0026lt;!-- 同理，css也可以这样渲染 --\u0026gt; \u0026lt;script th:inline=\u0026#34;javascript\u0026#34;\u0026gt; /* 若user没有传值，则使用后面的默认值;若user传了值，使用注释里的user值 */ let user =/*[[${user}]]*/{} console.log(\u0026#34;thymeleaf-user:\u0026#34;,user); \u0026lt;/script\u0026gt; 组件(碎片) th:replace component/com.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ch\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;!-- 本页面的style样式在组件被其它页面引入后是不会显示的 --\u0026gt; \u0026lt;style\u0026gt; #com1 { width: 300px; height: 20px; background-color: greenyellow; } #com2 { width: 300px; height: 20px; background-color: yellow; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div th:fragment=\u0026#34;com1\u0026#34; id=\u0026#34;com1\u0026#34;\u0026gt; com1 \u0026lt;/div\u0026gt; \u0026lt;div th:fragment=\u0026#34;com2\u0026#34; id=\u0026#34;com2\u0026#34;\u0026gt; com2 \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; basic.html\n1 2 3 4 5 6 7 8 \u0026lt;!-- th:replace --\u0026gt; \u0026lt;!-- 替换碎片 --\u0026gt; \u0026lt;!-- 将div标签也替换成com1内的标签 --\u0026gt; \u0026lt;div th:replace=\u0026#34;~{component/com::com1}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 如果不希望div标签被替换，可以使用insert --\u0026gt; \u0026lt;div th:insert=\u0026#34;~{component/com::com2}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 也可以通过类似jquery选择器的方式获取 --\u0026gt; \u0026lt;div th:insert=\u0026#34;~{component/com::#com2}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ajax格式\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 $.ajax({ //请求的url地址 url: \u0026#34;\u0026#34;, //返回格式为json dataType: \u0026#34;json\u0026#34;, //请求是否异步，默认为异步，这也是ajax重要特性 async: true, //参数值 data: {}, //请求方式 type: \u0026#34;GET\u0026#34;, beforeSend: function () { //请求前的处理 }, success: function (data) { //请求成功时处理 console.log(\u0026#34;data:\u0026#34;, data) }, complete: function () { //请求完成的处理 }, error: function () { //请求出错处理 } }); 项目地址\r点击\n","date":"2023-04-15T00:00:00Z","image":"http://localhost:1313/p/thymeleaf/202412211939238_hu15059918093444388389.png","permalink":"http://localhost:1313/p/thymeleaf/","title":"Thymeleaf"},{"content":"注解@RequestBody使用报错\r@RequestBody\r今天在使用requestBody注解时，出现了一些问题 不知道咋想的，传参不是这么传的\n既然用的是@RequestBody注解，如果是User user，那这么写没问题，但是写的是Integer id\n那应该使用如下格式的传参 ","date":"2023-04-05T00:00:00Z","image":"http://localhost:1313/p/%E6%B3%A8%E8%A7%A3@requestbody%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/%E6%B3%A8%E8%A7%A3@requestbody%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/","title":"注解@RequestBody使用报错"},{"content":"自定义异常未被捕获\r自定义异常未被@RestControllerAdvice捕获\r自定义了一个异常未被@RestControllerAdvice捕获\n原因是被try..catch..捕获了，而没被@RestControllerAdvice捕获\n这个原因其实我之前听说过但是没遇到过，现在遇到了，真的长记性了… ","date":"2023-04-05T00:00:00Z","image":"http://localhost:1313/p/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E6%9C%AA%E8%A2%AB@restcontrolleradvice%E6%8D%95%E8%8E%B7/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E6%9C%AA%E8%A2%AB@restcontrolleradvice%E6%8D%95%E8%8E%B7/","title":"自定义异常未被@RestControllerAdvice捕获"},{"content":"Hibernate学习01\r参考博客\n1 2 3 4 5 6 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!-- 在实体类所在的包下，创建一个xml文件。名称为【实体类+.hbm.xml】 --\u0026gt; \u0026lt;!-- 导入约束:dtd约束 --\u0026gt; \u0026lt;!DOCTYPE hibernate-mapping PUBLIC \u0026#34;-//Hibernate/Hibernate Mapping DTD 3.0//EN\u0026#34; \u0026#34;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\u0026#34;\u0026gt; 复制hibernate-mapping-3.0.dtd内约束指实体类xml\n1 2 3 4 5 6 7 8 9 10 11 12 create table tb_user( id number primary key , username varchar2(20), password varchar2(20), nick_name varchar2(20) ); comment on table tb_user is \u0026#39;用户表\u0026#39;; comment on column tb_user.id is \u0026#39;主键\u0026#39;; comment on column tb_user.username is \u0026#39;用户名\u0026#39;; comment on column tb_user.password is \u0026#39;密码\u0026#39;; comment on column tb_user.nick_name is \u0026#39;昵称\u0026#39;; commit; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class User { private int uids; private String username; private String password; private String nickName; public User() { } public User(int uids, String username, String password, String nickName) { this.uids = uids; this.username = username; this.password = password; this.nickName = nickName; } public int getUids() { return uids; } public void setUids(int uids) { this.uids = uids; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getNickName() { return nickName; } public void setNickName(String nickName) { this.nickName = nickName; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!-- 在实体类所在的包下，创建一个xml文件。名称为【实体类+.hbm.xml】 --\u0026gt; \u0026lt;!-- 导入约束:dtd约束 --\u0026gt; \u0026lt;!DOCTYPE hibernate-mapping PUBLIC \u0026#34;-//Hibernate/Hibernate Mapping DTD 3.0//EN\u0026#34; \u0026#34;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\u0026#34;\u0026gt; \u0026lt;hibernate-mapping package=\u0026#34;com.example.domain\u0026#34;\u0026gt; \u0026lt;class name=\u0026#34;User\u0026#34; table=\u0026#34;TB_USER\u0026#34;\u0026gt; \u0026lt;id name=\u0026#34;uids\u0026#34; column=\u0026#34;id\u0026#34;\u0026gt; \u0026lt;!-- 主键的生成方式 native是使用本地数据库的自动增长能力--\u0026gt; \u0026lt;generator class=\u0026#34;native\u0026#34;/\u0026gt; \u0026lt;/id\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; column=\u0026#34;username\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; column=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;nickName\u0026#34; column=\u0026#34;nick_name\u0026#34;/\u0026gt; \u0026lt;/class\u0026gt; \u0026lt;/hibernate-mapping\u0026gt; 在根目录下创建hibernate.cfg.xml，一般是src，但是我这里设置的是java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!-- 在项目的根路径下创建名为hibernate.cfg.xml的配置文件 --\u0026gt; \u0026lt;!-- 导入约束:dtd约束 --\u0026gt; \u0026lt;!DOCTYPE hibernate-configuration PUBLIC \u0026#34;-//Hibernate/Hibernate Configuration DTD 3.0//EN\u0026#34; \u0026#34;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\u0026#34;\u0026gt; \u0026lt;hibernate-configuration\u0026gt; \u0026lt;!-- 配置sessionFactory --\u0026gt; \u0026lt;!-- sessionFactory的作用是用来创建session对象，session对象就是hibernate中操作数据库的核心对象--\u0026gt; \u0026lt;!-- 创建sessionFactory的三步 --\u0026gt; \u0026lt;!-- 1.连接数据库的信息 2.hibernate的可选配置 3.映射文件位置 --\u0026gt; \u0026lt;session-factory\u0026gt; \u0026lt;!-- 1.连接数据库的信息 --\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.driver_class\u0026#34;\u0026gt; oracle.jdbc.driver.OracleDriver \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.url\u0026#34;\u0026gt; jdbc:oracle:thin:@localhost:1521:orcl \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.username\u0026#34;\u0026gt; test \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.password\u0026#34;\u0026gt; 123456 \u0026lt;/property\u0026gt; \u0026lt;!-- 数据库的方言 --\u0026gt; \u0026lt;property name=\u0026#34;hibernate.dialect\u0026#34;\u0026gt;org.hibernate.dialect.Oracle8iDialect\u0026lt;/property\u0026gt; \u0026lt;!-- 2.hibernate的可选配置 --\u0026gt; \u0026lt;!-- 显示hibernate生成的sql语句 --\u0026gt; \u0026lt;property name=\u0026#34;hibernate.show_sql\u0026#34;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;!-- 是否使用格式化输出sql语句 --\u0026gt; \u0026lt;property name=\u0026#34;hibernate.format_sql\u0026#34;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;!-- 配置hibernate采用何种方式生成DDL语句 --\u0026gt; \u0026lt;!-- update表示检测实体类的映射配置与数据库结构是否一致，如果不一致，更新表结构;如果没有该表，则创建该表 --\u0026gt; \u0026lt;!-- SQL结构化查询语言: 一共分为6个部分 DDL: Data Definition Language DML: Data Manipulatiok Language DQL: Data Query Language DCL: Data Control Language 数据控制语言 CCL: Cursor Control Language 游标控制语言 TPL: Transaction Processing Language 事务处理语言 --\u0026gt; \u0026lt;property name=\u0026#34;hibernate.hbm2ddl.auto\u0026#34;\u0026gt;update\u0026lt;/property\u0026gt; \u0026lt;!-- 3.映射配置文件的路径 --\u0026gt; \u0026lt;!-- 多个配置文件就在这里写多次 --\u0026gt; \u0026lt;mapping resource=\u0026#34;com/example/domain/User.hbm.xml\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;mapping resource=\u0026#34;com/example/domain/User.hbm.xml\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;/session-factory\u0026gt; \u0026lt;/hibernate-configuration\u0026gt; ","date":"2023-04-02T00:00:00Z","image":"http://localhost:1313/p/hibernate/202412212123233_hu1335506920949643513.png","permalink":"http://localhost:1313/p/hibernate/","title":"Hibernate"},{"content":"Java泛型\r参考视频\n在类上\r这是个打印integer的类，但也仅仅只能打印integer了\n难道以后要打印String、Double还需要复制粘贴再新建类吗？\n1 2 3 4 5 6 7 8 9 public class PrinterInteger { Integer needToPrint; public PrinterInteger(Integer needToPrint) { this.needToPrint = needToPrint; } public void print(){ System.out.println(needToPrint); } } 可以考虑采用以下方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Printer \u0026lt;T\u0026gt;{ T needToPrint; public Printer(T needToPrint) { this.needToPrint = needToPrint; } public void print(){ System.out.println(needToPrint); } /** * 测试 */ static class MyTest{ public static void main(String[] args) { // 打印String Printer\u0026lt;String\u0026gt; stringPrinter = new Printer\u0026lt;\u0026gt;(\u0026#34;hello world\u0026#34;); stringPrinter.print(); // 打印Double Printer\u0026lt;Double\u0026gt; doublePrinter = new Printer\u0026lt;\u0026gt;(30.5); doublePrinter.print(); } } } 泛型不能使用基本数据类型，如int、long等 泛型 extends\n1 2 3 4 5 6 7 public class Animal { String name; int age; public void eat(){ System.out.println(\u0026#34;吃饭ing\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Cat extends Animal{ private String litterPreference; public Cat(String name) { this.name = name; } public Cat() { } public String getLitterPreference() { return litterPreference; } public void setLitterPreference(String litterPreference) { this.litterPreference = litterPreference; } } 1 2 3 public class Dog extends Animal{ int walkDistancePreference; } 泛型这么写\n1 2 3 4 5 6 7 8 9 public class Printer \u0026lt;T extends Animal\u0026gt;{ T needToPrint; public Printer(T needToPrint) { this.needToPrint = needToPrint; } public void print(){ System.out.println(needToPrint); } } 这个时候就会报错了，因为泛型写了\u0026lt;T extends Animal\u0026gt;，改写成如下写法后正确\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Printer \u0026lt;T extends Animal\u0026gt;{ T needToPrint; public Printer(T needToPrint) { this.needToPrint = needToPrint; } public void print(){ System.out.println(needToPrint); } /** * 测试 */ static class MyTest{ public static void main(String[] args) { // 打印Cat Printer\u0026lt;Cat\u0026gt; stringPrinter = new Printer\u0026lt;\u0026gt;(new Cat()); stringPrinter.print(); // 打印Dog Printer\u0026lt;Dog\u0026gt; doublePrinter = new Printer\u0026lt;\u0026gt;(new Dog()); doublePrinter.print(); } } } eat方法定义在Animal类中，但如果取消掉类上的\u0026lt;T extends Animal\u0026gt;后，这行代码会报错 但是java不支持多继承，所以如果还需要同时继承Animal怎么办，参考如下写法\n但是注意，接口要写在后面，如果调换位置会报错 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Printer\u0026lt;T extends Animal \u0026amp; Serializable\u0026gt; { T needToPrint; public Printer(T needToPrint) { this.needToPrint = needToPrint; } public void print() { System.out.println(needToPrint); } /** * 测试 */ static class MyTest { public static void main(String[] args) { } } } 多个泛型参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Printer\u0026lt;T, V\u0026gt; { T needToPrint; V moreMsg; public Printer(T needToPrint, V moreMsg) { this.needToPrint = needToPrint; this.moreMsg = moreMsg; } public void print() { System.out.printf(\u0026#34;T:%s%n\u0026#34;, needToPrint); System.out.printf(\u0026#34;V:%s%n\u0026#34;, moreMsg); } /** * 测试 */ static class MyTest { public static void main(String[] args) { Printer\u0026lt;String, Cat\u0026gt; catPrinter = new Printer\u0026lt;\u0026gt;(\u0026#34;哈哈哈\u0026#34;, new Cat()); catPrinter.print(); } } } 在方法上\r作用在方法上 注意，这个时候他并不知道T是一个泛型，你需要”告诉他” 1 2 3 4 5 6 7 8 9 10 public class MyTest { public static void main(String[] args) { print(\u0026#34;abc\u0026#34;); print(123); print(new Cat()); } public static \u0026lt;T\u0026gt; void print(T str){ System.out.println(str+\u0026#34;:打印完成\u0026#34;); } } 当然，也可以写多个参数 1 2 3 4 5 6 7 8 9 public class MyTest { public static void main(String[] args) { print(\u0026#34;哈哈哈\u0026#34;, new Cat()); } public static \u0026lt;T, V\u0026gt; void print(T str, V msg) { System.out.printf(\u0026#34;T:%s%n\u0026#34;, str); System.out.printf(\u0026#34;V:%s%n\u0026#34;, msg); } } 指定返回值的泛型\n1 2 3 4 5 6 7 8 9 10 11 public class MyTest { public static void main(String[] args) { String print = print(\u0026#34;哈哈哈\u0026#34;, new Cat()); System.out.println(\u0026#34;返回值:\u0026#34;+print); } public static \u0026lt;T, V\u0026gt; T print(T str, V msg) { System.out.printf(\u0026#34;T:%s%n\u0026#34;, str); System.out.printf(\u0026#34;V:%s%n\u0026#34;, msg); return str; } } 泛型通配符 首先，来看一下下面这个问题 报错如下 是不是觉得很奇怪？Integer是Object的子类，为什么不能这么传值呢?\n对，Integer是Object的子类没错，但是这里是List\u0026lt;Object\u0026gt;和List\u0026lt;Integer\u0026gt;\nList\u0026lt;Integer\u0026gt;并不是List\u0026lt;Object\u0026gt;的子类\n或者可以把List\u0026lt;Object\u0026gt;换成Object，List\u0026lt;Integer\u0026gt;是Object的子类\n但是我们要的不是这种效果\n这时可以采用通配符?\n1 2 3 4 5 6 7 8 9 10 public class MyTest { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); print(list); } public static void print(List\u0026lt;?\u0026gt; list) { System.out.println(list); } } 甚至还可以指定是否继承某个类\n1 2 3 4 5 6 7 8 9 10 public class MyTest { public static void main(String[] args) { List\u0026lt;Cat\u0026gt; animal = new ArrayList\u0026lt;\u0026gt;(); animal.add(new Cat()); print(animal); } public static void print(List\u0026lt;? extends Animal\u0026gt; list) { System.out.println(list); } } ","date":"2023-04-01T00:00:00Z","image":"http://localhost:1313/p/09_java%E6%B3%9B%E5%9E%8B/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/09_java%E6%B3%9B%E5%9E%8B/","title":"09_Java泛型"},{"content":"添加【通过XXX打开】的右键菜单\r推介使用ContextMenuManager进行管理，以下不再演示ContextMenuManager用法 参考博文\n暂时还没有以webstorm打开的快捷方式 win+R，输入regedit\n新建项，命名为webstorm\n步骤4\n点击默认项，输入Open Folder as WebStorm Project\n设置图标\n命名为Icon 赋值webStorm文件路径 设置之前新建的Icon的值\n参考\u0026quot;D:\\IntelliJ IDEA 2022.3.1\\bin\\idea64.exe\u0026quot; \u0026quot;%1\u0026quot;这个命令，将文件路径换成自己的，其他不变\n","date":"2023-03-27T00:00:00Z","image":"http://localhost:1313/p/%E6%B7%BB%E5%8A%A0%E9%80%9A%E8%BF%87xxx%E6%89%93%E5%BC%80%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu4898064707681593350.jpg","permalink":"http://localhost:1313/p/%E6%B7%BB%E5%8A%A0%E9%80%9A%E8%BF%87xxx%E6%89%93%E5%BC%80%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/","title":"添加\"通过XXX打开\"的右键菜单"},{"content":"支付宝沙箱支付\r参考博客1\n参考博客2\n网站\n参考视频,青戈的demo项目 密钥 导入依赖\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sdk\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;alipay-sdk-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.22.110.ALL\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.7.20\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; application.properties里需要配置这四个 这里复制第一个appid 复制第二个私钥 复制第三个支付宝公钥 至于第四个url，需要下载一个工具 natapp地址\n官网：https://natapp.cn/ 下载：https://pan.baidu.com/s/1L99Ibawylnck4b4c0NtmXg?pwd=685x\n下载后，去官网注册账号 配好之后双击start.bat 还需要配置controller的地址 配置到此结束 1 2 3 4 5 6 7 8 9 10 11 12 import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Data @Component @ConfigurationProperties(prefix = \u0026#34;alipay\u0026#34;) public class AliPayConfig { private String appId; private String appPrivateKey; private String alipayPublicKey; private String notifyUrl; } 1 2 3 4 5 6 7 8 import lombok.Data; @Data public class AliPay { private String traceNo; private double totalAmount; private String subject; private String alipayTraceNo; } 继续新建AliPayController，把报错的AliPayConfig包换成自己项目里的路径，还有Order\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 import cn.hutool.json.JSONObject; import com.alipay.api.AlipayApiException; import com.alipay.api.AlipayClient; import com.alipay.api.DefaultAlipayClient; import com.alipay.api.internal.util.AlipaySignature; import com.alipay.api.request.AlipayTradePagePayRequest; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.example.alipay.common.AliPayConfig; import com.example.alipay.dao.OrdersMapper; import com.example.alipay.entity.Orders; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Date; import java.util.HashMap; import java.util.Map; // xjlugv6874@sandbox.com // 9428521.24 - 30 = 9428491.24 + 30 = 9428521.24 @RestController @RequestMapping(\u0026#34;/alipay\u0026#34;) public class AliPayController { private static final String GATEWAY_URL = \u0026#34;https://openapi.alipaydev.com/gateway.do\u0026#34;; private static final String FORMAT = \u0026#34;JSON\u0026#34;; private static final String CHARSET = \u0026#34;UTF-8\u0026#34;; //签名方式 private static final String SIGN_TYPE = \u0026#34;RSA2\u0026#34;; @Resource private AliPayConfig aliPayConfig; @Resource private OrdersMapper ordersMapper; @GetMapping(\u0026#34;/pay\u0026#34;) // \u0026amp;subject=xxx\u0026amp;traceNo=xxx\u0026amp;totalAmount=xxx public void pay(AliPay aliPay, HttpServletResponse httpResponse) throws Exception { // 1. 创建Client，通用SDK提供的Client，负责调用支付宝的API AlipayClient alipayClient = new DefaultAlipayClient(GATEWAY_URL, aliPayConfig.getAppId(), aliPayConfig.getAppPrivateKey(), FORMAT, CHARSET, aliPayConfig.getAlipayPublicKey(), SIGN_TYPE); // 2. 创建 Request并设置Request参数 AlipayTradePagePayRequest request = new AlipayTradePagePayRequest(); // 发送请求的 Request类 request.setNotifyUrl(aliPayConfig.getNotifyUrl()); JSONObject bizContent = new JSONObject(); bizContent.set(\u0026#34;out_trade_no\u0026#34;, aliPay.getTraceNo()); // 我们自己生成的订单编号 bizContent.set(\u0026#34;total_amount\u0026#34;, aliPay.getTotalAmount()); // 订单的总金额 bizContent.set(\u0026#34;subject\u0026#34;, aliPay.getSubject()); // 支付的名称 bizContent.set(\u0026#34;product_code\u0026#34;, \u0026#34;FAST_INSTANT_TRADE_PAY\u0026#34;); // 固定配置 request.setBizContent(bizContent.toString()); // 执行请求，拿到响应的结果，返回给浏览器 String form = \u0026#34;\u0026#34;; try { form = alipayClient.pageExecute(request).getBody(); // 调用SDK生成表单 } catch (AlipayApiException e) { e.printStackTrace(); } httpResponse.setContentType(\u0026#34;text/html;charset=\u0026#34; + CHARSET); httpResponse.getWriter().write(form);// 直接将完整的表单html输出到页面 httpResponse.getWriter().flush(); httpResponse.getWriter().close(); } @PostMapping(\u0026#34;/notify\u0026#34;) // 注意这里必须是POST接口 public String payNotify(HttpServletRequest request) throws Exception { if (request.getParameter(\u0026#34;trade_status\u0026#34;).equals(\u0026#34;TRADE_SUCCESS\u0026#34;)) { System.out.println(\u0026#34;=========支付宝异步回调========\u0026#34;); Map\u0026lt;String, String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, String[]\u0026gt; requestParams = request.getParameterMap(); for (String name : requestParams.keySet()) { params.put(name, request.getParameter(name)); // System.out.println(name + \u0026#34; = \u0026#34; + request.getParameter(name)); } String outTradeNo = params.get(\u0026#34;out_trade_no\u0026#34;); String gmtPayment = params.get(\u0026#34;gmt_payment\u0026#34;); String alipayTradeNo = params.get(\u0026#34;trade_no\u0026#34;); String sign = params.get(\u0026#34;sign\u0026#34;); String content = AlipaySignature.getSignCheckContentV1(params); boolean checkSignature = AlipaySignature.rsa256CheckContent(content, sign, aliPayConfig.getAlipayPublicKey(), \u0026#34;UTF-8\u0026#34;); // 验证签名 // 支付宝验签 if (checkSignature) { // 验签通过 System.out.println(\u0026#34;交易名称: \u0026#34; + params.get(\u0026#34;subject\u0026#34;)); System.out.println(\u0026#34;交易状态: \u0026#34; + params.get(\u0026#34;trade_status\u0026#34;)); System.out.println(\u0026#34;支付宝交易凭证号: \u0026#34; + params.get(\u0026#34;trade_no\u0026#34;)); System.out.println(\u0026#34;商户订单号: \u0026#34; + params.get(\u0026#34;out_trade_no\u0026#34;)); System.out.println(\u0026#34;交易金额: \u0026#34; + params.get(\u0026#34;total_amount\u0026#34;)); System.out.println(\u0026#34;买家在支付宝唯一id: \u0026#34; + params.get(\u0026#34;buyer_id\u0026#34;)); System.out.println(\u0026#34;买家付款时间: \u0026#34; + params.get(\u0026#34;gmt_payment\u0026#34;)); System.out.println(\u0026#34;买家付款金额: \u0026#34; + params.get(\u0026#34;buyer_pay_amount\u0026#34;)); // 查询订单 QueryWrapper\u0026lt;Orders\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(\u0026#34;order_id\u0026#34;, outTradeNo); Orders orders = ordersMapper.selectOne(queryWrapper); if (orders != null) { orders.setAlipayNo(alipayTradeNo); orders.setPayTime(new Date()); orders.setState(\u0026#34;已支付\u0026#34;); ordersMapper.updateById(orders); } } } return \u0026#34;success\u0026#34;; } } 1 http://localhost:15000/alipay/pay?subject=香蕉\u0026amp;traceNo=202208221661165525068\u0026amp;totalAmount=6.99 可以看到这里是502，奇怪，视频上明明是这样做的，上网搜了一下，发现博客每周日中午12点至每周一中午12点沙箱环境进行维护，今天是周日\n官方也说了，请查看 ok，过了时间就可以打开了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 商家信息 商户账号rilvmb5932@sandbox.com 登录密码111111 商户PID2088621987551356 账户余额2132135.00 买家信息 买家账号xesgkm3338@sandbox.com 登录密码111111 支付密码111111 用户UID2088622987164881 用户名称xesgkm3338 证件类型IDENTITY_CARD 证件账号308282195800026310 账户余额99999.00 这里我遇到了一个问题，没有执行回调，我上网查了一下，找到这篇博客，但是我不是这个原因 这个url，复制粘贴到alipay.notifyUrl这里，这个url每次启动都会改变，所以应该更改properties\n","date":"2023-03-27T00:00:00Z","image":"http://localhost:1313/p/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98/202412212138297_hu2482118038820507632.png","permalink":"http://localhost:1313/p/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98/","title":"支付宝沙箱支付"},{"content":"SpringSecurity密码加密存储\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encode = passwordEncoder.encode(user.getPassword()); // 配置加密后的密码 user.setPassword(encode); public static void main(String[] args) { BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encode = passwordEncoder.encode(\u0026#34;123\u0026#34;); String encode1 = passwordEncoder.encode(\u0026#34;123\u0026#34;); boolean matches = passwordEncoder.matches(\u0026#34;123\u0026#34;, encode); //true boolean matches1 = passwordEncoder.matches(\u0026#34;123\u0026#34;, encode1); //true boolean matches2 = passwordEncoder.matches(encode,encode1); //false System.out.println(matches); System.out.println(matches1); System.out.println(matches2); } ","date":"2023-03-26T00:00:00Z","image":"http://localhost:1313/p/springsecurity/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/springsecurity/","title":"SpringSecurity"},{"content":"项目中遇到的问题\r对话框\r之前在网上copy的，现在我自己也找不到人家原创的了，仅此记录 index.js\n1 2 3 4 5 6 7 8 9 10 11 12 // 多行查看box框 export function messageBoxMutiple(content, title, func) { MessageBox.confirm(content, title, { type: \u0026#34;success\u0026#34;, showConfirmButton: false, showCancelButton: false, dangerouslyUseHTMLString: true }).then(function () { func(); }).catch(() =\u0026gt; { }); } 在需要引入的vue组件内引入使用\n1 2 3 4 5 6 7 8 9 10 11 12 // 引入 import {messageBoxMutiple} from \u0026#34;@/utils\u0026#34;; // 使用 var str = \u0026#34;\u0026#34;; var msg = [ `姓名:${this.user.name}`, `性别:${this.user.gender}`, ]; msg.forEach((item) =\u0026gt; { str += `\u0026lt;div\u0026gt;${item}\u0026lt;/div\u0026gt;`; }); messageBoxMutiple(str, \u0026#34;查看用户信息\u0026#34;, function () {}); 第二个，在网上找到的，博客\n这里仅作记录，请前往该博客支持原创\n创建组件Dialog.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;m-dialog-mask\u0026#34; @click.self=\u0026#34;onBlur\u0026#34;\u0026gt; \u0026lt;div :class=\u0026#34;[\u0026#39;m-dialog\u0026#39;, center ? \u0026#39;relative-hv-center\u0026#39; : \u0026#39;top-center\u0026#39;]\u0026#34; :style=\u0026#34;`width: ${dialogWidth}; height: ${dialogHeight};`\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;m-dialog-content\u0026#34; :class=\u0026#34;{loading: loading}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;m-spin-dot\u0026#34; v-show=\u0026#34;loading\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;u-dot-item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;u-dot-item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;u-dot-item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;u-dot-item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;svg @click=\u0026#34;onFullScreen\u0026#34; v-show=\u0026#34;!fullScreen\u0026amp;\u0026amp;switchFullscreen\u0026#34; class=\u0026#34;u-screen\u0026#34; viewBox=\u0026#34;64 64 896 896\u0026#34; data-icon=\u0026#34;fullscreen\u0026#34; aria-hidden=\u0026#34;true\u0026#34; focusable=\u0026#34;false\u0026#34;\u0026gt;\u0026lt;path d=\u0026#34;M290 236.4l43.9-43.9a8.01 8.01 0 0 0-4.7-13.6L169 160c-5.1-.6-9.5 3.7-8.9 8.9L179 329.1c.8 6.6 8.9 9.4 13.6 4.7l43.7-43.7L370 423.7c3.1 3.1 8.2 3.1 11.3 0l42.4-42.3c3.1-3.1 3.1-8.2 0-11.3L290 236.4zm352.7 187.3c3.1 3.1 8.2 3.1 11.3 0l133.7-133.6 43.7 43.7a8.01 8.01 0 0 0 13.6-4.7L863.9 169c.6-5.1-3.7-9.5-8.9-8.9L694.8 179c-6.6.8-9.4 8.9-4.7 13.6l43.9 43.9L600.3 370a8.03 8.03 0 0 0 0 11.3l42.4 42.4zM845 694.9c-.8-6.6-8.9-9.4-13.6-4.7l-43.7 43.7L654 600.3a8.03 8.03 0 0 0-11.3 0l-42.4 42.3a8.03 8.03 0 0 0 0 11.3L734 787.6l-43.9 43.9a8.01 8.01 0 0 0 4.7 13.6L855 864c5.1.6 9.5-3.7 8.9-8.9L845 694.9zm-463.7-94.6a8.03 8.03 0 0 0-11.3 0L236.3 733.9l-43.7-43.7a8.01 8.01 0 0 0-13.6 4.7L160.1 855c-.6 5.1 3.7 9.5 8.9 8.9L329.2 845c6.6-.8 9.4-8.9 4.7-13.6L290 787.6 423.7 654c3.1-3.1 3.1-8.2 0-11.3l-42.4-42.4z\u0026#34;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt; \u0026lt;svg @click=\u0026#34;onFullScreen\u0026#34; v-show=\u0026#34;fullScreen\u0026amp;\u0026amp;switchFullscreen\u0026#34; class=\u0026#34;u-screen\u0026#34; viewBox=\u0026#34;64 64 896 896\u0026#34; data-icon=\u0026#34;fullscreen-exit\u0026#34; aria-hidden=\u0026#34;true\u0026#34; focusable=\u0026#34;false\u0026#34;\u0026gt;\u0026lt;path d=\u0026#34;M391 240.9c-.8-6.6-8.9-9.4-13.6-4.7l-43.7 43.7L200 146.3a8.03 8.03 0 0 0-11.3 0l-42.4 42.3a8.03 8.03 0 0 0 0 11.3L280 333.6l-43.9 43.9a8.01 8.01 0 0 0 4.7 13.6L401 410c5.1.6 9.5-3.7 8.9-8.9L391 240.9zm10.1 373.2L240.8 633c-6.6.8-9.4 8.9-4.7 13.6l43.9 43.9L146.3 824a8.03 8.03 0 0 0 0 11.3l42.4 42.3c3.1 3.1 8.2 3.1 11.3 0L333.7 744l43.7 43.7A8.01 8.01 0 0 0 391 783l18.9-160.1c.6-5.1-3.7-9.4-8.8-8.8zm221.8-204.2L783.2 391c6.6-.8 9.4-8.9 4.7-13.6L744 333.6 877.7 200c3.1-3.1 3.1-8.2 0-11.3l-42.4-42.3a8.03 8.03 0 0 0-11.3 0L690.3 279.9l-43.7-43.7a8.01 8.01 0 0 0-13.6 4.7L614.1 401c-.6 5.2 3.7 9.5 8.8 8.9zM744 690.4l43.9-43.9a8.01 8.01 0 0 0-4.7-13.6L623 614c-5.1-.6-9.5 3.7-8.9 8.9L633 783.1c.8 6.6 8.9 9.4 13.6 4.7l43.7-43.7L824 877.7c3.1 3.1 8.2 3.1 11.3 0l42.4-42.3c3.1-3.1 3.1-8.2 0-11.3L744 690.4z\u0026#34;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt; \u0026lt;svg @click=\u0026#34;onClose\u0026#34; class=\u0026#34;u-close\u0026#34; viewBox=\u0026#34;64 64 896 896\u0026#34; data-icon=\u0026#34;close\u0026#34; aria-hidden=\u0026#34;true\u0026#34; focusable=\u0026#34;false\u0026#34;\u0026gt;\u0026lt;path d=\u0026#34;M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 0 0 203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z\u0026#34;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt; \u0026lt;div class=\u0026#34;m-dialog-header\u0026#34;\u0026gt; \u0026lt;slot name=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;u-head\u0026#34;\u0026gt;{{ title }}\u0026lt;/div\u0026gt; \u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;m-dialog-body\u0026#34; :style=\u0026#34;`height: calc(${dialogHeight} - ${footer ? \u0026#39;158px\u0026#39;:\u0026#39;103px\u0026#39;});`\u0026#34;\u0026gt; \u0026lt;slot\u0026gt;{{ content }}\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;m-dialog-footer\u0026#34; v-show=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;u-cancel\u0026#34; @click=\u0026#34;onCancel\u0026#34;\u0026gt;{{ cancelText }}\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;u-confirm\u0026#34; @click=\u0026#34;onConfirm\u0026#34;\u0026gt;{{ okText }}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;Dialog\u0026#39;, props: { title: { // 标题 string | slot type: String, default: \u0026#39;提示\u0026#39; }, content: { // 内容 string | slot type: String, default: \u0026#39;\u0026#39; }, width: { // 宽度，默认640 type: Number, default: 640 }, height: { // 高度，默认480 type: Number, default: 480 }, switchFullscreen: { // 是否允许切换全屏（允许后右上角会出现一个按钮） type: Boolean, default: false }, cancelText: { // 取消按钮文字 type: String, default: \u0026#39;取消\u0026#39; }, okText: { // 确认按钮文字 type: String, default: \u0026#39;确定\u0026#39; }, footer: { // 是否显示底部按钮，默认显示 type: Boolean, default: true }, center: { // 水平垂直居中：true 固定高度水平居中：false type: Boolean, default: true }, loading: { // 加载中 type: Boolean, default: false } }, data () { return { fullScreen: false } }, computed: { dialogWidth () { if (this.fullScreen) { return \u0026#39;100%\u0026#39; } else { return this.width + \u0026#39;px\u0026#39; } }, dialogHeight () { if (this.fullScreen) { return \u0026#39;100vh\u0026#39; } else { return this.height + \u0026#39;px\u0026#39; } } }, methods: { onBlur () { if (this.loading) { this.$emit(\u0026#39;close\u0026#39;) } }, onFullScreen () { this.fullScreen = !this.fullScreen }, onClose () { this.$emit(\u0026#39;close\u0026#39;) }, onCancel () { this.$emit(\u0026#39;cancel\u0026#39;) }, onConfirm () { this.$emit(\u0026#39;ok\u0026#39;) } } } \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;less\u0026#34; scoped\u0026gt; .flex-hv-center { // 水平垂直居中方法①：弹性布局，随内容增大高度，并自适应水平垂直居中 display: flex; justify-content: center; align-items: center; } .relative-hv-center { // 水平垂直居中方法②：相对定位，随内容增大高度，并自适应水平垂直居中 position: relative; top: 50%; transform: translateY(-50%); -ms-transform: translateY(-50%);; /* IE 9 */ -webkit-transform: translateY(-50%); /* Safari and Chrome */ } .top-center { // 相对定位，固定高度，始终距离视图顶端100px position: relative; top: 100px; } .m-dialog-mask { position: fixed; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%; z-index: 10000; background: rgba(0,0,0,0.45); .m-dialog { margin: 0 auto; transition: all .3s ease; .m-spin-dot { // 绝对定位，并设置水平垂直居中 position: absolute; display: inline-block; right: 0; left: 0; top: 0; bottom: 0; margin: auto; width: 24px; height: 24px; transform: rotate(45deg); -ms-transform: rotate(45deg); /* Internet Explorer */ -moz-transform: rotate(45deg); /* Firefox */ -webkit-transform: rotate(45deg); /* Safari 和 Chrome */ -o-transform: rotate(45deg); /* Opera */ animation: rotate 1.2s linear infinite; -webkit-animation: rotate 1.2s linear infinite; @keyframes rotate { 100% {transform: rotate(405deg);} } .u-dot-item { // 单个圆点样式 position: absolute; width: 8px; height: 8px; background: #1890ff; border-radius: 50%; opacity: .3; animation: spinMove 1s linear infinite alternate; -webkit-animation: spinMove 1s linear infinite alternate; @keyframes spinMove { 100% {opacity: 1;} } } .u-dot-item:first-child { top: 0; left: 0; } .u-dot-item:nth-child(2) { top: 0; right: 0; animation-delay: .4s; -webkit-animation-delay: .4s; } .u-dot-item:nth-child(3) { bottom: 0; right: 0; animation-delay: .8s; -webkit-animation-delay: .8s; } .u-dot-item:last-child { bottom: 0; left: 0; animation-delay: 1.2s; -webkit-animation-delay: 1.2s; } } .loading { // 加载过程背景虚化 background: rgb(248, 248, 248) !important; pointer-events: none; // 屏蔽鼠标事件 } .m-dialog-content { position: relative; background: #fff; border-radius: 4px; box-shadow: 0 4px 12px rgba(0,0,0,.1); .u-screen { .u-close(); right: 64px; } .u-close { width: 16px; height: 16px; position: absolute; top: 19px; right: 24px; fill: rgba(0,0,0,.45); cursor: pointer; transition: fill .3s; \u0026amp;:hover { fill: rgba(0,0,0,.75); } } .m-dialog-header { height: 22px; padding: 16px 24px; color: rgba(0,0,0,.65); border-radius: 4px 4px 0 0; border-bottom: 1px solid #e8e8e8; .u-head { margin: 0; color: rgba(0,0,0,.85); font-weight: 500; font-size: 16px; line-height: 22px; word-wrap: break-word; } } .m-dialog-body { padding: 24px; font-size: 16px; line-height: 1.5; word-wrap: break-word; overflow: auto; transition: all .3s; } .m-dialog-footer { padding: 10px 16px; text-align: right; border-top: 1px solid #e8e8e8; .u-cancel { height: 32px; line-height: 32px; padding: 0 15px; font-size: 16px; border-radius: 4px; color: rgba(0,0,0,.65); background: #fff; border: 1px solid #d9d9d9; cursor: pointer; transition: all .3s cubic-bezier(.645,.045,.355,1); \u0026amp;:hover { color: #40a9ff; border-color: #40a9ff; } \u0026amp;:focus { color: #096dd9; border-color: #096dd9; } } .u-confirm { margin-left: 8px; height: 32px; line-height: 32px; padding: 0 15px; font-size: 16px; border-radius: 4px; background: #1890ff; border: 1px solid #1890ff; color: #fff; transition: all .3s cubic-bezier(.645,.045,.355,1); cursor: pointer; \u0026amp;:hover { color: #fff; background: #40a9ff; border-color: #40a9ff; } \u0026amp;:focus { background: #096dd9; border-color: #096dd9; } } } } } } \u0026lt;/style\u0026gt; 使用Dialog组件弹出对话框 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;Dialog :title=\u0026#34;title\u0026#34; :width=\u0026#34;720\u0026#34; :height=\u0026#34;480\u0026#34; :content=\u0026#34;content\u0026#34; :footer=\u0026#34;footer\u0026#34; cancelText=\u0026#34;取消\u0026#34; okText=\u0026#34;确认\u0026#34; switchFullscreen @close=\u0026#34;onClose\u0026#34; @cancel=\u0026#34;onCancel\u0026#34; @ok=\u0026#34;onConfirm\u0026#34; :center=\u0026#34;center\u0026#34; :loading=\u0026#34;loading\u0026#34; v-show=\u0026#34;visible\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;p class=\u0026#34;u-title\u0026#34;\u0026gt;Title\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;p\u0026gt;Bla bla ...\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Bla bla ...\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Bla bla ...\u0026lt;/p\u0026gt; \u0026lt;/Dialog\u0026gt; import Dialog from \u0026#39;@/components/Dialog\u0026#39; components: { Dialog }, data () { return { visible: false, content: \u0026#39;\u0026#39; } }, methods: { onDialog (content) { // 调用Dialog弹出对话框 this.content = \u0026#39;Some descriptions ...\u0026#39; this.visible = true }, onClose () { // 关闭dialog this.visible = false }, onCancel () { // “取消”按钮回调 this.visible = false }, onConfirm () { // “确定”按钮回调 this.visible = false } } 更改每一行的数据\r在表格内更改每一行的数据\n1 2 3 4 5 6 7 8 9 10 \u0026lt;el-table-column prop=\u0026#34;phone\u0026#34; header-align=\u0026#34;center\u0026#34; align=\u0026#34;center\u0026#34; label=\u0026#34;手机号\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;el-tag type=\u0026#34;info\u0026#34;\u0026gt;{{scope.row.phone}}\u0026lt;/el-tag\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34; @click=\u0026#34;seeDialog(scope.row.phone)\u0026#34;\u0026gt;手机号\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; 选择器\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;el-form-item label=\u0026#34;用户类型\u0026#34; prop=\u0026#34;gender\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;dataForm.gender\u0026#34; placeholder=\u0026#34;请选择接种人性别\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in options\u0026#34; :key=\u0026#34;item.value\u0026#34; :label=\u0026#34;item.label\u0026#34; :value=\u0026#34;item.value\u0026#34;\u0026gt; \u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;!-- data --\u0026gt; options:[{ value:\u0026#34;1\u0026#34;, label:\u0026#34;男\u0026#34; }, { value:\u0026#34;0\u0026#34;, label:\u0026#34;女\u0026#34; }], Can\u0026rsquo;t resolve \u0026rsquo;less-loader'\r1 2 3 4 5 6 // 安装 npm install --save-dev less-loader less // 若继续报错 // UnhandledPromiseRejectionWarning: TypeError: loaderContext.getResolve is not … // 执行以下命令，在版本位置处选择合适的版本 npm install less-loader@5.0.0 -D 修改store内的数据\r1 2 3 this.$store.dispatch(\u0026#39;asyncUpdateUser\u0026#39;,{ email:this.email }) ","date":"2023-03-26T00:00:00Z","image":"http://localhost:1313/p/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","title":"Vue项目中遇到的问题"},{"content":"Hbuilder配置\r关闭更新提示\r工具 设置 常用配置（拉到最下面） 运行到谷歌浏览器失败\r链接：https://pan.baidu.com/s/178gTB9MOQXGMaC_m7QXFdQ?pwd=1234 提取码：1234\n","date":"2023-03-25T00:00:00Z","image":"http://localhost:1313/p/hbuilder%E9%85%8D%E7%BD%AE/202412211333217_hu9375312175773522084.png","permalink":"http://localhost:1313/p/hbuilder%E9%85%8D%E7%BD%AE/","title":"Hbuilder"},{"content":"Servlet\r项目创建\r删掉pom.xml\n点击运行即可\n因为没有页面\n在WEB-INF下新建lib包，在lib下存放jar包\n此时依赖还没完全导入，还需如下操作\n选择lib，此时就算导入成功了\n网上copy一个jdbc的工具包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 package com.example.util; import org.apache.commons.beanutils.BeanUtils; import java.lang.reflect.Field; import java.sql.*; import java.util.ArrayList; import java.util.List; public class JDBCUtil { //1.加载驱动 static { try { Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } } //2.获取连接 public static Connection getConnection() { Connection conn = null; try { conn = DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/xiaoy\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;mysql\u0026#34;); } catch (SQLException e) { e.printStackTrace(); } return conn; } //3.关闭连接 public static void close(Connection conn, Statement st, ResultSet rs) { //关闭连接 if (conn != null) { try { conn.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } //关闭statement if (st != null) { try { st.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } //关闭结果集 if (rs != null) { try { rs.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } //-------------------------------封装sql操作------------------------------ //查询返回List集合 public static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; getList(Class\u0026lt;T\u0026gt; cls, String sql, Object... obj) { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { //1.获取连接 conn = getConnection(); //2.获取预处理对象 ps = conn.prepareStatement(sql); //循环参数，如果没有就不走这里 for (int i = 1; i \u0026lt;= obj.length; i++) { //注意：数组下标从0开始，预处理参数设置从1开始 ps.setObject(i, obj[i - 1]); } //3.执行SQL语句 System.out.println(sql); rs = ps.executeQuery(); //4.遍历结果集 //遍历之前准备：因为封装不知道未来会查询多少列，所以我们需要指定有多少列 //获取ResultSet对象的列编号、类型和属性 ResultSetMetaData date = rs.getMetaData(); //获取列数 int column = date.getColumnCount(); //获取本类所有的属性 Field[] fields = cls.getDeclaredFields(); //创建一个list集合对象来存储查询数据 List\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); //开始遍历结果集 while (rs.next()) { //创建类类型实例 T t = cls.newInstance(); for (int i = 1; i \u0026lt;= column; i++) { //每一列的值 Object value = rs.getObject(i); /** *String columnName = date.getColumnName(i);//获取每一列名称 * 关于获取每一列名称，如果列取了别名的话，则不能用上面的方法取列的名称 * 用下面的方法 */ String columnName = date.getColumnLabel(i);//获取每一列名称（别名） //遍历所有属性对象 for (Field field : fields) { //获取属性名 String name = field.getName(); field.setAccessible(true);//打破封装，忽略对封装修饰符的检测 /*if (name.equals(columnName)) { //获取列类型名称 String string = date.getColumnTypeName(i); //如果列类型是Date类型，转换成字符串表现形式 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;); String d = sdf.format(value); //赋值：将数据库中查询的字段赋值给对应名称的属性 field.set(t, d); }else{ field.set(t, value); }*/ if (name.equals(columnName)) { BeanUtils.copyProperty(t, name, value); break;//增加效率，避免不必要的循环 } } } list.add(t); } return list; //5.关闭连接 } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtil.close(conn, ps, rs); } return null; } /** * 增加、删除、修改 * * @param sql sql语句 * @param obj 参数 */ public static boolean getDML(String sql, Object... obj) { Connection conn = null; PreparedStatement ps = null; try { conn = getConnection(); ps = conn.prepareStatement(sql); for (int i = 1; i \u0026lt;= obj.length; i++) { ps.setObject(i, obj[i - 1]); } System.out.println(sql); int update = ps.executeUpdate(); if (update \u0026gt; 0) { return true; } } catch (Exception e) { e.printStackTrace(); } finally { close(conn, ps, null); } return false; } //查询返回单个对象 public static \u0026lt;T\u0026gt; T getOneObject(Class\u0026lt;T\u0026gt; cls, String sql, Object... obj) { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { //1.获取连接 conn = getConnection(); //2.获取预处理对象 ps = conn.prepareStatement(sql); //循环参数，如果没有就不走这里 for (int i = 1; i \u0026lt;= obj.length; i++) { //注意：数组下标从0开始，预处理参数设置从1开始 ps.setObject(i, obj[i - 1]); } //3.执行SQL语句 System.out.println(sql); rs = ps.executeQuery(); //4.遍历结果集 //遍历之前准备：因为封装不知道未来会查询多少列，所以我们需要指定有多少列 //获取ResultSet对象的列编号、类型和属性 ResultSetMetaData date = rs.getMetaData(); //获取列数 int column = date.getColumnCount(); //获取本类所有的属性 Field[] fields = cls.getDeclaredFields(); //开始遍历结果集 if (rs.next()) { //创建类类型实例 T t = cls.newInstance(); for (int i = 1; i \u0026lt;= column; i++) { //每一列的值 Object value = rs.getObject(i); //获取每一列名称 String columnName = date.getColumnName(i); //遍历所有属性对象 for (Field field : fields) { //获取属性名 String name = field.getName(); //打破封装，忽略对封装修饰符的检测 field.setAccessible(true); if (name.equals(columnName)) { BeanUtils.copyProperty(t, name, value); } } } return t; } //5.关闭连接 } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtil.close(conn, ps, rs); } return null; } //查询总记录数 public static Integer getCount(String sql, Object... obj) { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { //1.获取连接 conn = getConnection(); //2.获取预处理对象 ps = conn.prepareStatement(sql); //循环参数，如果没有就不走这里 for (int i = 1; i \u0026lt;= obj.length; i++) { //注意：数组下标从0开始，预处理参数设置从1开始 ps.setObject(i, obj[i - 1]); } //3.执行SQL语句 System.out.println(sql); rs = ps.executeQuery(); //开始遍历结果集 if (rs.next()) { return rs.getInt(1); } //5.关闭连接 } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtil.close(conn, ps, rs); } return null; } } BeanUtils需要导包，commons-beanutils-1.9.4.jar\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-beanutils\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-beanutils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 如果需要连接oracle，则jdbcUtil需要改改配置\n导入jquery，使用ajax，下载网址\n配置webservlet\n我这里@WebServlet注解爆红，导入javax.servlet-api-3.1.0.jar包后解决 看到有博客说servlet.jar也可以，不过我就导入了javax.servlet-api-3.1.0.jar就已解决\n注释掉SubHandle内的super.doPost(req, resp);即可，记得重启服务\n前端之前一直接受不到数据\r既不执行success也不执行error，是因为后端的返回格式不是json\n","date":"2023-03-24T00:00:00Z","image":"http://localhost:1313/p/jsp/202412211853801_hu17419495927518905628.png","permalink":"http://localhost:1313/p/jsp/","title":"Jsp"},{"content":"创建Vue项目\rVue脚手架的安装与卸载\r安装、卸载vue-cli2命令\n1 2 npm install vue-cli -g npm uninstall vue-cli -g 安装、卸载vue-cli3命令\n1 2 npm install @vue/cli -g npm uninstall @vue/cli -g Vue项目创建\r1 2 # 创建一个名为demo-vue的项目 vue create demo-vue Element-UI\r1 2 3 4 5 6 7 8 9 10 11 12 13 # 安装 # npm i element-ui -S vue add element # 引入Element import Vue from \u0026#39;vue\u0026#39;; import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; Vue.use(ElementUI); new Vue({ el: \u0026#39;#app\u0026#39;, render: h =\u0026gt; h(App) }); axios\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 npm install axios -s // 配置request.js------------------------- import axios from \u0026#39;axios\u0026#39; const request = axios.create({ // baseURL: \u0026#39;/api\u0026#39;, // 注意！！ 这里是全局统一加上了 \u0026#39;/api\u0026#39; 前缀，也就是说所有接口都会加上\u0026#39;/api\u0026#39;前缀在，页面里面写接口的时候就不要加 \u0026#39;/api\u0026#39;了，否则会出现2个\u0026#39;/api\u0026#39;，类似 \u0026#39;/api/api/user\u0026#39;这样的报错，切记！！！ timeout: 5000 }) // request 拦截器 // 可以自请求发送前对请求做一些处理 // 比如统一加token，对请求参数统一加密 request.interceptors.request.use(config =\u0026gt; { config.headers[\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/json;charset=utf-8\u0026#39;; // config.headers[\u0026#39;token\u0026#39;] = user.token; // 设置请求头 return config }, error =\u0026gt; { return Promise.reject(error) }); // response 拦截器 // 可以在接口响应后统一处理结果 request.interceptors.response.use( response =\u0026gt; { let res = response.data; // 如果是返回的文件 if (response.config.responseType === \u0026#39;blob\u0026#39;) { return res } // 兼容服务端返回的字符串数据 if (typeof res === \u0026#39;string\u0026#39;) { res = res ? JSON.parse(res) : res } return res; }, error =\u0026gt; { console.log(\u0026#39;err\u0026#39; + error) // for debug return Promise.reject(error) } ) export default request // 配置vue.config.js------------------------------------ // 跨域配置 module.exports = { devServer: { //记住，别写错了devServer//设置本地默认端口 选填 port: 9876, proxy: { //设置代理，必须填 \u0026#39;/api\u0026#39;: { //设置拦截器 拦截器格式 斜杠+拦截器名字，名字可以自己定 target: \u0026#39;http://localhost:9999\u0026#39;, //代理的目标地址 changeOrigin: true, //是否设置同源，输入是的 pathRewrite: { //路径重写 \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; //选择忽略拦截器里面的内容 } } } } } qs\r1 2 3 4 npm install qs // 在main.js中配置 import qs from \u0026#39;qs\u0026#39; Vue.prototype.qs=qs vue-cookie\r1 2 npm install vue-cookie --save // main.js lodash\r1 2 npm i -save lodash // 全局安装 import cloneDeep from \u0026#39;lodash/cloneDeep\u0026#39; mockjs\r1 npm install mockjs -D vuex-persistedstate\r参考博客1 参考博客2\n1 npm i vuex-persistedstate --save ","date":"2023-03-22T00:00:00Z","image":"http://localhost:1313/p/%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/","title":"创建Vue项目"},{"content":"MyBatis\r使用以下sql新建表(我使用的是oracle数据库，而非mysql)\n使用之前提过的自动生成方式生成对应的实体类和mapper\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 -- 创建用户表 create table tb_people ( id varchar2(50) primary key, name varchar2(30), gender number(1), age number(3) check ( age \u0026gt; 0 ) ); -- 创建手机表 create table tb_phone ( id varchar2(50) primary key, name varchar2(20), brand varchar2(20), price number(10, 2) ); -- 创建 用户-手机详情表 create table tb_people_phone_detail ( people_id varchar2(50), phone_id varchar2(50), primary key (people_id, phone_id) ); commit; select * from tb_people; select * from tb_phone; select * from tb_people_phone_detail; -- 添加表注释 comment on table tb_people is \u0026#39;用户表\u0026#39;; comment on table tb_phone is \u0026#39;手机表\u0026#39;; comment on table tb_people_phone_detail is \u0026#39;用户-手机详情表\u0026#39;; -- 添加字段注释 comment on column tb_people.id is \u0026#39;用户主键\u0026#39;; comment on column tb_people.name is \u0026#39;用户姓名\u0026#39;; comment on column tb_people.gender is \u0026#39;用户性别\u0026#39;; comment on column tb_people.age is \u0026#39;用户年龄\u0026#39;; comment on column tb_phone.id is \u0026#39;手机主键\u0026#39;; comment on column tb_phone.name is \u0026#39;手机名称\u0026#39;; comment on column tb_phone.brand is \u0026#39;手机品牌\u0026#39;; comment on column tb_phone.price is \u0026#39;手机价格\u0026#39;; comment on column tb_people_phone_detail.people_id is \u0026#39;用户主键\u0026#39;; comment on column tb_people_phone_detail.phone_id is \u0026#39;手机主键\u0026#39;; 添加依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--oracle--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.database.jdbc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ojdbc6\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;11.2.0.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--log4j--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- hutool --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.15\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 # 数据库驱动： jdbc.driver=oracle.jdbc.driver.OracleDriver # 数据库连接地址 jdbc.url=jdbc:oracle:thin:@localhost:1521:orcl # 数据库用户名\u0026amp;密码： jdbc.username=root jdbc.password=123456 1 2 3 4 5 6 7 8 9 10 11 12 # 控制台打印 log4j.rootLogger=debug, stdout log4j.logger.org.mybatis.example.BlogMapper=TRACE log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n # 输出到文件 log4j.appender.file=org.apache.log4j.ConsoleAppender log4j.appender.file.File=C:\\Users\\tong\\Desktop\\log4j log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--设置文件所在路径--\u0026gt; \u0026lt;properties resource=\u0026#34;jdbc.properties\u0026#34;/\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!-- 打印sql日志 --\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;!--别名配置--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.example.domain\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;!--指定包--\u0026gt; \u0026lt;package name=\u0026#34;com.example.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class ApplicationTest { private SqlSession session; @Before public void init() throws IOException { String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); session=sqlSessionFactory.openSession(); } @After public void destory(){ // 提交事务，并释放资源 session.commit(); session.close(); } } #{}和${}的区别\r如果使用#{}，他是预编译的sq可以防止SQL注入攻击 如果使用${}，他是直接把参数值拿来进行拼接，这样会有SQL注入的危险 SQL片段抽取\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.example.mapper.PeopleMapper\u0026#34;\u0026gt; \u0026lt;resultMap id=\u0026#34;BaseResultMap\u0026#34; type=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;ID\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;NAME\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;GENDER\u0026#34; jdbcType=\u0026#34;DECIMAL\u0026#34; property=\u0026#34;gender\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;AGE\u0026#34; jdbcType=\u0026#34;DECIMAL\u0026#34; property=\u0026#34;age\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;sql id=\u0026#34;Base_Column_List\u0026#34;\u0026gt; ID , NAME, GENDER, AGE \u0026lt;/sql\u0026gt; \u0026lt;!-- 查询全部用户 --\u0026gt; \u0026lt;select id=\u0026#34;selectPeople\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from tb_people \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; mapper.xml 标签\rif trim where set foreach choose if\n1 2 3 4 5 6 7 8 9 \u0026lt;select id=\u0026#34;selectPeople\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from tb_people where id = #{id} \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; and name = #{name} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; trim\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- 清除前缀 --\u0026gt; \u0026lt;select id=\u0026#34;selectPeople\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from tb_people \u0026lt;trim prefixOverrides=\u0026#34;and|or\u0026#34;\u0026gt; and \u0026lt;/trim\u0026gt; \u0026lt;/select\u0026gt; 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 清除后缀 --\u0026gt; \u0026lt;select id=\u0026#34;selectPeople\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from tb_people \u0026lt;trim suffixOverrides=\u0026#34;like\u0026#34;\u0026gt; where 1=1 like \u0026lt;/trim\u0026gt; \u0026lt;/select\u0026gt; 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 添加前缀 --\u0026gt; \u0026lt;select id=\u0026#34;selectPeople\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from tb_people \u0026lt;trim prefix=\u0026#34;where\u0026#34;\u0026gt; 1=1 \u0026lt;/trim\u0026gt; \u0026lt;/select\u0026gt; 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 添加后缀 --\u0026gt; \u0026lt;select id=\u0026#34;selectPeople\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from tb_people \u0026lt;trim prefix=\u0026#34;1=1\u0026#34;\u0026gt; where \u0026lt;/trim\u0026gt; \u0026lt;/select\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!-- 综合使用 --\u0026gt; \u0026lt;select id=\u0026#34;selectPeople\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from tb_people \u0026lt;trim prefix=\u0026#34;where\u0026#34; prefixOverrides=\u0026#34;and|or\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;id!=null\u0026#34;\u0026gt; id = #{id} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; and name = #{name} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;/select\u0026gt; where\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!--where 标签等价于 trim prefix=\u0026#34;where\u0026#34; prefixOverrides=\u0026#34;and|or\u0026#34;--\u0026gt; \u0026lt;select id=\u0026#34;selectPeople\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from tb_people \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;id!=null\u0026#34;\u0026gt; and id = #{id} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; and name = #{name} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; set\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- set 标签等价于 trim prefix=\u0026#34;set\u0026#34; suffixOverrides=\u0026#34;,\u0026#34; --\u0026gt; \u0026lt;update id=\u0026#34;updatePeople\u0026#34;\u0026gt; update people \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name = #{name}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!=null\u0026#34;\u0026gt; gender = #{gender}, \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt; foreach\n1 select * from people where id in (?,?,?,?); 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--ids 为接口内接收的参数名称--\u0026gt; \u0026lt;select id=\u0026#34;selectPeople\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from tb_people \u0026lt;where\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; open=\u0026#34;id in (\u0026#34; close=\u0026#34;)\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; choose\n类似于java的switch、case、default\n如果id不为空，则通过id查询 如果id为空，名称不为空，则通过名称查询 如果id和名称都为空，则查询id为3的用户 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;select id=\u0026#34;selectPeople\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from tb_people \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;id!=null\u0026#34;\u0026gt; id = #{id} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;name!=null\u0026#34;\u0026gt; name = #{name} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; id = 3 \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 字段映射问题\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 先插入几条数据 @Test public void addPeople(){ PeopleMapper peopleMapper=session.getMapper(PeopleMapper.class); peopleMapper.insert(new People(IdUtil.simpleUUID(),\u0026#34;李华\u0026#34;,1,15)); peopleMapper.insert(new People(IdUtil.simpleUUID(),\u0026#34;张三\u0026#34;,1,25)); peopleMapper.insert(new People(IdUtil.simpleUUID(),\u0026#34;王大锤\u0026#34;,1,26)); peopleMapper.insert(new People(IdUtil.simpleUUID(),\u0026#34;翠花\u0026#34;,0,18)); } @Test public void addPhone(){ PhoneMapper phoneMapper = session.getMapper(PhoneMapper.class); phoneMapper.insert(new Phone(IdUtil.simpleUUID(),\u0026#34;k30\u0026#34;,\u0026#34;红米\u0026#34;,BigDecimal.valueOf(3000))); phoneMapper.insert(new Phone(IdUtil.simpleUUID(),\u0026#34;note 11t\u0026#34;,\u0026#34;红米\u0026#34;,BigDecimal.valueOf(4000))); phoneMapper.insert(new Phone(IdUtil.simpleUUID(),\u0026#34;mate 50\u0026#34;,\u0026#34;华为\u0026#34;,BigDecimal.valueOf(5000))); } @Test public void addPeoplePhoneDetail(){ PeoplePhoneDetailMapper peoplePhoneDetailMapper=session.getMapper(PeoplePhoneDetailMapper.class); peoplePhoneDetailMapper.insert(new PeoplePhoneDetail(\u0026#34;b0e11aed0db6412ebf342dc9676b5ba6\u0026#34;,\u0026#34;1cff22c9409c44fd8524ea9c4d6e3385\u0026#34;)); peoplePhoneDetailMapper.insert(new PeoplePhoneDetail(\u0026#34;b0e11aed0db6412ebf342dc9676b5ba6\u0026#34;,\u0026#34;639153d49e0d4d33af43e4d4534b1631\u0026#34;)); peoplePhoneDetailMapper.insert(new PeoplePhoneDetail(\u0026#34;6f226961637346ec82499567122e00ea\u0026#34;,\u0026#34;2b1edb7c93f04d7d91fc8200378a2c94\u0026#34;)); peoplePhoneDetailMapper.insert(new PeoplePhoneDetail(\u0026#34;672b002417de41d184d7d14f31660e9f\u0026#34;,\u0026#34;639153d49e0d4d33af43e4d4534b1631\u0026#34;)); peoplePhoneDetailMapper.insert(new PeoplePhoneDetail(\u0026#34;de32b418f26e475aa68ef2f692e58cb6\u0026#34;,\u0026#34;1cff22c9409c44fd8524ea9c4d6e3385\u0026#34;)); } 如 数据库 people_id 字段无法映射到 java 里peopleId，即驼峰命名法 解决方法1：在mybatis里开启驼峰命名的自动映射\n1 2 3 4 5 6 \u0026lt;settings \u0026lt;!-- 打印sql日志 --\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;!-- 配置驼峰映射 --\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 解决方法2：在sql里配置别名\n1 select people_id peopleId,phone_id phoneId from tb_people_phone_detail 解决方法3：自定义映射规则(继承映射规则) 问题 正确展示 多表查询\n一对一\r可以看到这是一个一对多的关系，但是就以张三作为演示，张三的关系是一对一的\n首先需要明确通过什么来查什么？\n我们现在需要通过使用者来查询他的手机，所以需要在使用者的属性里新建一个手机\n别忘了生成对应属性的get、set等方法哦 关联查询\r先测试一下sql是否正确\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 select tb_people.id \u0026#34;id\u0026#34;, tb_people.name \u0026#34;name\u0026#34;, tb_people.gender \u0026#34;gender\u0026#34;, tb_people.age \u0026#34;age\u0026#34;, tb_phone.id \u0026#34;phone_id\u0026#34;, tb_phone.name \u0026#34;phone_name\u0026#34;, tb_phone.brand \u0026#34;phone_brand\u0026#34;, tb_phone.price \u0026#34;phone_price\u0026#34; from tb_people, tb_people_phone_detail, tb_phone where tb_people.id = tb_people_phone_detail.people_id(+) and tb_people_phone_detail.phone_id = tb_phone.id(+) and tb_people.id = \u0026#39;6f226961637346ec82499567122e00ea\u0026#39; 写法1 写法2 以上两种写法都能查询到结果 一对多\r接下来测试一对多，将Phone phone 改成List\u0026lt;Phone\u0026gt; phones 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.example.mapper.PeopleMapper\u0026#34;\u0026gt; \u0026lt;resultMap id=\u0026#34;BaseResultMap\u0026#34; type=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;ID\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;NAME\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;GENDER\u0026#34; jdbcType=\u0026#34;DECIMAL\u0026#34; property=\u0026#34;gender\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;AGE\u0026#34; jdbcType=\u0026#34;DECIMAL\u0026#34; property=\u0026#34;age\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;sql id=\u0026#34;Base_Column_List\u0026#34;\u0026gt; ID , NAME, GENDER, AGE \u0026lt;/sql\u0026gt; \u0026lt;resultMap id=\u0026#34;PeoplePhonesResultMap\u0026#34; type=\u0026#34;com.example.domain.People\u0026#34; extends=\u0026#34;BaseResultMap\u0026#34;\u0026gt; \u0026lt;collection property=\u0026#34;phones\u0026#34; ofType=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;phone_id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;phone_name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;phone_brand\u0026#34; property=\u0026#34;brand\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;phone_price\u0026#34; property=\u0026#34;price\u0026#34;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 根据用户id查询 --\u0026gt; \u0026lt;select id=\u0026#34;selectPeopleWithPhones\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select tb_people.id \u0026#34;id\u0026#34;, tb_people.name \u0026#34;name\u0026#34;, tb_people.gender \u0026#34;gender\u0026#34;, tb_people.age \u0026#34;age\u0026#34;, tb_phone.id \u0026#34;phone_id\u0026#34;, tb_phone.name \u0026#34;phone_name\u0026#34;, tb_phone.brand \u0026#34;phone_brand\u0026#34;, tb_phone.price \u0026#34;phone_price\u0026#34; from tb_people, tb_people_phone_detail, tb_phone where tb_people.id = tb_people_phone_detail.people_id(+) and tb_people_phone_detail.phone_id = tb_phone.id(+) and tb_people.id = #{id} \u0026lt;/select\u0026gt; \u0026lt;!-- 查询全部用户 --\u0026gt; \u0026lt;select id=\u0026#34;selectPeople\u0026#34; resultType=\u0026#34;com.example.domain.People\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from tb_people \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 分步查询\r分布查询也可以完成以上操作\n我们分为两个select操作\n查找到对应的手机id(可能是多部) 根据手机id查找到对应的手机 在方法上右键，选择copy reference 将id作为参数传给findRoleByUserId方法 查看打印的日志 可以看到执行了两个sql 分布查询里的按需加载\n这里我们只打印输出了人的id，并没有涉及到手机的信息，所以只执行了一个sql语句 分页查询\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--oracle--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.database.jdbc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ojdbc6\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;11.2.0.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--log4j--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--hutool--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.15\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--pagehelper--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; pagehelper的版本不要太高，否则匹配会出现问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Test public void test2(){ PeopleMapper peopleMapper = session.getMapper(PeopleMapper.class); // 设置分页查询参数 PageHelper.startPage(1,2); List\u0026lt;People\u0026gt; peopleList = peopleMapper.selectPeople(); PageInfo\u0026lt;People\u0026gt; pageInfo = new PageInfo\u0026lt;\u0026gt;(peopleList); // 总条数 long total = pageInfo.getTotal(); // 总页数 int pages = pageInfo.getPages(); // 当前页 int pageNum = pageInfo.getPageNum(); // 每页显示长度 int pageSize = pageInfo.getPageSize(); System.out.println(\u0026#34;总条数:\u0026#34;+total); System.out.println(\u0026#34;总页数:\u0026#34;+pages); System.out.println(\u0026#34;当前页:\u0026#34;+pageNum); System.out.println(\u0026#34;每页显示长度:\u0026#34;+pageSize); } 分页查询可能出现的问题\r在一对多的多表查询中，pagehelper可能会出现数据显示不全的问题，这种情况使用分布查询即可解决 MyBatis缓存\n一级缓存\r一级缓存是默认开启的 几种不会使用一级缓存的情况\n调用相同方法但是传入的参数不同 调用相同方法参数也相同，但是使用的是另外一个SqISession 如果查询完后，对同一个表进行了增，删改的操作，都会清空这sqlSession上的缓存 如果手动调用SqlSession的clearCache方法清除缓存了，后面也使用不了缓存 二级缓存\r注意:只有close或者commit后的数据才会进入二级缓存。\n开启二级缓存\r全局开启\n在mybatis配置文件中配置\n1 2 3 \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 局部开启\n在mapper.xml里配置cache标签\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.example.mapper.PeopleMapper\u0026#34;\u0026gt; \u0026lt;cache/\u0026gt; \u0026lt;/mapper\u0026gt; 需要注意的问题\r一般不用二级缓存，一级缓存是session级，而二级缓存是mapper级，即便是一个新的sqlSession，也可以获取到之前缓存里的数据，可能导致数据更改后未更新的情况\nmapper里的注释不要写在sql里\n","date":"2023-03-19T00:00:00Z","image":"http://localhost:1313/p/mybatis/mybatis-logo_hu1721408179241078439.png","permalink":"http://localhost:1313/p/mybatis/","title":"MyBatis"},{"content":"SpringMVC\rspring-mvc.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- SpringMVC只扫描controller包即可 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.example.controller\u0026#34;/\u0026gt; \u0026lt;!-- 解决静态资源访问问题，如果不加mvc:annotation-driven会导致无法访问handler--\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;!--解决响应乱码--\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; \u0026lt;/beans\u0026gt; web.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;DispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!-- 为DispatcherServlet提供初始化参数的 设置springmvc配置文件的路径 name是固定的，必须是contextConfigLocation value指的是SpringMVC配置文件的位置 --\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:spring-mvc.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!-- 指定项目启动就初始化DispatcherServlet --\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;DispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- / 表示当前servlet映射除jsp之外的所有请求（包含静态资源） *.do 表示.do结尾的请求路径才能被SpringMVC处理(老项目会出现) /* 表示当前servlet映射所有请求（包含静态资源,jsp），不应该使用其配置DispatcherServlet --\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!--乱码处理过滤器，由SpringMVC提供--\u0026gt; \u0026lt;!-- 处理post请求乱码 --\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;!-- name固定不变，value值根据需要设置 --\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;!-- 所有请求都设置utf-8的编码 --\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt; pom.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--不能漏--\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--servlet依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--jsp依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--springmvc依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.15.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--jackson--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- \u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;groupId\u0026gt;org.apache.tomcat.maven\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;artifactId\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;configuration\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;port\u0026gt;8000\u0026lt;/port\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;path\u0026gt;/\u0026lt;/path\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;uriEncoding\u0026gt;utf-8\u0026lt;/uriEncoding\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;/configuration\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 指定请求参数\r必须有code参数\n1 2 3 4 5 6 7 8 9 @Controller @RequestMapping(\u0026#34;/test\u0026#34;) public class TestController { @RequestMapping(value = \u0026#34;/testParams\u0026#34;,method = RequestMethod.GET,params = \u0026#34;code\u0026#34;) public String testParams(){ System.out.println(\u0026#34;testParams处理了请求\u0026#34;); return \u0026#34;/success.jsp\u0026#34;; } } 不能有code参数\n1 2 3 4 5 6 7 8 9 @Controller @RequestMapping(\u0026#34;/test\u0026#34;) public class TestController { @RequestMapping(value = \u0026#34;/testParams\u0026#34;,method = RequestMethod.GET,params = \u0026#34;!code\u0026#34;) public String testParams(){ System.out.println(\u0026#34;testParams处理了请求\u0026#34;); return \u0026#34;/success.jsp\u0026#34;; } } code参数必须是某个值\n1 2 3 4 5 6 7 8 9 @Controller @RequestMapping(\u0026#34;/test\u0026#34;) public class TestController { @RequestMapping(value = \u0026#34;/testParams\u0026#34;,method = RequestMethod.GET,params = \u0026#34;code=sgct\u0026#34;) public String testParams(){ System.out.println(\u0026#34;testParams处理了请求\u0026#34;); return \u0026#34;/success.jsp\u0026#34;; } } code参数参数必须不是某个值\n1 2 3 4 5 6 7 8 9 @Controller @RequestMapping(\u0026#34;/test\u0026#34;) public class TestController { @RequestMapping(value = \u0026#34;/testParams\u0026#34;,method = RequestMethod.GET,params = \u0026#34;code!=sgct\u0026#34;) public String testParams(){ System.out.println(\u0026#34;testParams处理了请求\u0026#34;); return \u0026#34;/success.jsp\u0026#34;; } } 指定请求头\r请求头必须有deviceType\n1 2 3 4 5 6 7 8 9 10 @Controller @RequestMapping(\u0026#34;/test\u0026#34;) public class TestController { @RequestMapping(value = \u0026#34;/testHeaders\u0026#34;,method = RequestMethod.GET,headers = \u0026#34;deviceType\u0026#34;) public String testHeaders(){ System.out.println(\u0026#34;testHeaders处理了请求\u0026#34;); return \u0026#34;/success.jsp\u0026#34;; } } 请求头不能有deviceType\n1 2 3 4 5 6 7 8 9 10 @Controller @RequestMapping(\u0026#34;/test\u0026#34;) public class TestController { @RequestMapping(value = \u0026#34;/testHeaders\u0026#34;,method = RequestMethod.GET,headers = \u0026#34;!deviceType\u0026#34;) public String testHeaders(){ System.out.println(\u0026#34;testHeaders处理了请求\u0026#34;); return \u0026#34;/success.jsp\u0026#34;; } } 请求头中的deviceType必须为aaa\n1 2 3 4 5 6 7 8 9 10 @Controller @RequestMapping(\u0026#34;/test\u0026#34;) public class TestController { @RequestMapping(value = \u0026#34;/testHeaders\u0026#34;,method = RequestMethod.GET,headers = \u0026#34;deviceType=aaa\u0026#34;) public String testHeaders(){ System.out.println(\u0026#34;testHeaders处理了请求\u0026#34;); return \u0026#34;/success.jsp\u0026#34;; } } 请求头中的deviceType不能是aaa\n1 2 3 4 5 6 7 8 9 10 @Controller @RequestMapping(\u0026#34;/test\u0026#34;) public class TestController { @RequestMapping(value = \u0026#34;/testHeaders\u0026#34;,method = RequestMethod.GET,headers = \u0026#34;deviceType!=aaa\u0026#34;) public String testHeaders(){ System.out.println(\u0026#34;testHeaders处理了请求\u0026#34;); return \u0026#34;/success.jsp\u0026#34;; } } 常用注解\rPathVariable RequestBody RequestParam required\r@RequestParam(value = “id”,required = false) 代表是否必须，默认值为true也就是必须要有对应的参数。如果没有就会报错。 如果对应的参数可传可不传则可以把去设置为fasle 例如：\n1 2 3 4 5 6 7 @RequestMapping(\u0026#34;/testRquestParam\u0026#34;) public String testRquestParam(@RequestParam(value = \u0026#34;id\u0026#34;,required = false) Integer uid,@RequestParam(\u0026#34;name\u0026#34;) String name, @RequestParam(\u0026#34;likes\u0026#34;)String[] likes){ System.out.println(\u0026#34;testRquestParam\u0026#34;); System.out.println(uid); System.out.println(name); return \u0026#34;/success.jsp\u0026#34;; } @RequestParam(value = “id”,required = false,defaultValue = “777”)\ndefaultValue\r如果对应的参数没有，我们可以用defaultValue属性设置默认值。 例如：\n1 2 3 4 5 6 @RequestMapping(\u0026#34;/testRquestParam\u0026#34;) public String testRquestParam(@RequestParam(value = \u0026#34;id\u0026#34;,required = false,defaultValue = \u0026#34;777\u0026#34;) Integer uid,@RequestParam(\u0026#34;name\u0026#34;) String name, @RequestParam(\u0026#34;likes\u0026#34;)String[] likes){ System.out.println(uid); System.out.println(name); return \u0026#34;/success.jsp\u0026#34;; } ","date":"2023-03-19T00:00:00Z","image":"http://localhost:1313/p/springmvc/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/springmvc/","title":"SpringMVC"},{"content":"AOT学习\rAOT学习\r选自 尚硅谷Spring6教程\nJIT\rjust in time，动态编译(实时编译)，边运行边编译\n在程序运行时候，动态生成代码\n启动时比较慢，编译时需要占用运行时候资源\n总结：程序运行过程中，把字节码转换成硬盘上直接运行的机器码，部署到环境的过程\nAOT\rahead of time，运行前编译，提前编译\n可以把源代码直接转换成机器码，启动快，内存占用低\n缺点:运行时不能优化，程序安装时间过长\n总结：在程序运行之前，就把字节码转换成机器码\n11.1.1、JIT与AOT的区别\rJIT和AOT 这个名词是指两种不同的编译方式，这两种编译方式的主要区别在于是否在“运行时”进行编译 （1）JIT， Just-in-time,动态(即时)编译，边运行边编译； 在程序运行时，根据算法计算出热点代码，然后进行 JIT 实时编译，这种方式吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制。JIT 缺点就是编译需要占用运行时资源，会导致进程卡顿。 （2）AOT，Ahead Of Time，指运行前编译，预先编译。 AOT 编译能直接将源代码转化为机器码，内存占用低，启动速度快，可以无需 runtime 运行，直接将 runtime 静态链接至最终的程序中，但是无运行时性能加成，不能根据程序运行情况做进一步的优化，AOT 缺点就是在程序运行前编译会使程序安装的时间增加。 **简单来讲：**JIT即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。\n1 .java -\u0026gt; .class -\u0026gt; (使用jaotc编译工具) -\u0026gt; .so（程序函数库,即编译好的可以供其他程序使用的代码和数据） （3）AOT的优点 **简单来讲，**Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验。 在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗\n可以在程序运行初期就达到最高性能，程序启动速度快\n运行产物只有机器码，打包体积小 AOT的缺点 由于是静态提前编译，不能根据硬件情况或程序运行情况择优选择机器指令序列，理论峰值性能不如JIT\n没有动态能力，同一份产物不能跨平台运行 第一种即时编译 (JIT) 是默认模式，Java Hotspot 虚拟机使用它在运行时将字节码转换为机器码。后者提前编译 (AOT)由新颖的 GraalVM 编译器支持，并允许在构建时将字节码直接静态编译为机器码。 现在正处于云原生，降本增效的时代，Java 相比于 Go、Rust 等其他编程语言非常大的弊端就是启动编译和启动进程非常慢，这对于根据实时计算资源，弹性扩缩容的云原生技术相冲突，Spring6 借助 AOT 技术在运行时内存占用低，启动速度快，逐渐的来满足 Java 在云原生时代的需求，对于大规模使用 Java 应用的商业公司可以考虑尽早调研使用 JDK17，通过云原生技术为公司实现降本增效。\n11.1.2、Graalvm\rSpring6 支持的 AOT 技术，这个 GraalVM 就是底层的支持，Spring 也对 GraalVM 本机映像提供了一流的支持。GraalVM 是一种高性能 JDK，旨在加速用 Java 和其他 JVM 语言编写的应用程序的执行，同时还为 JavaScript、Python 和许多其他流行语言提供运行时。 GraalVM 提供两种运行 Java 应用程序的方法：在 HotSpot JVM 上使用 Graal 即时 (JIT) 编译器或作为提前 (AOT) 编译的本机可执行文件。 GraalVM 的多语言能力使得在单个应用程序中混合多种编程语言成为可能，同时消除了外语调用成本。GraalVM 向 HotSpot Java 虚拟机添加了一个用 Java 编写的高级即时 (JIT) 优化编译器。 GraalVM 具有以下特性： （1）一种高级优化编译器，它生成更快、更精简的代码，需要更少的计算资源 （2）AOT 本机图像编译提前将 Java 应用程序编译为本机二进制文件，立即启动，无需预热即可实现最高性能 （3）Polyglot 编程在单个应用程序中利用流行语言的最佳功能和库，无需额外开销 （4）高级工具在 Java 和多种语言中调试、监视、分析和优化资源消耗 总的来说对云原生的要求不算高短期内可以继续使用 2.7.X 的版本和 JDK8，不过 Spring 官方已经对 Spring6 进行了正式版发布。\n11.1.3、Native Image\r目前业界除了这种在JVM中进行AOT的方案，还有另外一种实现Java AOT的思路，那就是直接摒弃JVM，和C/C++一样通过编译器直接将代码编译成机器代码，然后运行。这无疑是一种直接颠覆Java语言设计的思路，那就是GraalVM Native Image。它通过C语言实现了一个超微缩的运行时组件 —— Substrate VM，基本实现了JVM的各种特性，但足够轻量、可以被轻松内嵌，这就让Java语言和工程摆脱JVM的限制，能够真正意义上实现和C/C++一样的AOT编译。这一方案在经过长时间的优化和积累后，已经拥有非常不错的效果，基本上成为Oracle官方首推的Java AOT解决方案。\nNative Image 是一项创新技术，可将 Java 代码编译成独立的本机可执行文件或本机共享库。在构建本机可执行文件期间处理的 Java 字节码包括所有应用程序类、依赖项、第三方依赖库和任何所需的 JDK 类。生成的自包含本机可执行文件特定于不需要 JVM 的每个单独的操作系统和机器体系结构。\n11.2、演示Native Image构建过程\r11.2.1、GraalVM安装\r（1）下载GraalVM\r进入官网下载：https://www.graalvm.org/downloads/ （2）配置环境变量\r添加GRAALVM_HOME 把JAVA_HOME修改为graalvm的位置 把Path修改位graalvm的bin位置 使用命令查看是否安装成功 （3）安装native-image插件\r使用命令 gu install native-image下载安装 11.2.2、安装C++的编译环境\r（1）下载Visual Studio安装软件\rhttps://visualstudio.microsoft.com/zh-hans/downloads/ （2）安装Visual Studio\r（3）添加Visual Studio环境变量\r配置INCLUDE、LIB和Path （4）打开工具，在工具中操作\r11.2.3、编写代码，构建Native Image\r（1）编写Java代码\r1 2 3 4 5 public class Hello { public static void main(String[] args) { System.out.println(\u0026#34;hello world\u0026#34;); } } （2）复制文件到目录，执行编译\r（3）Native Image 进行构建\r（4）查看构建的文件\r（5）执行构建的文件\r可以看到这个Hello最终打包产出的二进制文件大小为11M，这是包含了SVM和JDK各种库后的大小，虽然相比C/C++的二进制文件来说体积偏大，但是对比完整JVM来说，可以说是已经是非常小了。 相比于使用JVM运行，Native Image的速度要快上不少，cpu占用也更低一些，从官方提供的各类实验数据也可以看出Native Image对于启动速度和内存占用带来的提升是非常显著的： 如果报错如下 原因，权限不够，以管理员权限启动即可 环境配置\n如果想像这样添加多行，那么在添加第一行的时候，加一个英文的分号，即 ; 1 2 3 4 5 INCLUDE D:\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.35.32215\\bin\\Hostx64\\x64 C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared 1 2 3 4 LIB C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\x64 C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\64 D:\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.35.32215\\bin\\Hostx64\\x64 1 2 path D:\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.35.32215\\bin\\Hostx64\\x64 java环境变量\n1 从D:\\java\\jdk改为D:\\graalvm-ce-java17-22.3.0 ","date":"2023-03-16T00:00:00Z","image":"http://localhost:1313/p/aot%E5%AD%A6%E4%B9%A0/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/aot%E5%AD%A6%E4%B9%A0/","title":"AOT学习"},{"content":"idea新建ssm项目\r打开project structure，选择web后点击ok 将web文件夹移入main下，并改名为webapp 修改pom文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ssm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--druid数据源--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.20\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--log4j--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--aop--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Hutool--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.6.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--LomBok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring+SpringMVC --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;!-- Exclude Commons Logging in favor of SLF4j --\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 事务管理 --\u0026gt; \u0026lt;!-- Spring的jdbc模块 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 做jdbc的连接管理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-dbcp2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jsp-api --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MyBatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--分页查询--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MyBatis-Spring连接包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jackson --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.8.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 日志管理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--commons文件上传，如果需要文件上传功能，需要添加本依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 测试\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis_test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;mybatis_test Maven Webapp\u0026lt;/name\u0026gt; \u0026lt;!-- FIXME change it to the project\u0026#39;s website --\u0026gt; \u0026lt;url\u0026gt;http://www.example.com\u0026lt;/url\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Hutool--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.6.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--LomBok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.16.18\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring+SpringMVC --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;!-- Exclude Commons Logging in favor of SLF4j --\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 事务管理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-tx\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring的jdbc模块 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 做jdbc的连接管理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-dbcp2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jsp-api --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MyBatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MyBatis-Spring连接包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jackson --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.8.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.8.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 日志管理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.13\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/project\u0026gt; ","date":"2023-03-15T00:00:00Z","image":"http://localhost:1313/p/idea%E6%96%B0%E5%BB%BAssm%E9%A1%B9%E7%9B%AE/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/idea%E6%96%B0%E5%BB%BAssm%E9%A1%B9%E7%9B%AE/","title":"Idea新建SSM项目"},{"content":"Spring6学习04\r手写IOC\r实现过程\n创建子模块 创建测试类 创建两个注解 @Bean(代替@Component) @Di(代替@Autowired) 创建Bean容器接口ApplicationContext，定义方法，返回对象 实现Bean容器接口 返回对象 根据包规则加载bean 规则:扫描当前包及其子包里的所有类，判断类上是否有@Bean注解，如果有，则把这个类通过反射实例化\n第一步，搭建项目\r创建两个注解，@Bean、@Di\n1 2 3 4 5 6 7 8 import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Bean { } 1 2 3 4 5 6 7 8 import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface Di { } 使用如下方式进行注入\n1 2 3 4 5 @Bean public class UserServiceImpl implements UserService { @Di private UserDao userDao; } 新建ApplicationContext接口\n1 2 3 public interface ApplicationContext { Object getBean(Class\u0026lt;?\u0026gt; clazz); } 对接口进行实例化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.HashMap; import java.util.Map; public class AnnotationApplicationContext implements ApplicationContext{ // 创建Map集合，用于存放Bean对象 private Map\u0026lt;Class\u0026lt;?\u0026gt;,Object\u0026gt; beanFactory=new HashMap\u0026lt;\u0026gt;(); /** * 返回bean对象 */ @Override public Object getBean(Class\u0026lt;?\u0026gt; clazz) { return beanFactory.get(clazz); } /** * 创建有参构造方法，传递包路径，设置包扫描规则 * 当前包及其子包，标注有@Bean注解，把这个类通过反射实例化 * * @param basePackage 包路径 */ public AnnotationApplicationContext(String basePackage) { // } } 为什么要写AnnotationApplicationContext的构造方法？\n我们先来看看原本Spring是怎么写的 以下是暂时的项目结构 第二步，配置扫描规则\r用法应该如下所示\n1 2 3 4 5 6 public class Main { public static void main(String[] args) { ApplicationContext context = new AnnotationApplicationContext(\u0026#34;com.example\u0026#34;); Object bean = context.getBean(UserDaoImpl.class); } } 将.替换成\\ （com.example）-\u0026gt;（com\\example） 获取包的(带盘符的)对路径 （这里的绝对路径并非是当前类的绝对路径，而是编译后生成的target内的类路径） 由于转义字符的影响，所以得这么写\n如果不放心，可以试着打印输出一下\n1 String packagePath = basePackage.replaceAll(\u0026#34;\\\\.\u0026#34;, \u0026#34;\\\\\\\\\u0026#34;); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 public class AnnotationApplicationContext implements ApplicationContext { // 创建Map集合，用于存放Bean对象 private Map\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt; beanFactory = new HashMap\u0026lt;\u0026gt;(); private String rootPath; /** * 返回bean对象 */ @Override public Object getBean(Class\u0026lt;?\u0026gt; clazz) { return beanFactory.get(clazz); } /** * 创建有参构造方法，传递包路径，设置包扫描规则 * 当前包及其子包，标注有@Bean注解，把这个类通过反射实例化 * * @param basePackage 包路径 */ public AnnotationApplicationContext(String basePackage) { // com.example // 1. 将.替换成\\ String packagePath = basePackage.replaceAll(\u0026#34;\\\\.\u0026#34;, \u0026#34;\\\\\\\\\u0026#34;); try { // 2. 获取包的绝对路径 Enumeration\u0026lt;URL\u0026gt; urls = Thread.currentThread().getContextClassLoader().getResources(packagePath); // 遍历枚举对象 while (urls.hasMoreElements()) { URL url = urls.nextElement(); // 斜杠会做url编码，所以要进行转码 String filePath = URLDecoder.decode(url.getFile(), \u0026#34;UTF-8\u0026#34;); // 获取包前面的路径部分，字符串截取 rootPath=filePath.substring(0,filePath.length()-packagePath.length()); // 包扫描 loadBean(new File(filePath)); } } catch (IOException e) { throw new RuntimeException(e); } } /** * 包扫描过程 * 实例化 */ private void loadBean(File file) { // 1.判断当前是否是文件夹 // 2.获取文件夹里的所有内容(文件夹、文件) // 3.若文件夹里为空，直接返回 // 4.文件夹不为空，遍历文件夹所有内容 // 4.1遍历得到每个File对象，递归判断文件夹里是否还有文件夹... // 4.2遍历得到File对象不是文件夹，是文件 // 4.3得到【包路径+类名称】部分-字符串截取 // 4.4判断当前类型是否是.class // 4.5如果是.class类型，就把\\替换成. 并 去掉后缀.class // com.example.service.UserServiceImpl 因为只有获取类全路径名才能使用反射 // 4.6判断类上是否有注解@Bean，如果有，实例化过程 // 4.7把对象实例化之后，放到map集合beanFactory // 小细节:如果有接口，就放接口class作为key，如果没有，就让自己class作为key } } 第三步，配置包扫描过程\r1 步骤 判断当前是否是文件夹 获取文件夹里的所有内容(文件夹、文件) 若文件夹里为空，直接返回 文件夹不为空，遍历文件夹所有内容\n4.1 遍历得到每个File对象，递归判断文件夹里是否还有文件夹…\n4.2 遍历得到File对象不是文件夹，是文件\n4.3 得到【包路径+类名称】部分-字符串截取\n4.4 判断当前类型是否是.class\n4.5 如果是.class类型，就把\\替换成. 并 去掉后缀.class com.example.service.UserServiceImpl 因为只有获取类全路径名才能使用反射\n4.6 判断类上是否有注解@Bean，如果有，实例化过程\n4.7 把对象实例化之后，放到map集合beanFactory\n小细节:如果有接口，就放接口class作为key，如果没有，就让自己class作为key 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 public class AnnotationApplicationContext implements ApplicationContext { // 创建Map集合，用于存放Bean对象 private Map\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt; beanFactory = new HashMap\u0026lt;\u0026gt;(); private String rootPath; /** * 返回bean对象 */ @Override public Object getBean(Class\u0026lt;?\u0026gt; clazz) { return beanFactory.get(clazz); } /** * 创建有参构造方法，传递包路径，设置包扫描规则 * 当前包及其子包，标注有@Bean注解，把这个类通过反射实例化 * * @param basePackage 包路径 */ public AnnotationApplicationContext(String basePackage) { // com.example // 1. 将.替换成\\ String packagePath = basePackage.replaceAll(\u0026#34;\\\\.\u0026#34;, \u0026#34;\\\\\\\\\u0026#34;); try { // 2. 获取包的绝对路径 Enumeration\u0026lt;URL\u0026gt; urls = Thread.currentThread().getContextClassLoader().getResources(packagePath); // 遍历枚举对象 while (urls.hasMoreElements()) { URL url = urls.nextElement(); // 斜杠会做url编码，所以要进行转码 String filePath = URLDecoder.decode(url.getFile(), \u0026#34;UTF-8\u0026#34;); // 获取包前面的路径部分，字符串截取 rootPath=filePath.substring(0,filePath.length()-packagePath.length()); // 包扫描 loadBean(new File(filePath)); } } catch (Exception e) { throw new RuntimeException(e); } } /** * 包扫描过程 * 实例化 */ private void loadBean(File file) throws Exception { // 1.判断当前是否是文件夹 if(file.isDirectory()){ // 2.获取文件夹里的所有内容(文件夹、文件) File[] childrenFiles = file.listFiles(); // 3.若文件夹里为空，直接返回 if(childrenFiles==null||childrenFiles.length==0){ return; } // 4.文件夹不为空，遍历文件夹所有内容 for(File child:childrenFiles){ // 4.1遍历得到每个File对象，递归判断文件夹里是否还有文件夹... if(child.isDirectory()){ // 递归 loadBean(child); }else{ // 4.2遍历得到File对象不是文件夹，是文件 // 4.3得到【包路径+类名称】部分-字符串截取 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); // 4.4判断当前类型是否是.class if(pathWithClass.contains(\u0026#34;.class\u0026#34;)){ // 4.5如果是.class类型，就把\\替换成. 并 去掉后缀.class // com.example.service.UserServiceImpl 因为只有获取类全路径名才能使用反射 String allName = pathWithClass.replaceAll(\u0026#34;\\\\\\\\\u0026#34;, \u0026#34;.\u0026#34;).replace(\u0026#34;.class\u0026#34;, \u0026#34;\u0026#34;); // 4.6判断类上是否有注解@Bean，如果有，实例化过程 // 4.6.1获取类的class对象 Class\u0026lt;?\u0026gt; clazz = Class.forName(allName); // 4.6.2判断，如果不是接口，则实例化 if(!clazz.isInterface()){ // 4.6.3判断，类上是否有注解@Bean Bean annotation = clazz.getAnnotation(Bean.class); if(annotation!=null){ // 类上@Bean有注解 // 4.6.4实例化 Object instance = clazz.getConstructor().newInstance(); // 4.7把对象实例化之后，放到map集合beanFactory // 4.7.1小细节:如果有接口，就放接口class作为key，如果没有，就让自己class作为key if(clazz.getInterfaces().length\u0026gt;0){ beanFactory.put(clazz.getInterfaces()[0],instance); }else{ beanFactory.put(clazz,instance); } } } } } } } } } 第四步，测试@Bean注解\r1 2 3 public interface UserDao { void insert(); } 1 2 3 4 5 6 7 @Bean public class UserDaoImpl implements UserDao { @Override public void insert() { System.out.println(\u0026#34;userDao--insert\u0026#34;); } } 1 2 3 public interface UserService { void add(); } 1 2 3 4 5 6 7 8 9 10 @Bean public class UserServiceImpl implements UserService { @Di private UserDao userDao; @Override public void add() { System.out.println(\u0026#34;service--add\u0026#34;); // TODO 调用dao的方法 } } 1 2 3 4 5 6 7 8 public class Main { public static void main(String[] args) { ApplicationContext context = new AnnotationApplicationContext(\u0026#34;com.example\u0026#34;); UserService userService = (UserService) context.getBean(UserService.class); System.out.println(userService); userService.add(); } } 第五步，编写@Di注解属性注入逻辑\r实例化对象在beanFactory的map集合里\n1.遍历beanFactory的map集合\n2.获取map集合每个对象(value)，每个对象的属性获取到\n3.遍历得到每个对象属性数组，得到每个属性\n4.属性上是否有@Di的注解(如果是私有属性，需要设置为【可以设置值】)\n5.如果有@Di的注解，把对象注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 public class AnnotationApplicationContext implements ApplicationContext { // 创建Map集合，用于存放Bean对象 private Map\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt; beanFactory = new HashMap\u0026lt;\u0026gt;(); private String rootPath; /** * 返回bean对象 */ @Override public Object getBean(Class\u0026lt;?\u0026gt; clazz) { return beanFactory.get(clazz); } /** * 创建有参构造方法，传递包路径，设置包扫描规则 * 当前包及其子包，标注有@Bean注解，把这个类通过反射实例化 * * @param basePackage 包路径 */ public AnnotationApplicationContext(String basePackage) { // com.example // 1. 将.替换成\\ String packagePath = basePackage.replaceAll(\u0026#34;\\\\.\u0026#34;, \u0026#34;\\\\\\\\\u0026#34;); try { // 2. 获取包的绝对路径 Enumeration\u0026lt;URL\u0026gt; urls = Thread.currentThread().getContextClassLoader().getResources(packagePath); // 遍历枚举对象 while (urls.hasMoreElements()) { URL url = urls.nextElement(); // 斜杠会做url编码，所以要进行转码 String filePath = URLDecoder.decode(url.getFile(), \u0026#34;UTF-8\u0026#34;); // 获取包前面的路径部分，字符串截取 rootPath = filePath.substring(0, filePath.length() - packagePath.length()); // 包扫描 loadBean(new File(filePath)); } } catch (Exception e) { throw new RuntimeException(e); } // 属性注入 loadDi(); } /** * 属性注入 */ private void loadDi() { // 实例化对象在beanFactory的map集合里 // 1.遍历beanFactory的map集合 Set\u0026lt;Map.Entry\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt;\u0026gt; entries = beanFactory.entrySet(); for (Map.Entry\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt; entry : entries) { // 2.获取map集合每个对象(value)，每个对象的属性获取到 Object obj = entry.getValue(); // 获取对象class Class\u0026lt;?\u0026gt; clazz = obj.getClass(); // 获取每个对象中的属性 Field[] declaredFields = clazz.getDeclaredFields(); // 3.遍历得到每个对象属性数组，得到每个属性 for (Field field : declaredFields) { // 4.属性上是否有@Di的注解(如果是私有属性，需要设置为【可以设置值】) Di annotation = field.getAnnotation(Di.class); if (annotation != null) { // 属性上有@Di注解 // 如果是私有属性，需要设置为【可设置值】 field.setAccessible(true); // 5.如果有@Di的注解，把对象注入 System.out.println(\u0026#34;类型:\u0026#34;+field.getType()); try { field.set(obj, beanFactory.get(field.getType())); } catch (IllegalAccessException e) { throw new RuntimeException(e); } } } } } /** * 包扫描过程 * 实例化 */ private void loadBean(File file) throws Exception { // 1.判断当前是否是文件夹 if (file.isDirectory()) { // 2.获取文件夹里的所有内容(文件夹、文件) File[] childrenFiles = file.listFiles(); // 3.若文件夹里为空，直接返回 if (childrenFiles == null || childrenFiles.length == 0) { return; } // 4.文件夹不为空，遍历文件夹所有内容 for (File child : childrenFiles) { // 4.1遍历得到每个File对象，递归判断文件夹里是否还有文件夹... if (child.isDirectory()) { // 递归 loadBean(child); } else { // 4.2遍历得到File对象不是文件夹，是文件 // 4.3得到【包路径+类名称】部分-字符串截取 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); // 4.4判断当前类型是否是.class if (pathWithClass.contains(\u0026#34;.class\u0026#34;)) { // 4.5如果是.class类型，就把\\替换成. 并 去掉后缀.class // com.example.service.UserServiceImpl 因为只有获取类全路径名才能使用反射 String allName = pathWithClass.replaceAll(\u0026#34;\\\\\\\\\u0026#34;, \u0026#34;.\u0026#34;).replace(\u0026#34;.class\u0026#34;, \u0026#34;\u0026#34;); // 4.6判断类上是否有注解@Bean，如果有，实例化过程 // 4.6.1获取类的class对象 Class\u0026lt;?\u0026gt; clazz = Class.forName(allName); // 4.6.2判断，如果不是接口，则实例化 if (!clazz.isInterface()) { // 4.6.3判断，类上是否有注解@Bean Bean annotation = clazz.getAnnotation(Bean.class); if (annotation != null) { // 类上@Bean有注解 // 4.6.4实例化 Object instance = clazz.getConstructor().newInstance(); // 4.7把对象实例化之后，放到map集合beanFactory // 4.7.1小细节:如果有接口，就放接口class作为key，如果没有，就让自己class作为key if (clazz.getInterfaces().length \u0026gt; 0) { beanFactory.put(clazz.getInterfaces()[0], instance); } else { beanFactory.put(clazz, instance); } } } } } } } } } 1 2 3 4 5 6 7 8 9 10 11 @Bean public class UserServiceImpl implements UserService { @Di private UserDao userDao; @Override public void add() { System.out.println(\u0026#34;service--add\u0026#34;); // 调用dao的方法 userDao.insert(); } } ","date":"2023-03-14T00:00:00Z","image":"http://localhost:1313/p/04_spring6/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/04_spring6/","title":"04_Spring6"},{"content":"拦截器\r问题起因：明明已将放行过测试的路径了，页面也能正常获取到数据，拦截器里的sout却依然有两次输出 输出了一下请求路径，发现如下 参考博客 至于为什么会请求error，应该是没有找到favicon.ico的请求 解决方法如下 放过favicon.ico请求 static里增加一个图标即可 ","date":"2023-03-14T00:00:00Z","image":"http://localhost:1313/p/%E6%8B%A6%E6%88%AA%E5%99%A8/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/%E6%8B%A6%E6%88%AA%E5%99%A8/","title":"拦截器"},{"content":"Spring6学习03\r注解开发\r引入依赖 开启组件扫描 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;dependencies\u0026gt; \u0026lt;!--spring ioc--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--junit5测试--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--log4j2的依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.19.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-slf4j2-impl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.19.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 开启组件扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.example\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 以上的基本组件扫描是最常用的\n同时还有以下两种组件扫描的写法 指定要排除的组件\n1 2 3 4 5 6 7 8 9 10 \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu.spring6\u0026#34;\u0026gt; \u0026lt;!-- context:exclude-filter标签：指定排除规则 --\u0026gt; \u0026lt;!-- type：设置排除或包含的依据 type=\u0026#34;annotation\u0026#34;，根据注解排除，expression中设置要排除的注解的全类名 type=\u0026#34;assignable\u0026#34;，根据类型排除，expression中设置要排除的类型的全类名 --\u0026gt; \u0026lt;context:exclude-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.Controller\u0026#34;/\u0026gt; \u0026lt;!--\u0026lt;context:exclude-filter type=\u0026#34;assignable\u0026#34; expression=\u0026#34;com.atguigu.spring6.controller.UserController\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;/context:component-scan\u0026gt; 仅扫描指定组件\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu\u0026#34; use-default-filters=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --\u0026gt; \u0026lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --\u0026gt; \u0026lt;!-- 此时必须设置use-default-filters=\u0026#34;false\u0026#34;，因为默认规则即扫描指定包下所有类 --\u0026gt; \u0026lt;!-- type：设置排除或包含的依据 type=\u0026#34;annotation\u0026#34;，根据注解排除，expression中设置要排除的注解的全类名 type=\u0026#34;assignable\u0026#34;，根据类型排除，expression中设置要排除的类型的全类名 --\u0026gt; \u0026lt;context:include-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.Controller\u0026#34;/\u0026gt; \u0026lt;!--\u0026lt;context:include-filter type=\u0026#34;assignable\u0026#34; expression=\u0026#34;com.atguigu.spring6.controller.UserController\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;/context:component-scan\u0026gt; 定义bean\n此时将以前的\u0026lt;bean id=\u0026quot;\u0026quot; class=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt;这种写法更换为一下写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.springframework.stereotype.Component; @Data // 不写则默认是首字母小写，即user @Component(\u0026#34;userEntity\u0026#34;) @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String name; private String gender; private Integer age; } 1 2 3 4 5 6 7 8 9 public class ApplicationTest { @Test public void test1(){ ApplicationContext context=new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); // 此处应该写component中写的名称，即userEntity User userEntity = context.getBean(\u0026#34;userEntity\u0026#34;, User.class); System.out.println(userEntity); } } Autowired\r属性注入 单独使用@Autowired注解，默认根据类型装配。【默认是byType】 1 2 3 4 5 6 7 8 9 @Controller public class UserController { @Autowired private UserService userService; public void userController1(){ System.out.println(\u0026#34;userController1方法已执行...\u0026#34;); userService.userService1(); } } 1 2 3 public interface UserService { public void userService1(); } 1 2 3 4 5 6 7 8 9 10 @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; @Override public void userService1() { System.out.println(\u0026#34;userService1方法执行了...\u0026#34;); userDao.userDao1(); } } 1 2 3 public interface UserDao { void userDao1(); } 1 2 3 4 5 6 7 @Repository public class UserDaoImpl implements UserDao { @Override public void userDao1() { System.out.println(\u0026#34;userDao1方法执行了...\u0026#34;); } } 1 2 3 4 5 6 7 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer id; private String name; } set方法注入 1 2 3 4 5 6 7 8 9 10 11 12 13 @Controller public class UserController { private UserService userService; // set方法注入 @Autowired public void setUserService(UserService userService) { this.userService = userService; } public void userController1(){ System.out.println(\u0026#34;userController1方法已执行...\u0026#34;); userService.userService1(); } } 构造方法注入 1 2 3 4 5 6 7 8 9 10 11 12 13 @Controller public class UserController { private UserService userService; @Autowired public UserController(UserService userService) { this.userService = userService; } @Autowired public void userController1(){ System.out.println(\u0026#34;userController1方法已执行...\u0026#34;); userService.userService1(); } } 形参注入 1 2 3 4 5 6 7 8 9 10 11 12 @Controller public class UserController { private UserService userService; public UserController(@Autowired UserService userService) { this.userService = userService; } @Autowired public void userController1(){ System.out.println(\u0026#34;userController1方法已执行...\u0026#34;); userService.userService1(); } } 只有一个有参构造函数，注解可以省略 1 2 3 4 5 6 7 8 9 10 11 12 @Controller public class UserController { private UserService userService; public UserController(UserService userService) { this.userService = userService; } @Autowired public void userController1(){ System.out.println(\u0026#34;userController1方法已执行...\u0026#34;); userService.userService1(); } } 必须只有一个有参的构造函数，若多一个无参构造函数，则报错\n@Controller不能省略若省略@Controller，也报错 6. Autowired+Qualifier联合注解\n接口有多个实现类，用Qualifier来指定bean名称\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Controller public class UserController { @Autowired // 指定bean名称 @Qualifier(\u0026#34;userServiceImpl\u0026#34;) private UserService userService; public UserController(UserService userService) { this.userService = userService; } @Autowired public void userController1(){ System.out.println(\u0026#34;userController1方法已执行...\u0026#34;); userService.userService1(); } } Resource\r@Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？\n@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。) @Autowired注解是Spring框架自己的。 @Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。 @Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。 @Resource注解用在属性上、setter方法上。 @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。 @Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。】 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jakarta.annotation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.annotation-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 全注解开发\r全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。\n1 2 3 4 5 6 7 8 package com.atguigu.spring6.config; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration //@ComponentScan({\u0026#34;com.atguigu.spring6.controller\u0026#34;, \u0026#34;com.atguigu.spring6.service\u0026#34;,\u0026#34;com.atguigu.spring6.dao\u0026#34;}) @ComponentScan(\u0026#34;com.atguigu.spring6\u0026#34;) public class Spring6Config { } 测试类\n1 2 3 4 5 6 7 @Test public void testAllAnnotation(){ ApplicationContext context = new AnnotationConfigApplicationContext(Spring6Config.class); UserController userController = context.getBean(\u0026#34;userController\u0026#34;, UserController.class); userController.out(); logger.info(\u0026#34;执行成功\u0026#34;); } ","date":"2023-03-13T00:00:00Z","image":"http://localhost:1313/p/03_spring6/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/03_spring6/","title":"03_Spring6"},{"content":"SpringBoot后端开发流程\rjwt生成以及解析token、拦截器、全局异常处理、自定义参数解析、跨域、参数校验 依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.12.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springbootTest\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;springbootTest\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;springbootTest\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;jjwt.version\u0026gt;0.9.1\u0026lt;/jjwt.version\u0026gt; \u0026lt;fastjson.version\u0026gt;1.2.72\u0026lt;/fastjson.version\u0026gt; \u0026lt;mybatis-plus.version\u0026gt;3.5.1\u0026lt;/mybatis-plus.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--jsr303--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/cn.easyproject/orai18n --\u0026gt; \u0026lt;!-- 如果数据库选用mysql则不需要此依赖，oracle则需要此依赖，不然后面会报错 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.easyproject\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;orai18n\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;12.1.0.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis plus--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--jjwt--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--web--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--json--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${fastjson.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--oracle--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.database.jdbc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ojdbc8\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 create table tb_user ( id number(10) primary key, nickname varchar2(20), username varchar2(20), password varchar2(20) ); insert into tb_user (id, nickname, username, password) values (1,\u0026#39;哈哈\u0026#39;,\u0026#39;admin\u0026#39;,\u0026#39;123456\u0026#39;); insert into tb_user (id, nickname, username, password) values (2,\u0026#39;呵呵\u0026#39;,\u0026#39;abcd\u0026#39;,\u0026#39;456\u0026#39;); insert into tb_user (id, nickname, username, password) values (3,\u0026#39;嘿嘿\u0026#39;,\u0026#39;aan\u0026#39;,\u0026#39;1234\u0026#39;); commit; select * from tb_user; jwt\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 package com.example.demo.util; import io.jsonwebtoken.Claims; import io.jsonwebtoken.JwtBuilder; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; import java.util.Date; import java.util.UUID; /** * JWT工具类 */ public class JwtUtil { //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = \u0026#34;sangeng\u0026#34;; public static String getUUID(){ String token = UUID.randomUUID().toString().replaceAll(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;); return token; } /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) { JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); } /** * 生成jtw * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) { JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); } private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) { SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null){ ttlMillis=JwtUtil.JWT_TTL; } long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(\u0026#34;sg\u0026#34;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); } /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) { JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); } public static void main(String[] args) throws Exception { String token = \u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\u0026#34;; Claims claims = parseJWT(token); System.out.println(claims); } /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() { byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \u0026#34;AES\u0026#34;); return key; } /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception { SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); } } JsonData\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package com.example.demo.util; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class JsonData { /** * 状态码 0 表示成功，1表示处理中，-1表示失败 */ private Integer code; /** * 数据 */ private Object data; /** * 描述 */ private String msg; // 成功，传入数据 public static JsonData buildSuccess() { return new JsonData(0, null, null); } // 成功，传入数据 public static JsonData buildSuccess(Object data) { return new JsonData(0, data, null); } // 失败，传入描述信息 public static JsonData buildError(String msg) { return new JsonData(-1, null, msg); } // 失败，传入描述信息,状态码 public static JsonData buildError(String msg, Integer code) { return new JsonData(code, null, msg); } } R\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.TypeReference; import org.springframework.http.HttpStatus; import java.util.HashMap; import java.util.Map; /** * @author:93879 * @date:2023/06/09/23:31 * @description: */ public class R extends HashMap\u0026lt;String, Object\u0026gt; { private static final long serialVersionUID = 1L; /** * 存元素 和setData的区别是 这个方法可以指定key的值 */ @Override public R put(String key, Object value) { super.put(key, value); return this; } public R setData(Object data) { put(\u0026#34;data\u0026#34;,data); return this; } /** * 获取数据 * 远程调用服务时，另一个服务也会返回R类型的数据，这个方法可以获取key为data的value值 * 利用fastjson进行反序列化 */ public \u0026lt;T\u0026gt; T getData(TypeReference\u0026lt;T\u0026gt; typeReference) { Object data = get(\u0026#34;data\u0026#34;);\t//默认是map String jsonString = JSON.toJSONString(data);//转为json字符串 T t = JSON.parseObject(jsonString, typeReference);//转为对象 return t; } /** * 利用fastjson进行反序列化 */ public \u0026lt;T\u0026gt; T getData(String key,TypeReference\u0026lt;T\u0026gt; typeReference) { Object data = get(key);\t//默认是map //转为json字符串 String jsonString = JSON.toJSONString(data);//转为json字符串 //转成需要的对象 T t = JSON.parseObject(jsonString, typeReference);//转为对象 return t; } public static long getSerialVersionUID() { return serialVersionUID; } //无参构造 public R() { put(\u0026#34;code\u0026#34;, 200); put(\u0026#34;msg\u0026#34;, \u0026#34;success\u0026#34;); } //返回错误码500的错误，错误内容：未知异常，请联系管理员 public static R error() { return error(HttpStatus.INTERNAL_SERVER_ERROR.value(), \u0026#34;未知异常，请联系管理员\u0026#34;); } //返回错误码500的错误，错误内容需要自己传入 public static R error(String msg) { return error(HttpStatus.INTERNAL_SERVER_ERROR.value(), msg); } //返回自定义错误码，自定义错误内容 public static R error(int code, String msg) { R r = new R(); r.put(\u0026#34;code\u0026#34;, code); r.put(\u0026#34;msg\u0026#34;, msg); return r; } //返回正常，内容需要自己传入 public static R ok(String msg) { R r = new R(); r.put(\u0026#34;msg\u0026#34;, msg); return r; } //存入多条返回消息 public static R ok(Map\u0026lt;String, Object\u0026gt; map) { R r = new R(); r.putAll(map); return r; } //默认返回 0 success public static R ok() { return new R(); } //获取code（状态码）的值 public Integer getCode() { return (Integer) this.get(\u0026#34;code\u0026#34;); } } 拦截器\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package com.example.demo.interceptor; import com.example.demo.util.JwtUtil; import io.jsonwebtoken.Claims; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * 自定义拦截器 * * @author tong * @date 2023/03/13 */ @Component public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 先获取请求头里的token String token = request.getHeader(\u0026#34;token\u0026#34;); // token判空 if(StringUtils.isEmpty(token)){ System.out.println(\u0026#34;这次的请求是：\u0026#34;+request.getServletPath()); throw new RuntimeException(\u0026#34;未登录，请登录后重试!\u0026#34;); } // token解析是否成功，若成功，则放行；否则，不放行 try { Claims claims = JwtUtil.parseJWT(token); String subject = claims.getSubject(); System.out.println(\u0026#34;sub:\u0026#34;+subject); } catch (Exception e) { throw new RuntimeException(\u0026#34;token解析错误，请稍后重试!\u0026#34;); } // 返回值代表是否放行 return true; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.example.demo.config; import com.example.demo.interceptor.MyInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * 拦截器配置 * * @author tong * @date 2023/03/13 */ @Configuration public class WebConfig implements WebMvcConfigurer { @Autowired private MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // 添加拦截器 registry.addInterceptor(myInterceptor) // 添加拦截路径 .addPathPatterns(\u0026#34;/**\u0026#34;) // 配置排除路径 .excludePathPatterns(\u0026#34;/user/login\u0026#34;,\u0026#34;/favicon.ico\u0026#34;); } } 异常处理\r1 2 3 4 5 6 7 8 9 10 11 12 package com.example.demo.handler; import com.example.demo.util.JsonData; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.RestControllerAdvice; @RestControllerAdvice public class AdviceController { @ExceptionHandler(RuntimeException.class) public Object handlerException(Exception e){ // 获取异常信息，并返回 return JsonData.buildError(e.getMessage()); } } 自定义参数解析\r许多的请求都需要获取到请求头里的token进行解析，在每个请求里都写解析的代码吗？\n选用以下的自定义参数解析会好很多\n1 2 3 4 5 6 7 8 9 10 11 12 package com.example.demo.resolver; import java.lang.annotation.*; /** * 自定义注解 * * @author tong * @date 2023/03/13 */ @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.PARAMETER }) public @interface CurrentUserId { } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package com.example.demo.resolver; import com.example.demo.util.JwtUtil; import io.jsonwebtoken.Claims; import org.springframework.core.MethodParameter; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import org.springframework.web.bind.support.WebDataBinderFactory; import org.springframework.web.context.request.NativeWebRequest; import org.springframework.web.method.support.HandlerMethodArgumentResolver; import org.springframework.web.method.support.ModelAndViewContainer; /** * 用户id参数解析器 * * @author tong * @date 2023/03/13 */ @Component public class UserIdArgumentResolver implements HandlerMethodArgumentResolver { /** * 是否能使用当前的参数解析器进行解析 * @return 是否进行解析 */ @Override public boolean supportsParameter(MethodParameter parameter) { // 如果参数上有CurrentUserId注解，则可以被解析，如果不包含，则不能被解析 return parameter.hasParameterAnnotation(CurrentUserId.class); } /** * 进行参数解析的方法，可以在方法中获取对应的数据，然后把数据作为返回值返回，方法的返回值就会赋值给对应的方法参数 */ @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { // 获取请求头中的token String token = webRequest.getHeader(\u0026#34;token\u0026#34;); if(StringUtils.hasText(token)){ // 解析token Claims claims = JwtUtil.parseJWT(token); return Integer.valueOf(claims.getSubject()); } return null; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package com.example.demo.config; import com.example.demo.resolver.UserIdArgumentResolver; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.method.support.HandlerMethodArgumentResolver; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import java.util.List; /** * 参数解析器配置 * * @author tong * @date 2023/03/13 */ @Configuration public class ArgumentResolverConfig implements WebMvcConfigurer { @Autowired private UserIdArgumentResolver userIdArgumentResolver; @Override public void addArgumentResolvers(List\u0026lt;HandlerMethodArgumentResolver\u0026gt; resolvers) { resolvers.add(userIdArgumentResolver); } } 测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private UserService userService; @PostMapping(\u0026#34;/login\u0026#34;) public Object checkLogin(@RequestBody LoginVo loginVo){ return userService.checkLogin(loginVo); } @PostMapping(\u0026#34;/test1\u0026#34;) public Object test1(@CurrentUserId Integer userId){ return JsonData.buildSuccess(userId); } } 可以看到参数已经被解析成id了 跨域\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.example.demo.config; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * 跨域配置 * * @author tong * @date 2023/03/13 */ @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { // 设置允许跨域的路径 registry.addMapping(\u0026#34;/**\u0026#34;) // 设置允许跨域的域名 .allowedOrigins(\u0026#34;*\u0026#34;) //是否允许cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(\u0026#34;GET\u0026#34;,\u0026#34;POST\u0026#34;,\u0026#34;DELETE\u0026#34;,\u0026#34;PUT\u0026#34;) // 设置允许的header属性 .allowedHeaders(\u0026#34;*\u0026#34;) // 跨域允许时间 .maxAge(3600); } } 参数校验\roracle实现id自增和mysql有点区别 新建分组\n1 2 public interface AddGroup { } 1 2 public interface DeleteGroup { } 1 2 3 4 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { @Insert(\u0026#34;INSERT INTO TB_USER (ID,NICKNAME,USERNAME,PASSWORD) VALUES ((SELECT MAX(ID)+1 FROM TB_USER),#{nickname},#{username},#{password})\u0026#34;) boolean insertUser(User user); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements UserService { @Override public Object checkLogin(LoginVo loginVo) { User user = baseMapper.selectOne( new QueryWrapper\u0026lt;User\u0026gt;() .eq(\u0026#34;USERNAME\u0026#34;, loginVo.getUsername()) .eq(\u0026#34;PASSWORD\u0026#34;, loginVo.getPassword())); if(user==null){ return JsonData.buildError(\u0026#34;用户不存在\u0026#34;); }else{ return JsonData.buildSuccess(JwtUtil.createJWT(user.getId().toString())); } } @Override public boolean saveUser(User user) { return baseMapper.insertUser(user); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private UserService userService; @PostMapping(\u0026#34;/login\u0026#34;) public Object checkLogin(@RequestBody LoginVo loginVo) { return userService.checkLogin(loginVo); } @PostMapping(\u0026#34;/test1\u0026#34;) public Object test1(@CurrentUserId Integer userId, @RequestBody User user) { HashMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;id\u0026#34;, userId); map.put(\u0026#34;user\u0026#34;, user); return JsonData.buildSuccess(map); } @PostMapping(\u0026#34;/add\u0026#34;) // 指定分组 public Object addUser(@Validated({AddGroup.class}) @RequestBody User user) { if(userService.saveUser(user)){ User one = userService.getOne(new QueryWrapper\u0026lt;User\u0026gt;() .eq(\u0026#34;USERNAME\u0026#34;, user.getUsername()) .eq(\u0026#34;PASSWORD\u0026#34;, user.getPassword())); return JsonData.buildSuccess(one); }else{ return JsonData.buildError(\u0026#34;注册失败\u0026#34;); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Data @TableName(value =\u0026#34;TB_USER\u0026#34;) public class User implements Serializable { /** * id */ @Null(message = \u0026#34;新增用户时，不能指定用户id\u0026#34;,groups = {AddGroup.class}) @NotNull(message = \u0026#34;删除用户时，必须指定用户id\u0026#34;,groups = {DeleteGroup.class}) @TableId(value = \u0026#34;ID\u0026#34;,type = IdType.AUTO) private Integer id; /** * 昵称 */ @TableField(value = \u0026#34;NICKNAME\u0026#34;) private String nickname; /** * 用户名 */ @TableField(value = \u0026#34;USERNAME\u0026#34;) private String username; /** * 密码 */ @TableField(value = \u0026#34;PASSWORD\u0026#34;) private String password; @TableField(exist = false) private static final long serialVersionUID = 1L; } 我们在日常开发中需要对程序内部的运行情况进行监控， 比如：健康度、运行指标、日志信息、线程状况等等 。而SpringBoot的监控Actuator就可以帮我们解决这些问题。\n监控指标\r①添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; ②访问监控接口 http://localhost:81/actuator ③配置启用监控端点\n1 2 3 4 5 6 management: endpoints: enabled-by-default: true #配置启用所有端点 web: exposure: include: \u0026#34;*\u0026#34; #web端暴露所有端点 常用端点\r端点名称 描述 beans 显示应用程序中所有Spring Bean的完整列表。 health 显示应用程序运行状况信息。 info 显示应用程序信息。 loggers 显示和修改应用程序中日志的配置。 metrics 显示当前应用程序的“指标”信息。 mappings 显示所有@RequestMapping路径列表。 scheduledtasks 显示应用程序中的计划任务。 图形化界面 SpringBoot Admin\r①创建SpringBoot Admin Server应用 要求引入spring-boot-admin-starter-server依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.codecentric\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-admin-starter-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 然后在启动类上加上@EnableAdminServer注解 ②配置SpringBoot Admin client应用 在需要监控的应用中加上spring-boot-admin-starter-client依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.codecentric\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-admin-starter-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 然后配置SpringBoot Admin Server的地址\n1 2 3 4 5 spring: boot: admin: client: url: http://localhost:8888 #配置 Admin Server的地址 ","date":"2023-03-13T00:00:00Z","image":"http://localhost:1313/p/springboot%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/springboot%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/","title":"SpringBoot后端开发流程"},{"content":"Spring6学习01\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;Spring6\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;Spring001\u0026lt;/artifactId\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--spring ioc--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--junit5测试--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--log4j2的依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.19.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-slf4j2-impl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.19.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; xml配置\rbeans.xml\n1 2 3 4 5 6 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; log4j2.xml，配置log4j2的日志输出\n其中log和RollingFile会将日志输出到文件中，如果文件夹不存在，会自动创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;loggers\u0026gt; \u0026lt;!-- level指定日志级别，从低到高的优先级： TRACE \u0026lt; DEBUG \u0026lt; INFO \u0026lt; WARN \u0026lt; ERROR \u0026lt; FATAL trace：追踪，是最低的日志级别，相当于追踪程序的执行 debug：调试，一般在开发中，都将其设置为最低的日志级别 info：信息，输出重要的信息，使用较多 warn：警告，输出警告的信息 error：错误，输出错误信息 fatal：严重错误 --\u0026gt; \u0026lt;root level=\u0026#34;DEBUG\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;spring6log\u0026#34;/\u0026gt; \u0026lt;appender-ref ref=\u0026#34;RollingFile\u0026#34;/\u0026gt; \u0026lt;appender-ref ref=\u0026#34;log\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/loggers\u0026gt; \u0026lt;appenders\u0026gt; \u0026lt;!--输出日志信息到控制台--\u0026gt; \u0026lt;console name=\u0026#34;spring6log\u0026#34; target=\u0026#34;SYSTEM_OUT\u0026#34;\u0026gt; \u0026lt;!--控制日志输出的格式--\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n\u0026#34;/\u0026gt; \u0026lt;/console\u0026gt; \u0026lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--\u0026gt; \u0026lt;File name=\u0026#34;log\u0026#34; fileName=\u0026#34;D:/spring6_log/test.log\u0026#34; append=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n\u0026#34;/\u0026gt; \u0026lt;/File\u0026gt; \u0026lt;!-- 这个会打印出所有的信息， 每次大小超过size， 则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩， 作为存档--\u0026gt; \u0026lt;RollingFile name=\u0026#34;RollingFile\u0026#34; fileName=\u0026#34;D:/spring6_log/app.log\u0026#34; filePattern=\u0026#34;log/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;%d{yyyy-MM-dd \u0026#39;at\u0026#39; HH:mm:ss z} %-5level %class{36} %L %M - %msg%xEx%n\u0026#34;/\u0026gt; \u0026lt;SizeBasedTriggeringPolicy size=\u0026#34;50MB\u0026#34;/\u0026gt; \u0026lt;!-- DefaultRolloverStrategy属性如不设置， 则默认为最多同一文件夹下7个文件，这里设置了20 --\u0026gt; \u0026lt;DefaultRolloverStrategy max=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;/RollingFile\u0026gt; \u0026lt;/appenders\u0026gt; \u0026lt;/configuration\u0026gt; 获取bean\r根据id获取bean 根据类型获取bean 根据id和类型获取bean 1 2 3 4 5 6 7 8 9 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String name; private String gender; private Integer age; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class ApplicationTest { private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); // 1.根据id获取bean User user1 = (User) context.getBean(\u0026#34;user\u0026#34;); // 2.根据类型获取bean User user2 = context.getBean(User.class); // 3.根据id和类型获取bean User user3 = context.getBean(\u0026#34;user\u0026#34;, User.class); // 日志输出 logger.info(\u0026#34;user1:{}\u0026#34;,user1); logger.info(\u0026#34;user2:{}\u0026#34;,user2); logger.info(\u0026#34;user3:{}\u0026#34;,user3); } } 需要注意的是如果根据类型获取，要求IOC中指定类型的bean只能有一个\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;user1\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 public class ApplicationTest { private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); // 根据类型获取bean User user2 = context.getBean(User.class); // 日志输出 logger.info(\u0026#34;user2:{}\u0026#34;,user2); } } 报错信息如下\n1 2 3 org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type \u0026#39;com.example.domain.User\u0026#39; available: expected single matching bean but found 2: user,user1 UserDao userDao=new UserDaoImpl();\nbean配置能否实现如上效果？如果有多个Impl的实现类呢？\n1 2 3 4 5 6 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userDaoImpl\u0026#34; class=\u0026#34;com.example.dao.impl.UserDaoImpl\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 public interface UserDao { void testDao(); } 1 2 3 4 5 6 public class UserDaoImpl implements UserDao { @Override public void testDao() { System.out.println(\u0026#34;这里是userDaoImpl\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 public class ApplicationTest { private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserDao userDao = context.getBean(UserDao.class); logger.info(\u0026#34;userDao:{}\u0026#34;,userDao); userDao.testDao(); } } 可以通过类型直接获取到\n但是当新建第二个impl实现类时，无法根据类型获取到，报错和之前一样 可以根据bean的名称获取到、也可以根据bean的名称+类型获取到\n结论\n根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。\njava中，instanceof运算符用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是返回true，否则返回false。也就是说：用instanceof关键字做判断时， instanceof 操作符的左右操作必须有继承或实现关系\n1 2 3 4 5 6 7 8 9 public class ApplicationTest { private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1(){ UserDaoImpl userDaoImpl = new UserDaoImpl(); System.out.println(userDaoImpl instanceof UserDao); } } // 结果为 true 依赖注入-setter注入\u0026amp;\u0026amp;构造器注入\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class ApplicationTest { private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1(){ // set方法 User user1 = new User(); user1.setUid(1); user1.setName(\u0026#34;哈哈\u0026#34;); user1.setGender(\u0026#34;男\u0026#34;); user1.setAge(15); // 构造器 User user2 = new User(1, \u0026#34;哈哈\u0026#34;, \u0026#34;男\u0026#34;, 15); System.out.println(\u0026#34;user1:\u0026#34;+user1); System.out.println(\u0026#34;user2:\u0026#34;+user2); } } 1 2 user1:User(uid=1, name=哈哈, gender=男, age=15) user2:User(uid=1, name=哈哈, gender=男, age=15) 这里想测试一下这两个user对象是否相等\n预想的情况应该是 false，false\n因为Object里的equals方法就是 == 1 2 System.out.println(\u0026#34;user1 \u0026amp;\u0026amp; user2是否相等:\u0026#34;+user1.equals(user2)); System.out.println(\u0026#34;user1 \u0026amp;\u0026amp; user2是否相等:\u0026#34;+(user1==user2)); 但答案是 true，false，我猜是@Data的问题\n我一直以为@Data=get+set+toString\n但其实@Data =get、set、equals、hashCode、toString\nsetter注入\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;user1\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;女\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;22\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 构造器注入\r1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 前提 使用setter注入，需要提前生成set方法 使用构造器注入，需要提前生成全参数的构造方法\n特殊值处理\rnull\r1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 10 public class ApplicationTest { private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); User bean = context.getBean(User.class); System.out.println(bean.getName() == null); System.out.println(Objects.equals(bean.getName(), \u0026#34;\u0026#34;)); } } 结果是 false，true\n此时name的值并不是null，是空字符串，如果希望它的值就是null，那么xml应该如下配置（set同理）\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 特殊符号\r写法1\n1 2 3 \u0026lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --\u0026gt; \u0026lt;!-- 解决方案一：使用XML实体来代替 --\u0026gt; \u0026lt;property name=\u0026#34;expression\u0026#34; value=\u0026#34;a \u0026amp;lt; b\u0026#34;/\u0026gt; 写法2\n1 2 3 4 5 6 7 \u0026lt;property name=\u0026#34;expression\u0026#34;\u0026gt; \u0026lt;!-- 解决方案二：使用CDATA节 --\u0026gt; \u0026lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --\u0026gt; \u0026lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --\u0026gt; \u0026lt;!-- 所以CDATA节中写什么符号都随意 --\u0026gt; \u0026lt;value\u0026gt;\u0026lt;![CDATA[a \u0026lt; b]]\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; 实体\r方法1 外部引入\n1 2 3 4 5 6 7 8 @Data @AllArgsConstructor @NoArgsConstructor public class Phone { private Integer pid; private String name; private Float price; } 1 2 3 4 5 6 7 8 9 10 11 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String name; private String gender; private Integer age; // 包含了phone类 private Phone phone; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;!-- ref 关联 phone --\u0026gt; \u0026lt;property name=\u0026#34;phone\u0026#34; ref=\u0026#34;phone\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 public class ApplicationTest { private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); User bean = context.getBean(User.class); System.out.println(bean); } } 方法2 内部bean\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;!-- 不填写value或ref，将bean写在property内 --\u0026gt; \u0026lt;property name=\u0026#34;phone\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 方法3 级联属性赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;phone\u0026#34; ref=\u0026#34;phone\u0026#34;/\u0026gt; \u0026lt;!-- 会将price的值进行覆盖 --\u0026gt; \u0026lt;property name=\u0026#34;phone.price\u0026#34; value=\u0026#34;3999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 总结：\n以上都是set注入的写法，构造器注入的写法是一样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;phone\u0026#34; ref=\u0026#34;phone\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 数组\r1 2 3 4 5 6 7 8 9 10 11 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String name; private String gender; private Integer age; private String[] hobby; private Phone phone; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;hobby\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;唱\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;跳\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;phone\u0026#34; ref=\u0026#34;phone\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 集合\rList\r1 2 3 4 5 6 7 8 9 10 11 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String name; private String gender; private Integer age; // 实体对象集合 private List\u0026lt;Phone\u0026gt; phones; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;phones\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;ref bean=\u0026#34;phone\u0026#34;/\u0026gt; \u0026lt;ref bean=\u0026#34;phone1\u0026#34;/\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone1\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;002\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;塑料手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;3999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 上面演示的是 实体对象集合，如果是字符串集合，可使用value，而不是ref\n1 2 3 4 5 6 7 8 9 10 11 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String name; private String gender; private Integer age; // 字符串集合 private List\u0026lt;String\u0026gt; phones; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;phones\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;呵呵\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;哈哈\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone1\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;002\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;塑料手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;3999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; Map\r1 2 3 4 5 6 7 8 9 10 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String name; private String gender; private Integer age; private Map\u0026lt;String,Phone\u0026gt; phoneMap; } 写法1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;phoneMap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;哈哈\u0026lt;/value\u0026gt; \u0026lt;/key\u0026gt; \u0026lt;ref bean=\u0026#34;phone\u0026#34;/\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 写法2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;phoneMap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;第一部手机\u0026#34; value-ref=\u0026#34;phone\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 以上的map集合里只有一个值，多个值的写法一样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;phoneMap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;第一部手机\u0026#34; value-ref=\u0026#34;phone\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;第二部手机\u0026#34; value-ref=\u0026#34;phone1\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;phone1\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;002\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;塑料手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;3999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 引用集合类型的bean util命令空间\u0026amp;\u0026amp;p命名空间\r1 2 3 4 5 6 7 8 9 10 11 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String name; private String gender; private Integer age; private List\u0026lt;Lesson\u0026gt; lessons; private Map\u0026lt;String,Phone\u0026gt; phoneMap; } 1 2 3 4 5 6 7 @Data @AllArgsConstructor @NoArgsConstructor public class Lesson { private Integer lid; private String name; } 1 2 3 4 5 6 7 8 @Data @AllArgsConstructor @NoArgsConstructor public class Phone { private Integer pid; private String name; private Float price; } 使用之前的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;lessons\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;ref bean=\u0026#34;lesson1\u0026#34;/\u0026gt; \u0026lt;ref bean=\u0026#34;lesson2\u0026#34;/\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;phoneMap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;第一部手机\u0026#34; value-ref=\u0026#34;phone1\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;第二部手机\u0026#34; value-ref=\u0026#34;phone2\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- lesson1 --\u0026gt; \u0026lt;bean id=\u0026#34;lesson1\u0026#34; class=\u0026#34;com.example.domain.Lesson\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;lid\u0026#34; value=\u0026#34;0001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;java开发\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- lesson2 --\u0026gt; \u0026lt;bean id=\u0026#34;lesson2\u0026#34; class=\u0026#34;com.example.domain.Lesson\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;lid\u0026#34; value=\u0026#34;0002\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;python开发\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- phone1 --\u0026gt; \u0026lt;bean id=\u0026#34;phone1\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- phone2 --\u0026gt; \u0026lt;bean id=\u0026#34;phone2\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;002\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;塑料手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;3999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 第二种写法\n这里需要更改xml上面的命名空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:util=\u0026#34;http://www.springframework.org/schema/util\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;lessons\u0026#34; ref=\u0026#34;lessonList\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;phoneMap\u0026#34; ref=\u0026#34;phoneMap\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;util:list id=\u0026#34;lessonList\u0026#34;\u0026gt; \u0026lt;ref bean=\u0026#34;lesson1\u0026#34;/\u0026gt; \u0026lt;ref bean=\u0026#34;lesson2\u0026#34;/\u0026gt; \u0026lt;/util:list\u0026gt; \u0026lt;util:map id=\u0026#34;phoneMap\u0026#34;\u0026gt; \u0026lt;entry key=\u0026#34;第一部手机\u0026#34; value-ref=\u0026#34;phone1\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;第二部手机\u0026#34; value-ref=\u0026#34;phone2\u0026#34;/\u0026gt; \u0026lt;/util:map\u0026gt; \u0026lt;!-- lesson1 --\u0026gt; \u0026lt;bean id=\u0026#34;lesson1\u0026#34; class=\u0026#34;com.example.domain.Lesson\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;lid\u0026#34; value=\u0026#34;0001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;java开发\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- lesson2 --\u0026gt; \u0026lt;bean id=\u0026#34;lesson2\u0026#34; class=\u0026#34;com.example.domain.Lesson\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;lid\u0026#34; value=\u0026#34;0002\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;python开发\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- phone1 --\u0026gt; \u0026lt;bean id=\u0026#34;phone1\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- phone2 --\u0026gt; \u0026lt;bean id=\u0026#34;phone2\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;002\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;塑料手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;3999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 第三种写法 p命名空间注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:util=\u0026#34;http://www.springframework.org/schema/util\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34; p:uid=\u0026#34;1\u0026#34; p:name=\u0026#34;马小跳\u0026#34; p:gender=\u0026#34;男\u0026#34; p:age=\u0026#34;15\u0026#34; p:lessons-ref=\u0026#34;lessonList\u0026#34; p:phoneMap-ref=\u0026#34;phoneMap\u0026#34;/\u0026gt; \u0026lt;util:list id=\u0026#34;lessonList\u0026#34;\u0026gt; \u0026lt;ref bean=\u0026#34;lesson1\u0026#34;/\u0026gt; \u0026lt;ref bean=\u0026#34;lesson2\u0026#34;/\u0026gt; \u0026lt;/util:list\u0026gt; \u0026lt;util:map id=\u0026#34;phoneMap\u0026#34;\u0026gt; \u0026lt;entry key=\u0026#34;第一部手机\u0026#34; value-ref=\u0026#34;phone1\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;第二部手机\u0026#34; value-ref=\u0026#34;phone2\u0026#34;/\u0026gt; \u0026lt;/util:map\u0026gt; \u0026lt;!-- lesson1 --\u0026gt; \u0026lt;bean id=\u0026#34;lesson1\u0026#34; class=\u0026#34;com.example.domain.Lesson\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;lid\u0026#34; value=\u0026#34;0001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;java开发\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- lesson2 --\u0026gt; \u0026lt;bean id=\u0026#34;lesson2\u0026#34; class=\u0026#34;com.example.domain.Lesson\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;lid\u0026#34; value=\u0026#34;0002\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;python开发\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- phone1 --\u0026gt; \u0026lt;bean id=\u0026#34;phone1\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;不锈钢手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;4999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- phone2 --\u0026gt; \u0026lt;bean id=\u0026#34;phone2\u0026#34; class=\u0026#34;com.example.domain.Phone\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;pid\u0026#34; value=\u0026#34;002\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;塑料手机\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;3999.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; ","date":"2023-03-11T00:00:00Z","image":"http://localhost:1313/p/01_spring6/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/01_spring6/","title":"01_Spring6"},{"content":"Spring6学习02\r引入外部文件\r引入数据库相关依赖 创建外部属性文件，如properties，定义数据库连接信息(用户名、密码\u0026hellip;) 创建spring配置文件，引入context命名空间来引入属性文件，使用表达式完成注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ApplicationTest { @Test public void test1() { try (DruidDataSource dataSource = new DruidDataSource()) { dataSource.setDriverClassName(\u0026#34;oracle.jdbc.driver.OracleDriver\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:oracle:thin:@localhost:1521:orcl\u0026#34;); dataSource.setUsername(\u0026#34;root\u0026#34;); dataSource.setPassword(\u0026#34;123456\u0026#34;); System.out.println(dataSource); } catch (Exception e) { throw new RuntimeException(\u0026#34;出现异常\u0026#34;, e); } } } 使用spring改造以上的代码\n1 2 3 4 jdbc.driver=oracle.jdbc.driver.OracleDriver jdbc.url=jdbc:oracle:thin:@localhost:1521:orcl jdbc.username=root jdbc.password=123456 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 引入属性 --\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;jdbc.properties\u0026#34;/\u0026gt; \u0026lt;!-- 完成数据库信息注入 --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 public class ApplicationTest { @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); DruidDataSource dataSource = context.getBean(DruidDataSource.class); System.out.println(dataSource); } } bean的作用域\r在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：\n取值 含义 创建对象的时机 singleton（默认） 在IOC容器中，这个bean的对象始终为单实例 IOC容器初始化时 prototype 这个bean在IOC容器中有多个实例 获取bean时 如果是在WebApplicationContext环境下还会有另外几个作用域（但不常用）： 取值 含义 \u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; request 在一个请求范围内有效 session 在一个会话范围内有效 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user1\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34; scope=\u0026#34;singleton\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;id\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;哈哈\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;user2\u0026#34; class=\u0026#34;com.example.domain.User\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;id\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;哈哈\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 @Setter public class User { private Integer id; private String name; } 1 2 3 4 5 6 7 8 @Test public void test3() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User user1_1 = context.getBean(\u0026#34;user1\u0026#34;, User.class); User user1_2 = context.getBean(\u0026#34;user1\u0026#34;, User.class); System.out.println(user1_1); System.out.println(user1_2); } 1 2 3 // 输出 com.example.domain.User@121314f7 com.example.domain.User@121314f7 这里可以看到 两个对象都是同一个地址，即同一个对象\n1 2 3 4 5 6 7 8 @Test public void test4() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User user1_1 = context.getBean(\u0026#34;user2\u0026#34;, User.class); User user1_2 = context.getBean(\u0026#34;user2\u0026#34;, User.class); System.out.println(user1_1); System.out.println(user1_2); } 1 2 3 // 输出 com.example.domain.User@130c12b7 com.example.domain.User@5e600dd5 这里显示对象的地址不同，即创建了多个对象\nbean的生命周期\rbean对象创建（调用无参构造器）\n给bean对象设置属性\nbean的后置处理器（初始化之前）\nbean对象初始化（需在配置bean时指定初始化方法）\nbean的后置处理器（初始化之后）\nbean对象就绪可以使用\nbean对象销毁（需在配置bean时指定销毁方法）\nIOC容器关闭\n","date":"2023-03-11T00:00:00Z","image":"http://localhost:1313/p/02_spring6/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/02_spring6/","title":"02_Spring6"},{"content":"Spring连接oracle\r使用过的jar包在文章结尾处，而且建议还是使用maven项目的结构，我这个结构不标准\n新建lib包，在lib下导入jar包\n如果发现无法使用jar包注解等，请在project structure-\u0026gt;modules-\u0026gt;dependencies中添加lib包 这个是新建maven项目导入spring-context依赖后的图片 这个是普通java项目手动导入jar包 此时已经可以新建spring-xml了\n测试lombok\r1 2 3 4 5 6 7 8 9 10 11 12 import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String name; private String gender; private Integer age; } 1 2 3 4 5 6 public class ApplicationTest { public static void main(String[] args) { User user = new User(1, \u0026#34;马小跳\u0026#34;, \u0026#34;男\u0026#34;, 15); System.out.println(user); } } 测试成功\n测试Spring\r1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;src.com.example.domain.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;马小跳\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 public class ApplicationTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;src/applicationContext.xml\u0026#34;); User user = (User) context.getBean(\u0026#34;user\u0026#34;); System.out.println(user); } } 运行后报错，继续导入该jar包 导入jar包后继续运行 这里需要注意applicationContext.xml的位置 如果在src下，需要写src/applicationContext.xml 如果和src同级，需要写applicationContext.xml\n配置Oracle\r```properties\r# 数据库驱动：\rspring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver\r# 数据库连接地址\rspring.datasource.url=jdbc:oracle:thin:@localhost:1521:orcl\r# 数据库用户名\u0026密码：\rspring.datasource.username=root\rspring.datasource.password=123456\r```\r```xml\r\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r```\r```java\rpublic class ApplicationTest {\r@Test\rpublic void test1(){\rApplicationContext context = new ClassPathXmlApplicationContext(\"src/applicationContext.xml\");\rDruidDataSource dataSource = context.getBean(\"dataSource\", DruidDataSource.class);\r}\r}\r```\r![image-20230311224204289](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303112242465.png)\r\u003e 可以看到已经配置成功\r\u003e\r\u003e 接下来测试一下sql\r```java\r@Data\r@AllArgsConstructor\r@NoArgsConstructor\rpublic class User {\rprivate Integer id;\rprivate String nickname;\rprivate String username;\rprivate String password;\r}\r```\r```java\rpublic class ApplicationTest {\r@Test\rpublic void test1() throws Exception {\rApplicationContext context = new ClassPathXmlApplicationContext(\"src/applicationContext.xml\");\rDruidDataSource dataSource = context.getBean(\"dataSource\", DruidDataSource.class);\rDruidPooledConnection connection = dataSource.getConnection();\rPreparedStatement preparedStatement = connection.prepareStatement(\"select * from tb_user\");\rResultSet resultSet = preparedStatement.executeQuery();\r// User列表\rList list = new ArrayList\u003c\u003e();\rwhile(resultSet.next()){\rUser user = new User(\rresultSet.getInt(\"id\"),\rresultSet.getString(\"nickname\"),\rresultSet.getString(\"username\"),\rresultSet.getString(\"password\"));\rlist.add(user);\r}\rlist.forEach(System.out::println);\r}\r}\r```\r```properties\r三月 11, 2023 10:56:36 下午 com.alibaba.druid.pool.DruidAbstractDataSource warn\r警告: oracle.jdbc.driver.OracleDriver is deprecated.Having use oracle.jdbc.OracleDriver.\r三月 11, 2023 10:56:36 下午 com.alibaba.druid.pool.DruidDataSource info\r信息: {dataSource-1} inited\rUser(id=1, nickname=哈哈, username=admin, password=123456)\rUser(id=2, nickname=呵呵, username=abcd, password=456)\rUser(id=3, nickname=嘿嘿, username=aan, password=1234)\rProcess finished with exit code 0\r```\r![image-20230311230401198](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303112304328.png)\r[项目](https://www.123pan.com/s/tMU0Vv-K2iUd.html)、[lib包](https://www.123pan.com/s/tMU0Vv-u2iUd.html)\r","date":"2023-03-11T00:00:00Z","image":"http://localhost:1313/p/02_spring%E8%BF%9E%E6%8E%A5oracle/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/02_spring%E8%BF%9E%E6%8E%A5oracle/","title":"02_Spring连接oracle"},{"content":"JDBC连接Oracle实现CRUD操作\r下面是项目的结构\nlib下存放的是oracle的连接包，ojdbc6-11.2.0.4.jar\n1 2 3 4 5 6 7 8 9 10 11 D:. ├─.idea │ └─inspectionProfiles ├─lib └─src └─com └─example ├─config ├─domain └─mapper └─impl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 建表 create table tb_user ( id number(10) primary key, nickname varchar2(20), username varchar2(20), password varchar2(20) ); -- 插入测试数据 insert into tb_user (id, nickname, username, password) values (1,\u0026#39;哈哈\u0026#39;,\u0026#39;admin\u0026#39;,\u0026#39;123456\u0026#39;); insert into tb_user (id, nickname, username, password) values (2,\u0026#39;呵呵\u0026#39;,\u0026#39;abcd\u0026#39;,\u0026#39;456\u0026#39;); insert into tb_user (id, nickname, username, password) values (3,\u0026#39;嘿嘿\u0026#39;,\u0026#39;aan\u0026#39;,\u0026#39;1234\u0026#39;); commit; -- 查询表 select * from tb_user; ```java\rpublic class User {\rprivate Integer id;\rprivate String nickname;\rprivate String username;\rprivate String password;\rpublic User(Integer id, String nickname, String username, String password) {\rthis.id = id;\rthis.nickname = nickname;\rthis.username = username;\rthis.password = password;\r}\rpublic User() {\r}\rpublic Integer getId() {\rreturn id;\r}\rpublic void setId(Integer id) {\rthis.id = id;\r}\rpublic String getNickname() {\rreturn nickname;\r}\rpublic void setNickname(String nickname) {\rthis.nickname = nickname;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic String getPassword() {\rreturn password;\r}\rpublic void setPassword(String password) {\rthis.password = password;\r}\r@Override\rpublic String toString() {\rreturn \"User{\" +\r\"id=\" + id +\r\", nickname='\" + nickname + '\\'' +\r\", username='\" + username + '\\'' +\r\", password='\" + password + '\\'' +\r'}';\r}\r}\r```\r```java\rimport java.sql.*;\rpublic class OracleConfig {\rpublic static Connection getConnection() {\rConnection connection = null;\rtry {\rClass.forName(\"oracle.jdbc.driver.OracleDriver\");\rconnection = DriverManager.getConnection(\"jdbc:oracle:thin:@localhost:1521/orcl\", \"root\", \"123456\");\r} catch (Exception e) {\rthrow new RuntimeException(e);\r}\rreturn connection;\r}\rpublic static void close(Connection connection, Statement statement, PreparedStatement preparedStatement, ResultSet resultSet){\rtry {\rresultSet.close();\rpreparedStatement.close();\rconnection.close();\r} catch (SQLException e) {\rthrow new RuntimeException(e);\r}\r}\r}\r```\r```java\rpublic interface UserMapper {\rList selectUsers();\r}\r```\r```java\rimport src.com.example.config.OracleConfig;\rimport src.com.example.domain.User;\rimport src.com.example.mapper.UserMapper;\rimport java.sql.*;\rimport java.util.ArrayList;\rimport java.util.List;\rpublic class UserMapperImpl implements UserMapper {\r@Override\rpublic List selectUsers() {\rList list = new ArrayList\u003c\u003e();\r// 建立连接\rConnection connection = OracleConfig.getConnection();\rPreparedStatement preparedStatement =null;\rResultSet resultSet =null;\rtry {\rpreparedStatement = connection.prepareStatement(\"select * from tb_user\");\rresultSet = preparedStatement.executeQuery();\rwhile (resultSet.next()){\r// 创建对象\rUser user=new User(\rresultSet.getInt(\"id\"),\rresultSet.getString(\"nickname\"),\rresultSet.getString(\"username\"),\rresultSet.getString(\"password\"));\rlist.add(user);\r}\r} catch (Exception e) {\rthrow new RuntimeException(e);\r}\r// 关闭资源\rOracleConfig.close(connection,null,preparedStatement,resultSet);\rreturn list;\r}\rstatic class MyTest{\rpublic static void main(String[] args) {\rUserMapperImpl userMapper = new UserMapperImpl();\rList list = userMapper.selectUsers();\rlist.forEach(System.out::println);\r}\r}\r}\r```\r\u003e 下图是演示结果\r![image-20230310224210463](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303102242670.png)\r### 关于在lib内导入jar包的操作\r\u003e 如果以上操作`依然无法连接到oracle`，请查看第二张图片内选择的模块是否正确\r### 可能出现的报错信息\r1. 表或视图不存在\r1. sql和数据库对不上\r2. 在数据库插入数据后执行以下commit操作`(非常重要！！！)`\r2. sql语句错误\r1. sql语句写错了\r2. sql语句内的末尾的分号去掉`(去掉;)`\r","date":"2023-03-10T00:00:00Z","image":"http://localhost:1313/p/01_jdbc%E8%BF%9E%E6%8E%A5oracle/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/01_jdbc%E8%BF%9E%E6%8E%A5oracle/","title":"01_Jdbc连接oracle"},{"content":"Optional使用\r安全的消费值\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 得到用户对象 * * @return */ public static User getUser() { User user = new User(); user.setUid(1); user.setUsername(\u0026#34;admin\u0026#34;); user.setPassword(\u0026#34;123456\u0026#34;); return user; } public static void main(String[] args) { User user = getUser(); Optional\u0026lt;User\u0026gt; userOptional = Optional.ofNullable(user); // 如果user对象不为空，则执行ifPresent的lambda表达式；反之，不执行 userOptional.ifPresent(item -\u0026gt; System.out.println(item.getUsername())); } 安全的获取值\rOptional对象的get方法(不推介) orElseGet()方法和orElseThrow()方法(推介) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 得到Optional\u0026lt;User\u0026gt;对象 * * @return */ public static Optional\u0026lt;User\u0026gt; getUser() { User user = new User(); user.setUid(1); user.setUsername(\u0026#34;admin\u0026#34;); user.setPassword(\u0026#34;123456\u0026#34;); return Optional.ofNullable(user); } public static void main(String[] args) { Optional\u0026lt;User\u0026gt; userEntity = getUser(); // 使用Optional对象的get方法来获取User值 System.out.println(userEntity.get()); } 1 2 3 4 // 不推介使用Optional对象的get方法，如果user对象为空，会抛出以下异常 Exception in thread \u0026#34;main\u0026#34; java.util.NoSuchElementException: No value present at java.util.Optional.get(Optional.java:135) at com.example.test.Test1.main(Test1.java:21) 推介使用orElseGet()方法和orElseThrow()方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 得到Optional\u0026lt;User\u0026gt;对象 * * @return */ public static Optional\u0026lt;User\u0026gt; getUser() { User user = new User(); user.setUid(1); user.setUsername(\u0026#34;admin\u0026#34;); user.setPassword(\u0026#34;123456\u0026#34;); return Optional.ofNullable(user); } public static void main(String[] args) { Optional\u0026lt;User\u0026gt; userEntity = getUser(); // 如果user对象为null，则会返回orElseGet内定义的默认值 User user = userEntity.orElseGet(() -\u0026gt; new User(2, \u0026#34;哈哈\u0026#34;, \u0026#34;123\u0026#34;)); System.out.println(user); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 得到Optional\u0026lt;User\u0026gt;对象 * * @return */ public static Optional\u0026lt;User\u0026gt; getUser() { User user = new User(); user.setUid(1); user.setUsername(\u0026#34;admin\u0026#34;); user.setPassword(\u0026#34;123456\u0026#34;); return Optional.ofNullable(null); } public static void main(String[] args) { Optional\u0026lt;User\u0026gt; userEntity = getUser(); // 如果该值为空，则会抛出异常，可通过Spring的全局异常处理优雅的返回值 User user = userEntity.orElseThrow(() -\u0026gt; new RuntimeException(\u0026#34;该值不可为空\u0026#34;)); System.out.println(user); } ","date":"2023-03-05T00:00:00Z","image":"http://localhost:1313/p/07_optional%E4%BD%BF%E7%94%A8/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/07_optional%E4%BD%BF%E7%94%A8/","title":"07_Optional使用"},{"content":"返回对象工具类\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import java.io.Serializable; public class Result\u0026lt;T\u0026gt; implements Serializable {//返回的结果集类 //服务器响应的状态 不是http状态 private Integer code; //备注 private String msg; //返回的数据 private T data; public Result() { } public Result(Integer code, String msg, T data) { this.code = code; this.msg = msg; this.data = data; } public Integer getCode() { return code; } public Result\u0026lt;?\u0026gt; setCode(Integer code) { this.code = code; return this; } public String getMsg() { return msg; } public Result\u0026lt;?\u0026gt; setMsg(String msg) { this.msg = msg; return this; } public T getData() { return data; } public Result\u0026lt;?\u0026gt; setData(T data) { this.data = data; return this; } @Override public String toString() { return \u0026#34;Result{\u0026#34; + \u0026#34;code=\u0026#34; + code + \u0026#34;, msg=\u0026#39;\u0026#34; + msg + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, data=\u0026#34; + data + \u0026#39;}\u0026#39;; } public Result\u0026lt;?\u0026gt; setCode(ResultEnum resultEnum) { this.code = resultEnum.code; return this; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 /** * 结果枚举 * * @author tong * @date 2023/03/04 */ public enum ResultEnum { /** * 成功 */ SUCCESS(200, \u0026#34;操作成功\u0026#34;), /** * 对象创建成功 */ CREATED(201, \u0026#34;对象创建成功\u0026#34;), /** * 请求已经被接受 */ ACCEPTED(202, \u0026#34;请求已经被接受\u0026#34;), /** * 操作已经执行成功，但是没有返回数据 */ NO_CONTENT(204, \u0026#34;操作已经执行成功，但是没有返回数据\u0026#34;), /** * 资源已被移除 */ MOVED_PERM(301, \u0026#34;资源已被移除\u0026#34;), /** * 重定向 */ SEE_OTHER(303, \u0026#34;重定向\u0026#34;), /** * 资源没有被修改 */ NOT_MODIFIED(304, \u0026#34;资源没有被修改\u0026#34;), /** * 参数列表错误（缺少，格式不匹配） */ BAD_REQUEST(400, \u0026#34;操作失败\u0026#34;), /** * 未授权 */ UNAUTHORIZED(401, \u0026#34;未授权\u0026#34;), /** * 访问受限，授权过期 */ FORBIDDEN(403, \u0026#34;访问受限，授权过期\u0026#34;), /** * 资源、服务未找到 */ NOT_FOUND(404, \u0026#34;资源，服务未找到\u0026#34;), /** * 不允许的http方法 */ BAD_METHOD(405, \u0026#34;不允许的http方法\u0026#34;), /** * 资源冲突，或者资源被锁 */ CONFLICT(409, \u0026#34;资源冲突，或者资源被锁\u0026#34;), /** * 不支持的数据、媒体类型 */ UNSUPPORTED_TYPE(415, \u0026#34;不支持的数据、媒体类型\u0026#34;), /** * 服务器内部错误 */ ERROR(500, \u0026#34;服务器内部错误\u0026#34;), /** * 接口未实现 */ NOT_IMPLEMENTED(501, \u0026#34;接口未实现\u0026#34;); public final Integer code; public final String msg; ResultEnum(Integer code, String msg) { this.code = code; this.msg = msg; } public Integer getCode() { return code; } public String getMsg() { return msg; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * 返回结果工具类 * * @author tong * @date 2023/03/04 */ public class ResultUtil { public static \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt; defineSuccess(Integer code, T data) { Result result = new Result\u0026lt;\u0026gt;(); return result.setCode(code).setData(data); } public static \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt; success(T data) { Result result = new Result(); result.setCode(ResultEnum.SUCCESS).setData(data); return result; } public static \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt; fail(String msg) { Result result = new Result(); result.setCode(ResultEnum.BAD_REQUEST).setMsg(msg); return result; } public static \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt; defineFail(Integer code, String msg){ Result result = new Result(); result.setCode(code).setMsg(msg); return result; } public static \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt; define(Integer code, String msg, T data){ Result result = new Result(); result.setCode(code).setMsg(msg).setData(data); return result; } public static Object defineSuccess(ResultEnum success, Object list) { Result result=new Result(); result.setCode(success); result.setData(list); return result; } } 用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private UserService userService; @GetMapping(\u0026#34;/id\u0026#34;) public Object getUser() { return ResultUtil.define( ResultEnum.SUCCESS.getCode(), ResultEnum.SUCCESS.getMsg(), userService.list() ); } } 其他返回工具类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Data @AllArgsConstructor @NoArgsConstructor public class JsonData { /** * 状态码 0 表示成功，1表示处理中，-1表示失败 */ private Integer code; /** * 数据 */ private Object data; /** * 描述 */ private String msg; // 成功，传入数据 public static JsonData buildSuccess() { return new JsonData(0, null, null); } // 成功，传入数据 public static JsonData buildSuccess(Object data) { return new JsonData(0, data, null); } // 失败，传入描述信息 public static JsonData buildError(String msg) { return new JsonData(-1, null, msg); } // 失败，传入描述信息,状态码 public static JsonData buildError(String msg, Integer code) { return new JsonData(code, null, msg); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /** * @Auther: Administrator * @Date: 2022/10/12/9:09 * @Description: */ import java.io.Serializable; public class JsonResult\u0026lt;T\u0026gt; implements Serializable { private Boolean success; private Integer errorCode; private String errorMsg; private T data; public JsonResult() { } public JsonResult(boolean success) { this.success = success; this.errorCode = success ? com.example.demo.util.ResultCode.SUCCESS.getCode() : com.example.demo.util.ResultCode.COMMON_FAIL.getCode(); this.errorMsg = success ? com.example.demo.util.ResultCode.SUCCESS.getMessage() : com.example.demo.util.ResultCode.COMMON_FAIL.getMessage(); } public JsonResult(boolean success, com.example.demo.util.ResultCode resultEnum) { this.success = success; this.errorCode = success ? com.example.demo.util.ResultCode.SUCCESS.getCode() : (resultEnum == null ? com.example.demo.util.ResultCode.COMMON_FAIL.getCode() : resultEnum.getCode()); this.errorMsg = success ? com.example.demo.util.ResultCode.SUCCESS.getMessage() : (resultEnum == null ? com.example.demo.util.ResultCode.COMMON_FAIL.getMessage() : resultEnum.getMessage()); } public JsonResult(boolean success, T data) { this.success = success; this.errorCode = success ? com.example.demo.util.ResultCode.SUCCESS.getCode() : com.example.demo.util.ResultCode.COMMON_FAIL.getCode(); this.errorMsg = success ? com.example.demo.util.ResultCode.SUCCESS.getMessage() : com.example.demo.util.ResultCode.COMMON_FAIL.getMessage(); this.data = data; } public JsonResult(boolean success, com.example.demo.util.ResultCode resultEnum, T data) { this.success = success; this.errorCode = success ? com.example.demo.util.ResultCode.SUCCESS.getCode() : (resultEnum == null ? com.example.demo.util.ResultCode.COMMON_FAIL.getCode() : resultEnum.getCode()); this.errorMsg = success ? com.example.demo.util.ResultCode.SUCCESS.getMessage() : (resultEnum == null ? com.example.demo.util.ResultCode.COMMON_FAIL.getMessage() : resultEnum.getMessage()); this.data = data; } public Boolean getSuccess() { return success; } public void setSuccess(Boolean success) { this.success = success; } public Integer getErrorCode() { return errorCode; } public void setErrorCode(Integer errorCode) { this.errorCode = errorCode; } public String getErrorMsg() { return errorMsg; } public void setErrorMsg(String errorMsg) { this.errorMsg = errorMsg; } public T getData() { return data; } public void setData(T data) { this.data = data; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /** * @Auther: Administrator * @Date: 2022/10/12/9:09 * @Description: */ public enum ResultCode { /* 成功 */ SUCCESS(200, \u0026#34;成功\u0026#34;), /* 默认失败 */ COMMON_FAIL(999, \u0026#34;失败\u0026#34;), /* 参数错误：1000～1999 */ PARAM_NOT_VALID(1001, \u0026#34;参数无效\u0026#34;), PARAM_IS_BLANK(1002, \u0026#34;参数为空\u0026#34;), PARAM_TYPE_ERROR(1003, \u0026#34;参数类型错误\u0026#34;), PARAM_NOT_COMPLETE(1004, \u0026#34;参数缺失\u0026#34;), /* 用户错误 */ USER_NOT_LOGIN(2001, \u0026#34;用户未登录\u0026#34;), USER_ACCOUNT_EXPIRED(2002, \u0026#34;账号已过期\u0026#34;), USER_CREDENTIALS_ERROR(2003, \u0026#34;密码错误\u0026#34;), USER_CREDENTIALS_EXPIRED(2004, \u0026#34;密码过期\u0026#34;), USER_ACCOUNT_DISABLE(2005, \u0026#34;账号不可用\u0026#34;), USER_ACCOUNT_LOCKED(2006, \u0026#34;账号被锁定\u0026#34;), USER_ACCOUNT_NOT_EXIST(2007, \u0026#34;账号不存在\u0026#34;), USER_ACCOUNT_ALREADY_EXIST(2008, \u0026#34;账号已存在\u0026#34;), USER_ACCOUNT_USE_BY_OTHERS(2009, \u0026#34;账号下线\u0026#34;), /* 业务错误 */ NO_PERMISSION(3001, \u0026#34;没有权限\u0026#34;); private Integer code; private String message; ResultCode(Integer code, String message) { this.code = code; this.message = message; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } /** * 根据code获取message * * @param code * @return */ public static String getMessageByCode(Integer code) { for (ResultCode ele : values()) { if (ele.getCode().equals(code)) { return ele.getMessage(); } } return null; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * @Auther: Administrator * @Date: 2022/10/12/9:10 * @Description: */ public class ResultTool { public static com.example.demo.util.JsonResult success() { return new com.example.demo.util.JsonResult(true); } public static \u0026lt;T\u0026gt; com.example.demo.util.JsonResult\u0026lt;T\u0026gt; success(T data) { return new com.example.demo.util.JsonResult(true, data); } public static com.example.demo.util.JsonResult fail() { return new com.example.demo.util.JsonResult(false); } public static com.example.demo.util.JsonResult fail(com.example.demo.util.ResultCode resultEnum) { return new com.example.demo.util.JsonResult(false, resultEnum); } } Redis配置及工具类\rRedis配置\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.serializer.SerializerFeature; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.type.TypeFactory; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.SerializationException; import com.alibaba.fastjson.parser.ParserConfig; import org.springframework.util.Assert; import java.nio.charset.Charset; /** * Redis使用FastJson序列化 * * @author sg */ public class FastJsonRedisSerializer\u0026lt;T\u0026gt; implements RedisSerializer\u0026lt;T\u0026gt; { public static final Charset DEFAULT_CHARSET = Charset.forName(\u0026#34;UTF-8\u0026#34;); private Class\u0026lt;T\u0026gt; clazz; static { ParserConfig.getGlobalInstance().setAutoTypeSupport(true); } public FastJsonRedisSerializer(Class\u0026lt;T\u0026gt; clazz) { super(); this.clazz = clazz; } @Override public byte[] serialize(T t) throws SerializationException { if (t == null) { return new byte[0]; } return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET); } @Override public T deserialize(byte[] bytes) throws SerializationException { if (bytes == null || bytes.length \u0026lt;= 0) { return null; } String str = new String(bytes, DEFAULT_CHARSET); return JSON.parseObject(str, clazz); } protected JavaType getJavaType(Class\u0026lt;?\u0026gt; clazz) { return TypeFactory.defaultInstance().constructType(clazz); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration public class RedisConfig { @Bean @SuppressWarnings(value = { \u0026#34;unchecked\u0026#34;, \u0026#34;rawtypes\u0026#34; }) public RedisTemplate\u0026lt;Object, Object\u0026gt; redisTemplate(RedisConnectionFactory connectionFactory) { RedisTemplate\u0026lt;Object, Object\u0026gt; template = new RedisTemplate\u0026lt;\u0026gt;(); template.setConnectionFactory(connectionFactory); FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class); // 使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(serializer); // Hash的key也采用StringRedisSerializer的序列化方式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; } } Redis工具类\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 import java.util.*; import java.util.concurrent.TimeUnit; @SuppressWarnings(value = { \u0026#34;unchecked\u0026#34;, \u0026#34;rawtypes\u0026#34; }) @Component public class RedisCache { @Autowired public RedisTemplate redisTemplate; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 */ public \u0026lt;T\u0026gt; void setCacheObject(final String key, final T value) { redisTemplate.opsForValue().set(key, value); } /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 * @param timeout 时间 * @param timeUnit 时间颗粒度 */ public \u0026lt;T\u0026gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) { redisTemplate.opsForValue().set(key, value, timeout, timeUnit); } /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout) { return expire(key, timeout, TimeUnit.SECONDS); } /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @param unit 时间单位 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout, final TimeUnit unit) { return redisTemplate.expire(key, timeout, unit); } /** * 获得缓存的基本对象。 * * @param key 缓存键值 * @return 缓存键值对应的数据 */ public \u0026lt;T\u0026gt; T getCacheObject(final String key) { ValueOperations\u0026lt;String, T\u0026gt; operation = redisTemplate.opsForValue(); return operation.get(key); } /** * 删除单个对象 * * @param key */ public boolean deleteObject(final String key) { return redisTemplate.delete(key); } /** * 删除集合对象 * * @param collection 多个对象 * @return */ public long deleteObject(final Collection collection) { return redisTemplate.delete(collection); } /** * 缓存List数据 * * @param key 缓存的键值 * @param dataList 待缓存的List数据 * @return 缓存的对象 */ public \u0026lt;T\u0026gt; long setCacheList(final String key, final List\u0026lt;T\u0026gt; dataList) { Long count = redisTemplate.opsForList().rightPushAll(key, dataList); return count == null ? 0 : count; } /** * 获得缓存的list对象 * * @param key 缓存的键值 * @return 缓存键值对应的数据 */ public \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; getCacheList(final String key) { return redisTemplate.opsForList().range(key, 0, -1); } /** * 缓存Set * * @param key 缓存键值 * @param dataSet 缓存的数据 * @return 缓存数据的对象 */ public \u0026lt;T\u0026gt; BoundSetOperations\u0026lt;String, T\u0026gt; setCacheSet(final String key, final Set\u0026lt;T\u0026gt; dataSet) { BoundSetOperations\u0026lt;String, T\u0026gt; setOperation = redisTemplate.boundSetOps(key); Iterator\u0026lt;T\u0026gt; it = dataSet.iterator(); while (it.hasNext()) { setOperation.add(it.next()); } return setOperation; } /** * 获得缓存的set * * @param key * @return */ public \u0026lt;T\u0026gt; Set\u0026lt;T\u0026gt; getCacheSet(final String key) { return redisTemplate.opsForSet().members(key); } /** * 缓存Map * * @param key * @param dataMap */ public \u0026lt;T\u0026gt; void setCacheMap(final String key, final Map\u0026lt;String, T\u0026gt; dataMap) { if (dataMap != null) { redisTemplate.opsForHash().putAll(key, dataMap); } } /** * 获得缓存的Map * * @param key * @return */ public \u0026lt;T\u0026gt; Map\u0026lt;String, T\u0026gt; getCacheMap(final String key) { return redisTemplate.opsForHash().entries(key); } /** * 往Hash中存入数据 * * @param key Redis键 * @param hKey Hash键 * @param value 值 */ public \u0026lt;T\u0026gt; void setCacheMapValue(final String key, final String hKey, final T value) { redisTemplate.opsForHash().put(key, hKey, value); } /** * 获取Hash中的数据 * * @param key Redis键 * @param hKey Hash键 * @return Hash中的对象 */ public \u0026lt;T\u0026gt; T getCacheMapValue(final String key, final String hKey) { HashOperations\u0026lt;String, String, T\u0026gt; opsForHash = redisTemplate.opsForHash(); return opsForHash.get(key, hKey); } /** * 删除Hash中的数据 * * @param key * @param hkey */ public void delCacheMapValue(final String key, final String hkey) { HashOperations hashOperations = redisTemplate.opsForHash(); hashOperations.delete(key, hkey); } /** * 获取多个Hash中的数据 * * @param key Redis键 * @param hKeys Hash键集合 * @return Hash对象集合 */ public \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; getMultiCacheMapValue(final String key, final Collection\u0026lt;Object\u0026gt; hKeys) { return redisTemplate.opsForHash().multiGet(key, hKeys); } /** * 获得缓存的基本对象列表 * * @param pattern 字符串前缀 * @return 对象列表 */ public Collection\u0026lt;String\u0026gt; keys(final String pattern) { return redisTemplate.keys(pattern); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class WebUtils { /** * 将字符串渲染到客户端 * * @param response 渲染对象 * @param string 待渲染的字符串 * @return null */ public static String renderString(HttpServletResponse response, String string) { try { response.setStatus(200); response.setContentType(\u0026#34;application/json\u0026#34;); response.setCharacterEncoding(\u0026#34;utf-8\u0026#34;); response.getWriter().print(string); } catch (IOException e) { e.printStackTrace(); } return null; } } JWT工具类\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 import io.jsonwebtoken.Claims; import io.jsonwebtoken.JwtBuilder; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; import java.util.Date; import java.util.UUID; /** * JWT工具类 */ public class JwtUtil { //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = \u0026#34;sangeng\u0026#34;; public static String getUUID(){ String token = UUID.randomUUID().toString().replaceAll(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;); return token; } /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) { JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); } /** * 生成jtw * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) { JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); } private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) { SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null){ ttlMillis=JwtUtil.JWT_TTL; } long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(\u0026#34;sg\u0026#34;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); } /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) { JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); } public static void main(String[] args) throws Exception { String token = \u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\u0026#34;; Claims claims = parseJWT(token); System.out.println(claims); } /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() { byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \u0026#34;AES\u0026#34;); return key; } /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception { SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); } } 密码加密存储\r​\t我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。 ​\t我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。 ​\t我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\n1 2 3 4 5 6 7 8 9 10 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */ @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } } 加密解密工具类\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import java.security.SecureRandom; // 加密、解密工具类 public class CryptUtil { private static final String AES = \u0026#34;AES\u0026#34;; private static int keysizeAES = 128; private static String charset = \u0026#34;UTF-8\u0026#34;; public static String parseByte2HexStr(final byte[] b) { final StringBuilder stringBuffer = new StringBuilder(); for (byte value : b) { String hex = Integer.toHexString(value \u0026amp; 0xFF); if (hex.length() == 1) { hex = \u0026#39;0\u0026#39; + hex; } stringBuffer.append(hex.toUpperCase()); } return stringBuffer.toString(); } public static byte[] parseHexStr2Byte(final String hexStr) { if (hexStr.length() \u0026lt; 1) { return null; } final byte[] result = new byte[hexStr.length() / 2]; for (int i = 0; i \u0026lt; hexStr.length() / 2; i++) { int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16); int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16); result[i] = (byte) (high * 16 + low); } return result; } private static String keyGeneratorES(final String res, final String algorithm, final String key, final Integer keysize, final boolean bEncode) { try { final KeyGenerator g = KeyGenerator.getInstance(algorithm); if (keysize == 0) { byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset); g.init(new SecureRandom(keyBytes)); } else if (key == null) { g.init(keysize); } else { byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset); SecureRandom random = SecureRandom.getInstance(\u0026#34;SHA1PRNG\u0026#34;); random.setSeed(keyBytes); g.init(keysize, random); } final SecretKey secretKey = g.generateKey(); final SecretKeySpec keySpec = new SecretKeySpec(secretKey.getEncoded(), algorithm); final Cipher cipher = Cipher.getInstance(algorithm); if (bEncode) { cipher.init(Cipher.ENCRYPT_MODE, keySpec); final byte[] result = charset == null ? res.getBytes() : res.getBytes(charset); return parseByte2HexStr(cipher.doFinal(result)); } else { cipher.init(Cipher.DECRYPT_MODE, keySpec); return new String(cipher.doFinal(parseHexStr2Byte(res))); } } catch (Exception e) { e.printStackTrace(); } return null; } public static String AESencode(final String res) { return keyGeneratorES(res, AES, \u0026#34;aAll*-%\u0026#34;, keysizeAES, true); } public static String AESdecode(final String res) { return keyGeneratorES(res, AES, \u0026#34;aAll*-%\u0026#34;, keysizeAES, false); } public static void main(String[] args) { System.out.println(\u0026#34;加密后:\u0026#34; + AESencode(\u0026#34;123456\u0026#34;)); System.out.println(\u0026#34;解密后:\u0026#34; + AESdecode(\u0026#34;555B695B57E024EEA169EAE275B9D93B\u0026#34;)); } } 常用pom依赖\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!--Swagger3.x--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--MyBatis-plus自动生成--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-generator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--velocity--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.velocity\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;velocity-engine-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--代码自动生成依赖--\u0026gt; \u0026lt;!--Json--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.vaadin.external.google\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;android-json\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.20131108.vaadin1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Swagger--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.swagger\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;swagger-annotations\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.22\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; swagger配置\r访问http://localhost:8090/swagger-ui/index.html即可查看接口文档\n1 2 3 4 5 6 \u0026lt;!--Swagger3.x--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 # ==========自定义swagger配置========== swagger.enable=true swagger.application-name=${spring.application.name} swagger.application-version=1.0 swagger.application-description=1024shop api info #swagger.application-description=1024shop电商平台管理后端接口文档 # 这里如果是中文，则会出现乱码，有以下两种解决方法 # 1. 修改文件编码 # 2. 使用yml格式 编码格式改为了ISO-8859-1，如果是配置yml文件，格式也需要更改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import io.swagger.annotations.ApiOperation; import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.oas.annotations.EnableOpenApi; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; /** * @Auther: 温豪 * @Date: 2022/11/30/15:05 * @Description: */ @Component @Data @ConfigurationProperties(\u0026#34;swagger\u0026#34;) // 映射到properties配置，省略前缀 @EnableOpenApi // 开启规范 public class SwaggerConfiguration { /** * 是否开启swagger，生产环境一般关闭，所以这里定义一个变量 */ private Boolean enable; /** * 项目应用名 */ private String applicationName; /** * 项目版本信息 */ private String applicationVersion; /** * 项目描述信息 */ private String applicationDescription; @Bean public Docket docket() { return new Docket(DocumentationType.OAS_30) .pathMapping(\u0026#34;/\u0026#34;) // 定义是否开启swagger，false为关闭，可以通过变量控制，线上关闭 .enable(enable) //配置api文档元信息 .apiInfo(apiInfo()) // 选择哪些接口作为swagger的doc发布 .select() //apis() 控制哪些接口暴露给swagger， // RequestHandlerSelectors.any() 所有都暴露 // RequestHandlerSelectors.basePackage(\u0026#34;net.xdclass.*\u0026#34;) 指定包位置 // withMethodAnnotation(ApiOperation.class)标记有这个注解 ApiOperation .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(applicationName) .description(applicationDescription) .contact(new Contact(\u0026#34;深海火锅店\u0026#34;, \u0026#34;tongstyle.gitee.io\u0026#34;, \u0026#34;938798576@aliyun.com\u0026#34;)) .version(applicationVersion) .build(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 主要注解 // 1.@Api() // 2.@ApiOperation() // 3.@ApiResponse() // 4.@ApiModel() // 5.@ApiModelProperty() @RestController @RequestMapping(\u0026#34;/user\u0026#34;) @Api(tags = \u0026#34;用户模块\u0026#34;, value = \u0026#34;用户controller\u0026#34;) // -------------------------------------------------- @ApiOperation(\u0026#34;用户登录\u0026#34;) @ApiResponses({ @ApiResponse(responseCode = \u0026#34;404\u0026#34;,description = \u0026#34;找不到该页面\u0026#34;), @ApiResponse(responseCode = \u0026#34;403\u0026#34;,description = \u0026#34;权限不够\u0026#34;) }) @ApiImplicitParams({ @ApiImplicitParam(name = \u0026#34;mobile\u0026#34;, value = \u0026#34;手机号码\u0026#34;, dataType = \u0026#34;string\u0026#34;, paramType = \u0026#34;query\u0026#34;, example = \u0026#34;13802780104\u0026#34;, required = true), @ApiImplicitParam(name = \u0026#34;user_name\u0026#34;, value = \u0026#34;登录账号\u0026#34;, dataType = \u0026#34;string\u0026#34;, paramType = \u0026#34;query\u0026#34;, example = \u0026#34;lihailin9073\u0026#34;, required = true), }) @PostMapping(\u0026#34;/login\u0026#34;) public Object login(@RequestBody User user) { return userService.login(user); } // -------------------------------------------------- // 这里千万要给get、set方法或者Data注解 @Data @ApiModel(value = \u0026#34;User对象\u0026#34;, description = \u0026#34;用户模型\u0026#34;) public class User implements Serializable { private static final long serialVersionUID = 1L; @TableId(value = \u0026#34;id\u0026#34;, type = IdType.AUTO) @ApiModelProperty(value = \u0026#34;主键\u0026#34;) private Integer id; @TableField(\u0026#34;username\u0026#34;) @ApiModelProperty(value = \u0026#34;用户名\u0026#34;, required = true, example = \u0026#34;admin\u0026#34;) private String username; @TableField(\u0026#34;password\u0026#34;) @ApiModelProperty(value = \u0026#34;密码\u0026#34;, required = true, example = \u0026#34;123456\u0026#34;) private String password; } 不加@RequestBody的情景，可以直接在Parameters获取到 加了@RequestBody的情景，显示No parameters，但Schema处可看到参数详情 MyBatis-plus配置\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 \u0026lt;!-- fastjson --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.72\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Swagger3.x--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--新版 mybatis-plus 自动生成器--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-generator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- freemarker --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.freemarker\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.31\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- web --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis-plus --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 自动生成\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 import java.util.Collections; import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.generator.FastAutoGenerator; import com.baomidou.mybatisplus.generator.config.OutputFile; import com.baomidou.mybatisplus.generator.config.rules.DateType; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; public class GeneratorTest { public static void main(String[] args) { // 配置相关的数据库连接 // TODO TODO FastAutoGenerator.create(\u0026#34;jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;) .globalConfig(builder -\u0026gt; { builder.author(\u0026#34;深海火锅店\u0026#34;) // 设置作者 .enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 // TODO TODO .outputDir(\u0026#34;src\\\\main\\\\java\\\\\u0026#34;) // 指定输出目录 .dateType(DateType.ONLY_DATE); }).packageConfig(builder -\u0026gt; { // TODO TODO builder.parent(\u0026#34;com.example.demo\u0026#34;) // 设置父包名 // .moduleName(\u0026#34;\u0026#34;) // 设置父包模块名 .entity(\u0026#34;domain\u0026#34;).controller(\u0026#34;controller\u0026#34;).mapper(\u0026#34;mapper\u0026#34;).service(\u0026#34;service\u0026#34;) .serviceImpl(\u0026#34;service.impl\u0026#34;) .pathInfo(Collections.singletonMap(OutputFile.xml, \u0026#34;src\\\\main\\\\resources\\\\mapper\\\\\u0026#34;)); // 设置mapperXml生成路径 }).strategyConfig(builder -\u0026gt; { // TODO TODO builder.addInclude(\u0026#34;user\u0026#34;)// 设置需要生成的表名 // TODO TODO // .addTablePrefix(\u0026#34;tb_\u0026#34;) // 设置过滤表前缀 .mapperBuilder() // 控制器controller配置 .controllerBuilder() // 开启生成@RestController 控制器 .enableRestStyle() // 开启驼峰转连字符 .enableHyphenStyle() // 开启父类 //\t.superClass(\u0026#34;com.example.demo.controller.BaseController\u0026#34;) // 控制器统一后缀 .formatFileName(\u0026#34;%sController\u0026#34;) // service配置 .serviceBuilder() // service统一后缀 .formatServiceFileName(\u0026#34;%sService\u0026#34;) // serviceImpl统一后缀 .formatServiceImplFileName(\u0026#34;%sServiceImpl\u0026#34;) // mapper配置 .mapperBuilder() // 生成基础字段的map映射map .enableBaseResultMap() // 生成基础查询的sql .enableBaseColumnList() // 实体类配置 .entityBuilder() // 开启链式模型，开启lombok模型不需要开启这个 // .enableChainModel() // 开启lombok模型 .enableLombok() // 开启表字段注解 .enableTableFieldAnnotation() // 逻辑删除字段 // TODO TODO .logicDeleteColumnName(\u0026#34;is_deleted\u0026#34;) // 数据库表映射到实体的命名策略 .naming(NamingStrategy.underline_to_camel) // 数据库表字段映射到实体的命名策略,驼峰命名，这个未设置会按照naming来配置 // .columnNaming(NamingStrategy.underline_to_camel) // 指定实体类父类 // .superClass(\u0026#34;com.mybatisplus.generator.entity.BaseEntity\u0026#34;) // 父类字段 // .addSuperEntityColumns(\u0026#34;id\u0026#34;, \u0026#34;create_id\u0026#34;, \u0026#34;modify_id\u0026#34;, \u0026#34;create_date\u0026#34;, \u0026#34;modify_date\u0026#34;, \u0026#34;is_deleted\u0026#34;) // 开启 ActiveRecord 模式，即实体类继承Model类,自己提供CRUD操作,不建议使用,会和父类形成单继承冲突 // .enableActiveRecord() // 表字段填充字段，对应数据库字段，插入的时候自动填充 .addTableFills(new Column(\u0026#34;create_date\u0026#34;, FieldFill.INSERT)) // 表字段填充字段，对应实体类字段，插入的时候自动填充 .addTableFills(new Property(\u0026#34;createDate\u0026#34;, FieldFill.INSERT)) // 表字段填充字段，对应数据库字段，更新的时候自动填充 .addTableFills(new Column(\u0026#34;modify_date\u0026#34;, FieldFill.UPDATE)) // 表字段填充字段，对应实体类字段，更新的时候自动填充 .addTableFills(new Property(\u0026#34;modifyDate\u0026#34;, FieldFill.UPDATE)) // 忽略的字段 //\t.addIgnoreColumns(\u0026#34;version\u0026#34;) // id自增 .idType(IdType.AUTO); // 实体类统一后缀 }).templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 应用名称 TODO spring.application.name=demo # 应用服务 WEB 访问端口 server.port=8080 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据源名称 spring.datasource.name=defaultDataSource # 数据库连接地址 TODO spring.datasource.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC # 数据库用户名\u0026amp;密码： TODO spring.datasource.username=root spring.datasource.password=123456 # 配置mybatis-plus 打印sql日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # xml文件路径 mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml # 配置最新全局配置文件 #mybatis-plus.config-location=classpath:mybatis-config.xml # 配置mybatis-plus 包路径 TODO mybatis-plus.type-aliases-package=com.example.demo.domain # mybatis-plus下划线转驼峰配置，默认为true mybatis-plus.configuration.map-underscore-to-camel-case=true # 配置全局默认主键类型，实体类不用加@TableId(value =\u0026#34;id\u0026#34;,type = IdType.AUTO) mybatis-plus.global-config.db-config.id-type=auto # 逻辑删除 （1为删除，0为未删除） #mybatis-plus.global-config.db-config.logic-delete-value=1 #mybatis-plus.global-config.db-config.logic-not-delete-value=0 # 如果java实体类没加注解@TableLogic，则可以配置这个，推介这里配置 #mybatis-plus.global-config.db-config.logic-delete-field=is_deleted 1 2 3 4 5 6 7 8 9 10 11 12 13 // 配置分页插件 @Configuration public class MyBatisPlusPaginationInnerConfig { /** * 分页插件（官网最新） */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 // 分页测试 @Test public void test1(){ // QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;\u0026gt;(); // wrapper.eq(\u0026#34;weight\u0026#34;,4); //第1页，每页2条 Page\u0026lt;User\u0026gt; page = new Page\u0026lt;\u0026gt;(1, 2); IPage\u0026lt;User\u0026gt; UserIPage = userMapper.selectPage(page, null); System.out.println(\u0026#34;总条数\u0026#34;+UserIPage.getTotal()); System.out.println(\u0026#34;总页数\u0026#34;+UserIPage.getPages()); //获取当前数据 System.out.println(UserIPage.getRecords().toString()); } FastJson\rfastjson jar包\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.72\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void returnJson() { User user = new User(1, \u0026#34;admin\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;哈哈\u0026#34;); System.out.println(\u0026#34;user1:\u0026#34; + user); // 对象转String System.out.println(\u0026#34;user2:\u0026#34; + JSON.toJSONString(user)); // 集合转json User user1 = new User(2, \u0026#34;张三\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;呵呵\u0026#34;); User user2 = new User(2, \u0026#34;李四\u0026#34;, \u0026#34;000\u0026#34;, \u0026#34;呵呵\u0026#34;); List\u0026lt;User\u0026gt; users = new ArrayList\u0026lt;User\u0026gt;(); users.add(user1); users.add(user2); System.out.println(\u0026#34;集合:\u0026#34; + JSON.toJSONString(users)); // 解析json对象 System.out.println(\u0026#34;解析:\u0026#34; + JSON.parseObject(JSON.toJSONString(user))); } 结果\n1 2 3 4 user1:com.example.demo.domain.User@5b251fb9 user2:{\u0026#34;id\u0026#34;:1,\u0026#34;nickName\u0026#34;:\u0026#34;哈哈\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123456\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;} 集合:[{\u0026#34;id\u0026#34;:2,\u0026#34;nickName\u0026#34;:\u0026#34;呵呵\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123456\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;张三\u0026#34;},{\u0026#34;id\u0026#34;:2,\u0026#34;nickName\u0026#34;:\u0026#34;呵呵\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;000\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;李四\u0026#34;}] 解析:{\u0026#34;password\u0026#34;:\u0026#34;123456\u0026#34;,\u0026#34;nickName\u0026#34;:\u0026#34;哈哈\u0026#34;,\u0026#34;id\u0026#34;:1,\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;} ","date":"2023-03-05T00:00:00Z","image":"http://localhost:1313/p/08_%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/08_%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB/","title":"08_常用配置、工具类"},{"content":"安装\rSpring Tools Suite 3\rspring-tool-suite-3.9.18 遇到的问题如下\n解决方法 装的jdk1.8，却显示17，这不是离谱吗？\njava_home配置也没有问题，确实是1.8的路径 原因出在oracle这里，将oracle一道java环境变量之下即可\n到这里还是依然报错，java版本不在11以上\n网上说把ini文件的11改为1.8即可，但我的还是报错，还是直接配置3.9.11版本或者sts4吧\n官网 spring-tool-suite-3.9.18（不推介） spring-tool-suite-3.9.11（推介） Spring Tools Suite 4\rspring-tool-suite-4-4.3.1\n配置\r取消空格或分号自动补全\r1 .abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY 快捷键配置\r这个是按照我的习惯配置的，如果不需要配置，请直接跳过 复制整行，如idea的ctrl+d，我习惯配置alt+d\n这个是代码提示快捷键\nformat 格式化代码快捷键\n方法提取(Extract method)\n全局查找(Find Text in File)\n开启注解提示\r配置maven\r配置本地java\r编码配置\r配置Lombok插件\rlombok jar包\n将lombok放在sts.exe文件处 双击jar包 配置字体\r配置代码模板\r自动导包\r配置tomcat\rwindow》show view》other》servers\n普通的java项目如何使用jar包\r","date":"2023-03-04T00:00:00Z","image":"http://localhost:1313/p/sts%E9%85%8D%E7%BD%AE/202412211431425_hu16431733443616631176.png","permalink":"http://localhost:1313/p/sts%E9%85%8D%E7%BD%AE/","title":"STS"},{"content":"tomcat安装及配置\rtomcat-8.5.87安装\n环境变量配置\r1 2 3 4 5 6 7 新建 CATALINA_HOME 值：解压后的路径，如D:\\apache-tomcat-8.5.87 path，新建 %CATALINA_HOME%\\bin 验证是否配置成功？ cmd输入startup.bat 打开localhost:8080 tomcat乱码\r","date":"2023-03-04T00:00:00Z","image":"http://localhost:1313/p/tomcat%E9%85%8D%E7%BD%AE/202412211436947_hu11472220631305509025.png","permalink":"http://localhost:1313/p/tomcat%E9%85%8D%E7%BD%AE/","title":"Tomcat"},{"content":"Elasticsearch基础\r环境配置\r![image-20230224221154537](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202302242212916.png)\r### 创建、查询、删除、修改 索引库\r```cmd\r# Click the Variables button, above, to create your own variables.\rGET ${exampleVariable1} // _search\r{\r\"query\": {\r\"${exampleVariable2}\": {} // match_all\r}\r}\rGET _analyze\r{\r\"analyzer\": \"pinyin\",\r\"text\": \"刘德华\"\r}\rGET _analyze\r{\r\"analyzer\": \"ik_smart\",\r\"text\": \"我的字典里没有白嫖\"\r}\rGET _analyze\r{\r\"analyzer\": \"ik_max_word\",\r\"text\": \"我的字典里没有白嫖\"\r}\r# 创建索引库\rPUT /user\r{\r\"mappings\": {\r\"properties\": {\r\"id\":{\r\"type\":\"keyword\",\r\"index\":false\r},\r\"nick_name\": {\r\"type\": \"text\",\r\"analyzer\": \"ik_smart\"\r},\r\"username\": {\r\"type\": \"keyword\",\r\"index\": false\r},\r\"password\": {\r\"type\": \"keyword\",\r\"index\": false\r}\r}\r}\r}\r# 查找索引库\rGET /user\r# 删除索引库\rDELETE /user\r# 修改索引库\r# 事实上，索引库创建后是不允许修改的\r# 修改字段时会导致原有的倒排索引失效\r# 禁止修改原有的字段，但可以添加新的字段\r# 一定要是一个全新的字段名，不能与原有的字段名相同\r# 修改索引库的本质是，添加新字段\rPUT /user/_mapping\r{\r\"properties\":{\r\"新字段名\":{\r\"type\":\"integer\"\r}\r}\r}\r```\r### 文档的CRUD操作\r```cmd\r# 插入文档\rPOST /user/_doc/1\r{\r\"nick_name\":\"小美\"\r}\r# 查询文档\rGET /user/_doc/1\r# 删除文档\rDELETE /user/_doc/1\r```\r#### 修改文档\r![image-20230224224312857](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202302242243003.png)\r```cmd\r# 全量修改文档\rPUT /user/_doc/1\r{\r\"nick_name\":\"小美\"\r}\r# 新增\r# 由于不存在id为2的文档\rPUT /user/_doc/2\r{\r\"nick_name\":\"妹妹\"\r}\r# 局部修改字段\rPOST /user/_update/1\r{\r\"doc\":{\r\"nick_name\":\"小美\"\r}\r}\r```\r","date":"2023-02-25T00:00:00Z","image":"http://localhost:1313/p/git/202412212118817_hu4777519752544750320.png","permalink":"http://localhost:1313/p/git/","title":"Elasticsearch基础"},{"content":"JDK下载\rjdk下载\nJava环境变量配置\r1 2 3 4 5 JAVA_HOME D:\\java\\jdk Path编辑，新增 %JAVA_HOME%\\bin %JAVA_HOME%\\jre\\bin ","date":"2023-02-18T00:00:00Z","image":"http://localhost:1313/p/java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/202412211340865_hu6537549549681616775.png","permalink":"http://localhost:1313/p/java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/","title":"Java"},{"content":"MySQL安装\r一直next 剩下的默认即可，一直next\nmysql环境变量配置\r1 2 path添加 D:\\MySQL\\MySQL Server 8.0\\bin MySQL时区配置\r打开mysql的安装目录，比如我的是D:\\MySQL\\MySQL Server 8.0 打开my.ini，添加下面这句，重启服务\n1 2 3 # [mysqld] # 永久更改时区，解决连接mysql时timeout的情况 default-time_zone = \u0026#39;+8:00\u0026#39; 1 2 # 查看时区是否设置成功 show variables like \u0026#34;%time_zone%\u0026#34;; 1 2 3 4 5 6 7 8 mysql\u0026gt; show variables like \u0026#34;%time_zone%\u0026#34;; +------------------+--------+ | Variable_name | Value | +------------------+--------+ | system_time_zone | | | time_zone | +08:00 | +------------------+--------+ 2 rows in set, 1 warning (0.01 sec) 若出现以上结果即可\n","date":"2023-02-18T00:00:00Z","image":"http://localhost:1313/p/mysql%E9%85%8D%E7%BD%AE/202412211354776_hu17520397624041452420.png","permalink":"http://localhost:1313/p/mysql%E9%85%8D%E7%BD%AE/","title":"MySQL"},{"content":"PowerDesigner安装\rPowerDesigner破解\r复制pdflm16.dll破解文件至安装文件夹，替换掉原本的文件\n注册表配置\r安装PowerDesigner之后，右键新建又多出了超级多的文件，这一步就是删除掉这些\n这数量，是不是巨恐怖？\nwin+R输入regedit，回车\n看一下文件后缀\n1 2 3 4 5 6 7 8 9 10 .BPM .CDM .DMM .EAM .FEM .LDM .OOM .PDM .RQM .XSM ","date":"2023-02-18T00:00:00Z","image":"http://localhost:1313/p/powerdesigner%E9%85%8D%E7%BD%AE/202412211427344_hu18091534060713237772.png","permalink":"http://localhost:1313/p/powerdesigner%E9%85%8D%E7%BD%AE/","title":"PowerDesigner"},{"content":"表单校验\rJSR303\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 给Bean添加校验注解 如@Email 标注的字段为邮箱、@NotNull 标注的字段不能为空、@Future 标注的字段必须是未来的时间、@Min标注最小值\n1 2 3 4 // 若不写message，则返回默认信息 @NotBlank(message = \u0026#34;用户名不能为空\u0026#34;) @TableField(value = \u0026#34;username\u0026#34;) private String username; 开启校验注解@Valid，告知spring方法需要开启校验这些字段，上面只是标注了校验规则，标注（@Valid）\n1 2 3 4 @PostMapping(\u0026#34;/test\u0026#34;) public String test(@Valid @RequestBody User user){ return \u0026#34;error1\u0026#34;; } 获取校验的结果，校验是否成功\u0026hellip;，紧跟参数后面添加BindingResult result，示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @PostMapping(\u0026#34;/test\u0026#34;) public Object test(@Valid @RequestBody User user, BindingResult result){ Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 如果校验出错 if (result.hasErrors()){ Map\u0026lt;String, String\u0026gt; error = new HashMap\u0026lt;\u0026gt;(); // 获取校验的错误结果 result.getFieldErrors().forEach((item)-\u0026gt;{ // FieldError 获取到错误提示 String message = item.getDefaultMessage(); // 获取错误的属性名字 String field = item.getField(); error.put(field,message); }); map.put(\u0026#34;code\u0026#34;,500); map.put(\u0026#34;message\u0026#34;,error); }else{ // 校验未出错 map.put(\u0026#34;code\u0026#34;,200); map.put(\u0026#34;message\u0026#34;,user); } return map; } 自定义校验规则\r1 2 3 4 // regexp内写 正则表达式 @Pattern(regexp = \u0026#34;/^[a-zA-Z0-9]$/\u0026#34;,message = \u0026#34;昵称必须是一个字母或数字\u0026#34;) @TableField(value = \u0026#34;nick_name\u0026#34;) private String nick_name; 配置全局异常处理\r类添加注解\n@ControllerAdvice 如果需要返回json数据，则需要在方法上加上@ResponseBody\n@RestControllerAdvice，默认返回json数据，方法不需要加@ResponseBody\n区别:参考@RestController和@Controller的\n方法添加处理器\n捕获全局异常，处理所有不可知异常\n@ExceptionHandler(value=Exception.class)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.RestControllerAdvice; @Slf4j @RestControllerAdvice(basePackages = \u0026#34;com.example.exceptiontest.controller\u0026#34;) public class UserExceptionControllerAdvice { @ExceptionHandler(value = Exception.class) public Object handleValidException(Exception e){ HashMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;message\u0026#34;,e.getMessage()); map.put(\u0026#34;class\u0026#34;,e.getClass().toString()); log.error(\u0026#34;数据校验出现异常:{}，异常类型:{}\u0026#34;,e.getMessage(),e.getClass()); return map; } } 既然要进行异常处理，那么上方配置的校验就需要抛出异常，去掉BindingResult即可\n1 2 3 4 5 6 7 @PostMapping(\u0026#34;/test2\u0026#34;) public Object test2(@Valid @RequestBody User user){ Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;code\u0026#34;,200); map.put(\u0026#34;message\u0026#34;,user); return map; } 指定的异常类型需要更精确才行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Slf4j @RestControllerAdvice(basePackages = \u0026#34;com.example.exceptiontest.controller\u0026#34;) public class UserExceptionControllerAdvice { @ExceptionHandler(value = MethodArgumentNotValidException.class) public Object handleValidException(MethodArgumentNotValidException e){ HashMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); BindingResult bindingResult = e.getBindingResult(); map.put(\u0026#34;code\u0026#34;,\u0026#34;400\u0026#34;); bindingResult.getFieldErrors().forEach((item)-\u0026gt;{ map.put(item.getField(),item.getDefaultMessage()); }); map.put(\u0026#34;msg\u0026#34;,\u0026#34;数据校验出现异常\u0026#34;); log.error(\u0026#34;数据校验出现异常:{}，异常类型:{}\u0026#34;,e.getMessage(),e.getClass()); return map; } } 为了更加统一、方便地编写返回状态码，可创建一个枚举类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public enum BizCodeEnume { /** * 系统未知异常 */ UNKNOWN_EXCEPTION(10000,\u0026#34;系统未知异常\u0026#34;), /** * 参数格式校验失败 */ VAILD_EXCEPTION(10001,\u0026#34;参数格式校验失败\u0026#34;); private final int code; private final String msg; BizCodeEnume(int code, String msg){ this.code = code; this.msg = msg; } /** * 获取状态码 * * @return int */ public int getCode() { return code; } /** * 获取信息 * * @return {@link String} */ public String getMsg() { return msg; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Slf4j @RestControllerAdvice(basePackages = \u0026#34;com.example.exceptiontest.controller\u0026#34;) public class UserExceptionControllerAdvice { @ExceptionHandler(value = MethodArgumentNotValidException.class) public Object handleValidException(MethodArgumentNotValidException e){ HashMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); BindingResult bindingResult = e.getBindingResult(); map.put(\u0026#34;code\u0026#34;, String.valueOf(BizCodeEnume.VAILD_EXCEPTION.getCode())); bindingResult.getFieldErrors().forEach((item)-\u0026gt;{ map.put(item.getField(),item.getDefaultMessage()); }); map.put(\u0026#34;msg\u0026#34;,BizCodeEnume.VAILD_EXCEPTION.getMsg()); log.error(\u0026#34;数据校验出现异常:{}，异常类型:{}\u0026#34;,e.getMessage(),e.getClass()); return map; } /** * 处理最大的异常 * * @param e e * @return {@link Object} */ @ExceptionHandler(value = Throwable.class) public Object handleException(Throwable e){ HashMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;code\u0026#34;,String.valueOf(BizCodeEnume.UNKNOWN_EXCEPTION.getCode())); map.put(\u0026#34;msg\u0026#34;,BizCodeEnume.UNKNOWN_EXCEPTION.getMsg()); return map; } } 自定义异常\r注释掉之前写过的@NotBlank(message = \u0026quot;用户名不能为空\u0026quot;)\u0026hellip;参数校验注解\n1 2 3 4 5 public class UsernameOrPasswordNULLException extends RuntimeException { public UsernameOrPasswordNULLException(String message) { super(message); } } 1 2 3 4 5 6 7 8 9 10 // 捕获UsernameOrPasswordNULLException异常 @ExceptionHandler(value = UsernameOrPasswordNULLException.class) public Object usernameOrPasswordIsNull(UsernameOrPasswordNULLException e){ HashMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 获取状态码 map.put(\u0026#34;code\u0026#34;, \u0026#34;501\u0026#34;); // 获取信息 map.put(\u0026#34;msg\u0026#34;,\u0026#34;用户名或密码为空\u0026#34;); return map; } 1 2 3 4 5 6 7 8 9 10 11 12 @PostMapping(\u0026#34;/test3\u0026#34;) public Object test3(@RequestBody User user){ String username=user.getUsername(); String password=user.getPassword(); if(username==null || \u0026#34;\u0026#34;.equals(username)||password==null ||\u0026#34;\u0026#34;.equals(password)){ throw new UsernameOrPasswordNULLException(\u0026#34;用户名或密码不能为空\u0026#34;); } Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;code\u0026#34;,200); map.put(\u0026#34;message\u0026#34;,user); return map; } 分组校验\r各个业务场景下的参数校验规则可能是不一样的 比如新增用户时，id字段自增，所以不需要填写，但删除用户时，id字段必须要填写\n此时需要使用到分组校验功能 给注解标明，何时使用A校验规则，何时使用B校验规则\n1 2 3 4 5 // 指定组AddGroup，新建AddGroup接口，什么都不用写;DeleteGroup 也一样 @Null(message = \u0026#34;新增用户时，不能指定用户id\u0026#34;,groups = {AddGroup.class}) @NotNull(message = \u0026#34;删除用户时，必须指定用户id\u0026#34;,groups = {DeleteGroup.class}) @TableId(value = \u0026#34;id\u0026#34;, type = IdType.AUTO) private Integer id; 1 2 3 4 public interface AddGroup { } public interface DeleteGroup { } 将@Valid注解 改为 @Validated注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @PostMapping(\u0026#34;/save\u0026#34;) public Object saveUser(@Validated({AddGroup.class}) @RequestBody User user) { boolean saveFlag = userService.save(user); Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;code\u0026#34;, 200); map.put(\u0026#34;message\u0026#34;, saveFlag ? \u0026#34;保存成功\u0026#34; : \u0026#34;保存失败\u0026#34;); return map; } @DeleteMapping(\u0026#34;/delete\u0026#34;) public Object deleteUser(@Validated({DeleteGroup.class}) @RequestBody User user) { boolean saveFlag = userService.removeById(user.getId()); Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;code\u0026#34;, 200); map.put(\u0026#34;message\u0026#34;, saveFlag ? \u0026#34;删除成功\u0026#34; : \u0026#34;删除失败\u0026#34;); return map; } 若校验注解如@NotNull不指定group，那么在执行方法时，会校验吗？ 答案是不会校验，不标注分组的校验注解是不起作用的 自定义校验\r若正则表达式无法满足业务需求，需要自定义校验逻辑\n编写自定义校验注解 编写自定义校验器 关联校验器和注解，让校验器来校验注解标注的字段 1 2 3 @NickValue(vals={\u0026#34;喜羊羊\u0026#34;,\u0026#34;灰太狼\u0026#34;}) @TableField(value = \u0026#34;nick_name\u0026#34;) private String nick_name; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import javax.validation.Constraint; import javax.validation.Payload; import java.lang.annotation.*; @Documented // 这里需要指定校验器，暂时先空着，等到后面再编写校验器 @Constraint( validatedBy = {} ) @Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE}) @Retention(RetentionPolicy.RUNTIME) public @interface NickValue { /** * 消息 * 这里写该注解的全类名 * 若校验失败，会前往ValidationMessages.properties来查询失败信息 * 所以我们需要自己配置一个ValidationMessages.properties * * @return {@link String} */ String message() default \u0026#34;{com.example.exceptiontest.valid.NickValue.message}\u0026#34;; Class\u0026lt;?\u0026gt;[] groups() default {}; Class\u0026lt;? extends Payload\u0026gt;[] payload() default {}; String[] vals() default {}; } 1 com.example.exceptiontest.valid.NickValue.message=昵称必须为指定的值 编写自定义校验器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import javax.validation.ConstraintValidator; import javax.validation.ConstraintValidatorContext; import java.util.HashSet; import java.util.Set; /** * 自定义昵称校验器 * ConstraintValidator\u0026lt;NickValue,String\u0026gt; 前面为注解，后面为校验的字段类型 * 如此时校验的字段是nickname，它的类型是String * * @author tong * @date 2023/02/18 */ public class NickValueConstraintValidator implements ConstraintValidator\u0026lt;NickValue,String\u0026gt; { private Set\u0026lt;String\u0026gt; set=new HashSet\u0026lt;String\u0026gt;(); /** * 初始化 * * @param constraintAnnotation 约束注释 */ @Override public void initialize(NickValue constraintAnnotation) { String[] vals = constraintAnnotation.vals(); for (String val : vals) { set.add(val); } } /** * 是否校验成功 * * @param s 昵称 * @param constraintValidatorContext 约束验证器上下文 * @return boolean */ @Override public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) { if(set.contains(s)){ return true; } return false; } } 别忘了在注解上添加对应的校验器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Documented // 添加对应的校验器 @Constraint( validatedBy = {NickValueConstraintValidator.class} ) @Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE}) @Retention(RetentionPolicy.RUNTIME) public @interface NickValue { /** * 消息 * 这里写该注解的全类名 * 若校验失败，会前往ValidationMessages.properties来查询失败信息 * 所以我们需要自己配置一个ValidationMessages.properties * * @return {@link String} */ String message() default \u0026#34;{com.example.exceptiontest.valid.NickValue.message}\u0026#34;; Class\u0026lt;?\u0026gt;[] groups() default {}; Class\u0026lt;? extends Payload\u0026gt;[] payload() default {}; String[] vals() default {}; } 打印一下错误信息\n1 2 3 4 5 6 7 8 9 10 11 @ExceptionHandler(value = Throwable.class) public Object handleException(Throwable e){ // 打印错误信息 log.error(\u0026#34;错误:\u0026#34;,e); HashMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 获取状态码 map.put(\u0026#34;code\u0026#34;,String.valueOf(BizCodeEnume.UNKNOWN_EXCEPTION.getCode())); // 获取信息 map.put(\u0026#34;msg\u0026#34;,BizCodeEnume.UNKNOWN_EXCEPTION.getMsg()); return map; } 指定分组\n1 2 3 @NickValue(vals={\u0026#34;喜羊羊\u0026#34;,\u0026#34;灰太狼\u0026#34;},groups = {AddGroup.class, DeleteGroup.class}) @TableField(value = \u0026#34;nick_name\u0026#34;) private String nick_name; 校验注解指定多个校验器\n1 2 3 4 // 这里可以添加多个校验器 @Constraint( validatedBy = {NickValueConstraintValidator.class} ) 此步骤参考博客\n按住ctrl+H 可以看到存在很多校验器 需要注意的问题如下 User UserController 在修改用户的时候，我们是需要传入密码和昵称的\n但是实际在个人主页修改个人昵称的时候，如果前端传递的user对象里只包含用户id和昵称而不包含密码，那么此时的校验无法通过 因为在修改方法内并未传入密码 但是也无法删除密码注解的UpdateGroup，否则修改密码的时候如果不传入密码也能通过校验\n原因是修改昵称和修改密码调用的是同一个修改方法和同一个UpdateGroup\n解决方法：修改方法分开编写，不要合并成同一个方法；同时创建一个新的修改分组，如UpdateNiceNameGroup\n","date":"2023-02-18T00:00:00Z","image":"http://localhost:1313/p/%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"表单校验+异常处理"},{"content":"1_Spring整合Junit\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;Spring_AOP_7_Junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Spring整合Junit依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.18\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 编写测试类\n在测试类上加上 @RunWith(SpringJUnit4ClassRunner.class)注解，指定让测试运行于Spring环境 @ContextConfiguration注解，指定Spring容器创建需要的配置文件或者配置类\n1 2 3 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = {\u0026#34;classpath:配置文件.xml\u0026#34;}) @ContextConfiguration(classes = spring配置类.class) 1 2 3 4 5 6 7 8 9 10 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = {\u0026#34;classpath:applicationContext.xml\u0026#34;}) public class MyTest { @Autowired private DoService doService; @Test public void test1(){ System.out.println(doService.success(\u0026#34;code\u0026#34;)); } } ","date":"2023-01-20T00:00:00Z","image":"http://localhost:1313/p/01_spring%E6%95%B4%E5%90%88junit/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/01_spring%E6%95%B4%E5%90%88junit/","title":"01_Spring整合Junit"},{"content":"2_MyBatis复习\r目录结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Spring_MyBatis ├─ src │ ├─ main │ │ ├─ java │ │ │ └─ com │ │ │ └─ example │ │ │ ├─ domain │ │ │ │ └─ User.java │ │ │ ├─ mapper │ │ │ │ └─ UserMapper.java │ │ │ └─ Demo.java │ │ └─ resources │ │ ├─ com │ │ │ └─ example │ │ │ └─ mapper │ │ │ └─ UserMapper.xml │ │ ├─ applicationContext.xml │ │ ├─ jdbc.properties │ │ └─ mybatis-config.xml │ └─ test │ └─ java └─ pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;Spring_MyBatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.30\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; mybatis-config.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--设置文件所在路径--\u0026gt; \u0026lt;properties resource=\u0026#34;jdbc.properties\u0026#34;/\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;!--指定包--\u0026gt; \u0026lt;package name=\u0026#34;com.example.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; jdbc.properties\n1 2 3 4 jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC jdbc.username=root jdbc.password=123456 UserMapper.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.example.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;resultMap id=\u0026#34;BaseResultMap\u0026#34; type=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;gender\u0026#34; column=\u0026#34;gender\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;address\u0026#34; column=\u0026#34;address\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;phone\u0026#34; column=\u0026#34;phone\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;sql id=\u0026#34;Base_Column_List\u0026#34;\u0026gt; id,name,gender, age,address,email, phone \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;selectByPrimaryKey\u0026#34; parameterType=\u0026#34;java.lang.Long\u0026#34; resultMap=\u0026#34;BaseResultMap\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34; /\u0026gt; from user where id = #{id,jdbcType=INTEGER} \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34; /\u0026gt; from user \u0026lt;/select\u0026gt; \u0026lt;delete id=\u0026#34;deleteByPrimaryKey\u0026#34; parameterType=\u0026#34;java.lang.Long\u0026#34;\u0026gt; delete from user where id = #{id,jdbcType=INTEGER} \u0026lt;/delete\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; keyColumn=\u0026#34;id\u0026#34; keyProperty=\u0026#34;id\u0026#34; parameterType=\u0026#34;com.example.domain.User\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34;\u0026gt; insert into user ( id,name,gender ,age,address,email ,phone) values (#{id,jdbcType=INTEGER},#{name,jdbcType=VARCHAR},#{gender,jdbcType=VARCHAR} ,#{age,jdbcType=INTEGER},#{address,jdbcType=VARCHAR},#{email,jdbcType=VARCHAR} ,#{phone,jdbcType=VARCHAR}) \u0026lt;/insert\u0026gt; \u0026lt;insert id=\u0026#34;insertSelective\u0026#34; keyColumn=\u0026#34;id\u0026#34; keyProperty=\u0026#34;id\u0026#34; parameterType=\u0026#34;com.example.domain.User\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34;\u0026gt; insert into user \u0026lt;trim prefix=\u0026#34;(\u0026#34; suffix=\u0026#34;)\u0026#34; suffixOverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;id != null\u0026#34;\u0026gt;id,\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt;name,\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt;gender,\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age != null\u0026#34;\u0026gt;age,\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;address != null\u0026#34;\u0026gt;address,\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;email != null\u0026#34;\u0026gt;email,\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;phone != null\u0026#34;\u0026gt;phone,\u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;trim prefix=\u0026#34;values (\u0026#34; suffix=\u0026#34;)\u0026#34; suffixOverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;id != null\u0026#34;\u0026gt;#{id,jdbcType=INTEGER},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt;#{name,jdbcType=VARCHAR},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt;#{gender,jdbcType=VARCHAR},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age != null\u0026#34;\u0026gt;#{age,jdbcType=INTEGER},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;address != null\u0026#34;\u0026gt;#{address,jdbcType=VARCHAR},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;email != null\u0026#34;\u0026gt;#{email,jdbcType=VARCHAR},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;phone != null\u0026#34;\u0026gt;#{phone,jdbcType=VARCHAR},\u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;updateByPrimaryKeySelective\u0026#34; parameterType=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; update user \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; name = #{name,jdbcType=VARCHAR}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; gender = #{gender,jdbcType=VARCHAR}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age != null\u0026#34;\u0026gt; age = #{age,jdbcType=INTEGER}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;address != null\u0026#34;\u0026gt; address = #{address,jdbcType=VARCHAR}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;email != null\u0026#34;\u0026gt; email = #{email,jdbcType=VARCHAR}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;phone != null\u0026#34;\u0026gt; phone = #{phone,jdbcType=VARCHAR}, \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id,jdbcType=INTEGER} \u0026lt;/update\u0026gt; \u0026lt;update id=\u0026#34;updateByPrimaryKey\u0026#34; parameterType=\u0026#34;com.example.domain.User\u0026#34;\u0026gt; update user set name = #{name,jdbcType=VARCHAR}, gender = #{gender,jdbcType=VARCHAR}, age = #{age,jdbcType=INTEGER}, address = #{address,jdbcType=VARCHAR}, email = #{email,jdbcType=VARCHAR}, phone = #{phone,jdbcType=VARCHAR} where id = #{id,jdbcType=INTEGER} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; UserMapper\n1 2 3 4 5 6 7 8 9 public interface UserMapper { List\u0026lt;User\u0026gt; selectAll(); int deleteByPrimaryKey(Long id); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Long id); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record); } User\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @Data @AllArgsConstructor @NoArgsConstructor public class User implements Serializable { /** * 用户id */ private Integer id; /** * 用户名字 */ private String name; /** * 用户性别 */ private String gender; /** * 用户年龄 */ private Integer age; /** * 用户地址 */ private String address; /** * 用户邮箱 */ private String email; /** * 用户手机号 */ private String phone; private static final long serialVersionUID = 1L; @Override public boolean equals(Object that) { if (this == that) { return true; } if (that == null) { return false; } if (getClass() != that.getClass()) { return false; } User other = (User) that; return (this.getId() == null ? other.getId() == null : this.getId().equals(other.getId())) \u0026amp;\u0026amp; (this.getName() == null ? other.getName() == null : this.getName().equals(other.getName())) \u0026amp;\u0026amp; (this.getGender() == null ? other.getGender() == null : this.getGender().equals(other.getGender())) \u0026amp;\u0026amp; (this.getAge() == null ? other.getAge() == null : this.getAge().equals(other.getAge())) \u0026amp;\u0026amp; (this.getAddress() == null ? other.getAddress() == null : this.getAddress().equals(other.getAddress())) \u0026amp;\u0026amp; (this.getEmail() == null ? other.getEmail() == null : this.getEmail().equals(other.getEmail())) \u0026amp;\u0026amp; (this.getPhone() == null ? other.getPhone() == null : this.getPhone().equals(other.getPhone())); } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((getId() == null) ? 0 : getId().hashCode()); result = prime * result + ((getName() == null) ? 0 : getName().hashCode()); result = prime * result + ((getGender() == null) ? 0 : getGender().hashCode()); result = prime * result + ((getAge() == null) ? 0 : getAge().hashCode()); result = prime * result + ((getAddress() == null) ? 0 : getAddress().hashCode()); result = prime * result + ((getEmail() == null) ? 0 : getEmail().hashCode()); result = prime * result + ((getPhone() == null) ? 0 : getPhone().hashCode()); return result; } @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(getClass().getSimpleName()); sb.append(\u0026#34; [\u0026#34;); sb.append(\u0026#34;Hash = \u0026#34;).append(hashCode()); sb.append(\u0026#34;, id=\u0026#34;).append(id); sb.append(\u0026#34;, name=\u0026#34;).append(name); sb.append(\u0026#34;, gender=\u0026#34;).append(gender); sb.append(\u0026#34;, age=\u0026#34;).append(age); sb.append(\u0026#34;, address=\u0026#34;).append(address); sb.append(\u0026#34;, email=\u0026#34;).append(email); sb.append(\u0026#34;, phone=\u0026#34;).append(phone); sb.append(\u0026#34;, serialVersionUID=\u0026#34;).append(serialVersionUID); sb.append(\u0026#34;]\u0026#34;); return sb.toString(); } } 测试MyBatis\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Demo { public static void main(String[] args) throws Exception { // 定义mybatis配置文件的路径 String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 获取UserMapper实现类对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 调用方法测试 List\u0026lt;User\u0026gt; users = userMapper.selectAll(); System.out.println(users); // 释放资源 sqlSession.close(); } } 14_Spring整合MyBatis\r参考文档\nMyBatis-String连接包版本对应\nMyBatis-Spring MyBatis Spring Framework Spring Batch Java 3.0 3.5+ 6.0+ 5.0+ Java 17+ 2.1 3.5+ 5.x 4.x Java 8+ 2.0 3.5+ 5.x 4.x Java 8+ 1.3 3.4+ 3.2.2+ 2.1+ Java 6+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;Spring_MyBatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Spring整合Junit依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.18\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Spring JDBC--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--ioc--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis整合spring--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--druid数据源--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.30\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 往容器中注入整合相关对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.example\u0026#34;/\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34;/\u0026gt; \u0026lt;!--配置Druid连接池--\u0026gt; \u0026lt;bean class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34; id=\u0026#34;dataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置Mapper扫描器，扫描到的mapper对象会被注入Spring容器中--\u0026gt; \u0026lt;bean class=\u0026#34;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026#34; id=\u0026#34;mapperScannerConfigurer\u0026#34;\u0026gt; \u0026lt;!--mapper.xml的路径--\u0026gt; \u0026lt;property name=\u0026#34;basePackage\u0026#34; value=\u0026#34;com.example.mapper\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34; id=\u0026#34;sqlSessionFactory\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;!--设置MyBatis配置文件的路径--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; mybatis-config.xml\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--别名配置--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.example.domain\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;/configuration\u0026gt; 测试\n1 2 3 4 5 6 7 8 9 10 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \u0026#34;classpath:applicationContext.xml\u0026#34;) public class MyTest { @Autowired private UserMapper userMapper; @Test public void test1(){ System.out.println(userMapper.selectAll()); } } MyBatis配置别名的作用\r例子 1 2 3 4 5 6 7 8 9 10 11 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \u0026#34;classpath:applicationContext.xml\u0026#34;) public class MyTest { @Autowired private UserMapper userMapper; @Test public void test1(){ User user = new User(4,\u0026#34;哈哈\u0026#34;,\u0026#34;男\u0026#34;,12,\u0026#34;湖南\u0026#34;,\u0026#34;xxx@qq.com\u0026#34;,\u0026#34;131xxxx5494\u0026#34;); userMapper.insert(user); } } 测试结果： 在配置了别名后，可继续使用上面的全类名写法，也可以只写类名\n1 2 3 4 5 6 7 8 9 10 11 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \u0026#34;classpath:applicationContext.xml\u0026#34;) public class MyTest { @Autowired private UserMapper userMapper; @Test public void test1(){ User user = new User(5,\u0026#34;呵呵\u0026#34;,\u0026#34;女\u0026#34;,15,\u0026#34;湖南\u0026#34;,\u0026#34;xxx@qq.com\u0026#34;,\u0026#34;131xxxx5494\u0026#34;); userMapper.insert(user); } } 它的作用是让Mapper.xml中的参数找到对应类,如下面parameterType=\u0026ldquo;User\u0026rdquo;，如果没有配置别名，则要改为parameterType=\u0026ldquo;com.example.domain.User\u0026rdquo;\u0026gt;\n","date":"2023-01-20T00:00:00Z","image":"http://localhost:1313/p/02_spring%E6%95%B4%E5%90%88mybatis/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/02_spring%E6%95%B4%E5%90%88mybatis/","title":"02_Spring整合MyBatis"},{"content":"3_事务\r事务的概念\n保证—组数据库的操作，要么同时成功，要么同时失败\n如：A转账给B，A的钱减少，B的钱增加\n事务的四大特性\r隔离性 多个事务之间要相互隔离，不能互相干扰 原子性 指事务是一个不可分割的整体，类似一个不可分割的原子 —致性 保障事务前后这组数据的状态是一致的。要么都是成功的，要么都是失败的。 持久性 指事务一旦被提交，这组操作修改的数据就真的的发生变化了。即使接下来数据库故障也不应该对其有影响。 声明式事务\r如果我们自己去对事务进行控制的话我们就需要值原来核心代码的基础上加上事务控制相关的代码。而在我们的实际开发中这种事务控制的操作也是非常常见的。所以Spring提供了声明式事务的方式让我们去控制事务。 只要简单的加个注解(或者是xml配置)就可以实现事务控制，不需要事务控制的时候只需要去掉相应的注解即可。\n转账案例-环境搭建\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Spring_MyBatis_1 ├─ src │ ├─ main │ │ ├─ java │ │ │ └─ com │ │ │ └─ example │ │ │ ├─ domain │ │ │ │ └─ Count.java │ │ │ ├─ mapper │ │ │ │ └─ CountMapper.java │ │ │ ├─ service │ │ │ │ ├─ impl │ │ │ │ │ └─ CountServiceImpl.java │ │ │ │ └─ CountService.java │ │ │ └─ Main.java │ │ └─ resources │ │ ├─ com │ │ │ └─ example │ │ │ └─ mapper │ │ │ └─ CountMapper.xml │ │ ├─ applicationContext.xml │ │ ├─ jdbc.properties │ │ └─ mybatis-config.xml │ └─ test │ └─ java │ └─ com │ └─ example │ └─ test │ └─ MyTest.java └─ pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;Spring_MyBatis_1\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Spring整合Junit依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.18\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Spring JDBC--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--ioc--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--aop--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis整合spring--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--druid数据源--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.30\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 1 2 3 4 jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC jdbc.username=root jdbc.password=123456 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!-- 打印sql日志 --\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;!--别名配置--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.example.domain\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;/configuration\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.example.mapper.CountMapper\u0026#34;\u0026gt; \u0026lt;resultMap id=\u0026#34;BaseResultMap\u0026#34; type=\u0026#34;com.example.domain.Count\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;money\u0026#34; column=\u0026#34;money\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;sql id=\u0026#34;Base_Column_List\u0026#34;\u0026gt; id ,name,money \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;selectByPrimaryKey\u0026#34; parameterType=\u0026#34;java.lang.Long\u0026#34; resultMap=\u0026#34;BaseResultMap\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34;/\u0026gt; from count where id = #{id,jdbcType=INTEGER} \u0026lt;/select\u0026gt; \u0026lt;delete id=\u0026#34;deleteByPrimaryKey\u0026#34; parameterType=\u0026#34;java.lang.Long\u0026#34;\u0026gt; delete from count where id = #{id,jdbcType=INTEGER} \u0026lt;/delete\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; keyColumn=\u0026#34;id\u0026#34; keyProperty=\u0026#34;id\u0026#34; parameterType=\u0026#34;com.example.domain.Count\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34;\u0026gt; insert into count (id, name, money) values (#{id,jdbcType=INTEGER}, #{name,jdbcType=VARCHAR}, #{money,jdbcType=INTEGER}) \u0026lt;/insert\u0026gt; \u0026lt;insert id=\u0026#34;insertSelective\u0026#34; keyColumn=\u0026#34;id\u0026#34; keyProperty=\u0026#34;id\u0026#34; parameterType=\u0026#34;com.example.domain.Count\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34;\u0026gt; insert into count \u0026lt;trim prefix=\u0026#34;(\u0026#34; suffix=\u0026#34;)\u0026#34; suffixOverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;id != null\u0026#34;\u0026gt;id,\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt;name,\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;money != null\u0026#34;\u0026gt;money,\u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;trim prefix=\u0026#34;values (\u0026#34; suffix=\u0026#34;)\u0026#34; suffixOverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;id != null\u0026#34;\u0026gt;#{id,jdbcType=INTEGER},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt;#{name,jdbcType=VARCHAR},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;money != null\u0026#34;\u0026gt;#{money,jdbcType=INTEGER},\u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;updateByPrimaryKeySelective\u0026#34; parameterType=\u0026#34;com.example.domain.Count\u0026#34;\u0026gt; update count \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; name = #{name,jdbcType=VARCHAR}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;money != null\u0026#34;\u0026gt; money = #{money,jdbcType=INTEGER}, \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id,jdbcType=INTEGER} \u0026lt;/update\u0026gt; \u0026lt;update id=\u0026#34;updateByPrimaryKey\u0026#34; parameterType=\u0026#34;com.example.domain.Count\u0026#34;\u0026gt; update count set name = #{name,jdbcType=VARCHAR}, money = #{money,jdbcType=INTEGER} where id = #{id,jdbcType=INTEGER} \u0026lt;/update\u0026gt; \u0026lt;update id=\u0026#34;updateMoney\u0026#34;\u0026gt; update count set money = money + #{updateMoney,jdbcType=INTEGER} where id = #{id,jdbcType=INTEGER} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @Data public class Count implements Serializable { /** * 账户id */ private Integer id; /** * 账户名 */ private String name; /** * 余额 */ private Integer money; private static final long serialVersionUID = 1L; @Override public boolean equals(Object that) { if (this == that) { return true; } if (that == null) { return false; } if (getClass() != that.getClass()) { return false; } Count other = (Count) that; return (this.getId() == null ? other.getId() == null : this.getId().equals(other.getId())) \u0026amp;\u0026amp; (this.getName() == null ? other.getName() == null : this.getName().equals(other.getName())) \u0026amp;\u0026amp; (this.getMoney() == null ? other.getMoney() == null : this.getMoney().equals(other.getMoney())); } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((getId() == null) ? 0 : getId().hashCode()); result = prime * result + ((getName() == null) ? 0 : getName().hashCode()); result = prime * result + ((getMoney() == null) ? 0 : getMoney().hashCode()); return result; } @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(getClass().getSimpleName()); sb.append(\u0026#34; [\u0026#34;); sb.append(\u0026#34;Hash = \u0026#34;).append(hashCode()); sb.append(\u0026#34;, id=\u0026#34;).append(id); sb.append(\u0026#34;, name=\u0026#34;).append(name); sb.append(\u0026#34;, money=\u0026#34;).append(money); sb.append(\u0026#34;, serialVersionUID=\u0026#34;).append(serialVersionUID); sb.append(\u0026#34;]\u0026#34;); return sb.toString(); } } 1 2 3 4 5 6 7 8 9 10 public interface CountMapper { int deleteByPrimaryKey(Long id); int insert(Count record); int insertSelective(Count record); Count selectByPrimaryKey(Long id); int updateByPrimaryKeySelective(Count record); int updateByPrimaryKey(Count record); // 增加和减少都是update void updateMoney(@Param(\u0026#34;id\u0026#34;) Integer id,@Param(\u0026#34;updateMoney\u0026#34;) Integer updateMoney); } 1 2 3 public interface CountService { void transfer(Integer outUserId, Integer inUserId, Integer money); } 1 2 3 4 5 6 7 8 9 10 11 12 @Service public class CountServiceImpl implements CountService { @Autowired private CountMapper countMapper; @Override public void transfer(Integer outUserId, Integer inUserId, Integer money) { // 增加 countMapper.updateMoney(inUserId, money); // 减少 countMapper.updateMoney(outUserId, -money); } } 测试方法\n1 2 3 4 5 6 7 8 9 10 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = {\u0026#34;classpath:applicationContext.xml\u0026#34;}) public class MyTest { @Autowired private CountService countService; @Test public void test1() { countService.transfer(1,2,10); } } 1 2 3 4 5 6 7 8 9 10 11 12 JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6f8e8894] will not be managed by Spring ==\u0026gt; Preparing: update count set money = money + ? where id = ? ==\u0026gt; Parameters: 10(Integer), 2(Integer) \u0026lt;== Updates: 1 Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@65f8f5ae] Creating a new SqlSession SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6f3187b0] was not registered for synchronization because synchronization is not active JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6f8e8894] will not be managed by Spring ==\u0026gt; Preparing: update count set money = money + ? where id = ? ==\u0026gt; Parameters: -10(Integer), 1(Integer) \u0026lt;== Updates: 1 Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6f3187b0] ","date":"2023-01-20T00:00:00Z","image":"http://localhost:1313/p/03_%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/03_%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/","title":"03_声明式事务"},{"content":"4_实现声明式事务\r这里会发生异常，用来模拟支付过程中的突发情况导致支付失败，如网络原因等\n测试后发现，前者的余额已经增加，但后者的余额由于发生异常导致没有减少\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;Spring_MyBatis_1\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Spring整合Junit依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.18\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Spring JDBC--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--ioc--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--aop--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis整合spring--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--druid数据源--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.30\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 注解实现\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.example\u0026#34;/\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34;/\u0026gt; \u0026lt;!--配置Druid连接池--\u0026gt; \u0026lt;bean class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34; id=\u0026#34;dataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置Mapper扫描器，扫描到的mapper对象会被注入Spring容器中--\u0026gt; \u0026lt;bean class=\u0026#34;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026#34; id=\u0026#34;mapperScannerConfigurer\u0026#34;\u0026gt; \u0026lt;!--mapper.xml的路径--\u0026gt; \u0026lt;property name=\u0026#34;basePackage\u0026#34; value=\u0026#34;com.example.mapper\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34; id=\u0026#34;sqlSessionFactory\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;!--设置MyBatis配置文件的路径--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--把事务管理器注入Spring容器，需要配置一个连接池--\u0026gt; \u0026lt;bean id=\u0026#34;txManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--开启事务注解驱动，配置使用的事务管理器--\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;txManager\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Service public class CountServiceImpl implements CountService { @Autowired private CountMapper countMapper; @Transactional @Override public void transfer(Integer outUserId, Integer inUserId, Integer money) { // 增加 countMapper.updateMoney(inUserId, money); //System.out.println(1/0); // 减少 countMapper.updateMoney(outUserId, -money); } } @Transactional可以加到方法上也可以加到类上，若在类上，则类中所有方法都被事务管理\nXML实现\r1 2 3 4 \u0026lt;!--把事务管理器注入Spring容器，需要配置一个连接池--\u0026gt; \u0026lt;bean id=\u0026#34;txManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--定义事务管理的通知类--\u0026gt; \u0026lt;tx:advice transaction-manager=\u0026#34;txManager\u0026#34; id=\u0026#34;txAdvice\u0026#34;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!--针对transfer进行事务控制--\u0026gt; \u0026lt;tx:method name=\u0026#34;transfer\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointCut\u0026#34; expression=\u0026#34;execution(* com.example.service..*.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;pointCut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; ","date":"2023-01-20T00:00:00Z","image":"http://localhost:1313/p/04_%E5%AE%9E%E7%8E%B0%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/04_%E5%AE%9E%E7%8E%B0%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/","title":"04_实现声明式事务"},{"content":"5_事务传播行为\r事务传播行为 propagation\r当事务方法嵌套调用时，需要控制是否开启新事务，可以使用事务传播行为来控制。 案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Service public class CountServiceImpl implements CountService { @Autowired private CountMapper countMapper; @Transactional @Override public void transfer(Integer outUserId, Integer inUserId, Integer money) { // 增加 countMapper.updateMoney(inUserId, money); //System.out.println(1/0); // 减少 countMapper.updateMoney(outUserId, -money); } @Transactional @Override public void log() { System.out.println(\u0026#34;记录日志\u0026#34;); int i = 1/0; } } 测试方法\n1 2 3 4 5 6 7 @Transactional public void test(){ // 转账 countService.transfer(1,2,10); // 记录日志 countService.log(); } 假如：转账正常，而记录日志出现异常；则会导致两者都被回滚\n属性值 行为 REQUIRED（必须要有） 外层方法有事务，内层方法就加入。外层没有，内层就新建 REQUIRES_NEW（必须要有新事务） 外层方法有事务，内层方法新建。外层没有，内层也新建 SUPPORTS（支持有） 外层方法有事务，内层方法就加入。外层没有，内层就也没有 NOT_SUPPORTED（支持没有） 外层方法有事务，内层方法没有。外层没有，内层也没有 MANDATORY（强制要求外层有） 外层方法有事务，内层方法加入。外层没有。内层就报错 NEVER(绝不允许有) 外层方法有事务，内层方法就报错。外层没有。内层就也没有 隔离级别 isolation\r1 2 3 4 5 6 7 8 9 @Transactional(propagation = Propagation.REQUIRES_NEW,isolation = Isolation.READ_COMMITTED) @Override public void transfer(Integer outUserId, Integer inUserId, Integer money) { // 增加 countMapper.updateMoney(inUserId, money); //System.out.println(1/0); // 减少 countMapper.updateMoney(outUserId, -money); } 隔离级别 行为 Isolation.DEFAULT 使用数据库默认隔离级别 Isolation.READ_COMMITTED Isolation.READ_UNCOMMITTED Isolation.REPEATABLE_READ Isolation.SERIALIZABLE 只读 readOnly\r如果事务中的操作都是读操作，没涉及到对数据的写操作可以设置readOnly为true。这样可以提高效率。\n1 2 3 4 5 @Transactional(readOnly = true) public void log(){ System.out.println(\u0026#34;打印日志\u0026#34;); int i = 1/0; } 注意：实际项目当中会将日志记录到数据库当中\n","date":"2023-01-20T00:00:00Z","image":"http://localhost:1313/p/05_%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/05_%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/","title":"05_事务传播行为"},{"content":" permalink: \u0026ldquo;/编程语言/Java/学习/框架/Spring/SpringAOP/10_多切面顺序问题.html\u0026rdquo; title: 10_多切面顺序问题 date: 2023-1-20 8:00:00 categories: \u0026ldquo;SpringAOP\u0026rdquo; tags: \u0026ldquo;SpringAOP\u0026rdquo;\r10_多切面顺序问题\r在实际项目中我们可能会存在配置了多个切面的情况。这种情况下我们很可能需要控制切面的顺序。我们在默认情况下Spring有它自己的排序规则。(按照类名排序) 默认排序规则往往不符合我们的要求，我们需要进行特殊控制。 如果是注解方式配置的AOP可以在切面类上加@Order注解来控制顺序。如果是XML方式配置的AOP,可以通过配置顺序来控制。\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.example\u0026#34;/\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 @Service public class DoService { public void doService(){ System.out.println(\u0026#34;doService\u0026#34;); } } 1 2 3 4 @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface Log { } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Component @Aspect @Order(2) public class MyAspect { @Pointcut(\u0026#34;execution(* com.example.service..*.doService(..))\u0026#34;) public void doService(){} @Around(\u0026#34;doService()\u0026#34;) public Object doAround(ProceedingJoinPoint pjp){ Object result = null; try { System.out.println(\u0026#34;MyAspect增强\u0026#34;); result=pjp.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); } return result; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Component @Aspect @Order(1) public class MyAspect2 { @Pointcut(\u0026#34;execution(* com.example.service..*.doService(..))\u0026#34;) public void doService(){} @Around(\u0026#34;doService()\u0026#34;) public Object doAround(ProceedingJoinPoint pjp){ Object result = null; try { System.out.println(\u0026#34;MyAspect2增强\u0026#34;); result=pjp.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); } return result; } } 1 2 3 4 5 6 7 public class Main { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); DoService bean = context.getBean(DoService.class); bean.doService(); } } 1 2 3 4 // 执行结果 MyAspect2增强 MyAspect增强 doService 总结\rorder越小，优先级越高\n","date":"2023-01-20T00:00:00Z","image":"http://localhost:1313/p/10_%E5%A4%9A%E5%88%87%E9%9D%A2%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/10_%E5%A4%9A%E5%88%87%E9%9D%A2%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/","title":"10_多切面顺序问题"},{"content":"11_AOP原理-动态代理\r实际上Spring的AOP其实底层就是使用动态代理来完成的。并且使用了两种动态代理分别是JDK的动态代理和Cglib动态代理。 所以我们接下去来学习下这两种动态代理，理解下它们的不同点。\nJDK动态代理\rJDK的动态代理使用的java.lang.reflect.Proxy这个类来进行实现的。要求被代理（被增强)的类需要实现了接口。并且JDK动态代理也只能对接口中的方法进行增强。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Main { public static void main(String[] args) { AIControllerImpl aiController = new AIControllerImpl(); //String answer = aiController.getAnswer(\u0026#34;张三很帅吗？\u0026#34;); //System.out.println(answer); // 使用动态代理增强getAnswer方法 // 1.JDK动态代理 // 获取类加载器 ClassLoader classLoader = Main.class.getClassLoader(); // 被代理类所实现接口的字节码对象数组 Class\u0026lt;?\u0026gt;[] interfaces = AIControllerImpl.class.getInterfaces(); // 使用代理对象（proxy）时，会调用invoke AIController proxy = (AIController) Proxy.newProxyInstance(classLoader, interfaces, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // proxy是代理对象 // method是当前被调用的方法封装的Method对象 // args是调用方法时传入的参数 // 调用被代理对象的对应方法 // 判断当前调用的是否是getAnswer方法 if (\u0026#34;getAnswer\u0026#34;.equals(method.getName())) { System.out.println(\u0026#34;已增强\u0026#34;); } Object ret = method.invoke(aiController, args); return ret; } }); String answer1 = proxy.getAnswer(\u0026#34;张三很帅？\u0026#34;); System.out.println(answer1); } } Cglib动态代理\r使用的是org.springframework.cglib.proxy.Enhancer类进行实现的。 已被spring中包含，pom导入ioc依赖即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Demo { public static void main(String[] args) { Enhancer enhancer = new Enhancer(); // 设置父类的字节码对象。即enhancer生成的代理对象为AIControllerImpl的子对象 enhancer.setSuperclass(AIControllerImpl.class); // 设置回调函数 enhancer.setCallback(new MethodInterceptor() { // 使用代理对象执行方法时，都会调用到intercept方法中 @Override public Object intercept(Object o, Method method, Object[] objects /*传入参数的数组*/, MethodProxy methodProxy) throws Throwable { // 判断当前调用的方法是不是getAnswer,若是，则进行增强 if(\u0026#34;getAnswer\u0026#34;.equals(method.getName())) { System.out.println(\u0026#34;方法已增强\u0026#34;); } // methodProxy.invokeSuper(); // 调用父类中对应的方法 return methodProxy.invokeSuper(o, objects); } }); // 生成代理对象 AIControllerImpl proxy = (AIControllerImpl) enhancer.create(); System.out.println(proxy.getAnswer(\u0026#34;我帅吗\u0026#34;)); } } 总结\rJDK动态代理要求被代理（被增强）的类必须要实现接口，生成的代理对象相当于是被代理对象的兄弟。\nCglib的动态代理不要求被代理（被增强）的类要实现接口，生成的代理对象相当于被代理对象的子类对象。\nSpring的AOP默认情况下优先使用的是JDK的动态代理，如果使用不了JDK的动态代理才会使用Cglib的动态代理。\n","date":"2023-01-20T00:00:00Z","image":"http://localhost:1313/p/11_aop%E5%8E%9F%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/11_aop%E5%8E%9F%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","title":"11_AOP原理-动态代理"},{"content":"12_注解方式配置AOP如何切换动态代理类型\r有的时候我们需要修改AOP的代理方式。我们可以使用以下方式修改: 如果我们是采用注解方式配置AOP的话: 设置aop:aspectj-autoproxy标签的proxy-target-class属性为true，代理方式就会修改成Cglib\n1 \u0026lt;aop:aspectj-autoproxy proxy-target-class=\u0026#34;true\u0026#34;/\u0026gt; 如果我们是采用xml方式配置AOP的话: 设置aop:config标签的proxy-target-class属性为true,代理方式就会修改成Cglib\n1 \u0026lt;aop:config proxy-target-class=\u0026#34;true\u0026#34;/\u0026gt; ","date":"2023-01-20T00:00:00Z","image":"http://localhost:1313/p/12_%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AEaop%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/12_%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AEaop%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B/","title":"12_注解方式配置AOP如何切换动态代理类型"},{"content":" 之前一直在做谷粒商城，确实学到了不少知识点，还有黑马的一个微服务全栈课程（哔哩哔哩有） 感觉学了不少，eruka、nacos、feign、rabbitmq、es 但是吧，一直往下学，感觉之前学过的知识点又不太清晰了 就准备了这个小项目试试水，结果\u0026hellip;泪目了\nspringboot、springcloud、springcloud alibaba版本不匹配\r这个错误仅代表其中一种，意思就是版本不匹配 大部分的错误都是版本不匹配、冲突造成 如java.lang.AbstractMethodError: null、等 折磨了我半天 在博客上找了好多所谓的“毕业版本依赖关系(推介使用)” 然后就是不停的报java.lang.AbstractMethodError: null这个错 网上说是由于版本不匹配造成，项目根本跑不起来 github上有版本说明，详情查看\nSpring Cloud Alibaba Version Spring Cloud Version Spring Boot Version 2021.0.4.0* Spring Cloud 2021.0.4 2.6.11 2021.0.1.0 Spring Cloud 2021.0.1 2.6.3 2021.1 Spring Cloud 2020.0.1 2.4.2 2.2.10-RC1* Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.9.RELEASE Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.8.RELEASE Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.7.RELEASE Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.6.RELEASE Spring Cloud Hoxton.SR9 2.3.2.RELEASE 2.2.1.RELEASE Spring Cloud Hoxton.SR3 2.2.5.RELEASE 2.2.0.RELEASE Spring Cloud Hoxton.RELEASE 2.2.X.RELEASE 2.1.4.RELEASE Spring Cloud Greenwich.SR6 2.1.13.RELEASE 2.1.2.RELEASE Spring Cloud Greenwich 2.1.X.RELEASE 2.0.4.RELEASE(停止维护，建议升级) Spring Cloud Finchley 2.0.X.RELEASE 1.5.1.RELEASE(停止维护，建议升级) Spring Cloud Edgware 1.5.X.RELEASE Spring Cloud Alibaba Version Sentinel Version Nacos Version \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- 2.2.10-RC1 1.8.6 2.2.0 2022.0.0.0-RC1 1.8.6 2.2.1-RC 2.2.9.RELEASE 1.8.5 2.1.0 2021.0.4.0 1.8.5 2.0.4 2.2.8.RELEASE 1.8.4 2.1.0 2021.0.1.0 1.8.3 1.4.2 2.2.7.RELEASE 1.8.1 2.0.3 2.2.6.RELEASE 1.8.1 1.4.2 2021.1 or 2.2.5.RELEASE or 2.1.4.RELEASE or 2.0.4.RELEASE 1.8.0 1.4.1 2.2.3.RELEASE or 2.1.3.RELEASE or 2.0.3.RELEASE 1.8.0 1.3.3 2.2.1.RELEASE or 2.1.2.RELEASE or 2.0.2.RELEASE 1.7.1 1.2.1 2.2.0.RELEASE 1.7.1 1.1.4 2.1.1.RELEASE or 2.0.1.RELEASE or 1.5.1.RELEASE 1.7.0 1.1.4 2.1.0.RELEASE or 2.0.0.RELEASE or 1.5.0.RELEASE 1.6.3 1.1.1 这里我用的是2.3.12.RELEASE的springboot、Hoxton.SR12的springcloud、2.2.9.RELEASE的springcloud alibaba，但是有个需要注意的地方，nacos的版本需要在2.1.0，我以前用的nacos是1.4.1，报错nacos版本不匹配，详情查看 1 com.alibaba.nacos.api.exception.NacosException: Request nacos server failed: 这里我找了好多博文，发现了这样一篇，原文连接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--spring boot--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring cloud--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring cloud alibaba--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-alibaba.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 我一直以来并不是这种写法，而是如下写法\n1 2 3 4 5 6 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.12.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; 第一次发现还有这种写法，记录一下\nnacos动态刷新\u0026ndash;空指针\r详情参考这篇博客在nacos中实现自动热部署用@RefreshScope出现空指针异常。 今天使用nacos的时候发现了这个问题 只有配置中心出现了问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @RefreshScope @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { @Value(\u0026#34;${app.user.name}\u0026#34;) private String name; @Value(\u0026#34;${app.user.gender}\u0026#34;) private String gender; @Value(\u0026#34;${app.user.age}\u0026#34;) private Integer age; @Autowired private UserService userService; @GetMapping(\u0026#34;/list\u0026#34;) public R listUser(){ return R.ok().put(\u0026#34;data\u0026#34;,userService.list()); } @GetMapping(\u0026#34;/{id}\u0026#34;) private R getUser(@PathVariable(\u0026#34;id\u0026#34;) Integer id){ return R.ok().put(\u0026#34;data\u0026#34;,userService.getOne(new QueryWrapper\u0026lt;User\u0026gt;().eq(\u0026#34;id\u0026#34;,id))); } @GetMapping(\u0026#34;/test1\u0026#34;) private R test1(){ return R.ok().put(\u0026#34;name\u0026#34;,name).put(\u0026#34;gender\u0026#34;,gender).put(\u0026#34;age\u0026#34;,age); } } 就这么一个简单的controller，添加@RefreshScope注解之前都没问题 加了之后user/{id}就开始报空指针了 小泽不会Java大佬是这么解释的：@RefreshScope他的默认代理方式是CGLIB，但是spring中默认的代理也是CGLIB，就相当于它被代理了两次，这样可能就会导致数据消失 解决方法1：将@RefreshScope改为@RefreshScope(proxyMode = ScopedProxyMode.DEFAULT)\n解决方法2：不使用@RefreshScope，使用@ConfigurationProperties注解\n注意：不是使用@ConfigurationProperties注解来替换@RefreshScope，详细请看下文\n1 2 3 app.user.name=深海 app.user.age=22 app.user.gender=男 1 2 3 4 5 6 7 8 9 // 配置类 @Data @Component @ConfigurationProperties(prefix = \u0026#34;app.user\u0026#34;) public class PatternProperties { private String name; private String gender; private Integer age; } 1 2 3 4 5 6 7 8 9 10 11 12 13 @PropertySource(\u0026#34;classpath:test.properties\u0026#34;) @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { @Autowired private PatternProperties properties; @Autowired private UserService userService; @GetMapping(\u0026#34;/test1\u0026#34;) private R test1(){ return R.ok().put(\u0026#34;name\u0026#34;,properties.getName()).put(\u0026#34;gender\u0026#34;,properties.getGender()).put(\u0026#34;age\u0026#34;,properties.getAge()); } } 人人开源-代码生成\u0026ndash;500\r老实说，这些谷粒商城的视频里都有，时间太久，我有些记不清了 在url地址栏输入localhost:80，之后回车，变成了localhost，报500 看到了这样一篇博客 和博主是一样的问题 解决方法：http://localhost:/index.html 人人开源-代码生成\u0026ndash;serviceimpl报错\r看到了一篇博客，说是导包的问题 我看了又看，包没有什么问题，并不是这个原因\n接下来又看到了这篇博客的p17，是一个大佬记录自己的谷粒商城踩坑记录\n第17条，serviceImpl 分页代码报错问题，那是因为你copy代码的时候去的是renrengenerator模块，应该去renrenfast 里面copy。\n恍然大悟，确实是这样，解决方法就是去renren-fast里复制\n以前没注意到这个问题，没踩过这个坑，现在终于补齐了\u0026hellip;\nopen feign返回值为null\rfeign的调用是成功了一半，可以看到user服务已经查询到了，但奇怪的是vacc服务没接收到\n上网搜了一下为null的情况，查看\n对比了一下自己的代码，@EnableFeignClients、@EnableDiscoveryClient、@FeignClient(\u0026quot;vaccine-user\u0026quot;)\n注解该在的都在，不是这个问题\n返回数据中多对一实体中还包含了一对多的关系也会返回null，我之前数据库里确实有写一对多的数据 本来是想试验一下来着，但仔细一看代码，不是这个问题\n错误原因：返回值的问题，被调用的方法的返回值是renren-fast的R，但clients接口的返回值是User 这个就是纯纯粗心了，太憨了 排除mybatis-plus相关依赖\r这是由于导入了mybatis-plus相关依赖却没有配置数据库的原因 但是网关服务本就不需要配置数据库 所以解决方法就是把相关依赖排除在外\n1 2 3 4 5 6 7 @EnableDiscoveryClient @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) public class VaccineGatewayApplication { public static void main(String[] args) { SpringApplication.run(VaccineGatewayApplication.class, args); } } ","date":"2023-01-20T00:00:00Z","image":"http://localhost:1313/p/alibaba%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81nacosopenfeign/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/alibaba%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81nacosopenfeign/","title":"Alibaba版本冲突、Nacos、OpenFeign"},{"content":"Spring Project\rSpringIOC SpringAOP、MyBatis\n","date":"2023-01-20T00:00:00Z","image":"http://localhost:1313/p/springioc-springaop-mybatis/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/springioc-springaop-mybatis/","title":"SpringIOC+SpringAOP+MyBatis"},{"content":"09_使用xml的方式配置AOP\r定义切面类 目标类和切面类注入容器 配置AOP 1 2 3 4 5 project.user.uid=2 project.user.username=李四 project.user.password=111111 project.phone.number=13195868989 project.phone.type=电信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface InvokeLog { } @Component public class MyAspect { @Pointcut(\u0026#34;execution(* com.example.service..*.*(..))\u0026#34;) public void servicePointCut() { } public void before(JoinPoint point){ MethodSignature signature = (MethodSignature) point.getSignature(); System.out.println(\u0026#34;方法所在的全类名是:\u0026#34;+signature.getDeclaringTypeName()); System.out.println(\u0026#34;方法名称是:\u0026#34;+signature.getName()); System.out.println(\u0026#34;方法参数是:\u0026#34;+ Arrays.toString(point.getArgs())); } public void after(JoinPoint point){ MethodSignature signature = (MethodSignature) point.getSignature(); System.out.println(\u0026#34;方法所在的全类名是:\u0026#34;+signature.getDeclaringTypeName()); System.out.println(\u0026#34;方法名称是:\u0026#34;+signature.getName()); System.out.println(\u0026#34;方法参数是:\u0026#34;+ Arrays.toString(point.getArgs())); } public void afterReturning(JoinPoint point,Object result){ MethodSignature signature = (MethodSignature) point.getSignature(); System.out.println(\u0026#34;方法所在的全类名是:\u0026#34;+signature.getDeclaringTypeName()); System.out.println(\u0026#34;方法名称是:\u0026#34;+signature.getName()); System.out.println(\u0026#34;方法参数是:\u0026#34;+ Arrays.toString(point.getArgs())); System.out.println(\u0026#34;result:\u0026#34;+result); } public void afterThrowing(JoinPoint point,Throwable throwable){ System.out.println(\u0026#34;方法的异常对象是:\u0026#34;+throwable); } public Object around(ProceedingJoinPoint point) { // 方法调用时传入的参数 Object[] args = point.getArgs(); // 被代理对象 Object target = point.getTarget(); // 获取被增强方法签名封装的对象 MethodSignature signature = (MethodSignature) point.getSignature(); Object proceed = null; try { proceed = point.proceed(); } catch (Throwable e) { throw new RuntimeException(e); } return proceed; } } @Data @Component public class User { @Value(\u0026#34;${project.user.uid}\u0026#34;) private Integer uid; @Value(\u0026#34;${project.user.username}\u0026#34;) private String username; @Value(\u0026#34;${project.user.password}\u0026#34;) private String password; } @Service public class UserService { @InvokeLog public void addUser(User user) { System.out.println(\u0026#34;新增用户\u0026#34;); } @InvokeLog public void updateUser(User user) { System.out.println(\u0026#34;修改用户\u0026#34;); } @InvokeLog public void deleteUser(Integer id) { System.out.println(\u0026#34;删除用户\u0026#34;); } @InvokeLog public User getUserById(Integer id) { System.out.println(\u0026#34;查询用户\u0026#34;); //List\u0026lt;Integer\u0026gt; num = null; //num.add(1); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); return context.getBean(User.class); } @InvokeLog public void testUser(){ System.out.println(\u0026#34;测试用户\u0026#34;); } } public class Main { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserService service = context.getBean(UserService.class); User userById = service.getUserById(1); // 这里userById为null的原因，是因为这是前置通知，目标方法还未执行，所以没有返回值 System.out.println(\u0026#34;返回值是:\u0026#34;+userById); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.example\u0026#34;/\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:project.properties\u0026#34;/\u0026gt; \u0026lt;!--配置AOP--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--定义切点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointCut\u0026#34; expression=\u0026#34;@annotation(com.example.aspect.InvokeLog)\u0026#34;/\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointCut1\u0026#34; expression=\u0026#34;execution(* com.example.service..*.*(..))\u0026#34;/\u0026gt; \u0026lt;!--配置通知方法--\u0026gt; \u0026lt;aop:aspect id=\u0026#34;myAspect\u0026#34; ref=\u0026#34;myAspect\u0026#34;\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;pointCut\u0026#34;/\u0026gt; \u0026lt;aop:after method=\u0026#34;after\u0026#34; pointcut-ref=\u0026#34;pointCut\u0026#34;/\u0026gt; \u0026lt;aop:after-returning method=\u0026#34;afterReturning\u0026#34; pointcut-ref=\u0026#34;pointCut\u0026#34; returning=\u0026#34;result\u0026#34;/\u0026gt; \u0026lt;aop:after-throwing method=\u0026#34;afterThrowing\u0026#34; pointcut-ref=\u0026#34;pointCut\u0026#34; throwing=\u0026#34;throwable\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; ","date":"2023-01-19T00:00:00Z","image":"http://localhost:1313/p/09_%E4%BD%BF%E7%94%A8xml%E7%9A%84%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AEaop/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/09_%E4%BD%BF%E7%94%A8xml%E7%9A%84%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AEaop/","title":"09_使用xml的方式配置AOP"},{"content":"Idea配置\r快捷键\r1 2 3 4 5 6 7 代码重排(reformat code)-\u0026gt;(ctrl+k) run context configuration-\u0026gt;(F5) # 可有可无 delete line-\u0026gt;(ctrl+d) 代码提示(basic)-\u0026gt;alt+? 方法提取(Extract method)-\u0026gt;(ctrl+alt+M) 全局查找(Find in files)-\u0026gt;(ctrl+H) 向下复制(Duplicate Line or Selection)-\u0026gt;(alt+D) 自动注释模板\r1 2 3 4 5 /** * @Auther: ${USER} * @Date: ${YEAR}/${MONTH}/${DAY}/${TIME} * @Description: */ 修改编码\r自动导包\r忽视代码大小写\r关闭自动更新\rtab页多行显示设置\rJava注释优化代码注释前空格格式\r开启代码自动编译\r去除idea自带的.iml文件，以及.idea文件夹\r配置maven\ridea启动时展开项目列表\rpom文件依赖报黄\r配置YML模板\r1.这种是直接添加new的文件 2.这种才类似添加用户的模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 server: # 应用服务 WEB 访问端口 port: 8080 spring: # 应用名称 TODO application: name: demo datasource: # 数据库驱动： driver-class-name: com.mysql.cj.jdbc.Driver # 数据源名称 name: defaultDataSource # 数据库连接地址 url: jdbc:mysql://localhost:3306/blue?serverTimezone=UTC # 数据库用户名\u0026amp;密码： username: root password: 123456 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 spring: application: name: demo cloud: nacos: # 服务注册 discovery: server-addr: localhost:8848 # 服务配置 config: server-addr: localhost:8848 # 命名空间 # namespace: # b6625ff9-0949-464b-bad3-fe4cf7858223 # ext-config: # - data-id: # oss.yml # group: # DEFAULT_GROUP # refresh: true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.example.demo\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo-common\u0026lt;/artifactId\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;druid.version\u0026gt;1.1.10\u0026lt;/druid.version\u0026gt; \u0026lt;servlet-api.version\u0026gt;2.3\u0026lt;/servlet-api.version\u0026gt; \u0026lt;validation-api.version\u0026gt;2.0.1.Final\u0026lt;/validation-api.version\u0026gt; \u0026lt;httpcore.version\u0026gt;4.4.15\u0026lt;/httpcore.version\u0026gt; \u0026lt;commons-lang.version\u0026gt;2.6\u0026lt;/commons-lang.version\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;mybatis-plus.version\u0026gt;3.5.1\u0026lt;/mybatis-plus.version\u0026gt; \u0026lt;mysql.version\u0026gt;8.0.30\u0026lt;/mysql.version\u0026gt; \u0026lt;spring-cloud-alibaba.version\u0026gt;2.2.9.RELEASE\u0026lt;/spring-cloud-alibaba.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--druid连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${druid.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--servlet-api--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${servlet-api.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--参数校验--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.validation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;validation-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${validation-api.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--httpcore--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpcore\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${httpcore.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--commons-lang--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-lang\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${commons-lang.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis-plus--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mysql.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--服务注册/发现--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--配置中心--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-alibaba.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;/project\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 应用名称 TODO spring.application.name=demo # 应用服务 WEB 访问端口 server.port=8080 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/blue?serverTimezone=UTC # 数据库用户名\u0026amp;密码： spring.datasource.username=root spring.datasource.password=123456 # 数据源名称 # spring.datasource.name=com.alibaba.druid.pool.DruidDataSource spring.datasource.name=defaultDataSource # 配置mybatis-plus 打印sql日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # xml文件路径 mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml # 配置mybatis-plus 包路径 TODO mybatis-plus.type-aliases-package=com.example.demo.entity # mybatis-plus下划线转驼峰配置，默认为true mybatis-plus.configuration.map-underscore-to-camel-case=true # 配置全局默认主键类型，实体类不用加@TableId(value =\u0026#34;id\u0026#34;,type = IdType.AUTO) mybatis-plus.global-config.db-config.id-type=auto # 1代表已经删除，0代表没有删除 mybatis-plus.global-config.db-config.logic-delete-value=1 mybatis-plus.global-config.db-config.logic-not-delete-value=0 idea本地缓存异常\rmybatis-plus xml报黄\r类上注释报黄\r找到java下的javadoc\ndescription,createDate == @description @createDate\ndescription:,createDate: == @description: @createDate:\nmapper层注入爆红，红色波浪线\rLombok requires enabled annotation processin\r![image-20230120211525558](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202301202115626.png)\r## lombok注解失效\r\u003e lombok注解失效，运行时提示找不到某个参数或方法\r解决方法有以下三种可能（我个人是第三种）：\r1. 更新lombok版本\r2. mvn clean后重新导入\r3. 加入 `-Djps.track.ap.dependencies=false`\r![image-20230311100422978](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303111004136.png)\r## pom文件变成灰色\r\u003e 原因，可能是之前创建项目后删除重建，所以idea排除了这个模块\r\u003e\r\u003e Setting-\u003eBuild Tools-\u003eMaven-\u003eIgnored Files `去掉勾选项即可`\r打开项目后没有显示项目结构\r选择import\nidea配置项目根目录\ridea好用的插件\rAlibaba Java Coding Guidelines\r阿里代码规范检查工具 CodeGlance2\r代码缩略图 Easy Javadoc\r自动生成类和方法的注释 Gitee\r将项目分享至gitee 将gitee项目克隆值idea LeetCode Editor\rLeetCode刷题 Maven Helper\r解决maven jar包冲突问题 MyBatisX\r快速生成实体类、mapper、mapper.xml、service、serviceimpl代码 RestfulTool\r帮助基于restful服务开发的插件 查看请求路径，在项目运行之后还能发送请求查看返回结果 SequenceDiagram\r生成时序图 Show comment\r显示注解，在方法上写好注解后，以后用到该方法的地方会看到写好的注解 statistic\r统计代码量 Tabnine\r生成代码提示 Translation\r翻译插件 Rainbow Brackets\r彩虹括号，以不同的颜色显示每队括号，方便括号配对 快捷键\r同时编辑多处\r按住alt+shift，点击多处即可\n方法提取\r方法提取(Extract method)alt+shift+m\n","date":"2023-01-19T00:00:00Z","image":"http://localhost:1313/p/idea%E9%85%8D%E7%BD%AE/overview-heading-screenshot_hu12432599690232039664.webp","permalink":"http://localhost:1313/p/idea%E9%85%8D%E7%BD%AE/","title":"Idea"},{"content":"maven下载\rmaven官网\n最新版\r历史版\r还是刚刚最新版的页面，往下拉，找到archives，或者点击链接前往 maven配置\r新建环境变量MAVEN_HOME\n1 D:\\apache-maven-3.8.6 系统变量path新建%MAVEN_HOME%\\bin\n1 %MAVEN_HOME%\\bin cmd窗口查看版本\n1 mvn -v 新建maven仓库repository【新建repository文件夹】 配置setting.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;localRepository\u0026gt;D:\\apache-maven-3.8.6\\repository\u0026lt;/localRepository\u0026gt; \u0026lt;!-- 阿里云仓库 --\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/repositories/central/\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;!-- java版本 --\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-1.8\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;jdk\u0026gt;1.8\u0026lt;/jdk\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerVersion\u0026gt;1.8\u0026lt;/maven.compiler.compilerVersion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; ","date":"2023-01-19T00:00:00Z","image":"http://localhost:1313/p/maven%E9%85%8D%E7%BD%AE/maven-logo-black-on-white_hu1659603913382017004.png","permalink":"http://localhost:1313/p/maven%E9%85%8D%E7%BD%AE/","title":"Maven"},{"content":"nvm安装\r前往下载 默认就好，免得配置环境\r在nvm文件夹下找到setting.txt，进行如下配置 1 2 3 4 5 6 7 8 ##当前操作系统的位数（32/64） arch: 64 ##是否需要代理 proxy: none ##node的淘宝镜像 node_mirror: http://npm.taobao.org/mirrors/node/ ##npm的淘宝镜像 npm_mirror: https://npm.taobao.org/mirrors/npm/ 1 2 3 4 5 ## nvm下载nodejs nvm install 14.17.2 nvm use 14.17.2 nvm install 16.13.2 nvm use 16.13.2 1 2 3 4 5 6 7 8 9 10 ## 安装cnpm,将npm设置为淘宝镜像 ## 安装 npm install -g cnpm --registry=https://registry.npm.taobao.org ## 设置 npm config set registry https://registry.npm.taobao.org ## 安装vue/cli cnpm install -g @vue/cli ## 检查是否安装成功 #vue -V 或者 vue --version 创建一个vue项目试试\r1 vue create demo 选择manually select features 手动创建 选择TypeScript、Router、Vuex，取消掉Linter/Formatter 选择3.X 根据提示运行命令\n1 2 cd demo npm run serve 安装nodejs\r网址 一直默认即可（安装地址自定义） 环境变量 path新建\u0026quot;D:\\nodejs\u0026quot; 在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹\n1 2 npm config set prefix \u0026#34;D:\\nodejs\\node_global\u0026#34; npm config set cache \u0026#34;D:\\nodejs\\node_cache\u0026#34; 环境变量 path新建\u0026quot;D:\\nodejs\\node_global\u0026quot;\n1 2 3 npm config get registry npm config set registry https://registry.npm.taobao.org/ npm config get registry ","date":"2023-01-19T00:00:00Z","image":"http://localhost:1313/p/nvm%E9%85%8D%E7%BD%AE/202412211357864_hu369094255779482265.png","permalink":"http://localhost:1313/p/nvm%E9%85%8D%E7%BD%AE/","title":"Nvm"},{"content":"06_获取被增强方法的返回值和异常对象\r获取方法返回值，由于前置通知是在目标方法执行之前，所以前置通知是无法获取到返回值的 应该在@AfterReturning里获取，配置returning属性 获取异常对象是在@AfterThrowing里获取，配置throwing属性 示例如下：\n1 2 3 4 5 6 7 8 @AfterReturning(value = \u0026#34;servicePointCut()\u0026#34;,returning = \u0026#34;ret\u0026#34;) public void afterReturning(JoinPoint point,Object ret){ System.out.println(\u0026#34;方法的返回对象是:\u0026#34;+ret); } @AfterThrowing(value = \u0026#34;servicePointCut()\u0026#34;,throwing = \u0026#34;throwable\u0026#34;) public void afterReturning(JoinPoint point,Throwable throwable){ System.out.println(\u0026#34;方法的异常对象是:\u0026#34;+throwable); } ","date":"2023-01-18T00:00:00Z","image":"http://localhost:1313/p/06_%E8%8E%B7%E5%8F%96%E8%A2%AB%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/06_%E8%8E%B7%E5%8F%96%E8%A2%AB%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1/","title":"06_获取被增强方法的返回值和异常对象"},{"content":"07_环绕通知获取被增强方法的相关信息\r直接在环绕通知方法中增加一个ProceedingJoinPoint类型的参数。这个参数封装了被增强方法的相关信息。该参数的proceed()方法被调用相当于被增强方法被执行，调用后的返回值就相当于被增强方法的返回值。例如:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Around(\u0026#34;servicePointCut()\u0026#34;) public Object around(ProceedingJoinPoint point) { // 方法调用时传入的参数 Object[] args = point.getArgs(); // 被代理对象 Object target = point.getTarget(); // 获取被增强方法签名封装的对象 MethodSignature signature = (MethodSignature) point.getSignature(); Object proceed = null; try { proceed = point.proceed(); } catch (Throwable e) { throw new RuntimeException(e); } return proceed; } 环绕通知注意事项\r需要给环绕通知的方法返回值定义为Object对象，如果不希望更改目标方法的返回值，直接返回目标方法的原本返回值即可。一句话概括，将目标方法的返回值，作为通知方法的返回值进行返回，详情看上述代码\n如果希望篡改目标方法的返回值，更改通知方法的返回值即可\n","date":"2023-01-18T00:00:00Z","image":"http://localhost:1313/p/07_%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E8%A2%AB%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/07_%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E8%A2%AB%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/","title":"07_环绕通知获取被增强方法的相关信息"},{"content":"08_AOP案例\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class AIController { // AI自动回答 public String getAnswer(String question) { // AI核心代码 String str = question.replace(\u0026#34;吗\u0026#34;, \u0026#34;\u0026#34;); str = str.replace(\u0026#34;？\u0026#34;, \u0026#34;！\u0026#34;); str = str.replace(\u0026#34;?\u0026#34;, \u0026#34;!\u0026#34;); return str; } // AI算命 public String fortuneTelling(String name) { // AI核心代码 String[] strs = {\u0026#34;女犯伤官把夫克，早地莲花栽不活，不是吃上两家饭，也要刷上三家锅。\u0026#34;, \u0026#34;一朵鲜花头上戴，一年四季也不开，一心想要花开时，采花之人没到来。\u0026#34;, \u0026#34;此命生来脾气暴，上来一阵双脚跳，对你脾气啥都好，经常与人吵和闹。\u0026#34;}; int index=name.hashCode()%3; return strs[index]; } } 需求：现在为了保证数据的安全性，传入加密后的参数给fortuneTelling方法，此时AOP进行解密后真正传给fortuneTelling方法，执行后的返回值再进行加密后返回\nps：后期也可能让其他方法进行加密处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import java.security.SecureRandom; // 加密、解密工具类 public class CryptUtil { private static final String AES = \u0026#34;AES\u0026#34;; private static int keysizeAES = 128; private static String charset = \u0026#34;UTF-8\u0026#34;; public static String parseByte2HexStr(final byte[] b) { final StringBuilder stringBuffer = new StringBuilder(); for (byte value : b) { String hex = Integer.toHexString(value \u0026amp; 0xFF); if (hex.length() == 1) { hex = \u0026#39;0\u0026#39; + hex; } stringBuffer.append(hex.toUpperCase()); } return stringBuffer.toString(); } public static byte[] parseHexStr2Byte(final String hexStr) { if (hexStr.length() \u0026lt; 1) { return null; } final byte[] result = new byte[hexStr.length() / 2]; for (int i = 0; i \u0026lt; hexStr.length() / 2; i++) { int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16); int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16); result[i] = (byte) (high * 16 + low); } return result; } private static String keyGeneratorES(final String res, final String algorithm, final String key, final Integer keysize, final boolean bEncode) { try { final KeyGenerator g = KeyGenerator.getInstance(algorithm); if (keysize == 0) { byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset); g.init(new SecureRandom(keyBytes)); } else if (key == null) { g.init(keysize); } else { byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset); SecureRandom random = SecureRandom.getInstance(\u0026#34;SHA1PRNG\u0026#34;); random.setSeed(keyBytes); g.init(keysize, random); } final SecretKey secretKey = g.generateKey(); final SecretKeySpec keySpec = new SecretKeySpec(secretKey.getEncoded(), algorithm); final Cipher cipher = Cipher.getInstance(algorithm); if (bEncode) { cipher.init(Cipher.ENCRYPT_MODE, keySpec); final byte[] result = charset == null ? res.getBytes() : res.getBytes(charset); return parseByte2HexStr(cipher.doFinal(result)); } else { cipher.init(Cipher.DECRYPT_MODE, keySpec); return new String(cipher.doFinal(parseHexStr2Byte(res))); } } catch (Exception e) { e.printStackTrace(); } return null; } public static String AESencode(final String res) { return keyGeneratorES(res, AES, \u0026#34;aAll*-%\u0026#34;, keysizeAES, true); } public static String AESdecode(final String res) { return keyGeneratorES(res, AES, \u0026#34;aAll*-%\u0026#34;, keysizeAES, false); } public static void main(String[] args) { System.out.println(\u0026#34;加密后:\u0026#34; + AESencode(\u0026#34;123456\u0026#34;)); System.out.println(\u0026#34;解密后:\u0026#34; + AESdecode(\u0026#34;555B695B57E024EEA169EAE275B9D93B\u0026#34;)); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface EnCodeAndDeCode { } @Component @Aspect public class MyAOP { @Pointcut(\u0026#34;execution(* com.example.controller..*.fortuneTelling(..))\u0026#34;) public void pointCut() { } @Pointcut(\u0026#34;@annotation(com.example.aspect.EnCodeAndDeCode)\u0026#34;) public void annotationPointCut() { } @Around(\u0026#34;annotationPointCut()\u0026#34;) public Object around(ProceedingJoinPoint point) { Object proceed = null; Object[] args = point.getArgs(); System.out.println(\u0026#34;明文参数是:\u0026#34; + Arrays.toString(args)); for (int i = 0; i \u0026lt; args.length; i++) { args[i] = CryptUtil.AESdecode((String) args[i]); } System.out.println(\u0026#34;密文参数是:\u0026#34; + Arrays.toString(args)); try { proceed = point.proceed(args); System.out.println(\u0026#34;明文返回值是:\u0026#34; + proceed); System.out.println(\u0026#34;密文返回值是:\u0026#34; + CryptUtil.AESencode((String) proceed)); } catch (Throwable e) { e.printStackTrace(); } return CryptUtil.AESencode((String) proceed); } } public class Main { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); AIController aiController = context.getBean(AIController.class); //String answer = aiController.getAnswer(\u0026#34;我帅吗？\u0026#34;); String result = aiController.fortuneTelling(CryptUtil.AESencode(\u0026#34;赵子龙\u0026#34;)); //System.out.println(answer); System.out.println(\u0026#34;返回值解密是:\u0026#34;+CryptUtil.AESdecode(result)); } } 执行结果：\n明文参数是:[6F152DBC4B9D1B6B03EA4B858D6AE775] 密文参数是:[赵子龙] 明文返回值是:女犯伤官把夫克，早地莲花栽不活，不是吃上两家饭，也要刷上三家锅。 密文返回值是:930617239D652C6E7BD9510B919BB44CAE3286191754B494FBB76F52FC370E2336813515381DDE2463A91F2588898E9CB9C4D31EBD2D09BCFFFBF593C675A13DC8A8FDEADC905A791A9E72D03F38E6B3C410C8EF7683A5130175E0670AC17210A6032F8A8CBC8256C8E0A70D65DE0148 返回值解密是:女犯伤官把夫克，早地莲花栽不活，不是吃上两家饭，也要刷上三家锅。\n","date":"2023-01-18T00:00:00Z","image":"http://localhost:1313/p/08_aop%E6%A1%88%E4%BE%8B/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/08_aop%E6%A1%88%E4%BE%8B/","title":"08_AOP案例"},{"content":"SpringAOP核心概念\rJoinpoint(连接点)︰所谓连接点是指那些可以被增强到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut(切入点)︰所谓切入点是指被增强的连接点(方法) Advice(通知/增强)︰所谓通知是指具体增强的代码 Target(目标对象)︰被增强的对象就是目标对象 Aspect(切面)︰是切入点和通知(引介)的结合 Proxy (代理)︰一个类被AOP增强后，就产生一个结果代理类 切点表达式\r1 2 // 返回值，某个类下某个方法，..代表任意参数，不加代表无参方法 @Pointcut(\u0026#34;execution(* com.example.service.*.sayHello(..))\u0026#34;) 切点函数@annotation\r我们也可以在要增强的方法上加上注解。然后使用@annotation来表示对加了什么注解的方法进行增强。 写法:@annotation(注解的全类名) 例如: 定义注解如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface InvokeLog { } @Pointcut(\u0026#34;@annotation(com.example.myannotation.InvokeLog)\u0026#34;) public void pointCut1(){} @Before(\u0026#34;pointCut1()\u0026#34;) public void before(){ System.out.println(\u0026#34;拜拜咯您嘞\u0026#34;); } @InvokeLog public void sayBye(){ System.out.println(\u0026#34;bye\u0026#34;); } phoneService.sayBye(); ","date":"2023-01-16T00:00:00Z","image":"http://localhost:1313/p/02_aop%E6%A6%82%E5%BF%B5/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/02_aop%E6%A6%82%E5%BF%B5/","title":"02_AOP概念"},{"content":"02_Before前置通知\r@Before:前置通知,在方法执行前执行 @AfterReturning:返回后通知，在目标方法执行后执行，如果出现异常不会执行 @After:后置通知，在目标方法返回结果之后执行，无论是否出现异常都会执行 @AfterThrowing:异常通知，在目标方法抛出异常后执行 @Around:环绕通知，围绕着方法执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public Object test(){ // @Before前置通知 beafore(); try { // 目标方法调用 Object ret=目标方法(); // @AfterReturning返回后通知 afterReturn(); }catch (Throwable throwable){ throwable.printStackTrace(); // @AfterThrowing 异常通知 afterThrowing(); }finally { // @After 后置通知 after(); } return ret; } 04_AfterReturning返回后异常\r若目标方法出现异常，不执行\n1 System.out.println(1/0); 05_After后置通知\r无论目标方法出现异常与否，都会执行\n06_AfterThrowing异常通知\r如果目标方法出现异常，则执行；反之不执行\n07_Around环绕通知\r围绕着目标方法执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Around(\u0026#34;pointCut1()\u0026#34;) public void around(ProceedingJoinPoint point) { System.out.println(\u0026#34;目标方法前---\u0026#34;); try { // 目标方法执行 point.proceed(); System.out.println(\u0026#34;目标方法后---\u0026#34;); } catch (Throwable e) { e.printStackTrace(); System.out.println(\u0026#34;出现异常后---\u0026#34;); }finally { System.out.println(\u0026#34;finally中进行增强---\u0026#34;); } } 总结\rAround的功能更加强大，IDEA中@Around报黄，提示Join point return value will be lost 是因为可以返回一个Object对象\n","date":"2023-01-16T00:00:00Z","image":"http://localhost:1313/p/03_%E9%80%9A%E7%9F%A5%E5%88%86%E7%B1%BB/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/03_%E9%80%9A%E7%9F%A5%E5%88%86%E7%B1%BB/","title":"03_通知分类"},{"content":"04_获取被增强方法的相关信息\r我们可以在除了环绕通知外的所有通知方法中增加一个JoinPoint类型的参数。这个参数封装了被增强方法的相关信息。我们可以通过这个参数获取到除了异常对象和返回值之外的所有信息。\n1 2 3 4 5 6 7 8 9 10 // 获取传入参数 joinPoint.getArgs(); // 获得签名，签名可以用来获得详细信息 joinPoint.getSignature(); // 获得增强的方法名，String joinPoint.getSignature().getName(); // 获得全类名，String joinPoint.getSignature().getDeclaringTypeName(); // 获得类的Class对象 joinPoint.getSignature().getDeclaringType(); 虽然签名Signature有一些有用的方法，但其实还不够多，所以选择MethodSignature来进行接收 MethodSignature是Signature的子接口 MethodSignature的方法更丰富\n1 2 3 4 5 6 7 8 @Before(\u0026#34;pointCut1()\u0026#34;) public void before(JoinPoint joinPoint) { System.out.println(\u0026#34;before---\u0026#34;); MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); method.invoke(); System.out.println(joinPoint); } DeBug\rdebug模式的小计算器可以直接测试你希望测试的方法并显示返回值 如上述的一些方法 joinPoint.getArgs();、joinPoint.getSignature();\n","date":"2023-01-16T00:00:00Z","image":"http://localhost:1313/p/04_%E8%8E%B7%E5%8F%96%E8%A2%AB%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/04_%E8%8E%B7%E5%8F%96%E8%A2%AB%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/","title":"04_获取被增强方法的相关信息"},{"content":"05_JoinPoint案例\r需求：在调用方法时，输出**某某类中的某某方法被调用了，调用时传入的参数是哪些**\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.example\u0026#34;/\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:project.properties\u0026#34;/\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 project.user.uid=2 project.user.username=李四 project.user.password=111111 project.phone.number=13195868989 project.phone.type=电信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Data @Component public class Phone { @Value(\u0026#34;${project.phone.number}\u0026#34;) private String number; @Value(\u0026#34;${project.phone.type}\u0026#34;) private String type; } @Data @Component public class User { @Value(\u0026#34;${project.user.uid}\u0026#34;) private Integer uid; @Value(\u0026#34;${project.user.username}\u0026#34;) private String username; @Value(\u0026#34;${project.user.password}\u0026#34;) private String password; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @Service public class PhoneService { public void addPhone(Phone phone) { System.out.println(\u0026#34;新增手机\u0026#34;); } public void updatePhone(Phone phone) { System.out.println(\u0026#34;修改手机\u0026#34;); } public void deletePhone(String number) { System.out.println(\u0026#34;删除手机\u0026#34;); } public Phone getPhoneByNumber(String number) { System.out.println(\u0026#34;查询手机\u0026#34;); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); return context.getBean(Phone.class); } public void testPhone(){ System.out.println(\u0026#34;测试手机\u0026#34;); } } @Service public class UserService { public void addUser(User user) { System.out.println(\u0026#34;新增用户\u0026#34;); } public void updateUser(User user) { System.out.println(\u0026#34;修改用户\u0026#34;); } public void deleteUser(Integer id) { System.out.println(\u0026#34;删除用户\u0026#34;); } public User getUserById(Integer id) { System.out.println(\u0026#34;查询用户\u0026#34;); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); return context.getBean(User.class); } public void testUser(){ System.out.println(\u0026#34;测试用户\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component @Aspect public class MyAspect { @Pointcut(\u0026#34;@annotation(com.example.aspect.InvokeLog)\u0026#34;) public void logPointCut() {} @Pointcut(\u0026#34;execution(* com.example.service..*.*(..))\u0026#34;) public void servicePointCut() {} @Before(\u0026#34;servicePointCut()\u0026#34;) public void before(JoinPoint point){ MethodSignature signature = (MethodSignature) point.getSignature(); System.out.println(\u0026#34;方法所在的全类名是:\u0026#34;+signature.getDeclaringTypeName()); System.out.println(\u0026#34;方法名称是:\u0026#34;+signature.getName()); System.out.println(\u0026#34;方法参数是:\u0026#34;+ Arrays.toString(point.getArgs())); System.out.println(\u0026#34;-------------------------------\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class Main { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); // 对象 User user = context.getBean(User.class); Phone phone = context.getBean(Phone.class); // service UserService userService = context.getBean(UserService.class); userService.addUser(user); userService.deleteUser(1); userService.updateUser(user); userService.getUserById(1); userService.testUser(); PhoneService phoneService = context.getBean(PhoneService.class); phoneService.addPhone(phone); phoneService.deletePhone(\u0026#34;1\u0026#34;); phoneService.updatePhone(phone); phoneService.getPhoneByNumber(\u0026#34;1\u0026#34;); phoneService.testPhone(); } } @value获取不到值\rstatic的属性使用@Value注解，因为Spring的类加载器是在jvm之后的，所以在jvm加载过程中@Value不起作用 使用@Value注解的类被Spring所管理，如@Component、@Service、@Controller等 new对象，Spring管理的对象，new出来，当然也获取不到 ","date":"2023-01-16T00:00:00Z","image":"http://localhost:1313/p/05_joinpoint%E6%A1%88%E4%BE%8B/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/05_joinpoint%E6%A1%88%E4%BE%8B/","title":"05_JoinPoint案例"},{"content":"01_AOP入门\rAOP为Aspect Oriented Programming的缩写，意为:面向切面编程。他是一种可以在不修改原来的核心代码的情况下给程序动态统—进行增强的一种技术。 SpringAOP:批量对Spring容器中bean的方法做增强，并且这种增强不会与原来方法中的代码耦合。 需求：要求让service包下所有类的所有方法在调用前都输出:方法被调用了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;_01_Spring_AOP\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- lombok依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- IOC相关依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.18\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- AOP相关依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 @Service public class PhoneService { public void toInit(){ System.out.println(\u0026#34;PhoneService中toInit的核心代码\u0026#34;); } } @Service public class UserService { public void toInit(){ System.out.println(\u0026#34;UserService中toInit的核心代码\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!-- 开启组件扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.example\u0026#34;/\u0026gt; \u0026lt;!-- 开启aop注解支持 --\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; \u0026lt;/beans\u0026gt; 创建切面类 创建一个类，在类上加上@Component和@Aspect使用@Pointcut注解来指定要被增强的方法 使用@Before注解来给我们的增强代码所在的方法进行标识，并且指定了增强代码是在被增强方法执行之前执行的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; import org.springframework.stereotype.Component; @Component @Aspect public class MyAspect { // 对哪些方法进行增强 @Pointcut(\u0026#34;execution(* com.example.service.*.toInit(..))\u0026#34;) public void pt(){} // 怎么增强 @Before(\u0026#34;pt()\u0026#34;) public void methodBefore(){ System.out.println(\u0026#34;方法被调用了\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 public class Application_01 { public static void main(String[] args) { // 创建容器 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); // 获取对象 PhoneService phoneService = context.getBean(PhoneService.class); UserService userService = context.getBean(UserService.class); // 方法调用 phoneService.toInit(); userService.toInit(); } } ","date":"2023-01-15T00:00:00Z","image":"http://localhost:1313/p/01_aop%E5%85%A5%E9%97%A8/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/01_aop%E5%85%A5%E9%97%A8/","title":"01_AOP入门"},{"content":"Spring注解开发\r1 \u0026lt;bean class=\u0026#34;com.example.entity.User\u0026#34; id=\u0026#34;userEntity\u0026#34;/\u0026gt; 等同于\n1 2 3 4 5 6 7 @Data @Component(\u0026#34;userEntity\u0026#34;) public class User { private Integer uid; private String username; private String password; } 注解开发的准备工作\n开启组件扫描\r如果要使用注解开发必须要开启组件扫描，这样加了注解的类才会被识别出来。Spring才能去解析其中的注解。\n1 2 \u0026lt;!--启动组件扫描，指定对应扫描的包路径，该包及其子包下所有的类都会被扫描，加载包含指定注解的类--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.example\u0026#34;/\u0026gt; 这里试一下连接数据库，查数据 普通的jdbc的方法\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- applicationContext --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.example\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;classpath:/mysql/jdbc.xml\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!-- jdbc.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:mysql/jdbc.properties\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34; id=\u0026#34;dataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${spring.datasource.driver-class-name}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${spring.datasource.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${spring.datasource.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${spring.datasource.password}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 spring.datasource.url= jdbc:mysql://localhost:3306/test?serverTimezone=UTC spring.datasource.username= root spring.datasource.password= 123456 spring.datasource.driver-class-name= com.mysql.cj.jdbc.Driver spring.datasource.name= com.alibaba.druid.pool.DruidDataSource 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public interface UserDao { String selectUserById(Integer id); String updateUserStatusById(Integer id,String status); } @Repository(\u0026#34;userDao\u0026#34;) public class UserDaoImpl implements UserDao { @Override public String selectUserById(Integer id) { return \u0026#34;select * from user where uid=\u0026#34;+id; } @Override public String updateUserStatusById(Integer id,String status) { return \u0026#34;update user set status=\u0026#39;\u0026#34;+status+\u0026#34;\u0026#39; where uid=\u0026#34;+id; } } public class Application_10 { public static void main(String[] args) throws Exception { int id=1; String status=\u0026#34;睡觉\u0026#34;; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); DruidDataSource dataSource = (DruidDataSource) context.getBean(\u0026#34;dataSource\u0026#34;); UserDao userDao= (UserDao) context.getBean(\u0026#34;userDao\u0026#34;); // 1.导入驱动jar包 // 2.加载驱动 Class.forName(dataSource.getDriverClassName()); // 3.获取数据库连接对象 Connection connection = DriverManager.getConnection(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword()); // 4.定义sql语句 // 5.获取执行sql语句的对象 Statement statement = connection.createStatement(); // 6.执行sql并接收返回的对象 statement.executeUpdate(userDao.updateUserStatusById(id,status)); ResultSet resultSet = statement.executeQuery(userDao.selectUserById(id)); // 7.处理结果 while (resultSet.next()) { System.out.println(\u0026#34;User(\u0026#34; + resultSet.getInt(\u0026#34;uid\u0026#34;) + \u0026#39;,\u0026#39; + resultSet.getString(\u0026#34;name\u0026#34;) + \u0026#39;,\u0026#39; + resultSet.getString(\u0026#34;gender\u0026#34;) + \u0026#39;,\u0026#39; + resultSet.getInt(\u0026#34;age\u0026#34;) + \u0026#39;,\u0026#39; + resultSet.getInt(\u0026#34;parent_id\u0026#34;) + \u0026#39;,\u0026#39;+ resultSet.getString(\u0026#34;status\u0026#34;)+\u0026#34;)\u0026#34;); } // 8.关闭连接，释放资源 resultSet.close(); statement.close(); connection.close(); } } 将uid为1的user的status字段更新为睡觉后查询输出 常用注解有@Component、@Repository、@Service、@Controller\n@Value\r@Value并不依赖于set方法，支持SPEL表达式\n1 \u0026lt;context:component-scan base-package=\u0026#34;org.example\u0026#34;/\u0026gt; 1 2 3 4 5 6 7 8 9 10 @ToString @Component(\u0026#34;userEntity\u0026#34;) public class User { @Value(\u0026#34;1\u0026#34;) private Integer uid; @Value(\u0026#34;admin\u0026#34;) private String username; @Value(\u0026#34;123456\u0026#34;) private String password; } 1 2 3 4 5 6 7 public class Main { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User userEntity = (User) context.getBean(\u0026#34;userEntity\u0026#34;); System.out.println(userEntity); } } 我这里User类并没有给set方法，并不影响运行结果，说明@Value并不依赖于set方法\n@Autowired\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Repository public class UserDao { @Value(\u0026#34;名字\u0026#34;) private String name; } @Service(\u0026#34;service\u0026#34;) public class UserService { @Autowired private UserDao userDao; } public class Main { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); //User userEntity = (User) context.getBean(\u0026#34;userEntity\u0026#34;); //System.out.println(userEntity); UserService userService = (UserService) context.getBean(\u0026#34;service\u0026#34;); System.out.println(userService); } } @Qualifier\r假如说，我们现在有多个UserDaoImpl实现UserDao 此时@Autowired根据类型会找到多个类，此时会发生报错\nNo qualifying bean of type 'org.example.dao.UserDao' available: expected single matching bean but found 2: userDao1,userDao2\n如何解决？ 1 2 3 4 5 6 7 8 9 10 11 12 13 public interface UserDao { } @Repository(\u0026#34;userDao1\u0026#34;) public class UserDaoImpl implements UserDao { @Value(\u0026#34;名字\u0026#34;) private String name; } @Repository(\u0026#34;userDao2\u0026#34;) @ToString public class UserDaoImpl2 implements UserDao { @Value(\u0026#34;名字2\u0026#34;) private String name; } 可以看到Idea这里也提示了报错信息\n1 2 3 4 5 6 7 @Service(\u0026#34;userService\u0026#34;) @ToString public class UserService { @Autowired @Qualifier(\u0026#34;userDao1\u0026#34;) private UserDao userDao; } 可以通过@Qualifier(\u0026quot;BeanName\u0026quot;)来指定对应的bean 这里的@Qualifier(\u0026quot;userDao1\u0026quot;)和UserDao接口下的@Repository(\u0026quot;userDao1\u0026quot;)对应\n注意，@Qualifier注解不能单独使用，需配合@Autowired来使用\n","date":"2023-01-15T00:00:00Z","image":"http://localhost:1313/p/08_spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/08_spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","title":"08_Spring注解开发"},{"content":"XML配置文件相关注解\r@Configuration\r标注在类上，表示当前类是一个配置类。我们可以用注解类来完全替换掉xml配置文件。 注意:如果使用配置类替换了xml配置，spring容器要使用:AnnotationConfigApplicationContext\n@ComponentScan\r可以用来代替contexcomponent-scan标签来配置组件扫描。 使用接下来的一个例子，来完全替换掉xml配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // java配置类 @Configuration @ComponentScan(basePackages = {\u0026#34;com.example\u0026#34;}) public class ApplicationConfig { } @Data @Component(\u0026#34;userEntity\u0026#34;) public class User { @Value(\u0026#34;1\u0026#34;) private Integer uid; @Value(\u0026#34;admin\u0026#34;) private String username; @Value(\u0026#34;123456\u0026#34;) private String password; } public class Application_11 { public static void main(String[] args) { // 创建注解容器，指定配置类(传入字节码对象) AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class); User userEntity = (User) context.getBean(\u0026#34;userEntity\u0026#34;); System.out.println(userEntity); } } 注意：这里使用AnnotationConfigApplicationContext而不是之前的ClassPathXmlApplicationContext\n@Bean\r可以用来代替bean标签，主要用于第三方类的注入。 比如Druid连接池，由于是第三方jar包，没办法添加@Component注解注入到Spring容器中 这时候，可以使用@Bean注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Configuration @ComponentScan(basePackages = {\u0026#34;com.example\u0026#34;}) public class ApplicationConfig { @Bean(\u0026#34;dataSource\u0026#34;) public DruidDataSource getDruidDataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(\u0026#34;1\u0026#34;); dataSource.setUrl(\u0026#34;2\u0026#34;); dataSource.setUsername(\u0026#34;3\u0026#34;); dataSource.setPassword(\u0026#34;4\u0026#34;); return dataSource; } } public class Application_11 { public static void main(String[] args) { // 创建注解容器，指定配置类(传入字节码对象) AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class); //User userEntity = (User) context.getBean(\u0026#34;userEntity\u0026#34;); //System.out.println(userEntity); DruidDataSource dataSource = (DruidDataSource) context.getBean(\u0026#34;dataSource\u0026#34;); System.out.println(dataSource); } } 这里其实还有一种更常用的写法，不配置Bean的id，直接通过字节码来获取Bean 这里能这么使用是因为对应类型的Bean只有一个 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Configuration @ComponentScan(basePackages = {\u0026#34;com.example\u0026#34;}) public class ApplicationConfig { // 没有指定Bean的id属性 @Bean public DruidDataSource getDruidDataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(\u0026#34;1\u0026#34;); dataSource.setUrl(\u0026#34;2\u0026#34;); dataSource.setUsername(\u0026#34;3\u0026#34;); dataSource.setPassword(\u0026#34;4\u0026#34;); return dataSource; } } public class Application_11 { public static void main(String[] args) { // 创建注解容器，指定配置类(传入字节码对象) AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class); // 这里写DruidDataSource.class或者DataSource.class都行 // 这里和config配置中的返回值类型相对应 DataSource bean = context.getBean(DruidDataSource.class); System.out.println(bean); } } @PropertySource\r可以用来代替context:property-placeholder，让Spring读取指定的properties文件。然后可以使用@Value来获取读取到的值。\n1 2 3 4 mysql.driverClassName=com.mysql.cj.jdbc.Driver mysql.url=jdbc:mysql://localhost/test?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;useSSL=false\u0026amp;serverTimezone=Asia/Shanghai mysql.username=root mysql.password=123456 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Configuration @ComponentScan(basePackages = {\u0026#34;com.example\u0026#34;}) @PropertySource(\u0026#34;classpath:jdbc.properties\u0026#34;) public class ApplicationConfig { @Value(\u0026#34;${mysql.driverClassName}\u0026#34;) private String driverClassName; @Value(\u0026#34;${mysql.url}\u0026#34;) private String url; @Value(\u0026#34;${mysql.username}\u0026#34;) private String username; @Value(\u0026#34;${mysql.password}\u0026#34;) private String password; @Bean public DruidDataSource getDruidDataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driverClassName); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; } } ","date":"2023-01-15T00:00:00Z","image":"http://localhost:1313/p/09_xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/09_xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/","title":"09_XML配置文件相关注解"},{"content":"SpringIOC快速入门\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 _04_SpringIOC_test ├─ src │ ├─ main │ │ ├─ java │ │ │ └─ com │ │ │ └─ example │ │ │ ├─ dao │ │ │ │ ├─ impl │ │ │ │ │ └─ StudentDaoImpl.java │ │ │ │ └─ StudentDao.java │ │ │ ├─ entity │ │ │ │ └─ Student.java │ │ │ └─ Application_04.java │ │ └─ resources │ │ └─ applicationContext.xml │ └─ test │ └─ java ├─ pom.xml └─ _04_SpringIOC_test.iml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!-- pom.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;_04_SpringIOC_test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--lombok依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Spring依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.14.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 1 2 3 4 5 6 7 8 \u0026lt;!-- applicationContext.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.dao.impl.StudentDaoImpl\u0026#34; id=\u0026#34;studentDao\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Data @AllArgsConstructor @NoArgsConstructor public class Student { private String name; private Integer id; private Integer age; } public interface StudentDao { Student getStudentById(Integer id); } public class StudentDaoImpl implements StudentDao { @Override public Student getStudentById(Integer id) { return new Student(\u0026#34;张三\u0026#34;,1,20); } } import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Application_04 { public static void main(String[] args) { // 创建容器 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); // 获取对象 StudentDao studentDao= (StudentDao) context.getBean(\u0026#34;studentDao\u0026#34;); Student studentById = studentDao.getStudentById(5); System.out.println(studentById); } } // 运行Application_04 // Student(name=张三, id=1, age=20) 读取applicationContext文件 根据bean标签的class以反射的方式来创建对象，以bean标签的id为key存入map集合当中 通过getBean()方法传入key来获取 ","date":"2023-01-14T00:00:00Z","image":"http://localhost:1313/p/01_springioc%E5%85%A5%E9%97%A8/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/01_springioc%E5%85%A5%E9%97%A8/","title":"01_SpringIOC入门"},{"content":"bean的常用属性配置\rid\rbean的唯一表示，同一个Spring容器中不允许重复\nclass\r全类名，用于反射创建对象\nscope\rscope主要有两个值：singleton、prototype 如果设置为singleton，则一个容器中只会有一个bean对象，多个方法共用一个bean对象 如果设置为prototype，则一个容器中会有多个该bean对象。每次调用getBean方法都会创建一个新对象\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- scope=\u0026#34;prototype\u0026#34;多例 ，scope=\u0026#34;singleton\u0026#34;单例， 默认是单例的 --\u0026gt; \u0026lt;!-- 多例：每调用一次getBean方法会创建一个新的对象，debug可以看到对象地址，单例和多例的两次对象地址不一样 --\u0026gt; \u0026lt;bean class=\u0026#34;com.example.dao.impl.StudentDaoImpl\u0026#34; id=\u0026#34;studentDao\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; ","date":"2023-01-14T00:00:00Z","image":"http://localhost:1313/p/02_bean%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/02_bean%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE/","title":"02_bean的常用属性配置"},{"content":"Set方法注入\u0026amp;\u0026amp;有参构造注入\r需知：@Data注解会为类自动生成get、set方法、toString方法 使用property标签来为实体类赋值是需要生成set方法的，如果去掉了@Data注解，则需要生成set方法才行 若类中不存在set方法，applicationContext.xml会爆红\n1 2 3 4 5 6 7 import lombok.Data; @Data public class Student { private String name; private String gender; private Integer age; } 1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.Student\u0026#34; id=\u0026#34;studentEntity\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;学生1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;22\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 public class Application_05 { public static void main(String[] args) { // 创建容器 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); // 获取对象 对应applicationContext里bean标签的id Student student= (Student) context.getBean(\u0026#34;studentEntity\u0026#34;); System.out.println(student); } } value来设置Student的属性，这里bean标签里有value属性和ref属性需要注意，下面针对ref属性来进行举例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import lombok.Data; @Data public class Student { private String name; private String gender; private Integer age; private Game game; } @Data public class Game { private String name; private String country; private Double money; } // Application_05不变 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- game --\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.Game\u0026#34; id=\u0026#34;gameEntity\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;王者荣耀\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;country\u0026#34; value=\u0026#34;中国\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;money\u0026#34; value=\u0026#34;88.8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- student --\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.Student\u0026#34; id=\u0026#34;studentEntity\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;学生1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;22\u0026#34;/\u0026gt; \u0026lt;!-- 这里ref指向上面的gameid --\u0026gt; \u0026lt;property name=\u0026#34;game\u0026#34; ref=\u0026#34;gameEntity\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; ref=\u0026ldquo;gameEntity\u0026quot;这里指向上面game的bean标签的id值\n有参构造注入\r和set注入一样，set注入需要存在set方法才能注入 这里同样需要存在有参构造方法才能进行注入 下图为了区别，就将原本的applicationContext改名了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Data // 全参构造方法 @AllArgsConstructor // 无参构造犯法 @NoArgsConstructor public class Game { private String name; private String country; private Double money; } @Data @AllArgsConstructor @NoArgsConstructor public class Student { private String name; private String gender; private Integer age; private Game game; } 这里报错是正常的，因为你game类的属性还没写完，但是给的是全参构造方法，所以会报错，把属性写完整就不会报错了 这里直接换到测试方法里进行测试\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.Game\u0026#34; id=\u0026#34;gameEntity\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;原神\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;country\u0026#34; value=\u0026#34;China\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;money\u0026#34; value=\u0026#34;136.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 @Test public void constructorTest(){ ApplicationContext context=new ClassPathXmlApplicationContext(\u0026#34;application_constructor.xml\u0026#34;); Game studentEntity = (Game) context.getBean(\u0026#34;gameEntity\u0026#34;); System.out.println(studentEntity); } 这里先测试Game实体类，显然是没问题，接下来测试Student类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.Game\u0026#34; id=\u0026#34;gameEntity\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;原神\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;country\u0026#34; value=\u0026#34;China\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;money\u0026#34; value=\u0026#34;136.9\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.Student\u0026#34; id=\u0026#34;studentEntity\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;学生2\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;gender\u0026#34; value=\u0026#34;女\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;age\u0026#34; value=\u0026#34;23\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;game\u0026#34; ref=\u0026#34;gameEntity\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example.test; import com.example.entity.Student; import org.junit.jupiter.api.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { @Test public void setterTest(){ ApplicationContext context=new ClassPathXmlApplicationContext(\u0026#34;application_set.xml\u0026#34;); Student studentEntity = (Student) context.getBean(\u0026#34;studentEntity\u0026#34;); System.out.println(studentEntity); } @Test public void constructorTest(){ ApplicationContext context=new ClassPathXmlApplicationContext(\u0026#34;application_constructor.xml\u0026#34;); Student studentEntity = (Student) context.getBean(\u0026#34;studentEntity\u0026#34;); System.out.println(studentEntity); } } ref和set注入的ref是一样的用法，用来关联game的bean\n复杂属性怎么注入？\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.example.complexEntity; @Data @AllArgsConstructor @NoArgsConstructor public class Phone { private double price; private String name; private String password; private String path; } import java.util.List; import java.util.Map; import java.util.Properties; import java.util.Set; @Data @AllArgsConstructor @NoArgsConstructor public class User { private int age; private String name; private Phone phone; private List\u0026lt;String\u0026gt; list; private List\u0026lt;Phone\u0026gt; phones; private Set\u0026lt;String\u0026gt; set; private Map\u0026lt;String,Phone\u0026gt; map; private int[] arr; private Properties properties; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- plone --\u0026gt; \u0026lt;bean class=\u0026#34;com.example.complexEntity.Phone\u0026#34; id=\u0026#34;phoneEntity1\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;1999.9\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;骁龙\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;path\u0026#34; value=\u0026#34;红米\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;com.example.complexEntity.Phone\u0026#34; id=\u0026#34;phoneEntity2\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;2999.9\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;天玑\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;654321\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;path\u0026#34; value=\u0026#34;vivo\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- user --\u0026gt; \u0026lt;bean class=\u0026#34;com.example.complexEntity.User\u0026#34; id=\u0026#34;userEntity\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;22\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;某用户\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;phone\u0026#34; ref=\u0026#34;phoneEntity1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;元素1\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;元素2\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;phones\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;ref bean=\u0026#34;phoneEntity1\u0026#34;/\u0026gt; \u0026lt;ref bean=\u0026#34;phoneEntity2\u0026#34;/\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;set\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;aaa\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;bbb\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;ccc\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;map\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;aa\u0026#34; value-ref=\u0026#34;phoneEntity1\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;bb\u0026#34; value-ref=\u0026#34;phoneEntity2\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;arr\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;1\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;2\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;3\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;4\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;5\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;properties\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;k1\u0026#34;\u0026gt;v1\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;k2\u0026#34;\u0026gt;v2\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;k3\u0026#34;\u0026gt;v3\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.example.test; import com.example.complexEntity.User; import com.example.entity.Student; import org.junit.jupiter.api.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { @Test public void setterTest() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;application_set.xml\u0026#34;); Student studentEntity = (Student) context.getBean(\u0026#34;studentEntity\u0026#34;); System.out.println(studentEntity); } @Test public void constructorTest() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;application_constructor.xml\u0026#34;); Student studentEntity = (Student) context.getBean(\u0026#34;studentEntity\u0026#34;); System.out.println(studentEntity); } @Test public void complexTest() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;application_complex.xml\u0026#34;); User studentEntity = (User) context.getBean(\u0026#34;userEntity\u0026#34;); System.out.println(studentEntity); } } ","date":"2023-01-14T00:00:00Z","image":"http://localhost:1313/p/03_spring_di/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/03_spring_di/","title":"03_Spring_DI"},{"content":"SPEL表达式\r先写原写法，再看spel表达式和原写法之间的区别\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- game --\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.Game\u0026#34; id=\u0026#34;gameEntity\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;王者荣耀\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;country\u0026#34; value=\u0026#34;中国\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;money\u0026#34; value=\u0026#34;88.8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- student --\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.Student\u0026#34; id=\u0026#34;studentEntity\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;学生1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;22\u0026#34;/\u0026gt; \u0026lt;!-- 这里ref指向上面的gameid --\u0026gt; \u0026lt;property name=\u0026#34;game\u0026#34; ref=\u0026#34;gameEntity\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; SPEL表达式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- game --\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.Game\u0026#34; id=\u0026#34;gameEntity\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;王者荣耀\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;country\u0026#34; value=\u0026#34;中国\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;money\u0026#34; value=\u0026#34;#{88+0.8}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- student --\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.Student\u0026#34; id=\u0026#34;studentEntity\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;学生1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;22\u0026#34;/\u0026gt; \u0026lt;!-- 这里ref指向上面的gameid --\u0026gt; \u0026lt;property name=\u0026#34;game\u0026#34; value=\u0026#34;#{gameEntity}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 注意：SPEL需要写到value属性中，而不能写在ref属性中\n","date":"2023-01-14T00:00:00Z","image":"http://localhost:1313/p/04_spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/04_spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"04_SPEL表达式"},{"content":"读取properties配置文件\r可以看到这四个属性已经注入进去了 以前是下面这种写法 现在直接读取properties配置文件后，注入属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;_06_Read_Properties\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.18\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;RELEASE\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 读取properties配置文件 --\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34; id=\u0026#34;dataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${mysql.driverClassName}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${mysql.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${mysql.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${mysql.password}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 mysql.driverClassName=com.mysql.cj.jdbc.Driver mysql.url=jdbc:mysql://localhost/test?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;useSSL=false\u0026amp;serverTimezone=Asia/Shanghai mysql.username=root mysql.password=123456 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.example.test; import com.alibaba.druid.pool.DruidDataSource; import org.junit.jupiter.api.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { @Test public void dataSourceTest(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;application_datasource.xml\u0026#34;); DruidDataSource dataSource = (DruidDataSource) context.getBean(\u0026#34;dataSource\u0026#34;); System.out.println(dataSource); } @Test public void dataSourceTest1(){ //DruidDataSource dataSource = new DruidDataSource(); //dataSource.setDriverClassName(); //dataSource.setUrl(); //dataSource.setUsername(); //dataSource.setPassword(); } } 本文第二张图片报了DruidDataSource警告，提示使用try-with-resources的写法 注意：用try-with-resources来代替try-catch-finally 在JavaGuide里有这里的解释，原文连接 按Ctrl+F，搜索 \u0026ldquo;如何使用 try-with-resources 代替try-catch-finally\u0026rdquo; 即可找到该位置 一般情况下会在finally语句中关闭资源，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void dataSourceTest1(){ DruidDataSource dataSource = null; try { dataSource = new DruidDataSource(); dataSource.setDriverClassName(\u0026#34;\u0026#34;); dataSource.setUrl(\u0026#34;\u0026#34;); dataSource.setUsername(\u0026#34;\u0026#34;); dataSource.setPassword(\u0026#34;\u0026#34;); }catch (Exception e){ throw new RuntimeException(\u0026#34;出现异常\u0026#34;,e); }finally { assert dataSource != null; dataSource.close(); } } 使用try-with-resources来改造上面的代码\n1 2 3 4 5 6 7 8 9 10 11 @Test public void dataSourceTest1(){ try (DruidDataSource dataSource = new DruidDataSource()) { dataSource.setDriverClassName(\u0026#34;\u0026#34;); dataSource.setUrl(\u0026#34;\u0026#34;); dataSource.setUsername(\u0026#34;\u0026#34;); dataSource.setPassword(\u0026#34;\u0026#34;); } catch (Exception e) { throw new RuntimeException(\u0026#34;出现异常\u0026#34;,e); } } 感兴趣的可以去了解一下@Value注解，会有不一样的感觉\n","date":"2023-01-14T00:00:00Z","image":"http://localhost:1313/p/05_%E8%AF%BB%E5%8F%96properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/05_%E8%AF%BB%E5%8F%96properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"05_读取properties配置文件"},{"content":"引入XML配置文件\r注意看左侧的项目结构 将来或许有各种各样的配置，将同类的配置文件放在一起 首先，jdbc.xml读取properties文件的配置，然后applicationContext导入jdbc.xml的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc/jdbc.properties\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34; id=\u0026#34;dataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${mysql.driverClassName}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${mysql.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${mysql.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${mysql.password}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 引入jdbc.xml配置文件 --\u0026gt; \u0026lt;import resource=\u0026#34;classpath:jdbc/jdbc.xml\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; ","date":"2023-01-14T00:00:00Z","image":"http://localhost:1313/p/06_%E5%BC%95%E5%85%A5xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/06_%E5%BC%95%E5%85%A5xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"06_引入xml配置文件"},{"content":"Spring低频知识点\rbean的配置\nname属性 lazy-init init-method destory-method factory-bean\u0026amp;factory-method bean的配置\rname属性\r1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.User\u0026#34; id=\u0026#34;userEntity\u0026#34; name=\u0026#34;user1\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;admin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Application_08 { public static void main(String[] args) { ApplicationContext context=new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User user= (User) context.getBean(\u0026#34;userEntity\u0026#34;); System.out.println(user); } } // User(uid=1, username=admin, password=123456) public class Application_08 { public static void main(String[] args) { ApplicationContext context=new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User user= (User) context.getBean(\u0026#34;user1\u0026#34;); System.out.println(user); } } // User(uid=1, username=admin, password=123456) 1 User user= (User) context.getBean(\u0026#34;user1\u0026#34;); 可以通过id or name来获取bean对象 name可以赋多个名字，如下\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.User\u0026#34; id=\u0026#34;userEntity\u0026#34; name=\u0026#34;user1,user2\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;admin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 public class Application_08 { public static void main(String[] args) { ApplicationContext context=new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User user= (User) context.getBean(\u0026#34;user2\u0026#34;); System.out.println(user); } } lazy-init\rscope=\u0026quot;singleton\u0026quot;单例bean，默认在容器创建时创建 而lazy-init是在第一次调用getBean方法是创建对象 和懒加载类似，需要用到的时候再加载 lazy-init=\u0026quot;true\u0026quot;或者lazy-init=\u0026quot;false\u0026quot;两种情况来进行对比\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.User\u0026#34; lazy-init=\u0026#34;true\u0026#34; id=\u0026#34;userEntity\u0026#34; name=\u0026#34;user1,user2\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;admin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; init-method\r设置出初始化方法，在对象创建之后，自动调用指定方法\n1 2 3 4 5 6 7 8 9 10 11 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String username; private String password; private void initUser(){ System.out.println(\u0026#34;学生对象初始化中---\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.User\u0026#34; id=\u0026#34;userEntity\u0026#34; init-method=\u0026#34;initUser\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;admin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 // 学生对象初始化中--- // User(uid=1, username=admin, password=123456) 注意：该初始化方法必须是空参方法 destory-method\r和init-method一样，这两个方法都需要是空参方法 怎么样销毁user对象？注意，配置文件中默认是单例bean，所以在容器销毁的时候，会销毁对象\n1 2 3 4 5 6 7 8 public class Application_08 { public static void main(String[] args) throws InterruptedException { ClassPathXmlApplicationContext context=new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User user= (User) context.getBean(\u0026#34;userEntity\u0026#34;); System.out.println(user); context.close(); } } 1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.entity.User\u0026#34; id=\u0026#34;userEntity\u0026#34; init-method=\u0026#34;initUser\u0026#34; destroy-method=\u0026#34;destoryUser\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;uid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;admin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String username; private String password; private void initUser(){ System.out.println(\u0026#34;学生对象初始化中---\u0026#34;); } private void destoryUser(){ System.out.println(\u0026#34;学生对象销毁前调用，用于释放资源---\u0026#34;); } } factory-bean\u0026amp;factory-method\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Data public class Car { /** * 发动机 */ private Motor motor; /** * 方向盘 */ private SteeringWheel steeringWheel; /** * 轮胎 */ private Tyre tyre; /** * 测试发动机 */ public void testMotor(){ System.out.println(\u0026#34;测试发动机---\u0026#34;); } /** * 测试方向盘 */ public void testSteeringWheel(){ System.out.println(\u0026#34;测试方向盘---\u0026#34;); } /** * 测试轮胎 */ public void testTyre(){ System.out.println(\u0026#34;测试轮胎---\u0026#34;); } } public class Motor { } public class SteeringWheel { } public class Tyre { } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /** * @author 深海 * @version 1.0.0 * @date 2023/01/14 * @doc 汽车实例工厂 * @since 1.0.0 */ public class CarFactory { public Car getCar(){ Car car = new Car(); // 设置属性 car.setMotor(new Motor()); car.setSteeringWheel(new SteeringWheel()); car.setTyre(new Tyre()); // 调用相关方法进行调试 car.testMotor(); car.testSteeringWheel(); car.testTyre(); return car; } } /** * @author 深海 * @version 1.0.0 * @date 2023/01/14 * @doc 汽车静态工厂 * @since 1.0.0 */ public class CarStaticFactory { public static Car getCar(){ Car car = new Car(); // 设置属性 car.setMotor(new Motor()); car.setSteeringWheel(new SteeringWheel()); car.setTyre(new Tyre()); // 调用相关方法进行调试 car.testMotor(); car.testSteeringWheel(); car.testTyre(); return car; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class MyTest { @Test public void test1(){ Car car = new Car(); // 设置属性 car.setMotor(new Motor()); car.setSteeringWheel(new SteeringWheel()); car.setTyre(new Tyre()); // 调用相关方法进行调试 car.testMotor(); car.testSteeringWheel(); car.testTyre(); System.out.println(car); } /** * 使用实例工厂来创建Car对象 */ @Test public void test2(){ CarFactory factory=new CarFactory(); Car car=factory.getCar(); System.out.println(car); } /** * 使用静态工厂来创建Car对象 */ @Test public void test3(){ Car car=CarStaticFactory.getCar(); System.out.println(car); } } 总体来说，实例工厂和静态工厂就是提取代码、增加代码复用性的作用 上述方法还是手动调用方法，接下来使用Spring来自动调用\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- 创建实例工厂 --\u0026gt; \u0026lt;bean class=\u0026#34;com.example.factory.CarFactory\u0026#34; id=\u0026#34;carFactory\u0026#34;/\u0026gt; \u0026lt;!-- 使用实例工厂创建Car，注入容器 --\u0026gt; \u0026lt;bean factory-bean=\u0026#34;carFactory\u0026#34; factory-method=\u0026#34;getCar\u0026#34; id=\u0026#34;car1\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 @Test public void test4(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); Car car1 = (Car) context.getBean(\u0026#34;car1\u0026#34;); System.out.println(car1); } 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- \u0026amp;lt;!\u0026amp;ndash; 创建实例工厂 \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!-- \u0026lt;bean class=\u0026#34;com.example.factory.CarFactory\u0026#34; id=\u0026#34;carFactory\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026amp;lt;!\u0026amp;ndash; 使用实例工厂创建Car，注入容器 \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!-- \u0026lt;bean factory-bean=\u0026#34;carFactory\u0026#34; factory-method=\u0026#34;getCar\u0026#34; id=\u0026#34;car1\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- 使用静态工厂创建Car，注入容器 --\u0026gt; \u0026lt;bean class=\u0026#34;com.example.factory.CarStaticFactory\u0026#34; factory-method=\u0026#34;getCar\u0026#34; id=\u0026#34;car2\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 @Test public void test5(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); Car car2 = (Car) context.getBean(\u0026#34;car2\u0026#34;); System.out.println(car2); } 细心地小伙伴可能发现了，为啥结果输出了两遍？ 测试实例工厂的时候，注释掉静态工厂的配置 测试静态工厂的时候，注释掉实例工厂的配置 其实就是两个工厂的配置之间的影响，测试哪个，就留哪个的配置\n","date":"2023-01-14T00:00:00Z","image":"http://localhost:1313/p/07_spring%E4%BD%8E%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/07_spring%E4%BD%8E%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9/","title":"07_Spring低频知识点"},{"content":"语法明明没有问题，却报错？\r以上操作即可关闭eslint的语法检查\n","date":"2023-01-10T00:00:00Z","image":"http://localhost:1313/p/%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5/","title":"语法检查"},{"content":"java 反射\r详细信息推介查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //获取包名、类名 clazz.getPackage().getName()//包名 clazz.getSimpleName()//类名 clazz.getName()//完整类名 //获取成员变量定义信息 getFields()//获取所有公开的成员变量,包括继承变量 getDeclaredFields()//获取本类定义的成员变量,包括私有,但不包括继承的变量 getField(变量名) getDeclaredField(变量名) //获取构造方法定义信息 getConstructor(参数类型列表)//获取公开的构造方法 getConstructors()//获取所有的公开的构造方法 getDeclaredConstructors()//获取所有的构造方法,包括私有 getDeclaredConstructor(int.class,String.class) //获取方法定义信息 getMethods()//获取所有可见的方法,包括继承的方法 getMethod(方法名,参数类型列表) getDeclaredMethods()//获取本类定义的的方法,包括私有,不包括继承的方法 getDeclaredMethod(方法名,int.class,String.class) //反射新建实例 clazz.newInstance();//执行无参构造创建对象 clazz.newInstance(222,\u0026#34;韦小宝\u0026#34;);//执行有参构造创建对象 clazz.getConstructor(int.class,String.class)//获取构造方法 //反射调用成员变量 clazz.getDeclaredField(变量名);//获取变量 clazz.setAccessible(true);//使私有成员允许访问 f.set(实例,值);//为指定实例的变量赋值,静态变量,第一参数给null f.get(实例);//访问指定实例变量的值,静态变量,第一参数给null //反射调用成员方法 Method m = Clazz.getDeclaredMethod(方法名,参数类型列表); m.setAccessible(true);//使私有方法允许被调用 m.invoke(实例,参数数据);//让指定实例来执行该方法 获取对象字节码的3种方式\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 1. public static void getClazz1() { User user = new User(); Class\u0026lt;? extends User\u0026gt; clazz = user.getClass(); System.out.println(clazz); } // 2. public static void getClazz2() { Class\u0026lt;User\u0026gt; clazz = User.class; System.out.println(clazz); } // 3. public static void getClazz3() { try { Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.example.domain.User\u0026#34;); System.out.println(clazz); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Demo1 { public static void main(String[] args) { System.out.println(getClazz()); // class com.example.domain.User System.out.println(getClazz().getName()); // com.example.domain.User System.out.println(getClazz().getSimpleName()); // User System.out.println(getClazz().getPackage()); // package com.example.domain System.out.println(getClazz().getPackage().getName()); // com.example.domain } public static Class\u0026lt;?\u0026gt; getClazz(){ try { return Class.forName(\u0026#34;com.example.domain.User\u0026#34;); } catch (Exception e) { throw new RuntimeException(e); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 package com.example.mytest; import com.example.domain.User; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.List; public class MyTest { public static void main(String[] args) { createObjectByReflect(); } /** * 获取 Class 对象 * 方法1 */ public static void getClazz1() { User user = new User(); Class\u0026lt;? extends User\u0026gt; clazz = user.getClass(); System.out.println(clazz); } /** * 获取 Class 对象 * 方法2 */ public static void getClazz2() { Class\u0026lt;User\u0026gt; clazz = User.class; System.out.println(clazz); } /** * 获取 Class 对象 * 方法3 */ public static void getClazz3() { try { Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.example.domain.User\u0026#34;); System.out.println(clazz); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } } /** * 获取类的所有方法信息 */ public static void getAllMethods() { Class\u0026lt;?\u0026gt; clazz = getClazz(); Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) { System.out.println(method); } } /** * 获取类的所有成员属性信息 */ public static void getAllFields() { Field[] declaredFields = getClazz().getDeclaredFields(); for (Field f : declaredFields) { System.out.println(f); } } /** * 获取类的构造方法信息 */ public static void getAllConstructors() { try { Constructor\u0026lt;?\u0026gt;[] declaredConstructors = getClazz().getDeclaredConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : declaredConstructors) { System.out.println(constructor); } } catch (Exception e) { throw new RuntimeException(e); } } // 利用反射动态创建对象实例 /** * 通过反射---创建对象 */ public static void createObjectByReflect() { Class\u0026lt;?\u0026gt; clazz = getClazz(); try { //User user = (User) clazz.newInstance(); Constructor\u0026lt;?\u0026gt; declaredConstructor = clazz.getDeclaredConstructor(Integer.class,String.class,Integer.class,String.class, List.class); User user = (User) declaredConstructor.newInstance(1, \u0026#34;张三\u0026#34;, 12, \u0026#34;男\u0026#34;, null); System.out.println(user); } catch (Exception e) { throw new RuntimeException(e); } } /** * 提取方法：---获取class对象 * * @return {@link Class}\u0026lt;{@link ?}\u0026gt; */ private static Class\u0026lt;?\u0026gt; getClazz() { try { return Class.forName(\u0026#34;com.example.domain.User\u0026#34;); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } } } 1 2 3 4 5 6 7 8 9 10 11 // User @Data @AllArgsConstructor @NoArgsConstructor public class User { private Integer uid; private String name; private Integer age; private String gender; private List\u0026lt;User\u0026gt; children; } ","date":"2023-01-05T00:00:00Z","image":"http://localhost:1313/p/06_%E5%8F%8D%E5%B0%84/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/06_%E5%8F%8D%E5%B0%84/","title":"06_反射"},{"content":"基本配置\r配置实时翻译\r参考教程如下\n教程1\n教程2 点击此处登录百度翻译\n点击开始注册\n","date":"2022-12-27T00:00:00Z","image":"http://localhost:1313/p/potplayer%E9%85%8D%E7%BD%AE/202412211456063_hu7238449547905668932.png","permalink":"http://localhost:1313/p/potplayer%E9%85%8D%E7%BD%AE/","title":"Potplayer"},{"content":"\r直接右键，可以选择在终端中打开//windows terminal here\n方便很多 这里有两种安装方法\n微软商店安装 github安装 第一种直接打开商店搜索Windows Terminal后安装即可 第二种点击链接 配置右键打开终端\r在C:\\Users\\用户名\\AppData\\Local下建立文件夹Terminal 新建一个空白的reg注册表文件，命名为terminal.reg，可以使用txt变换后缀得到 编辑terminal.reg文件，写入如下语句，这里的%USERPROFILE%可以换成绝对路径C:\\Users\\用户名\n1 2 3 4 5 6 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt] @=\u0026#34;打开终端\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;%USERPROFILE%\\\\AppData\\\\Local\\\\Terminal\\\\terminal.ico\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command] @=\u0026#34;C:\\\\Users\\\\用户名\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe\u0026#34; 然后双击注册表文件即可 具体步骤可查看安装+美化\n","date":"2022-12-27T00:00:00Z","image":"http://localhost:1313/p/terminal%E9%85%8D%E7%BD%AE/settings-default-shell_hu10230822076856537688.png","permalink":"http://localhost:1313/p/terminal%E9%85%8D%E7%BD%AE/","title":"Terminal"},{"content":"新建的数据库\n新建后端项目\n直接自动生成，两种方法，人人开源里的renren-generator，mybatisx插件生成\n现在已经可以自由发送请求了 链接：https://pan.baidu.com/s/1QZMyWBx6JCIpn4wF8_01gA?pwd=nc8q 提取码：nc8q ​\n","date":"2022-12-26T00:00:00Z","image":"http://localhost:1313/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE04/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE04/","title":"从零开始搭建前后端分离项目04"},{"content":"Java集合\r接口继承关系和实现\r集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。\nCollection：Collection 是集合 List、Set、Queue 的最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的数据。 Map：是映射表的基础接口。 集合框架：\nCollection List ArrayList:排列有序，可重复、底层使用数组、查询快增删慢、线程不安全、当容量不够时-ArrayList是当前容量*1.5+1 Vector:排列有序，可重复、底层使用数组、查询快增删慢、线程安全但效率低、当容量不够时-Vector默认扩展一倍容量 LinkedList:排列有序，可重复、底层使用双向循环链表数据结构、查询慢增删快、线程不安全 Set HashSet:排列无序，不可重复、底层使用Hash实现、存取速度快、内部是HashMap TreeSet:排列无序，不可重复、底层使用二叉树实现、排列存储、内部是TreeMap的SortedSet LinkedHashSet:采用Hash表存储，并用双向链表记录插入顺序、内部是LinkedHashMap Queue:在两端出入的List，所以也可以用数组和链表来实现 Map HashMap:键不可重复，值可重复、底层哈希表、线程不安全、允许键null值也可以为null HashTable:键不可重复，值可重复、底层哈希表、线程安全、键值都不允许为null TreeMap:键不可重复，值可重复、底层二叉树 List\rJava 的 List 是非常常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类分别是 ArrayList、Vector 和 LinkedList\nArrayList（数组）\rArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。\nVector（数组实现、线程同步）\rVector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。\nLinkedList（链表）\rLinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。\nSet\rSet 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。\nHashSet（Hash表）\r哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equals 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。 哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。\nTreeSet（二叉树）\rTreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。 在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 LinkHashSet（HashSet+LinkedHashMap）\r对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。\nMap\rHashMap（数组+链表+红黑树）\rHashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。\nConcurrentHashMap\rJava7实现：13/04/2018 Page 50 of 283大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 loadFactor：负载因子，默认为 0.75。 threshold：扩容的阈值，等于 capacity * loadFact Java8实现：Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 Segment段\rConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表部分或一段的意思，所以很多地方都会将其描述为分段锁。注意，行文中，槽来代表一个segment。\n线程安全（Segment继承ReentrantLock加锁）\r简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。\n并行度（默认16）\rconcurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。\nJava8实现（引入了红黑树）\rJava8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。\nHashTable（线程安全）\rHashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。\nTreeMap（可排序）\rTreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。\nLinkHashMap（记录插入的顺序）\rLinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。\n","date":"2022-12-17T00:00:00Z","image":"http://localhost:1313/p/002_%E9%9B%86%E5%90%88/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/002_%E9%9B%86%E5%90%88/","title":"002_集合"},{"content":"JVM\r加油哦！不要过度焦虑 ヾ(◍°∇°◍)ﾉﾞ\nJVM\r线程\r这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。 label Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。 当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 Java线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的CPU上。 当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源\nHotspot JVM 后台运行的系统线程主要有下面几个：\n虚拟机线程（VM thread） 周期性任务线程 GC线程 编译器线程 信号分发线程 虚拟机线程：这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-the-world垃圾回收、线程栈dump、线程暂停、线程偏向锁（biased locking）解除。 周期性任务线程：这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。 GC线程：这些线程支持 JVM 中不同的垃圾回收活动。 编译器线程：这些线程在运行时将字节码动态编译成本地平台相关的机器码。 信号分发线程：这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。\nJVM内存区域\rJVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【Java堆、方法区】、直接内存。 label 线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内，每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。 线程共享区域随虚拟机的启动/关闭而创建/销毁。 直接内存并不是 JVM 运行时数据区的一部分，但也会被频繁的使用: 在 JDK 1.4 引入的label NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作, 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能\n程序计数器（线程私有）\r一块较小的内存空间, 是当前线程所执行的字节码的行号指示器 ，每条线程都要有一个独立的程序计数器，这类内存也称为线程私有的内存。正在在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域\n虚拟机栈（线程私有）\r是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程\n栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接（Dynamic Linking）、方法返回值和异常分派（Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁 ————无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。\n本地方法区（线程私有）\r本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为\n一。\n堆（线程共享）\r是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。\n方法区/永久代（线程共享）\r即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久代的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小） 运行时常量池 （Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。\nJVM运行时内存\rJava 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。 新生代：是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。\n新生代\rEden区\nJava 新对象的出生地 （如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。\nServivorFrom区\n上一次 GC 的幸存者，作为这一次 GC 的被扫描者。\nServivorTo区\n保留了一次 MinorGC 过程中的幸存者。\nMinorGC的过程（复制–清空–互换） MinorGC 采用复制算法。\neden、servicorFrom 复制到 ServicorTo，年龄+1\n首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则复制到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年代区） 清空 eden、servicorFrom\n然后，清空 Eden 和 ServicorFrom 中的对 ServicorTo 和 ServicorFrom 互换\n最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。 老年代\r主要存放应用程序中生命周期长的内存对象。 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋升入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。\nMajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。\n永久代\r指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理 。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。 在 Java8 中，永久代已经被移除，被一个称为元数据区（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。\n垃圾回收算法\r引用计数法\n在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。（存在A引用B，B引用A，即AB互相引用，导致都无法被回收的现象） 可达性分析法\n为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收， 标记清除算法\n最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题是内存碎片化严重 ，后续可能发生大对象不能找到可利用空间的问题。 复制算法\n为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。\n这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，复制 算法的效率会大大降低。 标记整理算法\n结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。 在新生代中采用复制算法：每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集。 在老年代中采用标记整理算法：因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用标记—清理或标记—整理算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。\n引用类型\r强引用\n在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用 。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。\n软引用\n软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。\n弱引用\n弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。\n虚引用\n虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。\nGC分代收集算法 与 分区收集算法\r分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。 分区收集算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是 可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。\nGC垃圾收集器\rJava 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器JDK1.6 中 Sun HotSot 虚拟机的垃圾收集器如下：\nSerial 垃圾收集器（单线程、复制算法） ParNew 垃圾收集器（Serial+多线程） Parallel Scavenge 收集器（多线程复制算法、高效） Serial Old 收集器（单线程标记整理算法） Parallel Old 收集器（多线程标记整理算法） CMS 收集器（多线程标记清除算法） G1收集器 Serial 垃圾收集器（单线程、复制算法）\rSerial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。\nParNew 垃圾收集器（Serial+多线程）\rParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。\nParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。【Parallel：平行的】\nParNew虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java虚拟机运行在 Server 模式下新生代的默认垃圾收集器。\nParallel Scavenge 收集器（多线程复制算法、高效）\rParallel Scavenge 收集器是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）， 高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的重要区别。\nSerial Old 收集器（单线程标记整理算法）\rSerial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。\n在 Server 模式下，主要有两个用途：\n在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。 作为年老代中使用 CMS 收集器的后备垃圾收集方案。 新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。\nParallel Old 收集器（多线程标记整理算法）\rParallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。\nCMS 收集器（多线程标记清除算法）\rConcurrent mark sweep(CMS)收集器是一种老年代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他老年代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。\nCMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段\n初始标记：只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。 并发标记：进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作。 重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线 并发清除：清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。 由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。\nG1 收集器\rGarbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收集器两个最突出的改进是：\n基于标记-整理算法，不产生内存碎片。 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。 G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域 。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。\nJava IO/NIO\r阻塞IO模型 非阻塞IO模型 多路复用IO模型 信号驱动IO模型 异步IO模型 IO模型\r阻塞IO模型\n最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data = socket.read();如果数据没有就绪，就会一直阻塞在 read 方法。\n非阻塞IO模型\n当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下。\n1 2 3 4 5 6 7 while (true) { data = socket.read(); if (data != error) { // 处理数据 break; } } 但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。\n多路复用IO模型\n多路复用 IO 模型是目前使用得比较多的模型。\nJava NIO 实际上就是多路复用 IO。在多路复用 IO模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。\n在 Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。\n多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。\n另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。\n不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。\n信号驱动IO模型\n在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。\n异步IO模型\n异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要知道实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。\n也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。 注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO\nJava IO包\rNIO 主要有三大核心部分：Channel(通道)、Buffer(缓冲区)、 Selector。传统 IO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。 NIO 和传统 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。\nChannel\n首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。NIO 中的 Channel 的主要实现有： FileChannel DatagramChannel SocketChannel ServerSocketChannel 这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。\nBuffer\nBuffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。\n客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。\n在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：\nByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、ShortBuffer\nSelector\nSelector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。\nNIO的缓冲区\nJava IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。\nNIO的非阻塞\nIO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。\nJava类加载机制\rJVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。\n加载 加载是类加载过程中的一个阶段（请勿混淆这两个概念） ，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。\n验证\n验证这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n准备\n准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：\n1 public static int v = 8080; 实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是程序被编译后，存放于类构造器client方法之中。但是注意如果声明为：\n1 public static final int v = 8080; 在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080.\n解析\n解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的\nCONSTANT_Class_info CONSTANT_Field_info CONSTANT_Method_info\n等类型的常量。 符号引用\n符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。\n直接引用\n直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。\n初始化\n初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。\n类构造器：初始化阶段是执行类构造器client方法的过程。client方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子client方法执行之前，父类的client方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成client()方法。 注意以下几种情况不会执行类初始化：\n通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 通过类名获取 Class 对象，不会触发类的初始化。 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 类加载器：虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提供了 3 种类加载器。\n启动类加载器(Bootstrap ClassLoader) 扩展类加载器(Extension ClassLoader) 应用程序类加载器(Application ClassLoader) 双亲委派机制：当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象 。 OSGI（动态模型系统）：OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。\n动态改变构造\nOSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。\n模块化编程与热插拔\nOSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。\n","date":"2022-12-17T00:00:00Z","image":"http://localhost:1313/p/01_jvm/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/01_jvm/","title":"01_Jvm"},{"content":"Java多线程并发\rJava线程实现/创建方式\r继承Thread类\rThread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。\n1 2 3 4 5 6 7 public class MyThread extends Thread { public void run() { System.out.println(\u0026#34;MyThread.run()\u0026#34;); } } MyThread myThread1 = new MyThread(); myThreadstart(); 实现Runnable接口\r如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class MyThread extends OtherClass implements Runnable { public void run() { System.out.println(\u0026#34;MyThread.run()\u0026#34;); } } //启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例： MyThread myThread = new MyThread(); Thread thread = new Thread(myThread); thread.start(); //事实上，当传入一个 Runnable target 参数给 Thread 后，Thread 的 run()方法就会调用 target.run() public void run() { if (target != null) { target.run(); } } 实现Callable接口\r有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须实现 Runnable 接口。\n执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //创建一个线程池 ExecutorService pool = Executors.newFixedThreadPool(taskSize); // 创建多个有返回值的任务 List\u0026lt;Future\u0026gt; list = new ArrayList\u0026lt;Future\u0026gt;(); for (int i = 0; i \u0026lt; taskSize; i++) { Callable c = new MyCallable(i + \u0026#34; \u0026#34;); // 执行任务并获取 Future 对象 Future f = pool.submit(c); list.add(f); } // 关闭线程池 pool.shutdown(); // 获取所有并发任务的运行结果 for (Future f : list) { // 从 Future 对象上获取任务的返回值，并输出到控制台 System.out.println(\u0026#34;res：\u0026#34; + f.get().toString()); } 基于线程池的方式\r线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); while(true) { threadPool.execute(new Runnable() { // 提交多个线程任务，并执行 @Override public void run() { System.out.println(Thread.currentThread().getName() + \u0026#34; is running ..\u0026#34;); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } } 4种线程池\rJava 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 ExecutorService。\nnewCachedThreadPool\r创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。\nnewFixedThreadPool\r创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。\nnewScheduledThreadPool\r创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n表头 表头 1 2 3 4 5 6 7 8 9 10 11 12 13 ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3); scheduledThreadPool.schedule(newRunnable(){ @Override public void run() { System.out.println(\u0026#34;延迟三秒\u0026#34;); } }, 3, TimeUnit.SECONDS); scheduledThreadPool.scheduleAtFixedRate(newRunnable(){ @Override public void run() { System.out.println(\u0026#34;延迟 1 秒后每三秒执行一次\u0026#34;); } },1,3,TimeUnit.SECONDS); newSingleThreadExecutor\rExecutors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去。\n线程生命周期（状态）\r当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直霸占着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。\n新建状态（new）\r当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值。\n就绪状态（runnable）\r当线程对象调用了 start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。\n运行状态（running）\r如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。\n阻塞状态（blocked）\r阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种：\n等待阻塞（o.wait-\u0026gt;等待对列） 运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中。\n同步阻塞(lock-\u0026gt;锁池) 运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中。\n其他阻塞(sleep/join) 运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入可运行(runnable)状态。\n线程死亡（dead）\r线程会以下面三种方式结束，结束后就是死亡状态。\n正常结束：run()或 call()方法执行完成，线程正常结束。 异常结束：线程抛出一个未捕获的 Exception 或 Error。 调用 stop：直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用。 终止线程的4种方式\r正常运行结束\r程序运行结束，线程自动结束。\n使用退出标志退出线程\r一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。 使用一个变量来控制循环，例如：最直接的方法就是设一个 boolean 类型的标志，并通过设置这个标志为 true 或 false 来控制 while循环是否退出，代码示例：\n1 2 3 4 5 6 7 8 public class ThreadSafe extends Thread { public volatile boolean exit = false; public void run() { while (!exit){ //do something } } } 定义了一个退出标志 exit，当 exit 为 true 时，while 循环退出，exit 的默认值为 false.在定义 exit时，使用了一个 Java 关键字 volatile ，这个关键字的目的是使 exit 同步，也就是说在同一时刻只能由一个线程来修改 exit 的值。\ninterrupt方法结束线程\r使用 interrupt()方法来中断线程有两种情况：\n线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法 线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。 1 2 3 4 5 6 7 8 9 10 11 12 public class ThreadSafe extends Thread { public void run() { while (!isInterrupted()){ //非阻塞过程中通过判断中断标志来退出 try{ Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出 }catch(InterruptedException e){ e.printStackTrace(); break;//捕获到异常之后，执行 break 跳出循环 } } } } stop方法终止线程（线程不安全）\r程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制) ，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。\nsleep与wait区别\r对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于Object 类中的。 sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。 在调用 sleep()方法的过程中，线程不会释放对象锁。 而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。 start与run区别\rstart（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。 在本质上run方法并没有实现多线程，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 Java后台线程\r定义：守护线程–也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公共服务，在没有用户线程可服务时会自动离开。 优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。 设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。 在 Daemon 线程中产生的新线程也是 Daemon 的。 线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。 example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。 Java锁\r乐观锁\r乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据 ，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。\njava 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。\n悲观锁\r悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。\n自旋锁\r自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。\n线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。\n如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。\n自旋锁的优缺点\n自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！\n但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；\n自旋锁时间阈值（1.6 引入了适应性自旋锁）\n自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！\nJVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。 自旋锁的开启\nJDK1.6 中-XX:+UseSpinning 开启；\n-XX:PreBlockSpin=10 为自旋次数；\nJDK1.7 后，去掉此参数，由 jvm 控制；\nSynchronized同步锁\rsynchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。\nsynchronized 作用范围\n作用于方法时，锁住的是对象的实例(this)； 当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程； synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。 Synchronized 核心组件\nWait Set：哪些调用 wait 方法被阻塞的线程被放置在这里； Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中； Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中； OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck； Owner：当前已经获取到所资源的线程被称为 Owner； !Owner：当前释放锁的线程。 Synchronized 实现\nJVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。 Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。 Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。 OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。 处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的） Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。 每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的 synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。 Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。 锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀； JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。 ReentranLock\rReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。 Lock 接口的主要方法\nvoid lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁. boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生. Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。 getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行 lock 方法的次数。 getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9 getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了condition 对象的 await 方法，那么此时执行此方法返回 10 hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法 hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁 hasQueuedThreads()：是否有线程等待此锁 isFair()：该锁是否公平锁 isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true isLock()：此锁是否有任意线程占用 lockInterruptibly（）：如果当前线程未被中断，获取锁 tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁 tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁 非公平锁\nJVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。 公平锁\n公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。 ReentrantLock 与 synchronized\nReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。 ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。 `ReentrantLock 实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class MyService { private Lock lock = new ReentrantLock(); //Lock lock=new ReentrantLock(true);//公平锁 //Lock lock=new ReentrantLock(false);//非公平锁 private Condition condition=lock.newCondition();//创建 Condition public void testMethod() { try { lock.lock();//lock 加锁 //1：wait 方法等待： //System.out.println(\u0026#34;开始 wait\u0026#34;); condition.await(); //通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁 //:2：signal 方法唤醒 condition.signal();//condition 对象的 signal 方法可以唤醒 wait 线程 for (int i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;ThreadName=\u0026#34; + Thread.currentThread().getName()+ (\u0026#34; \u0026#34; + (i + 1))); } } catch (InterruptedException e) { e.printStackTrace(); } finally{ lock.unlock(); } } } Condition 类和 Object 类锁方法 区别\nCondition 类的 awiat 方法和 Object 类的 wait 方法等效 Condition 类的 signal 方法和 Object 类的 notify 方法等效 Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效 ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的 tryLock 和 lock 和 lockInterruptibly 的区别\ntryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false lock 能获得锁就返回 true，不能的话一直等待获得锁 lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。 Semaphore信号量\rSemaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池 实现互斥锁（计数器为 1）\n我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制 ，这也叫二元信号量，表示两种互斥状态。 `代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 创建一个计数阈值为 5 的信号量对象 // 只能 5 个线程同时访问 Semaphore semp = new Semaphore(5); try { // 申请许可 semp.acquire(); try { // 业务逻辑 } catch (Exception e) { } finally { // 释放许可 semp.release(); } } catch (InterruptedException e) { } Semaphore 与 ReentrantLock\nSemaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。\n此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能 ，除了方法名 tryAcquire 与 tryLock不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。\nSemaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。\nAtomicInteger\r首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference将一个对象的所有操作转化成原子操作。\n我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是 ReentantLock 的好几倍。\n可重入锁（递归锁）\r本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。\n公平锁与非公平锁\r公平锁（Fair）\n加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得 非公平锁（Nonfair）\n加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待\n非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列 Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。 ReadWriteLock读写锁\r为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。\n读锁\n如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁\n写锁\n如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现ReentrantReadWriteLock。\n共享锁 和 独占锁\rjava 并发包提供的加锁模式分为独占锁和共享锁。\n独占锁\n独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。 共享锁\n共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。\nAQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。 java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。 重量级锁（Mutex Lock）\rSynchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为重量级锁。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了轻量级锁和偏向锁\n轻量级锁\r锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。\n锁升级\n随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。轻量级是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。\n偏向锁\rHotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。\n分段锁\r分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践。\n锁优化\r减少锁持有时间\n只用在有线程安全要求的程序上加锁\n减小锁粒度\n将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。\n锁分离\n最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。JDK 并发包，读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比LinkedBlockingQueue 从头部取出，从尾部放数据\n锁粗化\n通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化。\n锁消除\n锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。\n线程基本方法\r线程相关的基本方法有 wait，notify，notifyAll，sleep，join，yield 等。\n线程等待（wait）\r调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中。\n线程睡眠（sleep）\rsleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态。\n线程让步（yield）\ryield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。\n线程中断（interrupt）\r中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)。\n调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。 若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。 许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。 中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。 Join等待其他线程终止\rjoin() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，等到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。\n为什么要用join()方法\r很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。\n1 2 3 4 5 System.out.println(Thread.currentThread().getName() + \u0026#34;线程运行开始!\u0026#34;); Thread6 thread1 = new Thread6(); threadsetName(\u0026#34;线程 B\u0026#34;); threadjoin(); System.out.println(\u0026#34;这时 thread1 执行完毕之后才能执行主线程\u0026#34;); 线程唤醒（notify）\rObject 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。\n其他方法\rsleep()：强迫一个线程睡眠Ｎ毫秒。 isAlive()： 判断一个线程是否存活。 join()： 等待线程终止。 activeCount()： 程序中活跃的线程数。 enumerate()： 枚举程序中的线程。 currentThread()： 得到当前线程。 isDaemon()： 一个线程是否为守护线程。 setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) setName()： 为线程设置一个名称。 wait()： 强迫一个线程等待。 notify()： 通知一个线程继续运行。 setPriority()： 设置一个线程的优先级。 getPriority():：获得一个线程的优先级。 线程上下文切换\r巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一个 CPU 上执行变成了可能。\n进程\r（有时候也称做任务）是指一个程序运行的实例。在 Linux 系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。\n上下文\r是指某一时间点 CPU 寄存器和程序计数器的内容。\n寄存器\r是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。\n程序计数器\r是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。\nPCB-“切换帧”\r上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作切换桢（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。\n上下文切换的活动\r挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。 在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。 引起线程上下文切换的原因\r当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务； 当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务； 多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务； 用户代码挂起当前任务，让出 CPU 时间； 硬件中断； 同步锁 与 死锁\r同步锁\r当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥 ，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。\n死锁\r何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。\n线程池原理\r线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。\n线程复用\r每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run\n方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。\n线程池组成\r一般的线程池主要分为以下 4 个组成部分：\n线程池管理器：用于创建并管理线程池\n工作线程：线程池中的线程\n任务接口：每个任务必须实现的接口，用于工作线程调度其运行\n任务队列：用于存放待处理的任务，提供一种缓冲机制\nJava 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，\nExecutorService，ThreadPoolExecutor ，Callable 和 Future、FutureTask 这几个类。\nThreadPoolExecutor 的构造方法如下：\n1 2 3 4 public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, long keepAliveTime,TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); } corePoolSize：指定了线程池中的线程数量。\nmaximumPoolSize：指定了线程池中的最大线程数量。\nkeepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多\n次时间内会被销毁。\nunit：keepAliveTime 的单位。\nworkQueue：任务队列，被提交但尚未被执行的任务。\nthreadFactory：线程工厂，用于创建线程，一般用默认的即可。\nhandler：拒绝策略，当任务太多来不及处理，如何拒绝任务。\n拒绝策略\r线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。JDK 内置的拒绝策略如下：\nAbortPolicy ： 直接抛出异常，阻止系统正常运行。 CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。 DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。 Java线程池工作过程\r线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。 当调用 execute() 方法添加一个任务时，线程池会做如下判断：\na) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；\nb) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；\nc) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；\nd) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。 当一个线程完成任务时，它会从队列中取下一个任务来执行。 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。 阻塞队列原理\r阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：\n当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队。 当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒 阻塞队列的主要方法\r抛出异常：抛出一个异常； 特殊值：返回一个特殊值（null 或 false,视情况而定） 阻塞：在成功操作之前，一直阻塞线程 超时：放弃前只在最大的时间内阻塞 插入操作：\n1：public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。\n2：public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。\n3：public abstract void put(E paramE) throws InterruptedException： 将指定元素插入此队列中，将等待可用的空间（如果有必要)\n4：offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败\n1 2 3 4 5 6 7 8 9 10 11 12 13 public void put(E paramE) throws InterruptedException { checkNotNull(paramE); ReentrantLock localReentrantLock = this.lock; localReentrantLock.lockInterruptibly(); try { while (this.count == this.items.length) this.notFull.await();//如果队列满了，则线程阻塞等待 enqueue(paramE); localReentrantLock.unlock(); } finally { localReentrantLock.unlock(); } } 获取数据操作：\n1：poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数规定的时间,取不到时返回 null;\n2：poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。\n3：take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入。\n4.drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。\nJava中的阻塞队列\rArrayBlockingQueue ：由数组结构组成的有界阻塞队列。 LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。 PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。 DelayQueue：使用优先级队列实现的无界阻塞队列。 SynchronousQueue：不存储元素的阻塞队列。 LinkedTransferQueue：由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：由链表结构组成的双向阻塞队列 ArrayBlockingQueue（公平、非公平）\r用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列。\nArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);\nLinkedBlockingQueue（两个独立锁提高并发）\r基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。\nLinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。\nPriorityBlockingQueue（compare to排序实现优先）\r是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。\nDelayQueue（缓存失效、定时任务）\r是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景。\n缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。 定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。 SynchronousQueue（不存储数据、可用于传递数据）\r是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另 外 一 个 线 程 使 用 ， SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和ArrayBlockingQueue。\nLinkedTransferQueue\r是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。\ntransfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。 tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。\n对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。 LinkedBlockingDeque\r是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在工作窃取模式中。\nCyclicBarrier、CountDownLatch、Semaphore用法\rCountDownLatch（线程计数器）\rCountDownLatch 类位于 java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch来实现这种功能了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 final CountDownLatch latch = new CountDownLatch(2); new Thread(){ public void run() { System.out.println(\u0026#34;子线程\u0026#34;+Thread.currentThread().getName()+\u0026#34;正在执行\u0026#34;); Thread.sleep(3000); System.out.println(\u0026#34;子线程\u0026#34;+Thread.currentThread().getName()+\u0026#34;执行完毕\u0026#34;); latch.countDown(); }; }.start(); new Thread(){ public void run() { System.out.println(\u0026#34;子线程\u0026#34;+Thread.currentThread().getName()+\u0026#34;正在执行\u0026#34;); Thread.sleep(3000); System.out.println(\u0026#34;子线程\u0026#34;+Thread.currentThread().getName()+\u0026#34;执行完毕\u0026#34;); latch.countDown(); }; }.start(); System.out.println(\u0026#34;等待 2 个子线程执行完毕...\u0026#34;); latch.await(); System.out.println(\u0026#34;2 个子线程已经执行完毕\u0026#34;); System.out.println(\u0026#34;继续执行主线程\u0026#34;); CycliBarrier（回环栅栏-等待至barrier状态再全部同时执行）\r字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做barrier，当调用 await()方法之后，线程就处于 barrier 了。\nCyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本：\npublic int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务； public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。\n具体使用如下，另外 CyclicBarrier 是可以重用的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static void main(String[] args) { int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i\u0026lt;N;i++) new Writer(barrier).start(); } static class Writer extends Thread{ private CyclicBarrier cyclicBarrier; public Writer(CyclicBarrier cyclicBarrier) { this.cyclicBarrier = cyclicBarrier; } @Override public void run() { try { Thread.sleep(5000); //以睡眠来模拟线程需要预定写入数据操作 System.out.println(\u0026#34;线程\u0026#34;+Thread.currentThread().getName()+\u0026#34;写入数据完 毕，等待其他线程写入完毕\u0026#34;); cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); }catch(BrokenBarrierException e){ e.printStackTrace(); } System.out.println(\u0026#34;所有线程写入完毕，继续处理其他任务，比如数据操作\u0026#34;); } } Semaphore（信号量-控制同时访问的线程个数）\rSemaphore 翻译成字面意思为 信号量，Semaphore 可以控制同时访问的线程个数，通过acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。Semaphore 类中比较重要的几个方法。\npublic void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。\npublic void acquire(int permits):获取 permits 个许可\npublic void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。\npublic void release(int permits) { }:释放 permits 个许可\n上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法\npublic boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false\npublic boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false\npublic boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false\npublic boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false\n还可以通过 availablePermits()方法得到可用的许可数目。例子：若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int N = 8; //工人数 Semaphore semaphore = new Semaphore(5); //机器数目 for(int i=0;i\u0026lt;N;i++){ new Worker(i,semaphore).start(); } static class Worker extends Thread{ private int num; private Semaphore semaphore; public Worker(int num,Semaphore semaphore){ this.num = num; this.semaphore = semaphore; } @Override public void run() { try { semaphore.acquire(); System.out.println(\u0026#34;工人\u0026#34;+this.num+\u0026#34;占用一个机器在生产...\u0026#34;); Thread.sleep(2000); System.out.println(\u0026#34;工人\u0026#34;+this.num+\u0026#34;释放出机器\u0026#34;); semaphore.release(); } catch (InterruptedException e) { e.printStackTrace(); } } } CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的 Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。 volatile关键字的作用（变量可见性、禁止重排序）\rJava 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。\n变量可见性\n其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。\n禁止重排序\nvolatile 禁止了指令重排。\n比 sychronized 更轻量级的同步锁\n在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。 当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。 适用场景\n值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：\n（1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）。\n（2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。\n如何在两个线程之间共享数据\rJava 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到同步和互斥。有以下常规实现方法：\n将数据抽象成一个类，并将数据的操作作为这个类的方法\n将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到同步，只要在方法上加“synchronize” Runnable 对象作为一个类的内部类：将 Runnable 对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个 Runnable 对象调用外部类的这些方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class MyData { private int j=0; public synchronized void add(){ j++; System.out.println(\u0026#34;线程\u0026#34;+Thread.currentThread().getName()+\u0026#34;j 为：\u0026#34;+j); } public synchronized void dec(){ j--; System.out.println(\u0026#34;线程\u0026#34;+Thread.currentThread().getName()+\u0026#34;j 为：\u0026#34;+j); } public int getData(){ return j; } } public class AddRunnable implements Runnable{ MyData data; public AddRunnable(MyData data){ this.data= data; } public void run() { data.add(); } } public class DecRunnable implements Runnable { MyData data; public DecRunnable(MyData data){ this.data = data; } public void run() { data.dec(); } } public static void main(String[] args) { MyData data = new MyData(); Runnable add = new AddRunnable(data); Runnable dec = new DecRunnable(data); for(int i=0;i\u0026lt;2;i++){ new Thread(add).start(); new Thread(dec).start(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class MyData { private int j=0; public synchronized void add(){ j++; System.out.println(\u0026#34;线程\u0026#34;+Thread.currentThread().getName()+\u0026#34;j 为：\u0026#34;+j); } public synchronized void dec(){ j--; System.out.println(\u0026#34;线程\u0026#34;+Thread.currentThread().getName()+\u0026#34;j 为：\u0026#34;+j); } public int getData(){ return j; } } public class TestThread { public static void main(String[] args) { final MyData data = new MyData(); for(int i=0;i\u0026lt;2;i++){ new Thread(new Runnable(){ public void run() { data.add(); } }).start(); new Thread(new Runnable(){ public void run() { data.dec(); } }).start(); } } } ThreadLocal作用（线性本地存储）\rThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\nThreadLocalMap（线程的一个属性）\n每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。 将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。 ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义ThreadLocal.ThreadLocalMap threadLocals = null;\n使用场景\n最常见的 ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。 1 2 3 4 5 6 7 8 9 10 11 12 13 private static final ThreadLocal threadSession = new ThreadLocal(); public static Session getSession() throws InfrastructureException { Session s = (Session) threadSession.get(); try { if (s == null) { s = getSessionFactory().openSession(); threadSession.set(s); } } catch (HibernateException ex) { throw new InfrastructureException(ex); } return s; } Synchronized 和 ReentrantLock 的区别\r两者的共同点\r都是用来协调多线程对共享对象、变量的访问 都是可重入锁，同一线程可以多次获得同一个锁 都保证了可见性和互斥性 两者的不同点\rReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁 ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性 ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的 ReentrantLock 可以实现公平锁 ReentrantLock 通过 Condition 可以绑定多个条件 底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略 Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。 synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。 Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。 ConcurrentHashMap并发\r减小锁粒度\r减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为 ConcurrentHashMap 的并发度。\nConcurrentHashMap分段锁\rConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，即就是锁的并发度。\n如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。\nConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成\nConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。\nJava中用到的线程调度\r抢占式调度\r抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。\n协同式调度\r协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。\njvm的线程调度实现（抢占式调度）\rjava 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。\n线程让出CPU的情况\r当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。 当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。 当前运行线程结束，即运行完 run()方法里面的任务。 进程调度算法\r优先调度算法\r先来先服务调度算法（FCFS） 当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。 短作业(进程)优先调度算法短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。 高优先权优先调度算法\r为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。\n非抢占式优先权算法在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 抢占式优先权调度算法在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。 高响应比优先调度算法 在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。 基于时间片的轮转调度算法\r时间片轮转法在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。 多级反馈队列调度算法\n(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。\n(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。\n(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。 在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。 什么是CAS（比较并交换-乐观锁机制-锁自旋）\r概念及特性\rCAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。\nCAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。\n原子包java.util.concurrent.atomic（锁自旋）\rJDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class AtomicInteger extends Number implements java.io.Serializable { private volatile int value; public final int get() { return value; } public final int getAndIncrement() { for (;;) { //CAS 自旋，一直尝试，直达成功 int current = get(); int next = current + 1; if (compareAndSet(current, next)) return current; } } public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } } getAndIncrement 采用了 CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行CAS 操作，如果成功就返回结果，否则重试直到成功为止。而 compareAndSet 利用 JNI 来完成CPU 指令的操作。\nABA问题\rCAS 会导致ABA 问题。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。\n比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。\n部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。\n什么是AQS（抽象的队列同步器）\rAbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。\n它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的访问方式有三种:\ngetState() setState() compareAndSetState() AQS 定义两种资源共享方式\nExclusive 独占资源-ReentrantLock\nExclusive（独占，只有一个线程能执行，如 ReentrantLock）\nShare 共享资源-Semaphore/CountDownLat\nShare（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。\nAQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS)之所以没有定义成abstract ，是 因 为独 占模 式 下 只 用实现 tryAcquire-tryRelease ，而 共享 模 式 下 只用 实 现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\nisHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。 tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回 false 同步器的实现是 ABS 核心（state 资源状态计数）\n同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。\n以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state会 CAS 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。 ReentrantReadWriteLock 实现独占和共享两种方式\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquired-tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。\n","date":"2022-12-17T00:00:00Z","image":"http://localhost:1313/p/03_java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/03_java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/","title":"03_Java多线程并发"},{"content":"Spring原理\rSpring特点\r它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是 Spring仍然可以和其他的框架无缝整合。\n轻量级\r控制反转\r面向切面\r容器\r框架集合\rSpring核心组件\rSpring常用模块\rSpring主要包\rSpring常用注解\rbean 注入与装配的的方式有很多种，可以通过 xml、get set 方式，、造函数或者注解等。简单易用的方式就是使用 Spring 的注解了，Spring 提供了大量的注解方式\nSpring第三方结合\rSpring IOC原理\r概念\rSpring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。\nSpring容器高层视图\rSpring 启动时读取应用程序提供的 Bean 配置信息，并在 Spring 容器中生成一份相应的 Bean 配置注册表，然后根据这张注册表实例化 Bean，装配好 Bean 之间的依赖关系，为上层应用提供准备就绪的运行环境。其中 Bean 缓存池为 HashMap 实现。\nIOC容器实现\rBeanFactory-框架基础设施\rBeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory\nBeanDefinitionRegistry 注册表：Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册BeanDefinition 对象的方法 BeanFactory 顶层接口：位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展 ListableBeanFactory：该接口定义了访问容器中 Bean 基本信息的若干方法，如查看 Bean 的个数、获取某一类型Bean 的配置名、查看容器中是否包括某一 Bean 等方法 HierarchicalBeanFactory 父子级联：父子级联 IOC 容器的接口，子容器可以通过接口方法访问父容器； 通过HierarchicalBeanFactory 接口， Spring 的 IOC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean ConfigurableBeanFactory：是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法 AutowireCapableBeanFactory 自动装配：定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法 SingletonBeanRegistry 运行期间注册单例 Bean：定义了允许在运行期间向容器注册单实例 Bean 的方法；对于单实例（ singleton）的 Bean 来说，BeanFactory 会缓存 Bean 实例，所以第二次使用 getBean() 获取 Bean 时将直接从IoC 容器的缓存中获取 Bean 实例。Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单实例 Bean 的缓存器，它是一个用 HashMap 实现的缓存器，单实例的 Bean 以beanName 为键保存在这个 HashMap中 依赖日志框架：在初始化 BeanFactory 时，必须为其提供一种日志框架，比如使用 Log4J， 即在类路径下提供 Log4J 配置文件，这样启动 Spring 容器才不会报错 ApplicationContext 面向开发应用\rApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能\nClassPathXmlApplicationContext：默认从类路径加载配置文件 FileSystemXmlApplicationContext：默认从文件系统中装载配置文件 ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。 MessageSource：为应用提供 i18n 国际化消息访问的功能； ResourcePatternResolver ： 所 有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。 LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体Bean 实现，ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。 ConfigurableApplicationContext 扩展于 ApplicationContext，它新增加了两个主要的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用 close()则可关闭应用上下文 WebApplication 体系架构\rWebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。从 WebApplicationContext 中可以获得ServletContext 的引用，整个 Web 应用上下文对象将作为属性放置到 ServletContext 中，以便 Web 应用环境可以访问 Spring 应用上下文\nSpringBean作用域\rSpring 3 中为 Bean 定义了 5 中作用域，分别为 singleton（单例）、prototype（原型）、request、session 和 global session，5 种作用域说明如下：\nsingleton：单例模式（多线程下不安全）\nsingleton：单例模式，Spring IoC 容器中只会存在一个共享的 Bean 实例，无论有多少个Bean 引用它，始终指向同一对象。该模式在多线程下是不安全的。Singleton 作用域是Spring 中的缺省作用域，也可以显示的将 Bean 定义为 singleton 模式.\n配置为：\n1 \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.ioc.UserDaoImpl\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt; prototype:原型模式每次使用时创建：\nprototype:原型模式，每次通过 Spring 容器获取 prototype 定义的 bean 时，容器都将创建一个新的 Bean 实例，每个 Bean 实例都有自己的属性和状态，而 singleton 全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。\nRequest：一次 request 一个实例：\nrequest：在一次 Http 请求中，容器会返回该 Bean 的同一实例。而对不同的 Http 请求则会产生新的 Bean，而且该 bean 仅在当前 Http Request 内有效,当前 Http 请求结束，该 bean实例也将会被销毁。\n1 \u0026lt;bean id=\u0026#34;loginAction\u0026#34; class=\u0026#34;com.cnblogs.Login\u0026#34; scope=\u0026#34;request\u0026#34;/\u0026gt; session\nsession：在一次 Http Session 中，容器会返回该 Bean 的同一实例。而对不同的 Session 请求则会创建新的实例，该 bean 实例仅在当前 Session 内有效。同 Http 请求相同，每一次session 请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的 session 请求内有效，请求结束，则实例将被销毁。\n1 \u0026lt;bean id=\u0026#34;userPreference\u0026#34; class=\u0026#34;com.ioc.UserPreference\u0026#34; scope=\u0026#34;session\u0026#34;/\u0026gt; global Session\nglobal Session：在一个全局的 Http Session 中，容器会返回该 Bean 的同一个实例，仅在使用 portlet context 时有效。\nSpringBean生命周期\r实例化\n实例化一个 Bean，也就是我们常说的 new。\nIOC 依赖注入\n按照 Spring 上下文对实例化的 Bean 进行配置，也就是 IOC 注入。\nsetBeanName 实现\n如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String)方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值\nBeanFactoryAware 实现\n如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory，setBeanFactory(BeanFactory)传递的是 Spring 工厂自身（可以用这个方式来获取其它 Bean，只需在 Spring 配置文件中配置一个普通的 Bean 就可以）。\nApplicationContextAware 实现\n如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用setApplicationContext(ApplicationContext)方法，传入 Spring 上下文（同样这个方式也可以实现步骤 4 的内容，但比 4 更好，因为 ApplicationContext 是 BeanFactory 的子接口，有更多的实现方法）\npostProcessBeforeInitialization 接口实现-初始化预处理\n如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor 经常被用作是 Bean 内容的更改，并且由于这个是在 Bean 初始化结束时调用那个的方法，也可以被应用于内存或缓存技术。\ninit-method\n如果 Bean 在 Spring 配置文件中配置了 init-method 属性会自动调用其配置的初始化方法。\npostProcessAfterInitialization\n如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用postProcessAfterInitialization(Object obj, String s)方法。\n注：以上工作完成以后就可以应用这个 Bean 了，那这个 Bean 是一个 Singleton 的，所以一般情况下我们调用同一个 id 的 Bean 会是在内容地址相同的实例，当然在 Spring 配置文件中也可以配置非 Singleton。\nDestroy 过期自动清理阶段\n当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用那个其实现的 destroy()方法；\ndestroy-method 自配置清理\n最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。\n![Bean在Spring Bean应用上下文中的生命周期](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202301201942515.png)\r（生命周期）\nbean 标签有两个重要的属性（init-method 和 destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct 和@PreDestroy）。 Spring依赖注入四种方式\r构造器注入\n1 2 3 4 /*带参数，方便利用构造器进行注入*/ public CatDaoImpl(String message){ this. message = message; } 1 2 3 \u0026lt;bean id=\u0026#34;CatDaoImpl\u0026#34; class=\u0026#34;com.CatDaoImpl\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34; message \u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; setter 方法注入\n1 2 3 4 5 6 7 8 9 public class Id { private int id; public int getId() { return id; } public void setId(int id) { this.id = id; } } 1 2 3 \u0026lt;bean id=\u0026#34;id\u0026#34; class=\u0026#34;com.id \u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;id\u0026#34; value=\u0026#34;123\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 静态工厂注入\n静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 spring 管理所有对象，我们不能直接通过工程类.静态方法()来获取对象，而是依然通过 spring 注入的形式获取\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class DaoFactory { //静态工厂 public static final FactoryDao getStaticFactoryDaoImpl(){ return new StaticFacotryDaoImpl(); } } public class SpringAction { private FactoryDao staticFactoryDao; //注入对象 //注入对象的 set 方法 public void setStaticFactoryDao(FactoryDao staticFactoryDao) { this.staticFactoryDao = staticFactoryDao; } } //factory-method=\u0026#34;getStaticFactoryDaoImpl\u0026#34;指定调用哪个工厂方法 1 2 3 4 5 6 \u0026lt;bean name=\u0026#34;springAction\u0026#34; class=\u0026#34; SpringAction\u0026#34; \u0026gt; \u0026lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--\u0026gt; \u0026lt;property name=\u0026#34;staticFactoryDao\u0026#34; ref=\u0026#34;staticFactoryDao\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--此处获取对象的方式是从工厂类中获取静态方法--\u0026gt; \u0026lt;bean name=\u0026#34;staticFactoryDao\u0026#34; class=\u0026#34;DaoFactory\u0026#34; factory-method=\u0026#34;getStaticFactoryDaoImpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 实例工厂\n实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先 new 工厂类，再调用普通的实例方法：\n1 2 3 4 5 6 7 8 9 10 11 public class DaoFactory { //实例工厂 public FactoryDao getFactoryDaoImpl(){ return new FactoryDaoImpl(); } } public class SpringAction { private FactoryDao factoryDao; //注入对象 public void setFactoryDao(FactoryDao factoryDao) { this.factoryDao = factoryDao; } } 1 2 3 4 5 6 7 \u0026lt;bean name=\u0026#34;springAction\u0026#34; class=\u0026#34;SpringAction\u0026#34;\u0026gt; \u0026lt;!--使用实例工厂的方法注入对象,对应下面的配置文件--\u0026gt; \u0026lt;property name=\u0026#34;factoryDao\u0026#34; ref=\u0026#34;factoryDao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--此处获取对象的方式是从工厂类中获取实例方法--\u0026gt; \u0026lt;bean name=\u0026#34;daoFactory\u0026#34; class=\u0026#34;com.DaoFactory\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean name=\u0026#34;factoryDao\u0026#34; factory-bean=\u0026#34;daoFactory\u0026#34; factory-method=\u0026#34;getFactoryDaoImpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 5种不同方式的自动装配\rSpring 装配包括手动装配和自动装配，手动装配是有基于 xml 装配、构造方法、setter 方法等\n自动装配有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。\nno：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。 byName：通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。 byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误。 constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。 autodetect：首先尝试使用 constructor 来自动装配，如果无法工作，则使用 byType 方式。 Spring AOP原理\r概念\r横切的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为Aspect，即切面。所谓切面，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。\n使用横切技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。\nAOP 主要应用场景有：\nAuthentication 权限 Caching 缓存 Context passing 内容传递 Error handling 错误处理 Lazy loading 懒加载 Debugging 调试 logging, tracing, profiling and monitoring 记录跟踪 优化 校准 Performance optimization 性能优化 Persistence 持久化 Resource pooling 资源池 Synchronization 同步 Transactions 事务 AOP核心概念\r1、切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象\n2、横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。\n3、连接点（joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。\n4、切入点（pointcut）：对连接点进行拦截的定义\n5、通知（advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类。\n6、目标对象：代理的目标对象\n7、织入（weave）：将切面应用到目标对象并导致代理对象创建的过程\n8、引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段\nAOP两种代理方式\rSpring 提供了两种方式来生成代理对象: JDKProxy 和 Cglib，具体使用哪种方式生成由AopProxyFactory 根据 AdvisedSupport 对象的配置来决定。默认的策略是如果目标类是接口，则使用 JDK 动态代理技术，否则使用 Cglib 来生成代理\nJDK 动态接口代理\nJDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy 利用 InvocationHandler 动态创建一个符合某一接口的实例，生成目标类的代理对象 CGLib 动态代理\nCGLib 全称为 Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展 Java 类与实现 Java 接口，CGLib 封装了 asm，可以在运行期动态生成新的 class。和 JDK 动态代理相比较：JDK 创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过 CGLib 创建动态代理。\n实现原理\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Aspect public class TransactionDemo { @Pointcut(value=\u0026#34;execution(* com.example.core.service.*.*.*(..))\u0026#34;) public void point(){ } @Before(value=\u0026#34;point()\u0026#34;) public void before(){ System.out.println(\u0026#34;transaction begin\u0026#34;); } @AfterReturning(value = \u0026#34;point()\u0026#34;) public void after(){ System.out.println(\u0026#34;transaction commit\u0026#34;); } @Around(\u0026#34;point()\u0026#34;) public void around(ProceedingJoinPoint joinPoint) throws Throwable{ System.out.println(\u0026#34;transaction begin\u0026#34;); joinPoint.proceed(); System.out.println(\u0026#34;transaction commit\u0026#34;); } } SpringMVC原理\rSpring 的模型-视图-控制器（MVC）框架是围绕一个 DispatcherServlet 来设计的，这个 Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。\nMVC流程\rHttp 请求到 DispatcherServlet\n客户端请求提交到 DispatcherServlet HandlerMapping 寻找处理器\n由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的Controller 调用处理器 Controller\nDispatcherServlet 将请求提交到 Controller。 Controller 调用业务逻辑处理后，返回 ModelAndView\n调用业务处理和返回结果：Controller 调用业务逻辑处理后，返回 ModelAndView。 DispatcherServlet 查询 ModelAndView\n处理视图映射并返回模型： DispatcherServlet 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 指定的视图。 ModelAndView 反馈浏览器 HTTP\nHttp 响应：视图负责将结果显示到客户端。 MVC常用注解\r@Controller @RestController @Component @Repository @Service @ResponseBody @RequestMapping @Autowired @PathVariable @RequestParam @RequestHeadler 作用请查看上面 Spring常用注解 图解\nSpringBoot原理\rSpring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。其特点如下：\n创建独立的 Spring 应用程序 嵌入的 Tomcat，无需部署 WAR 文件 简化 Maven 配置 自动配置 Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成和对 XML 没有要求配置 JPA原理\r事务\r事务是计算机应用中不可或缺的组件模型，它保证了用户操作的原子性 ( Atomicity )、一致性( Consistency )、隔离性 ( Isolation ) 和持久性 ( Durabilily)。\n本地事务\r紧密依赖于底层资源管理器(例如数据库连接)，事务处理局限在当前事务资源内。此种事务处理方式不存在对应用服务器的依赖，因而部署灵活却无法支持多数据源的分布式事务。\n在数据库连接中使用本地事务示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public void transferAccount() { Connection conn = null; Statement stmt = null; try{ conn = getDataSource().getConnection(); // 将自动提交设置为 false，若设置为 true 则数据库将会把每一次数据更新认定为一个事务并自动提交 conn.setAutoCommit(false); stmt = conn.createStatement(); // 将 A 账户中的金额减少 500 stmt.execute(\u0026#34;update t_account set amount = amount - 500 where account_id = \u0026#39;A\u0026#39;\u0026#34;); // 将 B 账户中的金额增加 500 stmt.execute(\u0026#34;update t_account set amount = amount + 500 where account_id = \u0026#39;B\u0026#39;\u0026#34;); // 提交事务 conn.commit(); // 事务提交：转账的两步操作同时成功 } catch(SQLException sqle){ // 发生异常，回滚在本事务中的操做 conn.rollback(); // 事务回滚：转账的两步操作完全撤销 stmt.close(); conn.close(); } } 分布式事务\rJava 事务编程接口（JTA：Java Transaction API）和 Java 事务服务 (JTS；Java Transaction Service) 为 J2EE 平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器 ( Resource Manager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public void transferAccount() { UserTransaction userTx = null; Connection connA = null; Statement stmtA = null; Connection connB = null; Statement stmtB = null; try{ // 获得 Transaction 管理对象 userTx = (UserTransaction)getContext().lookup(\u0026#34;java:comp/UserTransaction\u0026#34;); connA = getDataSourceA().getConnection();// 从数据库 A 中取得数据库连接 connB = getDataSourceB().getConnection();// 从数据库 B 中取得数据库连接 userTx.begin(); // 启动事务 stmtA = connA.createStatement();// 将 A 账户中的金额减少 500 stmtA.execute(\u0026#34;update t_account set amount = amount - 500 where account_id = \u0026#39;A\u0026#39;\u0026#34;); // 将 B 账户中的金额增加 500 stmtB = connB.createStatement(); stmtB.execute(\u0026#34;update t_account set amount = amount + 500 where account_id = \u0026#39;B\u0026#39;\u0026#34;); userTx.commit();// 提交事务 // 事务提交：转账的两步操作同时成功（数据库 A 和数据库 B 中的数据被同时更新） } catch(SQLException sqle){ // 发生异常，回滚在本事务中的操纵 userTx.rollback();// 事务回滚：数据库 A 和数据库 B 中的数据更新被同时撤销 } catch(Exception ne){ } } 两阶段提交\r两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做，所谓的两个阶段是指：第一阶段：准备阶段；第二阶段：提交阶段。 1 准备阶段\n事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一种万事俱备，只欠东风的状态。 2 提交阶段\n如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)将提交分成两阶段进行的目的很明确，就是尽可能晚地提交事务，让事务在提交前尽可能地完成所有能完成的工作。\nMyBatis缓存\rMybatis 中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存是指 SqlSession 级别的缓存，当在同一个 SqlSession 中进行相同的 SQL 语句查询时，第二次以后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存 1024 条 SQL。二级缓存是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存，对于 mapper 级别的缓存不同的sqlsession 是可以共享的。 MyBatis一级缓存原理（sqlsession级别）\r第一次发出一个查询 sql，sql 查询结果写入 sqlsession 的一级缓存中，缓存使用的数据结构是一个 map。 key：MapperID+offset+limit+Sql+所有的入参 value：用户信息 同一个 sqlsession 再次发出相同的 sql，就从缓存中取出数据。如果两次中间出现 commit 操作（修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存\n二级缓存原理（mapper级别）\r二级缓存的范围是 mapper 级别（mapper 同一个命名空间），mapper 以命名空间为单位创建缓存数据结构，结构是 map。mybatis 的二级缓存是通过 CacheExecutor 实现的。CacheExecutor其实是 Executor 的代理对象。所有的查询操作，在 CacheExecutor 中都会先匹配缓存中是否存在，不存在则查询数据库。 具体使用需要配置：\nMybatis 全局配置中启用二级缓存配置 在对应的 Mapper.xml 中配置 cache 节点 在对应的 select 查询节点中添加 useCache=true ","date":"2022-12-17T00:00:00Z","image":"http://localhost:1313/p/04_spring%E5%8E%9F%E7%90%86/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/04_spring%E5%8E%9F%E7%90%86/","title":"04_Spring原理"},{"content":"Java基础\rJava异常分类及处理\r概念\r如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。\n异常分类\rThrowable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception\nError\nError 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。\nException（RuntimeException、CheckedException） Exception 又 有 两 个 分 支 ， 一 个 是 运 行 时 异 常 RuntimeException ， 一 个 是CheckedException。\nRuntimeException 如 ： NullPointerException 、 ClassCastException ； 一 个 是 检 查 异 常CheckedException，如 I/O 错误导致的 IOException、SQLException。 RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一定是程序员的错误。\n检查异常 CheckedException：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一般包括几个方面： 试图在文件尾部读取数据 试图打开一个错误格式的 URL 试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在 异常的处理方式\r遇到问题不进行具体处理，而是继续抛给调用者 （throw,throws）\n抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常\n1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) { String s = \u0026#34;abc\u0026#34;; if(s.equals(\u0026#34;abc\u0026#34;)) { throw new NumberFormatException(); } else { System.out.println(s); } } int div(int a,int b) throws Exception{ return a/b; } try catch 捕获异常针对性处理方式\nThrow 和 throws 的区别：\r位置不同：\nthrows 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的是异常对象。\n功能不同： throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。 throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。 两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处处理 Java反射\r动态语言\r动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。\n反射机制概念（运行状态中知道类所有的属性和方法）\r在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。\n反射的应用场合\r编译时类型和运行时类型\n在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。\n编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定。如：\n1 Person p=new Student(); 其中编译时类型为 Person，运行时类型为 Student。 编译时类型无法获取具体方法\n程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object,但是程序有需要调用该对象的运行时类型的方法。\n为了解决这些问题，程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。\nJava 反射 API\r反射 API 用来生成 JVM 中的类、接口或者对象的信息\nClass 类：反射的核心类，可以获取类的属性，方法等信息。 Field 类：Java.lang.reflect 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。 Method 类： Java.lang.reflect 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。 Constructor 类： Java.lang.reflect 包中的类，表示类的构造方法。 反射使用步骤（获取 Class 对象、调用对象方法）\r获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。 调用 Class 类中的方法，既就是反射的使用阶段。 使用反射 API 来操作这些信息。 获取 Class 对象的 3 种方法\r调用某个对象的 getClass()方法\n1 2 3 // 调用某个对象的 getClass()方法 Person p=new Person(); Class clazz=p.getClass(); 调用某个类的 class 属性来获取该类对应的 Class 对象\n1 2 // 调用某个类的 class 属性来获取该类对应的 Class 对象 Class clazz=Person.class; 使用 Class 类中的 forName()静态方法(最安全/性能最好) (最常用)\n1 2 // 使用 Class 类中的 forName()静态方法(最安全/性能最好) Class clazz=Class.forName(\u0026#34;类的全路径\u0026#34;); // (最常用) 当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法和属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //获取 Person 类的 Class 对象 Class clazz=Class.forName(\u0026#34;reflection.Person\u0026#34;); //获取 Person 类的所有方法信息 Method[] method=clazz.getDeclaredMethods(); for(Method m:method){ System.out.println(m.toString()); } //获取 Person 类的所有成员属性信息 Field[] field=clazz.getDeclaredFields(); for(Field f:field){ System.out.println(f.toString()); } //获取 Person 类的所有构造方法信息 Constructor[] constructor=clazz.getDeclaredConstructors(); for(Constructor c:constructor){ System.out.println(c.toString()); } 创建对象的两种方法\rClass 对象的 newInstance()\n使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该Class对象对应的类有默认的空构造器 。\n调用 Constructor 对象的 newInstance() 先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。 1 2 3 4 5 6 7 8 //获取 Person 类的 Class 对象 Class clazz=Class.forName(\u0026#34;reflection.Person\u0026#34;); //使用.newInstane 方法创建对象 Person p=(Person) clazz.newInstance(); //获取构造方法并创建对象 Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class); //创建对象并设置属性 Person p1=(Person) c.newInstance(\u0026#34;李四\u0026#34;,\u0026#34;男\u0026#34;,20); Java注解\r概念\rAnnotation（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径和方法。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation对象，然后通过该 Annotation 对象来获取注解中的元数据信息\n4 种标准元注解\r元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。\n@Target 修饰的对象范围\n@Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标 @Retention 定义 被保留的时间长短\nRetention 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：\nSOURCE:在源文件中有效（即源文件保留） CLASS:在 class 文件中有效（即 class 保留） RUNTIME:在运行时有效（即运行时保留） @Documented 描述-javadoc\n@Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化 @Inherited 阐述了某个被标注的类型是被继承的\n@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该class 的子类。\n注解处理器\r如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5 扩展了反射机制的 API，以帮助程序员快速的构造自定义注解处理器。下面实现一个注解处理器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /*1：*** 定义注解 *** */ @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface FruitProvider { /**供应商编号*/ public int id() default -1; /*** 供应商名称*/ public String name() default \u0026#34;\u0026#34;; /** * 供应商地址*/ public String address() default \u0026#34;\u0026#34;; } //2：注解使用 public class Apple { @FruitProvider(id = 1, name = \u0026#34;陕西红富士集团\u0026#34;, address = \u0026#34;陕西省西安市延安路\u0026#34;) private String appleProvider; public void setAppleProvider(String appleProvider) { this.appleProvider = appleProvider; } public String getAppleProvider() { return appleProvider; } } /* 3：*********** 注解处理器 ************** */ public class FruitInfoUtil { public static void getFruitInfo(Class\u0026lt;?\u0026gt; clazz) { String strFruitProvicer = \u0026#34;供应商信息：\u0026#34;; Field[] fields = clazz.getDeclaredFields();//通过反射获取处理注解 for (Field field : fields) { // FruitProvider 的注解是否在 field上 if (field.isAnnotationPresent(FruitProvider.class)) { FruitProvider fruitProvider = (FruitProvider) field.getAnnotation(FruitProvider.class); //注解信息的处理地方 strFruitProvicer = \u0026#34; 供应商编号：\u0026#34; + fruitProvider.id() + \u0026#34; 供应商名称：\u0026#34; + fruitProvider.name() + \u0026#34; 供应商地址：\u0026#34;\\+ fruitProvider.address(); System.out.println(strFruitProvicer); } } } } public class FruitRun { public static void main(String[] args) { FruitInfoUtil.getFruitInfo(Apple.class); /***********输出结果***************/ // 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延 } } Java内部类\rJava 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。根据定义的方式不同，内部类分为静态内部类 、成员内部类 、局部内部类 、匿名内部类 四种。\n静态内部类\r定义在类内部的静态类，就是静态内部类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Out { private static int a; private int b; public static class Inner { public void print() { Out out=new Out(); System.out.println(\u0026#34;a:\u0026#34;+a); System.out.println(\u0026#34;b:\u0026#34;+out.b); } } public static void main(String[] args) { Inner inner=new Inner(); inner.print(); } } 静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。\n静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。\n其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：\n1 2 Out.Inner inner = new Out.Inner(); inner.print(); Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。\n成员内部类\r定义在类内部的非静态类，就是成员内部类。\n成员内部类不能定义静态方法和变量（final 修饰的除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。\n1 2 3 4 5 6 7 8 9 10 public class Out { private static int a; private int b; public class Inner { public void print() { System.out.println(a); System.out.println(b); } } } 局部内部类\r定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类\n1 2 3 4 5 6 7 8 9 10 11 12 public class Out { private static int a; private int b; public void test(final int c) { final int d = 1; class Inner { public void print() { System.out.println(c); } } } } 匿名内部类\r要继承一个父类或者实现一个接口、直接使用new 来生成一个对象的引用\n匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public abstract class Bird { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public abstract int fly(); } public class Test { public void test1(Bird bird) { System.out.println(bird.getName()+\u0026#34;能够飞\u0026#34;+bird.fly()+\u0026#34;米\u0026#34;); } public static void main(String[] args) { Out out=new Out(); out.test1(new Bird() { @Override public int fly() { // TODO Auto-generated method stub return 100; } @Override public String getName() { return \u0026#34;大眼仔\u0026#34;; } }); } } Java泛型\r泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。\n比如我们要写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。\n泛型方法（）\r你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。\n1 2 3 4 5 6 // 泛型方法 printArray public static \u0026lt; E \u0026gt; void printArray(E[] inputArray ){ for ( E element : inputArray ){ System.out.printf( \u0026#34;%s \u0026#34;, element ); } } 表示该通配符所代表的类型是 T 类型的子类。 表示该通配符所代表的类型是 T 类型的父类。 泛型类\r泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。\n1 2 3 4 5 6 7 8 9 public class Box\u0026lt;T\u0026gt; { private T t; public void add(T t) { this.t = t; } public T get() { return t; } } 类型通配符 ?\r类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数 。 例 如 List\u003c?\u003e 在逻辑上是List,List 等所有 List\u0026lt;具体类型实参\u0026gt;的父类。\n类型擦除\rJava 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List和 List等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。\nJava序列化(创建可复用的 Java 对象)\r保存(持久化)对象及其状态到内存或者磁盘\nJava 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java 对象序列化就能够帮助我们实现该功能。 序列化对象以字节数组保持-静态成员不保存\n使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的状态，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量 序列化用户远程对象传输\n除了在持久化对象时会用到对象序列化之外，当使用 RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。 Serializable 实现序列化\n在 Java 中，只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化。 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化\n通过 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化 writeObject 和 readObject 自定义序列化策略\n在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略 序列化 ID\n虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID） 序列化并不保存静态变量\n序列化子父类说明：要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。 Transient 关键字阻止该变量被序列化到文件中\n在变量声明前加上 Transient 关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。（@Transient注解 同） 服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。 Java复制\r将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象\n直接赋值复制\r直接赋值。在 Java 中，A a1 = a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Copy { public static void main(String[] args) throws Exception { Class clazz=Class.forName(\u0026#34;com.example.domain.Person\u0026#34;); Constructor c=clazz.getDeclaredConstructor(Integer.class,String.class,Integer.class); Person p1=(Person) c.newInstance(1,\u0026#34;张三\u0026#34;,1); Person p2=p1; System.out.println(String.format(\u0026#34;p1:%s %np2:%s\u0026#34;,ptoString(),ptoString())); psetName(\u0026#34;李四\u0026#34;); System.out.println(String.format(\u0026#34;p1:%s %np2:%s\u0026#34;,ptoString(),ptoString())); } } // p1:Person(id=1, name=张三, sex=2) // p2:Person(id=1, name=张三, sex=2) // p1:Person(id=1, name=李四, sex=2) // p2:Person(id=1, name=李四, sex=2) 浅复制（复制引用但不复制引用的对象）\r创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。\n1 2 3 4 5 6 7 8 9 10 class Resume implements Cloneable{ public Object clone() { try { return (Resume)super.clone(); } catch (Exception e) { e.printStackTrace(); return null; } } } 深复制（复制对象和其应用对象）\r深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Student implements Cloneable { String name; int age; Professor p; Student(String name, int age, Professor p) { this.name = name; this.age = age; this.p = p; } public Object clone() { Student o = null; try { o = (Student) super.clone(); } catch (CloneNotSupportedException e) { System.out.println(e.toString()); } o.p = (Professor) p.clone(); return o; } } 序列化（深 clone 中实现）\r在 Java 语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。\n","date":"2022-12-17T00:00:00Z","image":"http://localhost:1313/p/05_java%E5%9F%BA%E7%A1%80/202412212036798_hu3711221556448402686.png","permalink":"http://localhost:1313/p/05_java%E5%9F%BA%E7%A1%80/","title":"05_Java基础"},{"content":"vue项目布局\rElement-plus HelloWorld组件删掉，再把HomeView内相关的内容删一删，App.vue内样式全部删掉 如果报错，可能是由于权限不够，复制报错信息上网查找解决方案即可 全局引入element-plus 再次运行项目 选择这里的代码，复制到App.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;common-layout\u0026#34;\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-header\u0026gt; Header \u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt;Aside\u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent} from \u0026#39;vue\u0026#39;; export default defineComponent({ components: { }, }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 现在就是页面暂时的结构 由于项目会涉及到图标，继续下载\n1 npm install @element-plus/icons-vue 1 2 3 4 5 6 7 // main.ts // 如果您正在使用CDN引入，请删除下面一行。 import * as ElementPlusIconsVue from \u0026#39;@element-plus/icons-vue\u0026#39; const app = createApp(App) for (const [key, component] of Object.entries(ElementPlusIconsVue)) { app.component(key, component) } 测试一下图标是否安装好了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!-- Home --\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-button icon=\u0026#34;Search\u0026#34; circle/\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; icon=\u0026#34;Edit\u0026#34; circle/\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34; icon=\u0026#34;Check\u0026#34; circle/\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Message\u0026#34; circle/\u0026gt; \u0026lt;el-button type=\u0026#34;warning\u0026#34; icon=\u0026#34;Star\u0026#34; circle/\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; icon=\u0026#34;Delete\u0026#34; circle/\u0026gt; \u0026lt;/el-row\u0026gt; import { Check, Delete, Edit, Message, Search, Star, } from \u0026#39;@element-plus/icons-vue\u0026#39; \u0026lt;!-- main.ts --\u0026gt; import * as ElementPlusIconsVue from \u0026#39;@element-plus/icons-vue\u0026#39; for (const [key, component] of Object.entries(ElementPlusIconsVue)) { app.component(key, component) } 可以看到可以正常使用，控制台也没报错\n1 2 \u0026lt;!-- 图标若不显示 --\u0026gt; \u0026lt;!-- 将标签中的 :icon 改为icon即可 --\u0026gt; 新建一个头部组件 component下新建Header.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;template\u0026gt; \u0026lt;div style=\u0026#34;height: 50px;line-height: 50px;border-bottom: 1px solid #ccc;display: flex\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;width: 200px;padding-left:30px;font-weight: bold;color:dodgerblue\u0026#34;\u0026gt;管理系统\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;flex: 1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;width: 150px;margin-top: 10px;\u0026#34;\u0026gt; \u0026lt;el-dropdown trigger=\u0026#34;click\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;el-dropdown-link\u0026#34;\u0026gt; 深海火锅店\u0026lt;el-icon class=\u0026#34;el-icon--right\u0026#34;\u0026gt;\u0026lt;arrow-down/\u0026gt;\u0026lt;/el-icon\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;template #dropdown\u0026gt; \u0026lt;el-dropdown-menu\u0026gt; \u0026lt;el-dropdown-item icon=\u0026#34;UserFilled\u0026#34;\u0026gt; 个人信息 \u0026lt;/el-dropdown-item\u0026gt; \u0026lt;el-dropdown-item icon=\u0026#34;SwitchButton\u0026#34; @click=\u0026#34;logout\u0026#34;\u0026gt; 退出登录 \u0026lt;/el-dropdown-item\u0026gt; \u0026lt;/el-dropdown-menu\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-dropdown\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {ref} from \u0026#39;vue\u0026#39; import { h } from \u0026#39;vue\u0026#39; import { ElMessage, ElMessageBox } from \u0026#39;element-plus\u0026#39; import { ArrowDown, Check, CircleCheck, CirclePlus, CirclePlusFilled, Plus, } from \u0026#39;@element-plus/icons-vue\u0026#39; export default { name: \u0026#34;Header\u0026#34;, setup() { const activeIndex = ref(\u0026#39;1\u0026#39;) const activeIndex2 = ref(\u0026#39;1\u0026#39;) const handleSelect = (key: string, keyPath: string[]) =\u0026gt; { console.log(key, keyPath) } const logout=()=\u0026gt;{ ElMessageBox({ title: \u0026#39;提示\u0026#39;, message: h(\u0026#39;p\u0026#39;, null, [ h(\u0026#39;span\u0026#39;, null, \u0026#39;您即将\u0026#39;), h(\u0026#39;i\u0026#39;, { style: \u0026#39;color: teal\u0026#39; }, \u0026#39;退出登录\u0026#39;), ]), showCancelButton: true, confirmButtonText: \u0026#39;确认\u0026#39;, cancelButtonText: \u0026#39;取消\u0026#39;, beforeClose: (action, instance, done) =\u0026gt; { if (action === \u0026#39;confirm\u0026#39;) { instance.confirmButtonLoading = true instance.confirmButtonText = \u0026#39;Loading...\u0026#39; setTimeout(() =\u0026gt; { done() setTimeout(() =\u0026gt; { instance.confirmButtonLoading = false }, 300) }, 3000) } else { done() } }, }).then((action) =\u0026gt; { ElMessage({ type: \u0026#39;info\u0026#39;, message: `action: ${action}`, }) }) } return {activeIndex, activeIndex2, handleSelect,logout} } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 暂时是定死了名字，用户名字是深海火锅店，以后再更改 此时我们发现文字和顶部之间有一段距离 在asset下新建css文件夹，css下新建global.css文件【右键新建，stylesheet，选择add】\n1 2 3 4 5 *{ margin: 0; padding: 0; box-sizing: border-box; } 在main.ts中引入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // import \u0026#39;@/assets/css/global.css\u0026#39;添加这句话-------------- import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; import ElementPlus from \u0026#39;element-plus\u0026#39; import \u0026#39;element-plus/dist/index.css\u0026#39; import * as ElementPlusIconsVue from \u0026#39;@element-plus/icons-vue\u0026#39; import \u0026#39;@/assets/css/global.css\u0026#39; // @ts-ignore import zhCn from \u0026#39;element-plus/dist/locale/zh-cn.mjs\u0026#39; const app = createApp(App) app.use(store) app.use(router) app.use(ElementPlus) for (const [key, component] of Object.entries(ElementPlusIconsVue)) { app.component(key, component) } app.mount(\u0026#39;#app\u0026#39;) app.use(ElementPlus, { locale: zhCn, }) 再新建左侧导航栏Aside.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 \u0026lt;template\u0026gt; \u0026lt;el-menu default-active=\u0026#34;2\u0026#34; class=\u0026#34;el-menu-vertical-demo\u0026#34; @open=\u0026#34;handleOpen\u0026#34; @close=\u0026#34;handleClose\u0026#34;\u0026gt; \u0026lt;el-sub-menu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;el-icon\u0026gt; \u0026lt;location/\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;span\u0026gt;学生信息管理\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group title=\u0026#34;Group One\u0026#34;\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;item one\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;item two\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;el-menu-item-group title=\u0026#34;Group Two\u0026#34;\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-3\u0026#34;\u0026gt;item three\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;el-sub-menu index=\u0026#34;1-4\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt;item four\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-4-1\u0026#34;\u0026gt;item one\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-sub-menu\u0026gt; \u0026lt;/el-sub-menu\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;el-icon\u0026gt; \u0026lt;icon-menu/\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;span\u0026gt;Navigator Two\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;3\u0026#34; disabled\u0026gt; \u0026lt;el-icon\u0026gt; \u0026lt;document/\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;span\u0026gt;Navigator Three\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;4\u0026#34;\u0026gt; \u0026lt;el-icon\u0026gt; \u0026lt;setting/\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;span\u0026gt;Navigator Four\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { Document, Menu as IconMenu, Location, Setting, } from \u0026#39;@element-plus/icons-vue\u0026#39; export default { name: \u0026#34;Aside\u0026#34;, setup() { const handleOpen = (key: string, keyPath: string[]) =\u0026gt; { console.log(key, keyPath) } const handleClose = (key: string, keyPath: string[]) =\u0026gt; { console.log(key, keyPath) } return {handleOpen, handleClose} } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 在App.vue中引入header、aside组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;template\u0026gt; \u0026lt;el-config-provider :locale=\u0026#34;locale\u0026#34;\u0026gt; \u0026lt;slot name=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;common-layout\u0026#34;\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-header\u0026gt; \u0026lt;Header/\u0026gt; \u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;250px\u0026#34;\u0026gt; \u0026lt;Aside/\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/slot\u0026gt; \u0026lt;/el-config-provider\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent} from \u0026#39;vue\u0026#39;; import Header from \u0026#34;@/components/Header.vue\u0026#34;; import Aside from \u0026#34;@/components/Aside.vue\u0026#34;; import { ElConfigProvider } from \u0026#39;element-plus\u0026#39; // 国际化：设置为中文 // begin---- import zhCn from \u0026#39;element-plus/lib/locale/lang/zh-cn\u0026#39; export default defineComponent({ name: \u0026#39;ZhProvider\u0026#39;, components: { Header, Aside, [ElConfigProvider.name]: ElConfigProvider }, setup() { let locale = zhCn return { locale } } }); // end---- \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 最后完成主页面HomeView.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 \u0026lt;template\u0026gt; \u0026lt;!--功能区域--\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Plus\u0026#34; @click=\u0026#34;openAdd\u0026#34;\u0026gt;新增\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Upload\u0026#34;\u0026gt;导入\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;Download\u0026#34;\u0026gt;导出\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--搜索区域--\u0026gt; \u0026lt;div style=\u0026#34;margin: 10px 0\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;search\u0026#34; placeholder=\u0026#34;请输入关键字\u0026#34; style=\u0026#34;width: 25%\u0026#34; clearable/\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; style=\u0026#34;margin-left: 5px\u0026#34; icon=\u0026#34;Search\u0026#34;\u0026gt;搜索\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; style=\u0026#34;width: 100%\u0026#34;\u0026gt; \u0026lt;el-table-column fixed prop=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;150\u0026#34; sortable/\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;120\u0026#34;/\u0026gt; \u0026lt;el-table-column prop=\u0026#34;age\u0026#34; label=\u0026#34;年龄\u0026#34; width=\u0026#34;120\u0026#34; sortable/\u0026gt; \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; width=\u0026#34;120\u0026#34;/\u0026gt; \u0026lt;el-table-column prop=\u0026#34;college\u0026#34; label=\u0026#34;学院\u0026#34; width=\u0026#34;120\u0026#34;/\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34; width=\u0026#34;300\u0026#34;/\u0026gt; \u0026lt;el-table-column prop=\u0026#34;state\u0026#34; label=\u0026#34;状态\u0026#34; width=\u0026#34;120\u0026#34;/\u0026gt; \u0026lt;el-table-column fixed=\u0026#34;right\u0026#34; label=\u0026#34;操作\u0026#34; width=\u0026#34;150\u0026#34;\u0026gt; \u0026lt;template #default\u0026gt; \u0026lt;el-popconfirm type=\u0026#34;warning\u0026#34; title=\u0026#34;确认删除此选项?\u0026#34;\u0026gt; \u0026lt;template #reference\u0026gt; \u0026lt;el-button link type=\u0026#34;warning\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-popconfirm\u0026gt; \u0026lt;el-button link type=\u0026#34;primary\u0026#34; plain size=\u0026#34;small\u0026#34; @click=\u0026#34;handleClick\u0026#34;\u0026gt;查看\u0026lt;/el-button\u0026gt; \u0026lt;el-button link type=\u0026#34;info\u0026#34; size=\u0026#34;small\u0026#34; @click=\u0026#34;editMsg\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;hr class=\u0026#34;my-4\u0026#34;/\u0026gt; \u0026lt;!--分页区域--\u0026gt; \u0026lt;div class=\u0026#34;demo-pagination-block\u0026#34; style=\u0026#34;margin: 5px\u0026#34;\u0026gt; \u0026lt;el-pagination v-model:current-page=\u0026#34;currentPage\u0026#34; v-model:page-size=\u0026#34;pageSize\u0026#34; :page-sizes=\u0026#34;[100, 200, 300, 400]\u0026#34; :small=\u0026#34;small\u0026#34; layout=\u0026#34;total, sizes, prev, pager, next, jumper\u0026#34; :total=\u0026#34;400\u0026#34; @size-change=\u0026#34;handleSizeChange\u0026#34; @current-change=\u0026#34;handleCurrentChange\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent} from \u0026#39;vue\u0026#39;; import {h,ref} from \u0026#39;vue\u0026#39; import { ElMessage, ElMessageBox } from \u0026#39;element-plus\u0026#39; import { UploadFilled } from \u0026#39;@element-plus/icons-vue\u0026#39; export default defineComponent({ name: \u0026#39;HomeView\u0026#39;, components: {}, setup() { /* 查看信息 */ const handleClick = () =\u0026gt; { console.log(\u0026#39;click\u0026#39;) ElMessageBox({ title: \u0026#39;信息\u0026#39;, message: h(\u0026#39;p\u0026#39;, null, [ h(\u0026#39;span\u0026#39;, null, \u0026#39;Message can be \u0026#39;), h(\u0026#39;i\u0026#39;, { style: \u0026#39;color: teal\u0026#39; }, \u0026#39;VNode\u0026#39;), ]), }) } /* 编辑信息 */ const editMsg = () =\u0026gt; { ElMessageBox.confirm( \u0026#39;您正在修改他人的个人信息. 是否继续?\u0026#39;, \u0026#39;警告\u0026#39;, { confirmButtonText: \u0026#39;确认\u0026#39;, cancelButtonText: \u0026#39;取消\u0026#39;, type: \u0026#39;warning\u0026#39;, } ) .then(() =\u0026gt; { ElMessage({ type: \u0026#39;success\u0026#39;, message: \u0026#39;修改成功\u0026#39;, }) }) .catch(() =\u0026gt; { ElMessage({ type: \u0026#39;info\u0026#39;, message: \u0026#39;取消修改\u0026#39;, }) }) } const search = ref(\u0026#34;\u0026#34;); const tableData = [ { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;Tom\u0026#39;, age: \u0026#39;12\u0026#39;, gender: \u0026#39;女\u0026#39;, college: \u0026#39;自动化\u0026#39;, address: \u0026#39;No. 189, Grove St, Los Angeles\u0026#39;, state: \u0026#39;24小时阴性\u0026#39;, }, { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;Tom\u0026#39;, age: \u0026#39;15\u0026#39;, gender: \u0026#39;男\u0026#39;, college: \u0026#39;经管\u0026#39;, address: \u0026#39;No. 189, Grove St, Los Angeles\u0026#39;, state: \u0026#39;24小时阴性\u0026#39;, }, { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;Tom\u0026#39;, age: \u0026#39;12\u0026#39;, gender: \u0026#39;女\u0026#39;, college: \u0026#39;计算机\u0026#39;, address: \u0026#39;No. 189, Grove St, Los Angeles\u0026#39;, state: \u0026#39;24小时阴性\u0026#39;, }, { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;Tom\u0026#39;, age: \u0026#39;16\u0026#39;, gender: \u0026#39;男\u0026#39;, college: \u0026#39;软件工程\u0026#39;, address: \u0026#39;No. 189, Grove St, Los Angeles\u0026#39;, state: \u0026#39;24小时阴性\u0026#39;, }, ] const currentPage = ref(1) const pageSize = ref(100) const small = ref(false) const handleSizeChange = (val: number) =\u0026gt; { console.log(`${val} items per page`) } const handleCurrentChange = (val: number) =\u0026gt; { console.log(`current page: ${val}`) } /* 消息弹出框 */ const openAdd = () =\u0026gt; { ElMessageBox.confirm( \u0026#39;您希望添加如下内容?\u0026#39;, \u0026#39;提示\u0026#39;, { confirmButtonText: \u0026#39;确定\u0026#39;, cancelButtonText: \u0026#39;取消\u0026#39;, type: \u0026#39;warning\u0026#39;, draggable: true, } ) .then(() =\u0026gt; { ElMessage({ type: \u0026#39;success\u0026#39;, message: \u0026#39;Delete completed\u0026#39;, }) }) .catch(() =\u0026gt; { ElMessage({ type: \u0026#39;info\u0026#39;, message: \u0026#39;Delete canceled\u0026#39;, }) }) } return { handleClick, editMsg, tableData, search, currentPage, pageSize, small, handleSizeChange, handleCurrentChange, openAdd } } }); \u0026lt;/script\u0026gt; 链接：https://pan.baidu.com/s/11qXNPDQ_87TKmvF8R_RlrQ?pwd=m9fn 提取码：m9fn \u0026ndash;来自百度网盘超级会员V3的分享\n","date":"2022-12-15T00:00:00Z","image":"http://localhost:1313/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE03/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE03/","title":"从零开始搭建前后端分离项目03"},{"content":"Docker环境配置\r安装VirtualBox 安装vagrant 安装完成vagrant后重启一下系统 验证vagrant是否安装成功 cmd输入vagrant，是否有命令提示 使用vagrant创建虚拟机——官方镜像仓库\r1 vagrant init centos/7 此时在E盘已经生成了一个名为“Vagrantfile”的文件 启动虚拟环境 1 2 3 4 5 vagrant up # 如果速度很慢，使用提前下载好的CentOS7镜像，速度嘎嘎快 # vagrant init centos/7 # 没初始化的，要初始化 vagrant box add centos/7 CentOS-7-x86_64-Vagrant-2004_01.VirtualBox.box vagrant up ctrl+c停掉\n1 vagrant ssh 提示[vagrant@localhost ~]$ 连接成功，此时已经可以在VirtualBox内查看到该虚拟机 若提示 vagrant@127.0.0.1: Permission denied (publickey,gssapi-keyex,gssapi-with-mic). 则输入命令set VAGRANT_PREFER_SYSTEM_BIN=0 后再重新连接即可 退出vagrant的方法：输入命令exit 以文本的方式打开Vagrantfile，找到这一行配置 1 # config.vm.network \u0026#34;private_network\u0026#34;, ip: \u0026#34;192.168.33.10\u0026#34; 所以我们需要将虚拟机改为192.168.56.XX 即更改为\n1 # config.vm.network \u0026#34;private_network\u0026#34;, ip: \u0026#34;192.168.56.10\u0026#34; 1 vagrant reload 重启虚拟机\n1 2 3 vagrant ssh ip addr # 查看虚拟机ip地址是否已经发生了改变 ping 192.168.xxx # 主机与虚拟机是否互相ping通 安装docker\r概念：什么是docker？ 虚拟化容器技术。Docker基于镜像，可以秒级启动各种容器。每一种容器都是一个完整的运行环境，容器之间互相隔离。\ndocker的镜像市场\r安装docker\n1 2 3 4 5 6 7 8 9 10 vagrant ssh # 连接虚拟机 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 卸载旧版本的docker 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin # 过程需要输入y选择确认 # 启动docker sudo systemctl start docker # 查看docker版本 docker -v # 查看docker安装了哪些镜像 sudo docker images # 设置docker开机自启动 sudo systemctl enable docker 镜像加速\r登录阿里云后，进入 控制台，左侧菜单找到 “产品与服务”，选择“容器镜像服务”，选择“镜像工具”，点击“镜像加速器”\n1 2 3 4 5 6 7 8 9 10 11 12 # 执行以下四个命令 sudo mkdir -p /etc/docker #---------------------------------- sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://g9nk2v6o.mirror.aliyuncs.com\u0026#34;] } EOF #---------------------------------- sudo systemctl daemon-reload #---------------------------------- sudo systemctl restart docker /etc/docker/daemon.json\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.m.daocloud.io\u0026#34;, \u0026#34;https://dockerproxy.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://docker.nju.edu.cn\u0026#34; ], \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;100m\u0026#34; }, \u0026#34;storage-driver\u0026#34;: \u0026#34;overlay2\u0026#34; } 切换root用户\r每次sudo很麻烦？直接切换root用户\n1 2 su root # 默认密码是vagrant 连接XShell\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vagrant ssh # 切换为root用户 sudo -i # 修改root用户密码 passwd sudo vi /etc/ssh/sshd_config # 找到PasswordAuthentication yes这一行，去掉前面的# # # To disable tunneled clear text passwords, change to no here! # PasswordAuthentication yes # #PermitEmptyPasswords no # PasswordAuthentication no # 保存后退出 # 重启sshd服务 systemctl restart sshd # 使用ssh工具进行连接 详情请查看这篇博客\n安装MySQL\r连接上虚拟机之后 在docker镜像仓库搜索mysql，进入tags可查看版本信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #------- 安装mysql5.7----------------- # docker pull mysql # 会下载最新的mysql # 下载指定版本的mysql，比如5.7 # docker pull mysql:5.7 sudo docker pull mysql:5.7 sudo docker run -p 3306:3306 \\ -v /mydata/mysql/log:/var/log/mysql \\ -v /mydata/mysql/data:/var/lib/mysql \\ -v /mydata/mysql/conf:/etc/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -d mysql:8.0.20 \\ --name mysql # 查看mysql是否运行 docker ps # 没有查看到容器 # 查看,发现容器是退出状态 docker ps -a # Exited # 运行以下命令 docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root mysql # 若依然存在问题,可以停用并删除容器,重新启动mysql docker stop $(docker ps -q) docker rm $(docker ps -aq) # 删除镜像 docker rmi 镜像id # docker 删除报错: Error response from daemon: conflict: unable to delete 8e6aee9da407 (must be forced) - image is referenced in multiple repositories # 解决办法 docker rmi -f 镜像id # docker 服务命令 # 启动： # systemctl start docker # 守护进程重启： # systemctl daemon-reload # 重启docker服务： # systemctl restart docker / service docker restart # 关闭： # docker service docker stop / docker systemctl stop docker # 问题解决之后------ # 进入配置文件挂载的目录下 cd /mydata/mysql/conf # 编辑配置文件my.cnf vi my.cnf [client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] init_connect=\u0026#39;SET collation_connection = utf8_unicode_ci\u0026#39; init_connect=\u0026#39;SET NAMES utf8\u0026#39; character-set-server=utf8 collation-server=utf8_unicode_ci skip-character-set-client-handshake skip-name-resolve # 重启mysql容器 docker restart mysql # 设置启动docker时，mysql自启动 docker update mysql --restart=always #------- 安装mysql8.0.20----------------- #拉取镜像 docker pull mysql:8.0.20 #启动镜像,用于拷贝配置文件到宿主机 docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.20 #查看是否启动成功 docker ps -a #新建挂载目录并拷贝配置文件 mkdir -p /mysqldata/ docker cp mysql:/etc/mysql /mysqldata/ #检查是否运行成功 docker ps -a # 重启mysql容器 docker restart mysql # 设置启动docker时，mysql自启动 docker update mysql --restart=always # 使用Navicat链接mysql # ql自启动 docker update mysql --restart=always Redis配置\r1 2 # 下载最新redis镜像 docker pull redis 1 2 3 4 5 6 mkdir -p /mydata/redis/conf cd /mydata/redis/conf touch redis.conf docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\ -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\ -d redis redis-server /etc/redis/redis.conf 1 2 # 测试一下redis docker exec -it redis redis-cli 1 2 3 4 5 6 7 # redis默认配置是没有持久化的 # 如果重启redis，再获取之前的数据就获取不到了 # 具体命令可查看下图 vi redis.conf # 【输入 i 进入插入模式】 # 开启AOF持久化 appendonly yes 修改redis的密码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 创建容器时设置密码 # docker run -itd --name redis-6379 -p 6379:6379 redis --requirepass 123456 # 为现有的redis创建密码或修改密码 #1.进入redis的容器 docker exec -it 容器ID bash #2.进入redis目录 cd /usr/local/bin #3.运行命令： redis-cli #4.查看现有的redis密码： config get requirepass # 这一步若报错(error) NOAUTH Authentication required. # 是因为redis本身设置有密码，此时需要执行以下命令 auth password; # password是之前设置的redis密码 #5.设置redis密码 config set requirepass 密码 # 清空redis密码 config set requirepass \u0026#34;\u0026#34; 安装redis可视化工具\r链接：https://pan.baidu.com/s/10z0S6b9mo76CWK9y3spPRg?pwd=51tz 提取码：51tz \u0026ndash;来自百度网盘超级会员V3的分享 点击New Connection右边的按钮，可进入设置页面，设置语言 docker安装ElasticSearch\r1.黑马程序员视频内安装方法：\r链接：https://pan.baidu.com/s/1pGnbmkMjD8RXe5Y4xotfOA?pwd=ihe5 提取码：ihe5 将其上传到虚拟机中，然后运行命令加载即可：\n1 2 # 导入数据 docker load -i es.tar 同理还有kibana的tar包也需要这样做。 运行docker命令，部署单点es：\n1 2 3 4 5 6 7 8 9 10 11 docker run -d \\ --name es \\ -e \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; \\ -e \u0026#34;discovery.type=single-node\u0026#34; \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\ elasticsearch:7.12.1 1 2 3 4 5 6 7 8 docker run -d \\ --name elasticsearch \\ -v /home/tong/software/docker/elasticsearch/data:/usr/share/elasticsearch/data \\ -v /home/tong/software/docker/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\ -v /home/tong/software/docker/elasticsearch/config:/usr/share/elasticsearch/config \\ -p 9200:9200 \\ -p 9300:9300 \\ elasticsearch:8.7.0 1 2 3 4 5 docker run -d \\ --name elasticsearch \\ -p 9200:9200 \\ -p 9300:9300 \\ elasticsearch:8.7.0 命令解释：\n-e \u0026quot;cluster.name=es-docker-cluster\u0026quot;：设置集群名称 -e \u0026quot;http.host=0.0.0.0\u0026quot;：监听的地址，可以外网访问 -e \u0026quot;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026quot;：内存大小 -e \u0026quot;discovery.type=single-node\u0026quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 -p 9200:9200：端口映射配置 运行docker命令，部署kibana 1 2 3 4 5 6 docker run -d \\ --name kibana \\ -e ELASTICSEARCH_HOSTS=http://es:9200 \\ --network=es-net \\ -p 5601:5601 \\ kibana:7.12.1 --network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中 -e ELASTICSEARCH_HOSTS=http://es:9200\u0026quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch -p 5601:5601：端口映射配置 kibana启动一般比较慢，需要多等待一会，可以通过命令： 1 docker logs -f kibana 查看运行日志，当查看到下面的日志，说明成功： 2.网上的安装方法：\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 下载镜像文件 docker pull elasticsearch:7.4.2 # 创建搭载目录 mkdir -p /mydata/elasticsearch/config mkdir -p /mydata/elasticsearch/data echo \u0026#34;http.host: 0.0.0.0\u0026#34; \u0026gt; /mydata/elasticsearch/config/elasticsearch.yml docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \\ -e \u0026#34;discovery.type=single-node\u0026#34; \\ -e ES_JAVA_OPTS=\u0026#34;-Xms64m -Xmx512m\u0026#34; \\ -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\ -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \\ -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\ -d elasticsearch:7.4.2 docker ps# 查看容器状态 up 运行 若存在问题，查看这篇博客 我这里的问题是启动的时候没问题，但是过一会有自动关闭 解决问题和上方博客中写的一样\n1 2 chmod -R 777 /mydata/elasticsearch/ docker start elasticsearch 查看运行结果 http://虚拟机ip地址:9200/ 安装Kibana\r1 2 3 4 # 下载镜像文件 docker pull kibana:7.4.2 # 安装容器 docker run --name kibana -e ELASTICSEARCH_HOSTS=http://自己的IP:9200 -p 5601:5601 -d kibana:7.4.2 安装ik分词器\rik分词器下载地址\n3.1.在线安装ik插件（较慢）\r1 2 3 4 5 6 7 8 # 进入容器内部 docker exec -it elasticsearch /bin/bash # 在线下载并安装 ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip #退出 exit #重启容器 docker restart elasticsearch 3.2.离线安装ik插件（推荐）\r1）查看数据卷目录\r安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:\n1 docker volume inspect es-plugins 显示结果：\n1 2 3 4 5 6 7 8 9 10 11 [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2022-05-06T10:06:34+08:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: null, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/es-plugins/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;es-plugins\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] 说明plugins目录被挂载到了：/var/lib/docker/volumes/es-plugins/_data 这个目录中。\n2）解压缩分词器安装包\r下面我们需要把课前资料中的ik分词器解压缩，重命名为ik 3）上传到es容器的插件数据卷中\r也就是/var/lib/docker/volumes/es-plugins/_data ： 4）重启容器\r1 2 # 4、重启容器 docker restart es 1 2 # 查看es日志 docker logs -f es 5）测试：\rIK分词器包含两种模式：\nik_smart：最少切分 ik_max_word：最细切分 1 2 3 4 5 GET /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;黑马程序员学习java太棒了\u0026#34; } 结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 { \u0026#34;tokens\u0026#34; : [ { \u0026#34;token\u0026#34; : \u0026#34;黑马\u0026#34;, \u0026#34;start_offset\u0026#34; : 0, \u0026#34;end_offset\u0026#34; : 2, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 0 }, { \u0026#34;token\u0026#34; : \u0026#34;程序员\u0026#34;, \u0026#34;start_offset\u0026#34; : 2, \u0026#34;end_offset\u0026#34; : 5, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 1 }, { \u0026#34;token\u0026#34; : \u0026#34;程序\u0026#34;, \u0026#34;start_offset\u0026#34; : 2, \u0026#34;end_offset\u0026#34; : 4, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 2 }, { \u0026#34;token\u0026#34; : \u0026#34;员\u0026#34;, \u0026#34;start_offset\u0026#34; : 4, \u0026#34;end_offset\u0026#34; : 5, \u0026#34;type\u0026#34; : \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34; : 3 }, { \u0026#34;token\u0026#34; : \u0026#34;学习\u0026#34;, \u0026#34;start_offset\u0026#34; : 5, \u0026#34;end_offset\u0026#34; : 7, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 4 }, { \u0026#34;token\u0026#34; : \u0026#34;java\u0026#34;, \u0026#34;start_offset\u0026#34; : 7, \u0026#34;end_offset\u0026#34; : 11, \u0026#34;type\u0026#34; : \u0026#34;ENGLISH\u0026#34;, \u0026#34;position\u0026#34; : 5 }, { \u0026#34;token\u0026#34; : \u0026#34;太棒了\u0026#34;, \u0026#34;start_offset\u0026#34; : 11, \u0026#34;end_offset\u0026#34; : 14, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 6 }, { \u0026#34;token\u0026#34; : \u0026#34;太棒\u0026#34;, \u0026#34;start_offset\u0026#34; : 11, \u0026#34;end_offset\u0026#34; : 13, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 7 }, { \u0026#34;token\u0026#34; : \u0026#34;了\u0026#34;, \u0026#34;start_offset\u0026#34; : 13, \u0026#34;end_offset\u0026#34; : 14, \u0026#34;type\u0026#34; : \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34; : 8 } ] } 3.3 扩展词词典\r随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。 所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。 1）打开IK分词器config目录： 2）在IKAnalyzer.cfg.xml配置文件内容添加：\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE properties SYSTEM \u0026#34;http://java.sun.com/dtd/properties.dtd\u0026#34;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;comment\u0026gt;IK Analyzer 扩展配置\u0026lt;/comment\u0026gt; \u0026lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--\u0026gt; \u0026lt;entry key=\u0026#34;ext_dict\u0026#34;\u0026gt;ext.dic\u0026lt;/entry\u0026gt; \u0026lt;/properties\u0026gt; 3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改\n1 2 传智播客 奥力给 4）重启elasticsearch\n1 2 3 docker restart es # 查看 日志 docker logs -f elasticsearch 日志中已经成功加载ext.dic配置文件 5）测试效果：\n1 2 3 4 5 GET /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;传智播客Java就业超过90%,奥力给！\u0026#34; } 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑\n","date":"2022-12-14T00:00:00Z","image":"http://localhost:1313/p/docker%E9%85%8D%E7%BD%AE/dbc-docker-desktop-home_hu5165119418789691799.webp","permalink":"http://localhost:1313/p/docker%E9%85%8D%E7%BD%AE/","title":"Docker"},{"content":"git环境配置\r安装一路默认即可【一直next】 在桌面右键，多出了Git Bash Here\n1 2 3 4 5 # 打开Git Bash Here，复制命令并粘贴，右键paste # 配置用户名【填写自己的用户名】 git config --global user.name \u0026#34;your username\u0026#34; # 配置邮箱【填写自己的邮箱】 git config --global user.email \u0026#34;your email\u0026#34; 同时配置gitee和github\r参考博客\n1 2 git config --global --unset user.name \u0026#34;你的名字\u0026#34; git config --global --unset user.email \u0026#34;你的邮箱\u0026#34; 生成新的 SSH keys\rGithub\r1 ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C \u0026#34;xxx@qq.com\u0026#34; 按三次回车\nGitee\r邮箱换一个，不与Github邮箱相同即可\n1 ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C \u0026#34;xxx@aliyun.com\u0026#34; 按三次回车 完成后会在~/.ssh / 目录下生成以下文件。\nid_rsa.github id_rsa.github.pub id_rsa.gitee id_rsa.gitee.pub 1 2 3 ssh-agent bash ssh-add ~/.ssh/id_rsa.github ssh-add ~/.ssh/id_rsa.gitee 创建一个名为config的文件，不带后缀，以文本形式打开，写入如下内容\n1 2 3 4 5 6 7 8 9 10 11 #Default gitHub user Self Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa.github # gitee Host gitee.com Port 22 HostName gitee.com User git IdentityFile ~/.ssh/id_rsa.gitee 添加 ssh到github和gitee中\n1 2 ssh -T git@gitee.com ssh -T git@github.com 输入yes\n补充\r说一下我遇到的问题，我是全程开着加速器的，毕竟github的特殊性\u0026hellip; 但是最后这一步测试github的连接始终是连不上，Connection reset by 140.82.114.4 port 22\n1 2 3 4 5 6 7 8 9 10 $ ping github.com Pinging github.com [140.82.114.4] with 32 bytes of data: Reply from 140.82.114.4: bytes=32 time=270ms TTL=41 Request timed out. Reply from 140.82.114.4: bytes=32 time=273ms TTL=41 Reply from 140.82.114.4: bytes=32 time=273ms TTL=41 Ping statistics for 140.82.114.4: Packets: Sent = 4, Received = 3, Lost = 1 (25% loss), Approximate round trip times in milli-seconds: Minimum = 270ms, Maximum = 273ms, Average = 272ms 看来确实是有问题的\n配置一下hosts文件就连上了 hosts文件在C:\\Windows\\System32\\drivers\\etc 点击测速，搜索github.com\n1 2 3 如我这里是20.205.243.166 则在hosts文件里添加 20.205.243.166 github.com 1 2 3 4 5 6 7 $ ssh -T git@github.com The authenticity of host \u0026#39;github.com (140.82.114.4)\u0026#39; can\u0026#39;t be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added \u0026#39;github.com\u0026#39; (ED25519) to the list of known hosts. Hi IsUnderAchiever! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 但是github克隆项目还是报错，开不开‘特殊手段’都是这样\n1 2 3 $ git clone https://github.com/nodejs/node.git Cloning into \u0026#39;node\u0026#39;... fatal: unable to access \u0026#39;https://github.com/nodejs/node.git/\u0026#39;: Failed to connect to github.com port 443 after 21049 ms: Couldn\u0026#39;t connect to server 只配置gitee或github\r以gitee为例，github类似 配置ssh免密登录\n1 2 3 4 5 6 7 8 ssh-keygen -t rsa -C \u0026#34;your email\u0026#34; # 按三次回车后，生成密钥【在用户目录下】 cat ~/.ssh/id_rsa.pub # 查看密钥 # 复制以上密钥 # 进入gitee，左侧找到SSH公钥，添加标题（自己随便写一个），公钥复制粘贴上一步查看的内容（注意不要携带空格） # 测试是否成功 (选择yes) ssh -T git@gitee.com ","date":"2022-12-13T00:00:00Z","image":"http://localhost:1313/p/git%E9%85%8D%E7%BD%AE/branching-illustration@2x_hu1127098983321772738.png","permalink":"http://localhost:1313/p/git%E9%85%8D%E7%BD%AE/","title":"Git"},{"content":"进入人人开源，用git的方式下载三个项目\nrenren-fast renren-fast-vue renren-generator renren-fast\r新建renren-fast数据库，并执行mysql.sql内的sql语句\n这里前端项目报错了，解决方法如下：\r1 2 cnpm install -g node-gyp npm install --global --production windows-build-tools 如果一直卡在Successfully installed Python 2.7不动。 我电脑的解决方法是\n1 npm install --global --production windows-build-tools@4.0.0 如果还解决不了，请看这篇博客\n若后端启动报错\r报错信息：jar:file:/D:/apache-maven-3.5.3/repository/javax/servlet/servlet-api\u0026hellip; 表示jar包冲突，我的解决方法是先去repository删了这些包，然后重新在项目中下载\n运行renren-fast和renren-fast-vue两个项目，前者是后端项目，后者是前端项目\n账号和密码都是admin\nrenren-generator\r先去配置数据库的信息\n以demo数据库为例：\n新建一个springboot项目，来操作demo数据库的这几个表 springcloud涉及到多个数据库，则需要创建多个项目来对应每个数据库【项目与数据库一一对应】\n【微服务还需要导入openfeign依赖】 打开generator.properties进行配置\n运行项目\n直接复制生成的main文件夹，粘贴到项目的main处\n有不少报错，别急，这是因为缺少了一些工具包和相应的依赖 考虑到各种原因，删除刚刚生成的内容 我们将工具包和其他依赖【如mybatis-plus、lombok等通用的依赖】集成成一个springboot项目 将其他springboot的公共依赖、公共包进行整合\n复制粘贴renren-fast/renren-generator内的类即可 在renren-common中导入依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!--mybatis-plus--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpcore\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.4.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-lang\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.30\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在demo示例项目中导入renren-common的依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;renren-common\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在运行项目前，还需要在demo配置mysql的连接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 应用名称 spring.application.name=demo # 应用服务 WEB 访问端口 server.port=8080 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据源名称 spring.datasource.name=defaultDataSource # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/demo?serverTimezone=UTC # 数据库用户名\u0026amp;密码： spring.datasource.username=root spring.datasource.password=123456 # 配置mybatis-plus 打印sql日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # xml文件路径 mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml # 配置最新全局配置文件 #mybatis-plus.config-location=classpath:mybatis-config.xml # 配置mybatis-plus 包路径 mybatis-plus.type-aliases-package=com.example.demo.domain # mybatis-plus下划线转驼峰配置，默认为true mybatis-plus.configuration.map-underscore-to-camel-case=true # 配置全局默认主键类型，实体类不用加@TableId(value =\u0026#34;id\u0026#34;,type = IdType.AUTO) mybatis-plus.global-config.db-config.id-type=auto # 逻辑删除 （1为删除，0为未删除） mybatis-plus.global-config.db-config.logic-delete-value=1 mybatis-plus.global-config.db-config.logic-not-delete-value=0 # 如果java实体类没加注解@TableLogic，则可以配置这个，推介这里配置 mybatis-plus.global-config.db-config.logic-delete-field=isDeleted 运行demo项目\n链接：https://pan.baidu.com/s/1OP2oPB1onrzMMai7jOmneg?pwd=j4nw 提取码：j4nw \u0026ndash;来自百度网盘超级会员V3的分享\n","date":"2022-12-13T00:00:00Z","image":"http://localhost:1313/p/%E4%BA%BA%E4%BA%BA%E5%BC%80%E6%BA%90%E9%85%8D%E7%BD%AE/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu4898064707681593350.jpg","permalink":"http://localhost:1313/p/%E4%BA%BA%E4%BA%BA%E5%BC%80%E6%BA%90%E9%85%8D%E7%BD%AE/","title":"人人开源配置"},{"content":" 编译App.vue之后，通过这个index.html来显示 access是存放静态资源的地方，比如图片、css、js component是存放组件的地方 如图，HelloWorld.vue是一个组件，通过export导出后在其他vue文件中引用 比如某宝等购物平台，页面的头部和底部基本不变，所以可以做成组件后在其他vue文件中直接引用 index.js【index.ts】是写路由的地方 实际上是将url路径和页面进行映射，通过url路径来访问页面 比如： 输入localhost:8080/ 会显示HomeView.vue的内容 输入localhost:8080/about 会显示AboutView.vue的内容 store则是用来定义页面的一些变量 比如，登录之后的用户信息、页面之间跳转的时候需要携带的参数等都可以放在store内 view是存放视图的地方，上图中就引入了HelloWorld组件 在components中定义HelloWorld组件 然后通过import的方式进行导入 最后可以通过\u0026lt;HelloWorld/\u0026gt;这样的标签进行使用 图中msg可以在HelloWorld中找到 图中HomeView中将msg传入HelloWorld中，然后通过胡子语法来使用，即{{msg}} ","date":"2022-12-11T22:00:00Z","image":"http://localhost:1313/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE02/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE02/","title":"从零开始搭建前后端分离项目02"},{"content":"node环境配置略过，如果有安装多个版本的nodejs的需求，建议安装一个nvm nvm和nodejs的安装配置在CSDN上都可以找到\n我这里使用nvm安装了两个版本的nodejs，正在使用的是16.13.2版本\n1 2 3 4 5 6 7 8 9 10 # node版本切换回14.17.2版本 nvm user 14.17.2 # 查询可以安装的所有nodejs的版本 nvm list available # 安装最新稳定版 nvm install stable # 安装nodejs，version是版本号 例如：nvm install 14.17.2 nvm install \u0026lt;version\u0026gt; # 卸载nodejs，卸载指定版本的nodejs，当安装失败时卸载使用 nvm uninstall \u0026lt;version\u0026gt; 新建vue项目\r新建文件夹“springboot+vue框架” 在文件夹内cmd vue的项目名为springboot-vue-demo\n1 vue create springboot-vue-demo 选择manually select features 手动创建\n按空格选择以上依赖，回车下一步\n选择3.X\n分别按照上述图片来输入y和n，最后一个是 选择是否保存本次的配置为模板（下次创建可直接选定这些配置），可选可不选\n项目创建成功，可输入这两个命令来运行vue项目\n1 2 cd springboot-vue-demo npm run serve 使用idea打开“springboot+vue框架”这个文件夹【根目录】 在idea中配置vue项目的运行环境 package.json和scripts需要配置 选择server后，点击“运行” 在浏览器输入http://localhost:8080/ 即可访问前端项目 ","date":"2022-12-11T00:00:00Z","image":"http://localhost:1313/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE01/202412211946837_hu8953745126500088997.png","permalink":"http://localhost:1313/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE01/","title":"从零开始搭建前后端分离项目01"},{"content":"新建SpringBoot项目\r下文包括使用sts、idea新建SpringBoot项目，并编写登录逻辑以及测试\n新建SpringBoot项目 使用Spring Tool Suite 右键新建，选择Spring Starter Project 注意：其实不安装lombok插件也没什么，手动给get、set方法 和 有参、无参的构造方法即可\nsts 的lombok插件需要自己安装jar包，安装过程上网查找，这里不再多说；idea的插件安装 同\n使用IDEA 右键新建，选择Spring Initializr (无法访问spring官网可以选择custom，https://start.aliyun.com)\n更正：\n这里我有mybatis-plus，我也不知道为啥，据说正常情况是没有的，重装系统之后又没有了\n如果没有mybatis-plus选择，可直接在pom.xml导入如下依赖即可\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 进入pom.xml，导入mybatis-plus自动生成的依赖 导入依赖后保存，sts保存后自动下载，idea需要点击右上角的 “M” 按钮，Load Maven Changes 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!--MyBatis-plus自动生成--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-generator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--velocity--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.velocity\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;velocity-engine-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写自动生成类，可自动生成简易版的（domain、mapper、mapper_xml、service、serviceimpl、controller） 如果想要生成比较完全的，可以去gitee上搜索“人人开源”，找到renren-generator，这个可以生成更完全，甚至可以生成前端的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.config.DataSourceConfig; import com.baomidou.mybatisplus.generator.config.GlobalConfig; import com.baomidou.mybatisplus.generator.config.PackageConfig; import com.baomidou.mybatisplus.generator.config.StrategyConfig; import com.baomidou.mybatisplus.generator.config.rules.DateType; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; public class MyBatisPlusGenerator { public static void main(String[] args) { //1. 全局配置 GlobalConfig config = new GlobalConfig(); // 是否支持AR模式 config.setActiveRecord(true) // 生成路径，最好使用绝对路径，window路径是不一样的 //TODO TODO TODO TODO .setOutputDir(\u0026#34;D:\\demo\\src\\main\\java\u0026#34;) // 文件覆盖 .setFileOverride(true) // 主键策略 .setIdType(IdType.AUTO) .setDateType(DateType.ONLY_DATE) // 设置生成的service接口的名字的首字母是否为I，默认Service是以I开头的 .setServiceName(\u0026#34;%sService\u0026#34;) //实体类结尾名称 .setEntityName(\u0026#34;%s\u0026#34;) //生成基本的resultMap .setBaseResultMap(true) //不使用AR模式 .setActiveRecord(false) //生成基本的SQL片段 .setBaseColumnList(true); //2. 数据源配置 DataSourceConfig dsConfig = new DataSourceConfig(); // 设置数据库类型 dsConfig.setDbType(DbType.MYSQL) .setDriverName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;) //TODO TODO TODO TODO .setUrl(\u0026#34;jdbc:mysql://127.0.0.1:3306/demo?useSSL=false\u0026#34;) .setUsername(\u0026#34;root\u0026#34;) .setPassword(\u0026#34;123456\u0026#34;); //3. 策略配置globalConfiguration中 StrategyConfig stConfig = new StrategyConfig(); //全局大写命名 stConfig.setCapitalMode(true) // 数据库表映射到实体的命名策略(驼峰命名) .setNaming(NamingStrategy.underline_to_camel) //使用lombok .setEntityLombokModel(true) //使用restcontroller注解 .setRestControllerStyle(true) // 生成的表, 支持多表一起生成，以数组形式填写 //TODO TODO TODO TODO 两个方式，直接写，或者使用命令行输入 .setInclude(\u0026#34;u\u0026#34;); // .setInclude(\u0026#34;product\u0026#34;,\u0026#34;product_task\u0026#34;,\u0026#34;banner\u0026#34;); //4. 包名策略配置 PackageConfig pkConfig = new PackageConfig(); //TODO TODO TODO TODO 包名策略配置 pkConfig.setParent(\u0026#34;com.example.demo\u0026#34;) .setMapper(\u0026#34;mapper\u0026#34;) .setService(\u0026#34;service\u0026#34;) .setServiceImpl(\u0026#34;service.impl\u0026#34;) .setController(\u0026#34;controller\u0026#34;) .setEntity(\u0026#34;domain\u0026#34;) .setXml(\u0026#34;mapper\u0026#34;); //5. 整合配置 AutoGenerator ag = new AutoGenerator(); ag.setGlobalConfig(config) .setDataSource(dsConfig) .setStrategy(stConfig) .setPackageInfo(pkConfig); //6. 执行操作 ag.execute(); System.out.println(\u0026#34;======= 相关代码生成完毕 ========\u0026#34;); } } 有几个地方根据自己的需求改（标有 //TODO TODO 的地方）\n生成文件的路径\n数据库连接的配置\n生成哪几个表\n包名策略配置 运行main方法，自动生成（需要注意，生成之后注销掉方法，不然等你编写完springboot代码点击运行的时候，可能运行的还是自动生成的代码，导致你刚写完的代码被覆盖）\nsts 运行完后需要右键刷新一下项目\n在src/main/resources下新建mapper文件夹，将生成的mapper.xml移动到mapper文件夹下\n如果不用lombok插件，则需要去掉实体类的注解，自己生成get、set方法 和 有参、无参的构造方法 注意@Data注解，不使用lombok插件的都需要自己生成get、set方法，下面使用@Data注解的位置我不再强调了\n配置application.properties\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 应用名称 spring.application.name=demo # 应用服务 WEB 访问端口 server.port=8080 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据源名称 spring.datasource.name=defaultDataSource # 数据库连接地址(demo是我们需要连接的数据库) spring.datasource.url=jdbc:mysql://localhost:3306/demo?serverTimezone=UTC # 数据库用户名\u0026amp;密码： spring.datasource.username=root spring.datasource.password=123456 这里我的数据库连接地址这样就可以了，如果你们有问题，需要配置mysql的时区 或者 写完整\n1 2 # 完整写法(demo是我们需要连接的数据库) spring.datasource.url=jdbc:mysql://localhost:3306/demo?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;autoReconnect=true\u0026amp;serverTimezone=Asia/Shanghai 在启动类上加上注解（DemoApplication.java）\n1 @MapperScan(\u0026#34;com.example.demo.mapper\u0026#34;) 接下来编写一个简单的登录业务\nmapper继承了BaseMapper，有基本的增删改查方法，所以不用管 在service里编写 1 2 // 登录 public Object login(U u); serviceimpl里实现该方法 这里有个问题要说一下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 如果你不准备改service层 以及 serviceimpl 的继承关系 public interface UService extends IService\u0026lt;U\u0026gt;{ } @Service public class UServiceImpl extends ServiceImpl\u0026lt;UMapper, U\u0026gt; implements UService { } // extends IService\u0026lt;U\u0026gt; 和 extends ServiceImpl\u0026lt;UMapper, U\u0026gt; 这两处 // 那么其实你在 UServiceImpl里不用再自动注入umapper了，如下 @Autowired private UMapper umapper; // 在UServiceImpl内，按住ctrl点击ServiceImpl，进入他的源码，你会发现里面有一个baseMapper // 源码内： @Autowired protected M baseMapper; // 仔细看看源码你就会发现baseMapper其实就是你的mapper层，所以不用再写mapper层的自动注入了，直接用baseMapper代替 // ------------------ // 还有一种说法，在service 和 serviceimpl里去掉他的继承关系，就是最原始的serviceimpl 实现 service即可 // 使用自动注入mapper的方式在serviceimpl内编写代码 public interface UService extends IService\u0026lt;U\u0026gt;{ } @Service public class UServiceImpl extends ServiceImpl\u0026lt;UMapper, U\u0026gt; implements UService { @Autowired private UMapper umapper; } // 因为继承IService 和 ServiceImpl实际上增加了耦合性，我们都知道，优秀的代码==高内聚、低耦合 // 以上两种写法请自行斟酌 这里我就用第一种了 这里推介一个好用的工具包 hutool，导入依赖 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 新建一个com.example.demo.util文件夹，新建R类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @Data public class R { private int code; private String message; private String type; private Boolean success; private Object data; public static R success(String message) { R r = new R(); r.setCode(200); r.setMessage(message); r.setSuccess(true); r.setType(\u0026#34;success\u0026#34;); r.setData(null); return r; } public static R success(String message, Object data) { R r = success(message); r.setData(data); return r; } public static R warning(String message) { R r = error(message); r.setType(\u0026#34;warning\u0026#34;); return r; } public static R error(String message) { R r = success(message); r.setSuccess(false); r.setType(\u0026#34;error\u0026#34;); return r; } public static R fatal(String message) { R r = error(message); r.setCode(500); return r; } } 编写serviceimpl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Service public class UServiceImpl extends ServiceImpl\u0026lt;UMapper, U\u0026gt; implements UService { @Override public Object login(U u) { // TODO Auto-generated method stub // 登录的情况 // 1.账号密码为空 // 2.账号未注册 // 3.密码错误 // 4.登陆成功 if(StrUtil.isEmptyIfStr(u)) { return R.error(\u0026#34;账号密码为空\u0026#34;); } QueryWrapper\u0026lt;U\u0026gt; userQuery=new QueryWrapper\u0026lt;\u0026gt;(); // 查找数据库，当数据库中name的值等于u.getName()的时候 userQuery.eq(\u0026#34;name\u0026#34;, u.getName()); // 从数据库中查找到的user（可能为空，即未注册） U user=baseMapper.selectOne(userQuery); if(user==null) { // 用户未注册 return R.error(\u0026#34;用户未注册\u0026#34;); }else { // 登录 成功 or 失败 if(user.getPassword().equals(u.getPassword())) { return R.success(\u0026#34;登陆成功\u0026#34;); }else { return R.error(\u0026#34;密码错误\u0026#34;); } } } } 编写controller 1 2 3 4 5 6 7 8 9 10 11 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UController { @Autowired private UService uservice; @PostMapping(\u0026#34;/login\u0026#34;) public Object checkLogin(@RequestBody U u) { return uservice.login(u); } } 运行启动类（DemoApplication.java） 目录结构 打开postman进行测试，没有的可以去官网下载，我这里也提供一份 链接：https://pan.baidu.com/s/1PfkZpMb_5zs9adP5TSRXRA?pwd=cc41 提取码：cc41 最后比较一下idea和sts。\nsts和eclipse差不多，上手难度低，需要配置的不多。相比之下idea上手难度高一些，需要配置的地方也多一些。\n但idea功能更多，比如安装一些插件，lombok、mybatis-plus的插件。建议用idea，编写代码真的比sts舒服很多。\n","date":"2022-11-27T00:00:00Z","image":"http://localhost:1313/p/%E6%96%B0%E5%BB%BAspringboot%E9%A1%B9%E7%9B%AE/202412212133331_hu2238536967496899376.png","permalink":"http://localhost:1313/p/%E6%96%B0%E5%BB%BAspringboot%E9%A1%B9%E7%9B%AE/","title":"新建springboot项目"}]